package com.addiPlot.gnuplot;

public class GlobalMembersSave
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: save.c,v 1.171.2.5 2010/02/24 22:48:49 sfeam Exp $");
	}

/*
 *  functions corresponding to the arguments of the GNUPLOT `save` command
 */
	///#endif

	/* GNUPLOT - save.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * $Id: save.h,v 1.15 2008/04/30 04:16:15 sfeam Exp $
	 */

	/* GNUPLOT - save.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif

	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)

	/* Type definitions */

	/* Variables of save.c needed by other modules: */

	/* Prototypes of functions exported by save.c */
	public static void save_functions(FILE fp)
	{
		/* I _love_ information written at the top and the end
		 * of a human readable ASCII file. */
		GlobalMembersShow.show_version(fp);
		GlobalMembersSave.save_functions__sub(fp);
		fputs("#    EOF\n", fp);
	}
	public static void save_variables(FILE fp)
	{
		GlobalMembersShow.show_version(fp);
		GlobalMembersSave.save_variables__sub(fp);
		fputs("#    EOF\n", fp);
	}
	public static void save_set(FILE fp)
	{
		GlobalMembersShow.show_version(fp);
		GlobalMembersSave.save_set_all(fp);
		fputs("#    EOF\n", fp);
	}

/* HBB 19990823: new function 'save term'. This will be mainly useful
 * for the typical 'set term post ... plot ... set term <normal term>
 * sequence. It's the only 'save' function that will write the
 * current term setting to a file uncommentedly. */
	public static void save_term(FILE fp)
	{
		GlobalMembersShow.show_version(fp);

		/* A possible gotcha: the default initialization often doesn't set
		 * term_options, but a 'set term <type>' without options doesn't
		 * reset the options to startup defaults. This may have to be
		 * changed on a per-terminal driver basis... */
		if (GlobalMembersTerm.term != null)
			fprintf(fp, "set terminal %s %s\n", GlobalMembersTerm.term.name, GlobalMembersTerm.term_options);
		else
			fputs("set terminal unknown\n", fp);

		/* output will still be written in commented form.  Otherwise, the
		 * risk of overwriting files is just too high */
		if (GlobalMembersTerm.outstr != null)
			fprintf(fp, "# set output '%s'\n", GlobalMembersTerm.outstr);
		else
			fputs("# set output\n", fp);
		fputs("#    EOF\n", fp);
	}
	public static void save_all(FILE fp)
	{
		GlobalMembersShow.show_version(fp);
		GlobalMembersSave.save_set_all(fp);
		GlobalMembersSave.save_functions__sub(fp);
		GlobalMembersSave.save_variables__sub(fp);
		fprintf(fp, "%s\n", GlobalMembersCommand.replot_line);
		if (GlobalMembersFit.wri_to_fil_last_fit_cmd(DefineConstants.NULL) != 0)
		{
			fputs("## ", fp);
			GlobalMembersFit.wri_to_fil_last_fit_cmd(fp);
			putc('\n', fp);
		}
		fputs("#    EOF\n", fp);
	}
	public static void save_range(FILE fp, AXIS_INDEX axis)
	{
		fprintf(fp, "set %srange [ ", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN != 0)
		{
		putc('*', fp);
		}
		else
		{
		do
		{
			if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
			{
				String s = new String(new char[80]);
				putc('"', fp);
				GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)(GlobalMembersAxis.axis_array[axis.getValue()].set_min));
				fputs(conv_text(s), fp);
				putc('"', fp);
			}
			else
			{
				fprintf(fp,"%#g",GlobalMembersAxis.axis_array[axis.getValue()].set_min);
			}
		} while (0);
		}
		fputs(" : ", fp);
		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX != 0)
		{
		putc('*', fp);
		}
		else
		{
		do
		{
			if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
			{
				String s = new String(new char[80]);
				putc('"', fp);
				GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)(GlobalMembersAxis.axis_array[axis.getValue()].set_max));
				fputs(conv_text(s), fp);
				putc('"', fp);
			}
			else
			{
				fprintf(fp,"%#g",GlobalMembersAxis.axis_array[axis.getValue()].set_max);
			}
		} while (0);
		}

		fprintf(fp, " ] %sreverse %swriteback", GlobalMembersAxis.axis_array[axis.getValue()].range_flags & DefineConstants.RANGE_REVERSE ? "" : "no", GlobalMembersAxis.axis_array[axis.getValue()].range_flags & DefineConstants.RANGE_WRITEBACK ? "" : "no");

		if (((int)GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale) != 0)
		{
		/* add current (hidden) range as comments */
		fputs("  # (currently [", fp);
		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN != 0)
		{
			do
			{
				if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
				{
					String s = new String(new char[80]);
					putc('"', fp);
					GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)(GlobalMembersAxis.axis_array[axis.getValue()].min));
					fputs(conv_text(s), fp);
					putc('"', fp);
				}
				else
				{
					fprintf(fp,"%#g",GlobalMembersAxis.axis_array[axis.getValue()].min);
				}
			} while (0);
		}
		putc(':', fp);
		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX != 0)
		{
			do
			{
				if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
				{
					String s = new String(new char[80]);
					putc('"', fp);
					GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)(GlobalMembersAxis.axis_array[axis.getValue()].max));
					fputs(conv_text(s), fp);
					putc('"', fp);
				}
				else
				{
					fprintf(fp,"%#g",GlobalMembersAxis.axis_array[axis.getValue()].max);
				}
			} while (0);
		}
		fputs("] )\n", fp);

		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & (e_autoscale.AUTOSCALE_FIXMIN) != 0)
			fprintf(fp, "set autoscale %sfixmin\n", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		if (GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_FIXMAX != 0)
			fprintf(fp, "set autoscale %sfixmax\n", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		}
		else
		putc('\n', fp);
	}
	public static void save_textcolor(FILE fp, t_colorspec tc)
	{
		if (tc.type != 0)
		{
			fprintf(fp, " textcolor");
		GlobalMembersSave.save_pm3dcolor(fp, tc);
		}
	}
	public static void save_pm3dcolor(FILE fp, t_colorspec tc)
	{
		if (tc.type != 0)
		{
		switch (tc.type)
		{
		case DefineConstants.TC_LT:
			fprintf(fp," lt %d", tc.lt + 1);
				  break;
		case DefineConstants.TC_LINESTYLE:
			fprintf(fp," linestyle %d", tc.lt);
				  break;
		case DefineConstants.TC_Z:
			fprintf(fp," palette z");
				  break;
		case DefineConstants.TC_CB:
			fprintf(fp," palette cb %g", tc.value);
				  break;
		case DefineConstants.TC_FRAC:
			fprintf(fp," palette fraction %4.2f", tc.value);
				  break;
		case DefineConstants.TC_RGB:
		{
				  String color = GlobalMembersTables.reverse_table_lookup(GlobalMembersTables.pm3d_color_names_tbl, tc.lt);
				  if (tc.value < 0)
				  fprintf(fp," rgb variable ");
				  else if (color != null)
					fprintf(fp," rgb \"%s\" ", color);
					  else
					fprintf(fp," rgb \"#%6.6x\" ", tc.lt);
					  break;
		}
		default:
			break;
		}
		}
	}
	public static void save_fillstyle(FILE fp, fill_style_type fs)
	{
		switch (fs.fillstyle)
		{
		case FS_SOLID:
		case FS_TRANSPARENT_SOLID:
		fprintf(fp, " %s solid %.2f ", fs.fillstyle == (int)(t_fillstyle.FS_SOLID.getValue()) != 0 ? "" : "transparent", fs.filldensity / 100.0);
		break;
		case FS_PATTERN:
		case FS_TRANSPARENT_PATTERN:
		fprintf(fp, " %s pattern %d ", fs.fillstyle == (int)(t_fillstyle.FS_PATTERN.getValue()) != 0 ? "" : "transparent", fs.fillpattern);
		break;
		case FS_DEFAULT:
		fprintf(fp, " default\n");
		return;
		default:
		fprintf(fp, " empty ");
		break;
		}
		if (fs.border_color.type == DefineConstants.TC_LT && fs.border_color.lt == DefineConstants.LT_NODRAW)
		{
		fprintf(fp, "noborder\n");
		}
		else
		{
		fprintf(fp, "border");
		GlobalMembersSave.save_pm3dcolor(fp, fs.border_color);
		fprintf(fp, "\n");
		}
	}
	public static void save_offsets(FILE fp, String lead)
	{
		fprintf(fp, "%s %s%g, %s%g, %s%g, %s%g\n", lead, GlobalMembersGraphics.loff.scalex == (position_type.graph.getValue()) != 0 ? "graph " : "", GlobalMembersGraphics.loff.x, GlobalMembersGraphics.roff.scalex == (position_type.graph.getValue()) != 0 ? "graph " : "", GlobalMembersGraphics.roff.x, GlobalMembersGraphics.toff.scaley == (position_type.graph.getValue()) != 0 ? "graph " : "", GlobalMembersGraphics.toff.y, GlobalMembersGraphics.boff.scaley == (position_type.graph.getValue()) != 0 ? "graph " : "", GlobalMembersGraphics.boff.y);
	}

///#ifdef EAM_OBJECTS

/* Save/show rectangle <tag> (0 means show all) */
	///#ifdef EAM_OBJECTS
	public static void save_object(FILE fp, int tag)
	{
		object this_object;
		rectangle this_rect;
		circle this_circle;
		ellipse this_ellipse;
		boolean showed = false;

		for (this_object = GlobalMembersGadgets.first_object; this_object != DefineConstants.NULL; this_object = this_object.next)
		{
		if ((this_object.object_type == DefineConstants.OBJ_RECTANGLE) && (tag == 0 || tag == this_object.tag))
		{
			this_rect = this_object.o.rectangle;
			showed = true;
			fprintf(fp, "%sobject %2d rect ", (fp == stderr) ? "\t" : "set ",this_object.tag);

			if (this_rect.type == 1)
			{
			fprintf(fp, "center ");
			GlobalMembersSave.save_position(fp, this_rect.center, false);
			fprintf(fp, " size ");
			GlobalMembersSave.save_position(fp, this_rect.extent, false);
			}
			else
			{
			fprintf(fp, "from ");
			GlobalMembersSave.save_position(fp, this_rect.bl, false);
			fprintf(fp, " to ");
			GlobalMembersSave.save_position(fp, this_rect.tr, false);
			}
		}

		else if ((this_object.object_type == DefineConstants.OBJ_CIRCLE) && (tag == 0 || tag == this_object.tag))
		{
			position e = this_object.o.circle.extent;
			this_circle = this_object.o.circle;
			showed = true;
			fprintf(fp, "%sobject %2d circle ", (fp == stderr) ? "\t" : "set ",this_object.tag);

			fprintf(fp, "center ");
			GlobalMembersSave.save_position(fp, this_circle.center, false);
			fprintf(fp, " size ");
			fprintf(fp, "%s%g", e.scalex == (position_type.first_axes.getValue()) != 0 ? "" : coord_msg[e.scalex.getValue()], e.x);
			fprintf(fp, " arc [%g:%g] ", this_circle.arc_begin, this_circle.arc_end);
		}

		else if ((this_object.object_type == DefineConstants.OBJ_ELLIPSE) && (tag == 0 || tag == this_object.tag))
		{
			position e = this_object.o.ellipse.extent;
			this_ellipse = this_object.o.ellipse;
			showed = true;
			fprintf(fp, "%sobject %2d ellipse ", (fp == stderr) ? "\t" : "set ",this_object.tag);
			fprintf(fp, "center ");
			GlobalMembersSave.save_position(fp, this_ellipse.center, false);
			fprintf(fp, " size ");
			fprintf(fp, "%s%g", e.scalex == (position_type.first_axes.getValue()) != 0 ? "" : coord_msg[e.scalex.getValue()], e.x);
			fprintf(fp, ", %s%g", e.scaley == ((int)e.scalex) != 0 ? "" : coord_msg[e.scaley.getValue()], e.y);
			fprintf(fp, "  angle %g", this_ellipse.orientation);
		}

		else if ((this_object.object_type == DefineConstants.OBJ_POLYGON) && (tag == 0 || tag == this_object.tag))
		{
			polygon this_polygon = this_object.o.polygon;
			int nv;
			showed = true;
			fprintf(fp, "%sobject %2d polygon ", (fp == stderr) ? "\t" : "set ",this_object.tag);
			if (this_polygon.vertex != null)
			{
			fprintf(fp, "from ");
			GlobalMembersSave.save_position(fp, this_polygon.vertex[0], false);
			}
			for (nv = 1; nv < this_polygon.type; nv++)
			{
			fprintf(fp, (fp == stderr) ? "\n\t\t\t    to " : " to ");
			GlobalMembersSave.save_position(fp, this_polygon.vertex[nv], false);
			}
		}

		/* Properties common to all objects */
		fprintf(fp, "\n%sobject %2d ", (fp == stderr) ? "\t" : "set ",this_object.tag);
		fprintf(fp, "%s ", this_object.layer > 0 ? "front" : this_object.layer < 0 ? "behind" : "back");
		if (this_object.lp_properties.l_width != 0)
			fprintf(fp, "lw %.1f ",this_object.lp_properties.l_width);
		fprintf(fp, "fc ");
		if (this_object.lp_properties.l_type == DefineConstants.LT_DEFAULT)
			fprintf(fp,"default");
		else if (this_object.lp_properties.use_palette)
			GlobalMembersSave.save_pm3dcolor(fp, this_object.lp_properties.pm3d_color);
		else
			fprintf(fp, "lt %d",this_object.lp_properties.l_type + 1);
		fprintf(fp, " fillstyle ");
		GlobalMembersSave.save_fillstyle(fp, this_object.fillstyle);

		}
		if (tag > 0 && !showed)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "object not found");
	}
	///#endif
	public static void save_data_func_style(FILE fp, String which, PLOT_STYLE style)
	{
		switch (style)
		{
		case LINES:
		fputs("lines\n", fp);
		break;
		case POINTSTYLE:
		fputs("points\n", fp);
		break;
		case IMPULSES:
		fputs("impulses\n", fp);
		break;
		case LINESPOINTS:
		fputs("linespoints\n", fp);
		break;
		case DOTS:
		fputs("dots\n", fp);
		break;
		case YERRORLINES:
		fputs("yerrorlines\n", fp);
		break;
		case XERRORLINES:
		fputs("xerrorlines\n", fp);
		break;
		case XYERRORLINES:
		fputs("xyerrorlines\n", fp);
		break;
		case YERRORBARS:
		fputs("yerrorbars\n", fp);
		break;
		case XERRORBARS:
		fputs("xerrorbars\n", fp);
		break;
		case XYERRORBARS:
		fputs("xyerrorbars\n", fp);
		break;
		case BOXES:
		fputs("boxes\n", fp);
		break;
		case HISTOGRAMS:
		fputs("histograms\n", fp);
		break;
		case FILLEDCURVES:
		fputs("filledcurves ", fp);
		if (!strcmp(which, "data") || !strcmp(which, "Data"))
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: filledcurves_options_tofile(&filledcurves_opts_data, fp);
			GlobalMembersMisc.filledcurves_options_tofile(new filledcurves_opts(GlobalMembersGadgets.filledcurves_opts_data), fp);
		else
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: filledcurves_options_tofile(&filledcurves_opts_func, fp);
			GlobalMembersMisc.filledcurves_options_tofile(new filledcurves_opts(GlobalMembersGadgets.filledcurves_opts_func), fp);
		fputc('\n', fp);
		break;
		case BOXERROR:
		fputs("boxerrorbars\n", fp);
		break;
		case BOXXYERROR:
		fputs("boxxyerrorbars\n", fp);
		break;
		case STEPS:
		fputs("steps\n", fp);
		break; // JG
		case FSTEPS:
		fputs("fsteps\n", fp);
		break; // HOE
		case HISTEPS:
		fputs("histeps\n", fp);
		break; // CAC
		case VECTOR:
		fputs("vector\n", fp);
		break;
		case FINANCEBARS:
		fputs("financebars\n", fp);
		break;
		case CANDLESTICKS:
		fputs("candlesticks\n", fp);
		break;
		case PM3DSURFACE:
		fputs("pm3d\n", fp);
		break;
		case LABELPOINTS:
		fputs("labels\n", fp);
		break;
		case IMAGE:
		fputs("image\n", fp);
		break;
		case RGBIMAGE:
		fputs("rgbimage\n", fp);
		break;
	///#ifdef EAM_OBJECTS
		case CIRCLES:
		fputs("circles\n", fp);
		break;
	///#endif
		default:
		fputs("---error!---\n", fp);
		}
	}
	public static void save_linetype(FILE fp, lp_style_type lp, boolean show_point)
	{

		fprintf(fp, " linetype %d", lp.l_type + 1);
		if (lp.use_palette)
		{
		fprintf(fp, " linecolor");
		if (lp.pm3d_color.type == DefineConstants.TC_LT)
				fprintf(fp, " %d", lp.pm3d_color.lt + 1);
		else
				GlobalMembersSave.save_pm3dcolor(fp, (lp.pm3d_color));
		}
		fprintf(fp, " linewidth %.3f", lp.l_width);

		if (show_point)
		{
		fprintf(fp, " pointtype %d", lp.p_type + 1);
		if (lp.p_size == DefineConstants.PTSZ_VARIABLE)
			fprintf(fp, " pointsize variable");
		else if (lp.p_size == DefineConstants.PTSZ_DEFAULT)
			fprintf(fp, " pointsize default");
		else
			fprintf(fp, " pointsize %.3f", lp.p_size);
		fprintf(fp, " pointinterval %d", lp.p_interval);
		}

	}

/*
 *  auxiliary functions
 */




	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#define DEFAULT_CONTOUR_LEVELS 5
	///#define DEFAULT_NUM_APPROX_PTS 5
	///#define DEFAULT_CONTOUR_ORDER 4
	///#define MAX_BSPLINE_ORDER 10
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define contour_levels_list ((double *)dyn_contour_levels_list.v)
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#define DF_EOF (-1)
	///#define DF_UNDEFINED (-2)
	///#define DF_FIRST_BLANK (-3)
	///#define DF_SECOND_BLANK (-4)
	///#define DF_MISSING (-5)
	///#define DF_FOUND_KEY_TITLE (-6)
	///#define DF_KEY_TITLE_MISSING (-7)
	///#define DF_STRINGDATA (-8)
	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX // in limits.h ?
	///#define MAXINT INT_MAX
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif
	///#define MAXDATACOLS 7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DF_DEFAULT_TYPE DF_FLOAT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SIGNED_TEST(val) ((val)==sizeof(long) ? DF_LONG : ((val)==sizeof(long long) ? DF_LONGLONG : ((val)==sizeof(int) ? DF_INT : ((val)==sizeof(short) ? DF_SHORT : ((val)==sizeof(char) ? DF_CHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define UNSIGNED_TEST(val) ((val)==sizeof(unsigned long) ? DF_ULONG : ((val)==sizeof(unsigned long long) ? DF_ULONGLONG : ((val)==sizeof(unsigned int) ? DF_UINT : ((val)==sizeof(unsigned short) ? DF_USHORT : ((val)==sizeof(unsigned char) ? DF_UCHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLOAT_TEST(val) ((val)==sizeof(float) ? DF_FLOAT : ((val)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define df_set_skip_after(col,bytes) df_set_skip_before(col+1,bytes)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STANDARD stderr
	///#define BACKUP_SUFFIX ".old"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex(a) {sprintf (fitbuf+9, (a)); error_ex ();}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex2(a,b) {sprintf (fitbuf+9, (a),(b)); error_ex ();}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex3(a,b,c) {sprintf (fitbuf+9, (a),(b),(c)); error_ex ();}
	///#ifdef GP_FIT_ERRVARS
	///#endif // GP_FIT_ERRVARS 
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#ifdef HIDDEN3D_VAR_PTSIZE // Needed for variable pointsize, but takes space
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLAG_VERTEX_AS_UNDEFINED(v) do { (v).z = -2.0; } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VERTEX_IS_UNDEFINED(v) ((v).z == -2.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define V_EQUAL(a,b) ( GE(0.0, fabs((a)->x - (b)->x) + fabs((a)->y - (b)->y) + fabs((a)->z - (b)->z)) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOORD(v,xvar,yvar) { xvar = ((int)((v)->x * xscaler)) + xmiddle; yvar = ((int)((v)->y * yscaler)) + ymiddle; }
	///#ifndef LITE
	///#endif
	///#define PROGRAM "G N U P L O T"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_NUM_OR_TIME(fp, x, axis) do{ if (axis_array[axis].is_timedata) { char s[80]; putc('"', fp); gstrftime(s,80,axis_array[axis].timefmt,(double)(x)); fputs(conv_text(s), fp); putc('"', fp); } else { fprintf(fp,"%#g",x); } } while(0)
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifndef TERM_HELP
	///#define PM3D_AT_BASE 'b'
	///#define PM3D_AT_TOP 't'
	///#define PM3D_AT_SURFACE 's'
	///#define PM3D_FLUSH_BEGIN 'b'
	///#define PM3D_FLUSH_END 'r'
	///#define PM3D_FLUSH_CENTER 'c'
	///#define PM3D_SCANS_AUTOMATIC 'a'
	///#define PM3D_SCANS_FORWARD 'f'
	///#define PM3D_SCANS_BACKWARD 'b'
	///#define PM3D_DEPTH 'd'
	///#define PM3D_CLIP_1IN '1'
	///#define PM3D_CLIP_4IN '4'
	///#endif // TERM_HELP 

	public static void save_functions__sub(FILE fp)
	{
		udft_entry udf = GlobalMembersEval.first_udf;

		while (udf != null)
		{
		if (udf.definition != null)
		{
			fprintf(fp, "%s\n", udf.definition);
		}
		udf = udf.next_udf;
		}
	}
	public static void save_variables__sub(FILE fp)
	{
		/* always skip pi */
		udvt_entry udv = GlobalMembersEval.first_udv.next_udv;

		while (udv != null)
		{
		if (!udv.udv_undef)
		{
			if (strncmp(udv.udv_name,"GPVAL_",6) && strncmp(udv.udv_name,"MOUSE_",6) && strncmp(udv.udv_name,"NaN",4))
			{
			fprintf(fp, "%s = ", udv.udv_name);
			disp_value(fp, (udv.udv_value), true);
			() putc('\n', fp);
			}
		}
		udv = udv.next_udv;
		}
	}
	public static void save_tics(FILE fp, AXIS_INDEX axis)
	{
		if ((GlobalMembersAxis.axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MASK) == DefineConstants.NO_TICS)
		{
		fprintf(fp, "set no%stics\n", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		return;
		}
		fprintf(fp, "set %stics %s %s scale %g,%g %smirror %s ", GlobalMembersAxis.axis_defaults[axis.getValue()].name, ((GlobalMembersAxis.axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MASK) == DefineConstants.TICS_ON_AXIS) ? "axis" : "border", (GlobalMembersAxis.axis_array[axis.getValue()].tic_in) ? "in" : "out", GlobalMembersAxis.axis_array[axis.getValue()].ticscale, GlobalMembersAxis.axis_array[axis.getValue()].miniticscale, (GlobalMembersAxis.axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MIRROR) ? "" : "no", GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate != 0 ? "rotate" : "norotate");
		if (GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate != 0)
			fprintf(fp,"by %d ",GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate);
		GlobalMembersSave.save_position(fp, GlobalMembersAxis.axis_array[axis.getValue()].ticdef.offset, true);
		fprintf(fp, "\nset %stics ", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		switch (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type)
		{
		case TIC_COMPUTED:
		{
			fputs("autofreq ", fp);
			break;
		}
		case TIC_MONTH:
		{
			fprintf(fp, "\nset %smtics", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
			break;
		}
		case TIC_DAY:
		{
			fprintf(fp, "\nset %sdtics", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
			break;
		}
		case TIC_SERIES:
		if (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.start != -DefineConstants.VERYLARGE)
		{
			do
			{
				if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
				{
					String s = new String(new char[80]);
					putc('"', fp);
					GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)((double) GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.start));
					fputs(conv_text(s), fp);
					putc('"', fp);
				}
				else
				{
					fprintf(fp,"%#g",(double) GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.start);
				}
			} while (0);
			putc(',', fp);
		}
		fprintf(fp, "%g", GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.incr);
		if (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.end != DefineConstants.VERYLARGE)
		{
			putc(',', fp);
			do
			{
				if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
				{
					String s = new String(new char[80]);
					putc('"', fp);
					GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)((double) GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.end));
					fputs(conv_text(s), fp);
					putc('"', fp);
				}
				else
				{
					fprintf(fp,"%#g",(double) GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.series.end);
				}
			} while (0);
		}
		break;
		case TIC_USER:
		break;
		}

		fprintf(fp, (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.rangelimited)?" rangelimit":" norangelimit");

		if (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font != null && GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font != null)
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font);

		if (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.textcolor.type != DefineConstants.TC_DEFAULT)
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: save_textcolor(fp, &axis_array[axis].ticdef.textcolor);
			GlobalMembersSave.save_textcolor(fp, new t_colorspec(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.textcolor));

		putc('\n', fp);

		if (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user != null)
		{
		ticmark t;
		fprintf(fp, "set %stics %s ", GlobalMembersAxis.axis_defaults[axis.getValue()].name, (GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type == en_ticseries_type.TIC_USER) ? "" : "add");
		fputs(" (", fp);
		for (t = GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user; t != DefineConstants.NULL; t = t.next)
		{
			if (t.level < 0) // Don't save ticlabels read from data file
			continue;
			if (t.label != null)
			fprintf(fp, "\"%s\" ", conv_text(t.label));
			do
			{
				if (GlobalMembersAxis.axis_array[axis.getValue()].is_timedata)
				{
					String s = new String(new char[80]);
					putc('"', fp);
					GlobalMembersTime.gstrftime(s, 80, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, (double)((double) t.position));
					fputs(conv_text(s), fp);
					putc('"', fp);
				}
				else
				{
					fprintf(fp,"%#g",(double) t.position);
				}
			} while (0);
			if (t.level != 0)
			fprintf(fp, " %d", t.level);
			if (t.next != null)
			{
			fputs(", ", fp);
			}
		}
		fputs(")\n", fp);
		}

	}
	public static void save_position(FILE fp, position pos, boolean offset)
	{
		assert position_type.first_axes == 0 && position_type.second_axes == 1 && position_type.graph == 2 && position_type.screen == 3 && position_type.character == 4;

		if (offset)
		fprintf(fp, " offset ");

		fprintf(fp, "%s%g, %s%g, %s%g", pos.scalex == (position_type.first_axes.getValue()) != 0 ? "" : coord_msg[pos.scalex.getValue()], pos.x, pos.scaley == ((int)pos.scalex) != 0 ? "" : coord_msg[pos.scaley.getValue()], pos.y, pos.scalez == ((int)pos.scaley) != 0 ? "" : coord_msg[pos.scalez.getValue()], pos.z);
	}
	public static void save_zeroaxis(FILE fp, AXIS_INDEX axis)
	{
		fprintf(fp, "set %szeroaxis", GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		GlobalMembersSave.save_linetype(fp, (GlobalMembersAxis.axis_array[axis.getValue()].zeroaxis), false);
		putc('\n', fp);
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String[] save_set_all_msg = {"first", "second", "graph", "screen", "character"};
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String[] save_set_all_msg = {"first", "second", "graph", "screen", "character"};
	public static void save_set_all(FILE fp)
	{
		text_label this_label;
		arrow_def this_arrow;
		linestyle_def this_linestyle;
		arrowstyle_def this_arrowstyle;
		legend_key key = GlobalMembersGadgets.keyT;

		/* opinions are split as to whether we save term and outfile
		 * as a compromise, we output them as comments !
		 */
		if (GlobalMembersTerm.term != null)
		fprintf(fp, "# set terminal %s %s\n", GlobalMembersTerm.term.name, GlobalMembersTerm.term_options);
		else
		fputs("# set terminal unknown\n", fp);

		if (GlobalMembersTerm.outstr != null)
		fprintf(fp, "# set output '%s'\n", GlobalMembersTerm.outstr);
		else
		fputs("# set output\n", fp);

		fprintf(fp, "%sset clip points\n%sset clip one\n%sset clip two\nset bar %f %s\n", (GlobalMembersGadgets.clip_points) ? "" : "un", (GlobalMembersGadgets.clip_lines1) ? "" : "un", (GlobalMembersGadgets.clip_lines2) ? "" : "un", GlobalMembersGraphics.bar_size, (GlobalMembersGraphics.bar_layer == DefineConstants.LAYER_BACK) ? "back" : "front");

		if (GlobalMembersGadgets.draw_border != 0)
		{
		fprintf(fp, "set border %d %s", GlobalMembersGadgets.draw_border, GlobalMembersGadgets.border_layer == 0 ? "back" : "front");
		GlobalMembersSave.save_linetype(fp, GlobalMembersGadgets.border_lp, false);
		fprintf(fp, "\n");
		}
		else
		fputs("unset border\n", fp);

		fprintf(fp, "set xdata%s\nset ydata%s\nset zdata%s\nset x2data%s\nset y2data%s\n", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].is_timedata ? " time" : "", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].is_timedata ? " time" : "", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].is_timedata ? " time" : "", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].is_timedata ? " time" : "", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].is_timedata ? " time" : "");

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_TIMEFMT(axis) if (strlen(axis_array[axis].timefmt)) fprintf(fp, "set timefmt %s \"%s\"\n", axis_defaults[axis].name, conv_text(axis_array[axis].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].timefmt));
		if (String.valueOf(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].timefmt).length())
			fprintf(fp, "set timefmt %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].timefmt));
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_TIMEFMT

		if (GlobalMembersPlot2d.boxwidth < 0.0)
		fputs("set boxwidth\n", fp);
		else
		fprintf(fp, "set boxwidth %g %s\n", GlobalMembersPlot2d.boxwidth, (GlobalMembersPlot2d.boxwidth_is_absolute) ? "absolute" : "relative");

		fprintf(fp, "set style fill ");
		GlobalMembersSave.save_fillstyle(fp, GlobalMembersGadgets.default_fillstyle);

	///#ifdef EAM_OBJECTS
		/* Default rectangle style */
		fprintf(fp, "set style rectangle %s fc ", GlobalMembersGadgets.default_rectangle.layer > 0 ? "front" : GlobalMembersGadgets.default_rectangle.layer < 0 ? "behind" : "back");
		if (GlobalMembersGadgets.default_rectangle.lp_properties.use_palette)
		GlobalMembersSave.save_pm3dcolor(fp, GlobalMembersGadgets.default_rectangle.lp_properties.pm3d_color);
		else
		fprintf(fp, "lt %d",GlobalMembersGadgets.default_rectangle.lp_properties.l_type + 1);
		fprintf(fp, " fillstyle ");
		GlobalMembersSave.save_fillstyle(fp, GlobalMembersGadgets.default_rectangle.fillstyle);
	///#endif

		if (GlobalMembersPlot3d.dgrid3d)
		{
		  if (GlobalMembersPlot3d.dgrid3d_mode == en_dgrid3d_mode.DGRID3D_QNORM.getValue())
		  {
		fprintf(fp, "set dgrid3d %d,%d, %d\n", GlobalMembersPlot3d.dgrid3d_row_fineness, GlobalMembersPlot3d.dgrid3d_col_fineness, GlobalMembersPlot3d.dgrid3d_norm_value);
		  }
		  else if (GlobalMembersPlot3d.dgrid3d_mode == en_dgrid3d_mode.DGRID3D_SPLINES.getValue())
		  {
		fprintf(fp, "set dgrid3d %d,%d splines\n", GlobalMembersPlot3d.dgrid3d_row_fineness, GlobalMembersPlot3d.dgrid3d_col_fineness);
		  }
		  else
		  {
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: fprintf(fp, "set dgrid3d %d,%d %s %f,%f\n", dgrid3d_row_fineness, dgrid3d_col_fineness, reverse_table_lookup(dgrid3d_mode_tbl, dgrid3d_mode), dgrid3d_x_scale, dgrid3d_y_scale);
		fprintf(fp, "set dgrid3d %d,%d %s %f,%f\n", GlobalMembersPlot3d.dgrid3d_row_fineness, GlobalMembersPlot3d.dgrid3d_col_fineness, GlobalMembersTables.reverse_table_lookup(new gen_table(GlobalMembersTables.dgrid3d_mode_tbl), GlobalMembersPlot3d.dgrid3d_mode), GlobalMembersPlot3d.dgrid3d_x_scale, GlobalMembersPlot3d.dgrid3d_y_scale);
		  }
		}

		fprintf(fp, "set dummy %s,%s\n", GlobalMembersParse.set_dummy_var[0], GlobalMembersParse.set_dummy_var[1]);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_FORMAT(axis) fprintf(fp, "set format %s \"%s\"\n", axis_defaults[axis].name, conv_text(axis_array[axis].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].formatstring));
		fprintf(fp, "set format %s \"%s\"\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].formatstring));
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_FORMAT

		fprintf(fp, "set angles %s\n", (GlobalMembersGadgets.ang2rad == 1.0) ? "radians" : "degrees");

		/* Grid back/front controls tics also. Make sure it is saved */
		if (GlobalMembersAxis.grid_layer >= 0)
		fprintf(fp,"set tics %s\n", GlobalMembersAxis.grid_layer == 0 ? "back" : "front");

		if (!GlobalMembersAxis.some_grid_selected())
		fputs("unset grid\n", fp);
		else
		{
		if (GlobalMembersAxis.polar_grid_angle != 0) // set angle already output
			fprintf(fp, "set grid polar %f\n", GlobalMembersAxis.polar_grid_angle / GlobalMembersGadgets.ang2rad);
			else
			fputs("set grid nopolar\n", fp);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_GRID(axis) fprintf(fp, " %s%stics %sm%stics", axis_array[axis].gridmajor ? "" : "no", axis_defaults[axis].name, axis_array[axis].gridminor ? "" : "no", axis_defaults[axis].name);
		fputs("set grid", fp);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
		fputs(" \\\n", fp);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
		fprintf(fp, " %s%stics %sm%stics", GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridmajor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridminor ? "" : "no", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
		fputs("\n", fp);
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_GRID

		fprintf(fp, "set grid %s  ", (GlobalMembersAxis.grid_layer == -1) ? "layerdefault" : ((GlobalMembersAxis.grid_layer == 0) ? "back" : "front"));
		GlobalMembersSave.save_linetype(fp, GlobalMembersAxis.grid_lp, false);
		fprintf(fp, ", ");
		GlobalMembersSave.save_linetype(fp, GlobalMembersAxis.mgrid_lp, false);
		fputc('\n', fp);
		}

		fprintf(fp, "set key title \"%s\"", conv_text(key.title));
		if (key.font != null)
		fprintf(fp, " font \"%s\"", key.font);
		if (key.textcolor.type != DefineConstants.TC_LT || key.textcolor.lt != DefineConstants.LT_BLACK)
		GlobalMembersSave.save_textcolor(fp, key.textcolor);
		fputs("\n", fp);

		fputs("set key ", fp);
		switch (key.region)
		{
		case GPKEY_AUTO_INTERIOR_LRTBC:
			fputs("inside", fp);
			break;
		case GPKEY_AUTO_EXTERIOR_LRTBC:
			fputs("outside", fp);
			break;
		case GPKEY_AUTO_EXTERIOR_MARGIN:
			switch (key.margin)
			{
			case GPKEY_TMARGIN:
			fputs("tmargin", fp);
			break;
			case GPKEY_BMARGIN:
			fputs("bmargin", fp);
			break;
			case GPKEY_LMARGIN:
			fputs("lmargin", fp);
			break;
			case GPKEY_RMARGIN:
			fputs("rmargin", fp);
			break;
			}
			break;
		case GPKEY_USER_PLACEMENT:
			fputs("at ", fp);
			GlobalMembersSave.save_position(fp, key.user_pos, false);
			break;
		}
		if (!(key.region == en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN && (key.margin == en_key_ext_region.GPKEY_LMARGIN || key.margin == en_key_ext_region.GPKEY_RMARGIN)))
		{
		switch (key.hpos)
		{
			case RIGHT:
			fputs(" right", fp);
			break;
			case LEFT:
			fputs(" left", fp);
			break;
			case CENTRE:
			fputs(" center", fp);
			break;
		}
		}
		if (!(key.region == en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN && (key.margin == en_key_ext_region.GPKEY_TMARGIN || key.margin == en_key_ext_region.GPKEY_BMARGIN)))
		{
		switch (key.vpos)
		{
			case JUST_TOP:
			fputs(" top", fp);
			break;
			case JUST_BOT:
			fputs(" bottom", fp);
			break;
			case JUST_CENTRE:
			fputs(" center", fp);
			break;
		}
		}
		fprintf(fp, " %s %s %sreverse %senhanced %s ", key.stack_dir == (en_key_stack_direction.GPKEY_VERTICAL.getValue()) != 0 ? "vertical" : "horizontal", key.just == (en_key_sample_positioning.GPKEY_LEFT.getValue()) != 0 ? "Left" : "Right", key.reverse ? "" : "no", key.enhanced ? "" : "no", key.auto_titles == (keytitle_type.COLUMNHEAD_KEYTITLES.getValue()) != 0 ? "autotitles columnhead" : key.auto_titles == (keytitle_type.FILENAME_KEYTITLES.getValue()) != 0 ? "autotitles" : "noautotitles");
		if (key.box.l_type > DefineConstants.LT_NODRAW)
		{
		fputs("box", fp);
		GlobalMembersSave.save_linetype(fp, (key.box), false);
		}
		else
		fputs("nobox", fp);

		/* Put less common options on a separate line*/
		fprintf(fp, "\nset key %sinvert samplen %g spacing %g width %g height %g ", key.invert ? "" : "no", key.swidth, key.vert_factor, key.width_fix, key.height_fix);
		fputc('\n', fp);

		if (!(key.visible))
		fputs("unset key\n", fp);

		fputs("unset label\n", fp);
		for (this_label = GlobalMembersGadgets.first_label; this_label != DefineConstants.NULL; this_label = this_label.next)
		{
		fprintf(fp, "set label %d \"%s\" at ", this_label.tag, conv_text(this_label.text));
		GlobalMembersSave.save_position(fp, this_label.place, false);

		switch (this_label.pos)
		{
		case LEFT:
			fputs(" left", fp);
			break;
		case CENTRE:
			fputs(" centre", fp);
			break;
		case RIGHT:
			fputs(" right", fp);
			break;
		}
		if (this_label.rotate != 0)
			fprintf(fp, " rotate by %d", this_label.rotate);
		else
			fprintf(fp, " norotate");
		if (!this_label.font.equals(DefineConstants.NULL))
			fprintf(fp, " font \"%s\"", this_label.font);
		fprintf(fp, " %s", (this_label.layer == 0) ? "back" : "front");
		if (this_label.noenhanced)
			fprintf(fp, " noenhanced");
		GlobalMembersSave.save_textcolor(fp, (this_label.textcolor));
		if (this_label.lp_properties.pointflag == 0)
			fprintf(fp, " nopoint");
		else
		{
			fprintf(fp, " point");
			GlobalMembersSave.save_linetype(fp, (this_label.lp_properties), true);
		}
		GlobalMembersSave.save_position(fp, this_label.offset, true);
		fputc('\n', fp);
		}
		fputs("unset arrow\n", fp);
		for (this_arrow = GlobalMembersGadgets.first_arrow; this_arrow != DefineConstants.NULL; this_arrow = this_arrow.next)
		{
		fprintf(fp, "set arrow %d from ", this_arrow.tag);
		GlobalMembersSave.save_position(fp, this_arrow.start, false);
		fputs(this_arrow.relative ? " rto " : " to ", fp);
		GlobalMembersSave.save_position(fp, this_arrow.end, false);
		fprintf(fp, " %s %s %s", GlobalMembersTerm.arrow_head_names[this_arrow.arrow_properties.head.getValue()], (this_arrow.arrow_properties.layer == 0) ? "back" : "front", ((this_arrow.arrow_properties.head_filled == 2) ? "filled" : ((this_arrow.arrow_properties.head_filled == 1) ? "empty" : "nofilled")));
		GlobalMembersSave.save_linetype(fp, (this_arrow.arrow_properties.lp_properties), false);
		if (this_arrow.arrow_properties.head_length > 0)
		{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static sbyte *msg[] = {"first", "second", "graph", "screen", "character"};
			fprintf(fp, " size %s %.3f,%.3f,%.3f", save_set_all_msg[this_arrow.arrow_properties.head_lengthunit], this_arrow.arrow_properties.head_length, this_arrow.arrow_properties.head_angle, this_arrow.arrow_properties.head_backangle);
		}
		fprintf(fp, "\n");
		}
		fprintf(fp, "set style increment %s\n", GlobalMembersGadgets.prefer_line_styles ? "userstyles" : "default");
		fputs("unset style line\n", fp);
		for (this_linestyle = GlobalMembersGadgets.first_linestyle; this_linestyle != DefineConstants.NULL; this_linestyle = this_linestyle.next)
		{
		fprintf(fp, "set style line %d ", this_linestyle.tag);
		GlobalMembersSave.save_linetype(fp, (this_linestyle.lp_properties), true);
		fprintf(fp, "\n");
		}
		fputs("unset style arrow\n", fp);
		for (this_arrowstyle = GlobalMembersGadgets.first_arrowstyle; this_arrowstyle != DefineConstants.NULL; this_arrowstyle = this_arrowstyle.next)
		{
		fprintf(fp, "set style arrow %d", this_arrowstyle.tag);
		fprintf(fp, " %s %s %s", GlobalMembersTerm.arrow_head_names[this_arrowstyle.arrow_properties.head.getValue()], (this_arrowstyle.arrow_properties.layer == 0)?"back":"front", ((this_arrowstyle.arrow_properties.head_filled == 2)?"filled": ((this_arrowstyle.arrow_properties.head_filled == 1)?"empty": "nofilled")));
		GlobalMembersSave.save_linetype(fp, (this_arrowstyle.arrow_properties.lp_properties), false);
		if (this_arrowstyle.arrow_properties.head_length > 0)
		{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static sbyte *msg[] = {"first", "second", "graph", "screen", "character"};
			fprintf(fp, " size %s %.3f,%.3f,%.3f", save_set_all_msg[this_arrowstyle.arrow_properties.head_lengthunit], this_arrowstyle.arrow_properties.head_length, this_arrowstyle.arrow_properties.head_angle, this_arrowstyle.arrow_properties.head_backangle);
		}
		fprintf(fp, "\n");
		}

		fprintf(fp, "set style histogram ");
		switch (GlobalMembersGadgets.histogram_opts.type)
		{
		default:
		case HT_CLUSTERED:
			fprintf(fp,"clustered gap %d ",GlobalMembersGadgets.histogram_opts.gap);
			break;
		case HT_ERRORBARS:
			fprintf(fp,"errorbars gap %d lw %g",GlobalMembersGadgets.histogram_opts.gap,GlobalMembersGadgets.histogram_opts.bar_lw);
			break;
		case HT_STACKED_IN_LAYERS:
			fprintf(fp,"rowstacked ");
			break;
		case HT_STACKED_IN_TOWERS:
			fprintf(fp,"columnstacked ");
			break;
		}
		fprintf(fp,"title ");
		GlobalMembersSave.save_position(fp, GlobalMembersGadgets.histogram_opts.title.offset, true);
		fprintf(fp, "\n");

	///#ifdef EAM_OBJECTS
		GlobalMembersSave.save_object(fp, 0);
	///#endif

		fputs("unset logscale\n", fp);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_LOG(axis) if (axis_array[axis].log) fprintf(fp, "set logscale %s %g\n", axis_defaults[axis].name, axis_array[axis].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].base);
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log)
			fprintf(fp, "set logscale %s %g\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].base);
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_LOG

		GlobalMembersSave.save_offsets(fp, "set offsets");

		/* FIXME */
		fprintf(fp, "set pointsize %g\nset encoding %s\n%sset polar\n%sset parametric\n", GlobalMembersGadgets.pointsize, GlobalMembersTerm.encoding_names[GlobalMembersGplt_x11.encoding.getValue()], (GlobalMembersGadgets.polar) ? "" : "un", (GlobalMembersGadgets.parametric) ? "" : "un");

		if (GlobalMembersUtil.numeric_locale != null)
		fprintf(fp, "set decimalsign locale \"%s\"\n", GlobalMembersUtil.numeric_locale);
		if (!GlobalMembersUtil.decimalsign.equals(DefineConstants.NULL))
		fprintf(fp, "set decimalsign '%s'\n", GlobalMembersUtil.decimalsign);
		if (GlobalMembersUtil.numeric_locale == null && GlobalMembersUtil.decimalsign == null)
			fprintf(fp, "unset decimalsign\n");

		fputs("set view ", fp);
		if (GlobalMembersGraph3d.splot_map == true)
		fputs("map", fp);
		else
		{
		fprintf(fp, "%g, %g, %g, %g", GlobalMembersGraph3d.surface_rot_x, GlobalMembersGraph3d.surface_rot_z, GlobalMembersGraph3d.surface_scale, GlobalMembersGraph3d.surface_zscale);
		}
		fprintf(fp, "  %s", GlobalMembersGadgets.aspect_ratio_3D == 2 ? "equal xy" : GlobalMembersGadgets.aspect_ratio_3D == 3 ? "equal xyz": "");

		fprintf(fp, "\nset samples %d, %d\nset isosamples %d, %d\n%sset surface\n%sset contour", GlobalMembersGadgets.samples_1, GlobalMembersGadgets.samples_2, GlobalMembersGraph3d.iso_samples_1, GlobalMembersGraph3d.iso_samples_2, (GlobalMembersGraph3d.draw_surface) ? "" : "un", (GlobalMembersGraph3d.draw_contour) ? "" : "un");

		switch (GlobalMembersGraph3d.draw_contour)
		{
		case CONTOUR_NONE:
		fputc('\n', fp);
		break;
		case CONTOUR_BASE:
		fputs(" base\n", fp);
		break;
		case CONTOUR_SRF:
		fputs(" surface\n", fp);
		break;
		case CONTOUR_BOTH:
		fputs(" both\n", fp);
		break;
		}
		if (GlobalMembersGraph3d.label_contours)
		fprintf(fp, "set clabel '%s'\n", GlobalMembersContour.contour_format);
		else
		fputs("unset clabel\n", fp);

	///#ifdef GP_MACROS
		if (GlobalMembersCommand.expand_macros)
		fputs("set macros\n", fp);
	///#endif

		fputs("set mapping ", fp);
		switch (GlobalMembersPlot3d.mapping3d)
		{
		case MAP3D_SPHERICAL:
		fputs("spherical\n", fp);
		break;
		case MAP3D_CYLINDRICAL:
		fputs("cylindrical\n", fp);
		break;
		case MAP3D_CARTESIAN:
		default:
		fputs("cartesian\n", fp);
		break;
		}

		if (!GlobalMembersDatafile.missing_val.equals(DefineConstants.NULL))
		fprintf(fp, "set datafile missing '%s'\n", GlobalMembersDatafile.missing_val);
		if (GlobalMembersDatafile.df_separator != '\0')
		fprintf(fp, "set datafile separator \"%c\"\n",GlobalMembersDatafile.df_separator);
		else
		fprintf(fp, "set datafile separator whitespace\n");
		if (strcmp(GlobalMembersDatafile.df_commentschars, DefineConstants.DEFAULT_COMMENTS_CHARS))
		fprintf(fp, "set datafile commentschars '%s'\n", GlobalMembersDatafile.df_commentschars);
		if (GlobalMembersDatafile.df_fortran_constants)
		fprintf(fp, "set datafile fortran\n");
		if (GlobalMembersDatafile.df_nofpe_trap)
		fprintf(fp, "set datafile nofpe_trap\n");

		GlobalMembersHidden3d.save_hidden3doptions(fp);
		fprintf(fp, "set cntrparam order %d\n", GlobalMembersContour.contour_order);
		fputs("set cntrparam ", fp);
		switch (GlobalMembersContour.contour_kind)
		{
		case CONTOUR_KIND_LINEAR:
		fputs("linear\n", fp);
		break;
		case CONTOUR_KIND_CUBIC_SPL:
		fputs("cubicspline\n", fp);
		break;
		case CONTOUR_KIND_BSPLINE:
		fputs("bspline\n", fp);
		break;
		}
		fputs("set cntrparam levels ", fp);
		switch (GlobalMembersContour.contour_levels_kind)
		{
		case LEVELS_AUTO:
		fprintf(fp, "auto %d\n", GlobalMembersContour.contour_levels);
		break;
		case LEVELS_INCREMENTAL:
		fprintf(fp, "incremental %g,%g,%g\n", (double)GlobalMembersContour.dyn_contour_levels_list.v[0], (double)GlobalMembersContour.dyn_contour_levels_list.v[1], (double)GlobalMembersContour.dyn_contour_levels_list.v[0] + (double)GlobalMembersContour.dyn_contour_levels_list.v[1] * GlobalMembersContour.contour_levels);
		break;
		case LEVELS_DISCRETE:
		{
			int i;
			fprintf(fp, "discrete %g", (double)GlobalMembersContour.dyn_contour_levels_list.v[0]);
			for (i = 1; i < GlobalMembersContour.contour_levels; i++)
			fprintf(fp, ",%g ", (double)GlobalMembersContour.dyn_contour_levels_list.v[i]);
			fputc('\n', fp);
		}
		}
		fprintf(fp, "set cntrparam points %d\nset size ratio %g %g,%g\nset origin %g,%g\n", GlobalMembersContour.contour_pts, GlobalMembersGadgets.aspect_ratio, GlobalMembersGadgets.xsize, GlobalMembersGadgets.ysize, GlobalMembersGadgets.xoffset, GlobalMembersGadgets.yoffset);

		fprintf(fp, "set style data ");
		GlobalMembersSave.save_data_func_style(fp, "data", GlobalMembersGadgets.data_style);
		fprintf(fp, "set style function ");
		GlobalMembersSave.save_data_func_style(fp, "function", GlobalMembersGadgets.func_style);

		GlobalMembersSave.save_zeroaxis(fp, AXIS_INDEX.FIRST_X_AXIS);
		GlobalMembersSave.save_zeroaxis(fp, AXIS_INDEX.FIRST_Y_AXIS);
		GlobalMembersSave.save_zeroaxis(fp, AXIS_INDEX.FIRST_Z_AXIS);
		GlobalMembersSave.save_zeroaxis(fp, AXIS_INDEX.SECOND_X_AXIS);
		GlobalMembersSave.save_zeroaxis(fp, AXIS_INDEX.SECOND_Y_AXIS);

		if (GlobalMembersGraph3d.xyplane.absolute)
		fprintf(fp, "set xyplane at %g\n", GlobalMembersGraph3d.xyplane.z);
		else
		fprintf(fp, "set ticslevel %g\n", GlobalMembersGraph3d.xyplane.z);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_MINI(axis) switch(axis_array[axis].minitics & TICS_MASK) { case 0: fprintf(fp, "set nom%stics\n", axis_defaults[axis].name); break; case MINI_AUTO: fprintf(fp, "set m%stics\n", axis_defaults[axis].name); break; case MINI_DEFAULT: fprintf(fp, "set m%stics default\n", axis_defaults[axis].name); break; case MINI_USER: fprintf(fp, "set m%stics %f\n", axis_defaults[axis].name, axis_array[axis].mtic_freq); break; }

		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].mtic_freq);
							break;
		};
		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].mtic_freq);
							break;
		};
		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].mtic_freq);
							break;
		};
		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].mtic_freq);
							break;
		};
		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].mtic_freq);
							break;
		};
		switch (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].minitics & DefineConstants.TICS_MASK)
		{
			case 0:
				fprintf(fp, "set nom%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
				break;
				case MINI_AUTO:
					fprintf(fp, "set m%stics\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
					break;
					case MINI_DEFAULT:
						fprintf(fp, "set m%stics default\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
						break;
						case MINI_USER:
							fprintf(fp, "set m%stics %f\n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].mtic_freq);
							break;
		};
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_MINI

		GlobalMembersSave.save_tics(fp, AXIS_INDEX.FIRST_X_AXIS);
		GlobalMembersSave.save_tics(fp, AXIS_INDEX.FIRST_Y_AXIS);
		GlobalMembersSave.save_tics(fp, AXIS_INDEX.FIRST_Z_AXIS);
		GlobalMembersSave.save_tics(fp, AXIS_INDEX.SECOND_X_AXIS);
		GlobalMembersSave.save_tics(fp, AXIS_INDEX.SECOND_Y_AXIS);
		GlobalMembersSave.save_tics(fp, AXIS_INDEX.COLOR_AXIS);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_AXISLABEL_OR_TITLE(name,suffix,lab) { fprintf(fp, "set %s%s \"%s\" ", name, suffix, lab.text ? conv_text(lab.text) : ""); fprintf(fp, "\nset %s%s ", name, suffix); save_position(fp, &(lab.offset), TRUE); fprintf(fp, " font \"%s\"", lab.font ? conv_text(lab.font) : ""); save_textcolor(fp, &(lab.textcolor)); if (lab.rotate) fprintf(fp, " rotate by %d", lab.rotate); else fprintf(fp, " norotate"); fprintf(fp, "%s\n", (lab.noenhanced) ? " noenhanced" : ""); }

		{
			fprintf(fp, "set %s%s \"%s\" ", "", "title", GlobalMembersGadgets.title.text != null ? conv_text(GlobalMembersGadgets.title.text) : "");
			fprintf(fp, "\nset %s%s ", "", "title");
			GlobalMembersSave.save_position(fp, (GlobalMembersGadgets.title.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersGadgets.title.font != null ? conv_text(GlobalMembersGadgets.title.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersGadgets.title.textcolor));
			if (GlobalMembersGadgets.title.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersGadgets.title.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersGadgets.title.noenhanced) ? " noenhanced" : "");
		};

		/* FIXME */
		fprintf(fp, "set timestamp %s \n", GlobalMembersGadgets.timelabel_bottom != 0 ? "bottom" : "top");
		{
			fprintf(fp, "set %s%s \"%s\" ", "", "timestamp", GlobalMembersGadgets.timelabel.text != null ? conv_text(GlobalMembersGadgets.timelabel.text) : "");
			fprintf(fp, "\nset %s%s ", "", "timestamp");
			GlobalMembersSave.save_position(fp, (GlobalMembersGadgets.timelabel.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersGadgets.timelabel.font != null ? conv_text(GlobalMembersGadgets.timelabel.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersGadgets.timelabel.textcolor));
			if (GlobalMembersGadgets.timelabel.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersGadgets.timelabel.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersGadgets.timelabel.noenhanced) ? " noenhanced" : "");
		};

		GlobalMembersSave.save_range(fp, AXIS_INDEX.R_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.T_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.U_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.V_AXIS);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_AXISLABEL(axis) { fprintf(fp, "set %s%s \"%s\" ", axis_defaults[axis].name, "label", axis_array[axis].label.text ? conv_text(axis_array[axis].label.text) : ""); fprintf(fp, "\nset %s%s ", axis_defaults[axis].name, "label"); save_position(fp, &(axis_array[axis].label.offset), true); fprintf(fp, " font \"%s\"", axis_array[axis].label.font ? conv_text(axis_array[axis].label.font) : ""); save_textcolor(fp, &(axis_array[axis].label.textcolor)); if (axis_array[axis].label.rotate) fprintf(fp, " rotate by %d", axis_array[axis].label.rotate); else fprintf(fp, " norotate"); fprintf(fp, "%s\n", (axis_array[axis].label.noenhanced) ? " noenhanced" : ""); }

		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		GlobalMembersSave.save_range(fp, AXIS_INDEX.FIRST_X_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.SECOND_X_AXIS);

		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		if (GlobalMembersGraph3d.splot_map == false)
		{
		GlobalMembersSave.save_range(fp, AXIS_INDEX.FIRST_Y_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.SECOND_Y_AXIS);
		} // 'set view map' uses flipped y-axes
		else
		{
		GlobalMembersCommand.splot_map_deactivate();
		GlobalMembersSave.save_range(fp, AXIS_INDEX.FIRST_Y_AXIS);
		GlobalMembersSave.save_range(fp, AXIS_INDEX.SECOND_Y_AXIS);
		GlobalMembersCommand.splot_map_activate();
		}

		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		GlobalMembersSave.save_range(fp, AXIS_INDEX.FIRST_Z_AXIS);

		{
			fprintf(fp, "set %s%s \"%s\" ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, "label", GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.text != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.text) : "");
			fprintf(fp, "\nset %s%s ", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name, "label");
			GlobalMembersSave.save_position(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.offset), true);
			fprintf(fp, " font \"%s\"", GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.font != null ? conv_text(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.font) : "");
			GlobalMembersSave.save_textcolor(fp, (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.textcolor));
			if (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.rotate != 0)
				fprintf(fp, " rotate by %d", GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.rotate);
				else
					fprintf(fp, " norotate");
					fprintf(fp, "%s\n", (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.noenhanced) ? " noenhanced" : "");
		};
		GlobalMembersSave.save_range(fp, AXIS_INDEX.COLOR_AXIS);
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_AXISLABEL
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SAVE_AXISLABEL_OR_TITLE

		fprintf(fp, "set zero %g\n", GlobalMembersGadgets.zero);

		fprintf(fp, "set lmargin %s %g\n", GlobalMembersGadgets.lmargin.scalex == (position_type.screen.getValue()) != 0 ? "at screen" : "", GlobalMembersGadgets.lmargin.x);
		fprintf(fp, "set bmargin %s %g\n", GlobalMembersGadgets.bmargin.scalex == (position_type.screen.getValue()) != 0 ? "at screen" : "", GlobalMembersGadgets.bmargin.x);
		fprintf(fp, "set rmargin %s %g\n", GlobalMembersGadgets.rmargin.scalex == (position_type.screen.getValue()) != 0 ? "at screen" : "", GlobalMembersGadgets.rmargin.x);
		fprintf(fp, "set tmargin %s %g\n", GlobalMembersGadgets.tmargin.scalex == (position_type.screen.getValue()) != 0 ? "at screen" : "", GlobalMembersGadgets.tmargin.x);

		fprintf(fp, "set locale \"%s\"\n", () GlobalMembersVariable.locale_handler(1 << 3, DefineConstants.NULL)());

		fputs("set pm3d ", fp);
		fputs((PM3D_IMPL_MODE.PM3D_IMPLICIT == ((int)GlobalMembersPm3d.pm3d.implicit) != 0 ? "implicit" : "explicit"), fp);
		fprintf(fp, " at %s\n", GlobalMembersPm3d.pm3d.where);
		fputs("set pm3d ", fp);
		switch (GlobalMembersPm3d.pm3d.direction)
		{
		case DefineConstants.PM3D_SCANS_AUTOMATIC:
			fputs("scansautomatic\n", fp);
			break;
		case DefineConstants.PM3D_SCANS_FORWARD:
			fputs("scansforward\n", fp);
			break;
		case DefineConstants.PM3D_SCANS_BACKWARD:
			fputs("scansbackward\n", fp);
			break;
		case DefineConstants.PM3D_DEPTH:
			fputs("depthorder\n", fp);
			break;
		}
		fprintf(fp, "set pm3d interpolate %d,%d", GlobalMembersPm3d.pm3d.interp_i, GlobalMembersPm3d.pm3d.interp_j);
		fputs(" flush ", fp);
		switch (GlobalMembersPm3d.pm3d.flush)
		{
		case DefineConstants.PM3D_FLUSH_CENTER:
			fputs("center", fp);
			break;
		case DefineConstants.PM3D_FLUSH_BEGIN:
			fputs("begin", fp);
			break;
		case DefineConstants.PM3D_FLUSH_END:
			fputs("end", fp);
			break;
		}
		fputs((GlobalMembersPm3d.pm3d.ftriangles != 0 ? " " : " no"), fp);
		fputs("ftriangles", fp);
		if (GlobalMembersPm3d.pm3d.hidden3d_tag != 0)
			fprintf(fp," hidden3d %d", GlobalMembersPm3d.pm3d.hidden3d_tag);
		else
			fputs(" nohidden3d", fp);
		fputs(" corners2color ", fp);
		switch (GlobalMembersPm3d.pm3d.which_corner_color)
		{
		case PM3D_WHICHCORNER_MEAN:
			fputs("mean", fp);
			break;
		case PM3D_WHICHCORNER_GEOMEAN:
			fputs("geomean", fp);
			break;
		case PM3D_WHICHCORNER_MEDIAN:
			fputs("median", fp);
			break;
		case PM3D_WHICHCORNER_MIN:
			fputs("min", fp);
			break;
		case PM3D_WHICHCORNER_MAX:
			fputs("max", fp);
			break;
		default: // PM3D_WHICHCORNER_C1 ... _C4
			 fprintf(fp, "c%i", GlobalMembersPm3d.pm3d.which_corner_color - PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_C1 + 1);
		}
		fputs("\n", fp);

		/*
		 *  Save palette information
		 */

		fprintf(fp, "set palette %s %s maxcolors %d ", GlobalMembersColor.sm_palette.positive == DefineConstants.SMPAL_POSITIVE ? "positive" : "negative", GlobalMembersColor.sm_palette.ps_allcF != 0 ? "ps_allcF" : "nops_allcF", GlobalMembersColor.sm_palette.use_maxcolors);
		fprintf(fp, "gamma %g ", GlobalMembersColor.sm_palette.gamma);
		if (GlobalMembersColor.sm_palette.colorMode == palette_color_mode.SMPAL_COLOR_MODE_GRAY)
		{
		  fputs("gray\n", fp);
		}
		else
		{
		  fputs("color model ", fp);
		  switch (GlobalMembersColor.sm_palette.cmodel)
		  {
			case C_MODEL_RGB:
				fputs("RGB ", fp);
				break;
			case C_MODEL_HSV:
				fputs("HSV ", fp);
				break;
			case C_MODEL_CMY:
				fputs("CMY ", fp);
				break;
			case C_MODEL_YIQ:
				fputs("YIQ ", fp);
				break;
			case C_MODEL_XYZ:
				fputs("XYZ ", fp);
				break;
			default:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
		  fprintf(stderr, "%s:%d ooops: Unknown color model '%c'.\n", __FILE__, __LINE__, (byte)(GlobalMembersColor.sm_palette.cmodel));
		  }
		  fputs("\nset palette ", fp);
		  switch (GlobalMembersColor.sm_palette.colorMode)
		  {
		  case SMPAL_COLOR_MODE_RGB:
		fprintf(fp, "rgbformulae %d, %d, %d\n", GlobalMembersColor.sm_palette.formulaR, GlobalMembersColor.sm_palette.formulaG, GlobalMembersColor.sm_palette.formulaB);
		break;
		  case SMPAL_COLOR_MODE_GRADIENT:
		  {
		int i = 0;
		fprintf(fp, "defined (");
		for (i = 0; i < GlobalMembersColor.sm_palette.gradient_num; ++i)
		{
		  fprintf(fp, " %.4g %.4g %.4g %.4g", GlobalMembersColor.sm_palette.gradient[i].pos, GlobalMembersColor.sm_palette.gradient[i].col.r, GlobalMembersColor.sm_palette.gradient[i].col.g, GlobalMembersColor.sm_palette.gradient[i].col.b);
		  if (i < GlobalMembersColor.sm_palette.gradient_num - 1)
		  {
			  fputs(",", fp);
			  if (i == 2 || i % 4 == 2)
				  fputs("\\\n    ", fp);
		  }
		}
		fputs(" )\n", fp);
		break;
		  }
		  case SMPAL_COLOR_MODE_FUNCTIONS:
		fprintf(fp, "functions %s, %s, %s\n", GlobalMembersColor.sm_palette.Afunc.definition, GlobalMembersColor.sm_palette.Bfunc.definition, GlobalMembersColor.sm_palette.Cfunc.definition);
		break;
		  default:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
		fprintf(stderr, "%s:%d ooops: Unknown color mode '%c'.\n", __FILE__, __LINE__, (byte)(GlobalMembersColor.sm_palette.colorMode));
		  }
		}

		/*
		 *  Save colorbox info
		 */
		if (GlobalMembersGadgets.color_box.where != DefineConstants.SMCOLOR_BOX_NO)
		fprintf(fp,"set colorbox %s\n", GlobalMembersGadgets.color_box.where == DefineConstants.SMCOLOR_BOX_DEFAULT ? "default" : "user");
		fprintf(fp, "set colorbox %sal origin ", GlobalMembersGadgets.color_box.rotation == 'v' ? "vertic" : "horizont");
		GlobalMembersSave.save_position(fp, GlobalMembersGadgets.color_box.origin, false);
		fputs(" size ", fp);
		GlobalMembersSave.save_position(fp, GlobalMembersGadgets.color_box.size, false);
		fprintf(fp, " %s ", GlobalMembersGadgets.color_box.layer == DefineConstants.LAYER_FRONT ? "front" : "back");
		if (GlobalMembersGadgets.color_box.border == 0)
			fputs("noborder", fp);
		else if (GlobalMembersGadgets.color_box.border_lt_tag < 0)
			fputs("bdefault", fp);
			 else
				 fprintf(fp, "border %d", GlobalMembersGadgets.color_box.border_lt_tag);
		if (GlobalMembersGadgets.color_box.where == DefineConstants.SMCOLOR_BOX_NO)
			fputs("\nunset colorbox\n", fp);
		else
			fputs("\n", fp);

		fputs("set loadpath ", fp);
		{
		String s;
		while ((s = () GlobalMembersVariable.loadpath_handler(1 << 4, DefineConstants.NULL)()) != DefineConstants.NULL)
			fprintf(fp, "\"%s\" ", s);
		fputc('\n', fp);
		}

		fputs("set fontpath ", fp);
		{
		String s;
		while ((s = () GlobalMembersVariable.fontpath_handler(1 << 4, DefineConstants.NULL)()) != DefineConstants.NULL)
			fprintf(fp, "\"%s\" ", s);
		fputc('\n', fp);
		}

		/* HBB NEW 20020927: fit logfile name option */
	///#if GP_FIT_ERRVARS
		fprintf(fp, "set fit %serrorvariables", GlobalMembersFit.fit_errorvariables ? "" : "no");
		if (GlobalMembersFit.fitlogfile != null)
		{
		fprintf(fp, " logfile \'%s\'", GlobalMembersFit.fitlogfile);
		}
		fputc('\n', fp);
	///#else
	//    if (fitlogfile) {
	//	fprintf(fp, "set fit logfile \'%s\'\n", fitlogfile);
	//    }
	///#endif // GP_FIT_ERRVARS

	}

	public static String[] coord_msg = {"first ", "second ", "graph ", "screen ", "character "};
}
///#endif

