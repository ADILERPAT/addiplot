package com.addiPlot.gnuplot;

public class GlobalMembersMouse
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: mouse.c,v 1.117.2.2 2009/07/05 00:07:10 sfeam Exp $");
	}
	///#endif

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern mouse_setting_t mouse_setting;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte mouse_fmt_default[];


	/* enum of GP_ -keycodes has moved to mousecmn.h so that it can be
	 * accessed by standalone terminals too */


	/* FIXME HBB 20010207: Codestyle violation, again. */
	///#ifdef _MOUSE_C
	/* the following table must match exactly the
	 * enum's of GP_ and end with a NULL pointer! */
	public static String[] special_keys = {"GP_FIRST_KEY", "Linefeed", "Clear", "Pause", "Scroll_Lock", "Sys_Req", "Insert", "Home", "Left", "Up", "Right", "Down", "PageUp", "PageDown", "End", "Begin", "KP_Space", "KP_Tab", "KP_F1", "KP_F2", "KP_F3", "KP_F4", "KP_Insert", "KP_End", "KP_Down", "KP_PageDown", "KP_Left", "KP_Begin", "KP_Right", "KP_Home", "KP_Up", "KP_PageUp", "KP_Delete", "KP_Equal", "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal", "KP_Divide", "KP_0", "KP_1", "KP_2", "KP_3", "KP_4", "KP_5", "KP_6", "KP_7", "KP_8", "KP_9", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "Close", "GP_LAST_KEY", (byte*) 0};
	///#endif // _MOUSE_C 

	/* FIXME HBB 20010207: Codestyle violation: these should be in mouse.c! */
	///#if defined(_MOUSE_C)
		public static int mouse_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
		public static int clipboard_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
		public static String mouse_alt_string = (byte*) 0;
		public static String clipboard_alt_string = (byte*) 0;
	///#else
	//    extern long mouse_mode;
	//    extern long clipboard_mode;
	//    extern char* mouse_alt_string;
	//    extern char* clipboard_alt_string;
	///#endif


	public static void event_plotdone()
	{
		if (needreplot)
		{
		needreplot = false;
		GlobalMembersMouse.do_save_3dplot(GlobalMembersPlot3d.first_3dplot, GlobalMembersPlot3d.plot3d_num, !!(modifier_mask & AnonymousEnum2.Mod_Ctrl));
		}
		else
		{
		allowmotion = true;
		}
	}
	public static void recalc_statusline()
	{
		GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);
		GlobalMembersMouse.UpdateStatusline();
	}

/* Recalculate and replot the ruler after a '(re)plot'. Called from term.c.
*/
	public static void update_ruler()
	{
		if (!GlobalMembersTerm.term.set_ruler || !ruler.on)
		return;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*GlobalMembersTerm.term.set_ruler)(-1, -1);
		GlobalMembersMouse.recalc_ruler_pos();
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*GlobalMembersTerm.term.set_ruler)(ruler.px, ruler.py);
	}

/* Set ruler on/off, and set its position.
   Called from set.c for 'set mouse ruler ...' command.
*/
	public static void set_ruler(boolean on, int mx, int my)
	{
		gp_event_t ge = new gp_event_t();
		if (ruler.on == false && on == false)
		return;
		if (ruler.on == true && on == true && (mx < 0 || my < 0))
		return;
		if (ruler.on == true) // ruler is on => switch it off
		GlobalMembersMouse.builtin_toggle_ruler(ge);
		/* now the ruler is off */
		if (on == false) // want ruler off
		return;
		if (mx >= 0 && my >= 0) // change ruler position
		{
		ge.mx = mx;
		ge.my = my;
		} // don't change ruler position
		else
		{
		ge.mx = ruler.px;
		ge.my = ruler.py;
		}
		GlobalMembersMouse.builtin_toggle_ruler(ge);
	}
	public static void UpdateStatusline()
	{
		GlobalMembersMouse.UpdateStatuslineWithMouseSetting(mouse_setting);
	}
	public static void do_event(gp_event_t ge)
	{
		if (GlobalMembersTerm.term == null)
		return;

		if (GlobalMembersTerm.multiplot && ge.type != AnonymousEnum.GE_fontprops.getValue())
		/* only informational event processing for multiplot */
		return;

		/* disable `replot` when some data were sent through stdin */
		GlobalMembersCommand.replot_disabled = GlobalMembersDatafile.plotted_data_from_stdin;

		if (ge.type != 0)
		{
		GlobalMembersFit.a((stderr, "(do_event) type       = %d\n", ge.type));
		GlobalMembersFit.a((stderr, "           mx, my     = %d, %d\n", ge.mx, ge.my));
		GlobalMembersFit.a((stderr, "           par1, par2 = %d, %d\n", ge.par1, ge.par2));
		}

		switch (ge.type)
		{
		case GE_plotdone:
		GlobalMembersMouse.event_plotdone();
		if (ge.winid != 0)
		{
			GlobalMembersGadgets.current_x11_windowid = ge.winid;
			GlobalMembersEval.update_gpval_variables(6); // fill GPVAL_TERM_WINDOWID
		}
		break;
		case GE_keypress:
		GlobalMembersMouse.event_keypress(ge, true);
		break;
		case GE_keypress_old:
		GlobalMembersMouse.event_keypress(ge, false);
		break;
		case GE_modifier:
		GlobalMembersMouse.event_modifier(ge);
		break;
		case GE_motion:
		if (!mouse_setting.on)
			break;
		GlobalMembersMouse.event_motion(ge);
		break;
		case GE_buttonpress:
		if (!mouse_setting.on)
			break;
		GlobalMembersMouse.event_buttonpress(ge);
		break;
		case GE_buttonrelease:
		if (!mouse_setting.on)
			break;
		GlobalMembersMouse.event_buttonrelease(ge);
		break;
		case GE_replot:
		/* used only by ggi.trm */
		GlobalMembersCommand.do_string("replot", false);
		break;
		case GE_reset:
		GlobalMembersMouse.event_reset(ge);
		break;
		case GE_fontprops:
		GlobalMembersTerm.term.h_char = ge.par1;
		GlobalMembersTerm.term.v_char = ge.par2;
		/* Update aspect ratio based on current window size */
		GlobalMembersTerm.term.v_tic = GlobalMembersTerm.term.h_tic * (double)ge.mx / (double)ge.my;
		/* EAM FIXME - We could also update term->xmax and term->ymax here, */
		/*             but the existing code doesn't expect it to change.   */
		GlobalMembersFit.a((stderr, "mouse do_event: window size %d X %d, font hchar %d vchar %d\n", ge.mx, ge.my, ge.par1,ge.par2));
		break;
		case GE_buttonpress_old:
		case GE_buttonrelease_old:
		/* ignore */
		break;
		default:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
		fprintf(stderr, "%s:%d protocol error\n", __FILE__, __LINE__);
		break;
		}

		GlobalMembersCommand.replot_disabled = false; // enable replot again
	}

/* for checking if we change from plot to splot (or vice versa) */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int plot_mode_mode = MODE_PLOT_TYPE.MODE_PLOT.getValue();
	public static int plot_mode(int set)
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int mode = MODE_PLOT;
		if (MODE_PLOT_TYPE.MODE_PLOT.getValue() == set || MODE_PLOT_TYPE.MODE_SPLOT.getValue() == set)
		{
		if (plot_mode_mode != set)
		{
			GlobalMembersMouse.turn_ruler_off();
		}
		plot_mode_mode = set;
		}
		return plot_mode_mode;
	}
	public static void event_reset(gp_event_t ge)
	{
		modifier_mask = 0;
		button = 0;
		GlobalMembersMouse.builtin_cancel_zoom(ge);
		if (GlobalMembersTerm.term != null && GlobalMembersTerm.term.set_cursor)
		{
		GlobalMembersTerm.term.set_cursor(0, 0, 0);
		if (mouse_setting.annotate_zoom_box && GlobalMembersTerm.term.put_tmptext)
		{
			GlobalMembersTerm.term.put_tmptext(1, "");
			GlobalMembersTerm.term.put_tmptext(2, "");
		}
		}

		if (GlobalMembersCommand.paused_for_mouse != 0)
		{
		GlobalMembersCommand.paused_for_mouse = 0;
	///#ifdef _Windows
	// /* remove pause message box after 'pause mouse' */
	//	kill_pending_Pause_dialog();
	///#endif
		/* This hack is necessary on some systems in order to prevent one  */
		/* character of input from being swallowed when the plot window is */
		/* closed. But which systems, exactly?                             */
		if (GlobalMembersTerm.term != null && (!strncmp("x11",GlobalMembersTerm.term.name,3) || !strncmp("wxt",GlobalMembersTerm.term.name,3)))
			ungetc('\n',stdin);
		}

		/* Dummy up a keystroke event so that we can conveniently check for a  */
		/* binding to "Close". We only get these for the current window. */
		if (ge != (Object)1)
		{
		ge.par1 = AnonymousEnum4.GP_Cancel.getValue(); // Dummy keystroke
		ge.par2 = 0; // Not used; could pass window id here?
		GlobalMembersMouse.event_keypress(ge, true);
		}
	}

	/* bind prototype(s) */

	public static void bind_process(String lhs, String rhs, boolean allwindows)
	{
		if (bindings == null)
		{
		GlobalMembersMouse.bind_install_default_bindings();
		}
		if (rhs == null)
		{
		GlobalMembersMouse.bind_display(lhs);
		}
		else
		{
		GlobalMembersMouse.bind_append(lhs, rhs, 0);
		if (allwindows)
			GlobalMembersMouse.bind_all(lhs);
		}
		if (lhs != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(lhs);
	}
	public static void bind_remove_all()
	{
		bind_t ptr;
		bind_t safe;
		for (ptr = bindings; ptr; safe = ptr, ptr = ptr.next, free(safe))
		{
		if (ptr.command != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(ptr.command);
			ptr.command = (String) 0;
		}
		}
		bindings = (bind_t) 0;
	}


	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifndef TERM_HELP
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#define PM3D_AT_BASE 'b'
	///#define PM3D_AT_TOP 't'
	///#define PM3D_AT_SURFACE 's'
	///#define PM3D_FLUSH_BEGIN 'b'
	///#define PM3D_FLUSH_END 'r'
	///#define PM3D_FLUSH_CENTER 'c'
	///#define PM3D_SCANS_AUTOMATIC 'a'
	///#define PM3D_SCANS_FORWARD 'f'
	///#define PM3D_SCANS_BACKWARD 'b'
	///#define PM3D_DEPTH 'd'
	///#define PM3D_CLIP_1IN '1'
	///#define PM3D_CLIP_4IN '4'
	///#endif // TERM_HELP 
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#define DF_EOF (-1)
	///#define DF_UNDEFINED (-2)
	///#define DF_FIRST_BLANK (-3)
	///#define DF_SECOND_BLANK (-4)
	///#define DF_MISSING (-5)
	///#define DF_FOUND_KEY_TITLE (-6)
	///#define DF_KEY_TITLE_MISSING (-7)
	///#define DF_STRINGDATA (-8)
	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX // in limits.h ?
	///#define MAXINT INT_MAX
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif
	///#define MAXDATACOLS 7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DF_DEFAULT_TYPE DF_FLOAT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SIGNED_TEST(val) ((val)==sizeof(long) ? DF_LONG : ((val)==sizeof(long long) ? DF_LONGLONG : ((val)==sizeof(int) ? DF_INT : ((val)==sizeof(short) ? DF_SHORT : ((val)==sizeof(char) ? DF_CHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define UNSIGNED_TEST(val) ((val)==sizeof(unsigned long) ? DF_ULONG : ((val)==sizeof(unsigned long long) ? DF_ULONGLONG : ((val)==sizeof(unsigned int) ? DF_UINT : ((val)==sizeof(unsigned short) ? DF_USHORT : ((val)==sizeof(unsigned char) ? DF_UCHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLOAT_TEST(val) ((val)==sizeof(float) ? DF_FLOAT : ((val)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define df_set_skip_after(col,bytes) df_set_skip_before(col+1,bytes)
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#if defined(HAVE_LIBREADLINE)
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#include <editline/readline.h>
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#endif
	///#if defined(READLINE) && !defined(HAVE_LIBREADLINE) && !defined(HAVE_LIBEDITLINE)
	///#endif
	///#ifdef HIDDEN3D_VAR_PTSIZE // Needed for variable pointsize, but takes space
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLAG_VERTEX_AS_UNDEFINED(v) do { (v).z = -2.0; } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VERTEX_IS_UNDEFINED(v) ((v).z == -2.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define V_EQUAL(a,b) ( GE(0.0, fabs((a)->x - (b)->x) + fabs((a)->y - (b)->y) + fabs((a)->z - (b)->z)) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOORD(v,xvar,yvar) { xvar = ((int)((v)->x * xscaler)) + xmiddle; yvar = ((int)((v)->y * yscaler)) + ymiddle; }
	///#ifndef LITE
	///#endif

	///#ifdef _Windows
	///#include "win/winmain.h"
	///#endif

	///#ifdef OS2
	///#include "os2/pm_msgs.h"
	///#endif

	/********************** variables ***********************************************************/
	public static String mouse_fmt_default = "% #g";

	///#ifdef OS2
	//mouse_setting_t mouse_setting = { 0 , 300 , 1, 0, 0, 0, 0, mouse_fmt_default, NULL };
	//ignore
	//ignore
	///#else
		public final 1 = new 1();
		public static final 1[] struct gen_table usual_special_keys = {{"BackSpace", AnonymousEnum3.GP_BackSpace}, {"Tab", AnonymousEnum3.GP_Tab}, {"KP_Enter", AnonymousEnum3.GP_KP_Enter}, {"Return", AnonymousEnum3.GP_Return}, {"Escape", AnonymousEnum3.GP_Escape}, {"Delete", AnonymousEnum3.GP_Delete}, {DefineConstants.NULL, 0}};
	///#endif
	/* "usual well-known" keycodes, i.e. those not listed in special_keys in mouse.h
	*/

	/* the status of the shift, ctrl and alt keys
	*/
	public static int modifier_mask = 0;
	public static AnonymousClass3 ruler = new AnonymousClass3(false, 0, 0, 0, 0, 0, 0);


	/* the coordinates of the mouse cursor in gnuplot's internal coordinate system
	 */
	public static int mouse_x = -1;
	public static int mouse_y = -1;


	/* the "real" coordinates of the mouse cursor, i.e., in the user's coordinate
	 * system(s)
	 */
	public static double real_x;
	public static double real_y;
	public static double real_x2;
	public static double real_y2;


	/* mouse_polar_distance is set to TRUE if user wants to see the
	 * distance between the ruler and mouse pointer in polar coordinates
	 * too (otherwise, distance in cartesian coordinates only is shown) */
	/* int mouse_polar_distance = FALSE; */
	/* moved to the struct mouse_setting_t (joze) */


	/* status of buttons; button i corresponds to bit (1<<i) of this variable
	 */
	public static int button = 0;


	/* variables for setting the zoom region:
	 */
	/* flag, TRUE while user is outlining the zoom region */
	public static boolean setting_zoom_region = false;
	/* coordinates of the first corner of the zoom region, in the internal
	 * coordinate system */
	public static int setting_zoom_x;
	public static int setting_zoom_y;


	/* variables for changing the 3D view:
	*/
	/* do we allow motion to result in a replot right now? */
	public static boolean allowmotion = true; // used by pm.trm, too
	/* did we already postpone a replot because allowmotion was FALSE ? */
	public static boolean needreplot = false;
	/* mouse position when dragging started */
	public static int start_x;
	public static int start_y;
	/* ButtonPress sets this to 0, ButtonMotion to 1 */
	public static int motion = 0;
	/* values for rot_x and rot_z corresponding to zero position of mouse */
	public static float zero_rot_x;
	public static float zero_rot_z;

	public static bind_t bindings = (bind_t *) 0;
	public static final int NO_KEY = -1;
	public static boolean trap_release = false;

/********* functions ********************************************/

/* produce a beep */

	/* forward declarations */
	public static void alert()
	{
	///#ifdef GNUPMDRV
	//    DosBeep(444, 111);
	///#else
	///#ifdef HAVE_LIBREADLINE
		rl_ding();
		fflush(rl_outstream);
	///#else
	//    fprintf(stderr, "\a");
	///#endif
	///#endif
	}

///#ifndef HAVE_STPCPY
// /* handy function for composing strings; note: some platforms may
//  * already provide it, how should we handle that? autoconf? -- ptdb */
//char *
//stpcpy(char *s, const char *p)
//{
//    strcpy(s, p);
//    return s + strlen(p);
//}
///#endif


/* main job of transformation, which is not device dependent
*/
	public static void MousePosToGraphPosReal(int xx, int yy, double x, double y, double x2, double y2)
	{
		if (!GlobalMembersGadgets.is_3d_plot)
		{
		GlobalMembersFit.a((stderr, "POS: plot_bounds.xleft=%i, plot_bounds.xright=%i, plot_bounds.ybot=%i, plot_bounds.ytop=%i\n", GlobalMembersGadgets.plot_bounds.xleft, GlobalMembersGadgets.plot_bounds.xright, GlobalMembersGadgets.plot_bounds.ybot, GlobalMembersGadgets.plot_bounds.ytop));

		if (GlobalMembersGadgets.plot_bounds.xright == GlobalMembersGadgets.plot_bounds.xleft)
			x = x2 = DefineConstants.VERYLARGE; // protection
		else
		{
			x = (((double)(xx) - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_lower) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_scale + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min);
			x2 = (((double)(xx) - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].term_lower) / GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].term_scale + GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].min);
		}
		if (GlobalMembersGadgets.plot_bounds.ytop == GlobalMembersGadgets.plot_bounds.ybot)
			y = y2 = DefineConstants.VERYLARGE; // protection
		else
		{
			y = (((double)(yy) - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_lower) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_scale + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min);
			y2 = (((double)(yy) - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].term_lower) / GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].term_scale + GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].min);
		}
		GlobalMembersFit.a((stderr, "POS: xx=%i, yy=%i  =>  x=%g  y=%g\n", xx, yy, x, y));

		}
		else
		{
		/* for 3D plots, we treat the mouse position as if it is
		 * in the bottom plane, i.e., the plane of the x and y axis */
		/* note: at present, this projection is only correct if
		 * surface_rot_z is a multiple of 90 degrees! */
		/* HBB 20010522: added protection against division by zero
		 * for cases like 'set view 90,0' */
		xx -= GlobalMembersGraph3d.axis3d_o_x;
		yy -= GlobalMembersGraph3d.axis3d_o_y;
		if (Math.abs(GlobalMembersGraph3d.axis3d_x_dx) > Math.abs(GlobalMembersGraph3d.axis3d_x_dy))
		{
			x = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min + ((double) xx) / GlobalMembersGraph3d.axis3d_x_dx * (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min);
		}
		else if (GlobalMembersGraph3d.axis3d_x_dy != 0)
		{
			x = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min + ((double) yy) / GlobalMembersGraph3d.axis3d_x_dy * (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min);
		}
		else
		{
			/* both diffs are zero (x axis points into the screen */
			x = DefineConstants.VERYLARGE;
		}

		if (Math.abs(GlobalMembersGraph3d.axis3d_y_dx) > Math.abs(GlobalMembersGraph3d.axis3d_y_dy))
		{
			y = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min + ((double) xx) / GlobalMembersGraph3d.axis3d_y_dx * (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min);
		}
		else if (GlobalMembersGraph3d.axis3d_y_dy != 0)
		{
			y = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min + ((double) yy) / GlobalMembersGraph3d.axis3d_y_dy * (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min);
		}
		else
		{
			/* both diffs are zero (y axis points into the screen */
			y = DefineConstants.VERYLARGE;
		}

		x2 = y2 = DefineConstants.VERYLARGE; // protection
		}
		/*
		   Note: there is plot_bounds.xleft+0.5 in "#define map_x" in graphics.c, which
		   makes no major impact here. It seems that the mistake of the real
		   coordinate is at about 0.5%, which corresponds to the screen resolution.
		   It would be better to round the distance to this resolution, and thus
		   *x = xmin + rounded-to-screen-resolution (xdistance)
		 */

		/* Now take into account possible log scales of x and y axes */
		x = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log ? Math.exp((x) * GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log_base): (x));
		y = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? Math.exp((y) * GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log_base): (y));
		if (!GlobalMembersGadgets.is_3d_plot)
		{
		x2 = (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].log ? Math.exp((x2) * GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].log_base): (x2));
		y2 = (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].log ? Math.exp((y2) * GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].log_base): (y2));
		}
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String xy_format_format = new String(new char[0xff]);
	public static String xy_format()
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte format[0xff];
		xy_format_format = tangible.StringFunctions.changeCharacter(xy_format_format, 0, DefineConstants.NUL);
		xy_format_format += mouse_setting.fmt;
		xy_format_format += ", ";
		xy_format_format += mouse_setting.fmt;
		return xy_format_format;
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String zoombox_format_format = new String(new char[0xff]);
	public static String zoombox_format()
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte format[0xff];
		zoombox_format_format = tangible.StringFunctions.changeCharacter(zoombox_format_format, 0, DefineConstants.NUL);
		zoombox_format_format += mouse_setting.fmt;
		zoombox_format_format += "\r";
		zoombox_format_format += mouse_setting.fmt;
		return zoombox_format_format;
	}

/* formats the information for an annotation (middle mouse button clicked)
 */
	public static String GetAnnotateString(String s, double x, double y, int mode, String fmt)
	{
		if (mode == AnonymousEnum.MOUSE_COORDINATES_XDATE.getValue() || mode == AnonymousEnum.MOUSE_COORDINATES_XTIME.getValue() || mode == AnonymousEnum.MOUSE_COORDINATES_XDATETIME.getValue() || mode == AnonymousEnum.MOUSE_COORDINATES_TIMEFMT.getValue()) // time is on the x axis
		{
		String buf = new String(new char[0xff]);
		String format = "[%s, ";
		format += mouse_setting.fmt;
		format += "]";
		String.format(s, format, GlobalMembersMouse.xDateTimeFormat(x, buf, mode), y);
		}
		else if (mode == AnonymousEnum.MOUSE_COORDINATES_FRACTIONAL.getValue())
		{
		double xrange = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min;
		double yrange = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min;
		/* calculate fractional coordinates.
		 * prevent division by zero */
		if (xrange != 0)
		{
			String format = "/";
			format += mouse_setting.fmt;
			String.format(s, format, (x - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min) / xrange);
		}
		else
		{
			String.format(s, "/(undefined)");
		}
		s += s.length();
		if (yrange != 0)
		{
			String format = ", ";
			format += mouse_setting.fmt;
			format += "/";
			String.format(s, format, (y - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min) / yrange);
		}
		else
		{
			String.format(s, ", (undefined)/");
		}
		}
		else if (mode == AnonymousEnum.MOUSE_COORDINATES_REAL1.getValue())
		{
		String.format(s, GlobalMembersMouse.xy_format(), x, y); // w/o brackets
		}
		else if (mode == AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() && fmt != null)
		{
		String.format(s, fmt, x, y); // user defined format
		}
		else
		{
		String.format(s, GlobalMembersMouse.xy_format(), x, y); // usual x,y values
		}
		return s + s.length();
	}

/* Format x according to the date/time mouse mode. Uses and returns b as
   a buffer
 */
	public static String xDateTimeFormat(double x, String b, int mode)
	{
	///#ifndef SEC_OFFS_SYS
	///#define SEC_OFFS_SYS 946684800
	///#endif
		time_t xtime_position = DefineConstants.SEC_OFFS_SYS + x;
		tm pxtime_position = gmtime(xtime_position);
		switch (mode)
		{
		case MOUSE_COORDINATES_XDATE:
	///#if 1
		String.format(b, "%d. %d. %04d", pxtime_position.tm_mday, (pxtime_position.tm_mon) + 1,(pxtime_position.tm_year) + ((pxtime_position.tm_year <= 68) ? 2000 : 1900));
	///#else
	//    sprintf(b, "%d. %d. %04d", pxtime_position->tm_mday, (pxtime_position->tm_mon) + 1,((pxtime_position->tm_year) < 100) ? (pxtime_position->tm_year) : (pxtime_position->tm_year) - 100
	// /*              (pxtime_position->tm_year)+1900 */
	///#endif
		break;
		case MOUSE_COORDINATES_XTIME:
		String.format(b, "%d:%02d", pxtime_position.tm_hour, pxtime_position.tm_min);
		break;
		case MOUSE_COORDINATES_XDATETIME:
	///#if 1
		String.format(b, "%d. %d. %04d %d:%02d", pxtime_position.tm_mday, (pxtime_position.tm_mon) + 1,(pxtime_position.tm_year) + ((pxtime_position.tm_year <= 68) ? 2000 : 1900), pxtime_position.tm_hour, pxtime_position.tm_min);
	///#else
	//    sprintf(b, "%d. %d. %04d %d:%02d", pxtime_position->tm_mday, (pxtime_position->tm_mon) + 1,((pxtime_position->tm_year) < 100) ? (pxtime_position->tm_year) : (pxtime_position->tm_year) - 100,
	// /*              (pxtime_position->tm_year)+1900, */
	///#endif
		break;
		case MOUSE_COORDINATES_TIMEFMT:
		/* FIXME HBB 20000507: timefmt is for *reading* timedata, not
		 * for writing them! */
		GlobalMembersTime.gstrftime(b, 0xff, GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].timefmt, x);
		break;
		default:
		String.format(b, mouse_setting.fmt, x);
		}
		return b;
	}

/* formats the ruler information (position, distance,...) into string p
	(it must be sufficiently long)
   x, y is the current mouse position in real coords (for the calculation
	of distance)
*/
	public static void GetRulerString(String p, double x, double y)
	{
		double dx;
		double dy;

		String format = "  ruler: [";
		format += mouse_setting.fmt;
		format += ", ";
		format += mouse_setting.fmt;
		format += "]  distance: ";
		format += mouse_setting.fmt;
		format += ", ";
		format += mouse_setting.fmt;

		dx = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log) ? ((ruler.x == 0) ? 99999 : x / ruler.x) : (x - ruler.x);
		dy = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log) ? ((ruler.y == 0) ? 99999 : y / ruler.y) : (y - ruler.y);
		String.format(p, format, ruler.x, ruler.y, dx, dy);

		/* Previously, the following "if" let the polar coordinates to be shown only
		   for lin-lin plots:
			if (mouse_setting.polardistance && !axis_array[FIRST_X_AXIS].log && !axis_array[FIRST_Y_AXIS].log) ...
		   Now, let us support also semilog and log-log plots.
		   Values of mouse_setting.polardistance are:
			0 (no polar coordinates), 1 (polar coordinates), 2 (tangent instead of angle).
		*/
		if (mouse_setting.polardistance)
		{
		double rho;
		double phi;
		double rx;
		double ry;
		String ptmp = new String(new char[69]);
		x = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log ? (Math.log(x) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log_base) : (x));
		y = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? (Math.log(y) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log_base) : (y));
		rx = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log ? (Math.log(ruler.x) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log_base) : (ruler.x));
		ry = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? (Math.log(ruler.y) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log_base) : (ruler.y));
		format = tangible.StringFunctions.changeCharacter(format, 0, '\0');
		format += " (";
		format += mouse_setting.fmt;
		rho = Math.sqrt((x - rx) * (x - rx) + (y - ry) * (y - ry)); // distance
		if (mouse_setting.polardistance == 1) // (distance, angle)
		{
			phi = (180 / DefineConstants.M_PI) * Math.atan2(y - ry, x - rx);
	///#ifdef OS2
	//	    strcat(format, ";% #.4g)");
	///#else
			format += ", % #.4gdeg)";
	///#endif
		} // mouse_setting.polardistance==2: (distance, tangent)
		else
		{
			phi = x - rx;
			phi = (phi == 0) ? ((y - ry > 0) ? DefineConstants.VERYLARGE : -DefineConstants.VERYLARGE) : (y - ry) / phi;
			String.format(format + format.length(), ", tangent=%s)", mouse_setting.fmt);
		}
		String.format(ptmp, format, rho, phi);
		p += ptmp;
		}
	}

/* Applies the zoom rectangle of  z  by sending the appropriate command
   to gnuplot
*/

	public static void apply_zoom(t_zoom z)
	{
		String s = new String(new char[1024]); // HBB 20011005: made larger
		int is_splot_map = (GlobalMembersGadgets.is_3d_plot && (GlobalMembersGraph3d.splot_map == true));
		int flip = 0;

		if (zoom_now != DefineConstants.NULL) // remember the current zoom
		{
		zoom_now.xmin = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].set_min;
		zoom_now.xmax = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].set_max;
		zoom_now.x2min = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].set_min;
		zoom_now.x2max = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].set_max;
		zoom_now.was_splot_map = is_splot_map;
		if (is_splot_map == 0) // 2D plot
		{
			zoom_now.ymin = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].set_min;
			zoom_now.ymax = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].set_max;
			zoom_now.y2min = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].set_min;
			zoom_now.y2max = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].set_max;
		} // the opposite, i.e. case 'set view map'
		else
		{
			zoom_now.ymin = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].set_max;
			zoom_now.ymax = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].set_min;
			zoom_now.y2min = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].set_max;
			zoom_now.y2max = GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].set_min;
		}

		}

		/* EAM DEBUG - The autoscale save/restore was too complicated, and
		 * broke refresh. Just save the complete axis state and have done with it.
		 */
		if (zoom_now == zoom_head && z != zoom_head)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(axis_array_copy, GlobalMembersAxis.axis_array, sizeof(GlobalMembersAxis.axis_array));
		}

		/* If we are zooming, we don't want to autoscale the range.
		 * This wasn't necessary before we introduced "refresh".  Why?
		 */
		if (zoom_now == zoom_head && z != zoom_head)
		{
		GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].autoscale = e_autoscale.AUTOSCALE_NONE;
		GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].autoscale = e_autoscale.AUTOSCALE_NONE;
		GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].autoscale = e_autoscale.AUTOSCALE_NONE;
		GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].autoscale = e_autoscale.AUTOSCALE_NONE;
		}

		zoom_now = z;
		if (zoom_now == DefineConstants.NULL)
		{
		GlobalMembersMouse.alert();
		return;
		}

		flip = (is_splot_map != 0 && zoom_now.was_splot_map != 0);
		String.format(s, "set xr[%.12g:%.12g]; set yr[%.12g:%.12g]", zoom_now.xmin, zoom_now.xmax, (flip) ? zoom_now.ymax : zoom_now.ymin, (flip) ? zoom_now.ymin : zoom_now.ymax);

		if (!GlobalMembersGadgets.is_3d_plot)
		{
		String.format(s + s.length(), "; set x2r[% #g:% #g]; set y2r[% #g:% #g]", zoom_now.x2min, zoom_now.x2max, zoom_now.y2min, zoom_now.y2max);
		}

		/* EAM Jun 2007 - The autoscale save/restore was too complicated, and broke
		 * refresh. Just save/restore the complete axis state and have done with it.
		 * Well, not _quite_ the complete state.  The labels are maintained dynamically.
		 */
		if (zoom_now == zoom_head)
		{
		int i;
		for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; i++)
		{
			axis_array_copy[i].label = GlobalMembersAxis.axis_array[i].label;
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(GlobalMembersAxis.axis_array, axis_array_copy, sizeof(GlobalMembersAxis.axis_array));
		s = tangible.StringFunctions.changeCharacter(s, 0, '\0'); // FIXME:  Is this better than calling replotrequest()?

	///#ifdef VOLATILE_REFRESH
		/* Falling through to do_string_replot() does not work! */
		if (GlobalMembersGadgets.volatile_data)
		{
			if (GlobalMembersGadgets.refresh_ok == 2)
			{
			GlobalMembersCommand.refresh_request();
			return;
			}
			if (is_splot_map != 0 && GlobalMembersGadgets.refresh_ok == 3)
			{
			GlobalMembersCommand.refresh_request();
			return;
			}
		}
	///#endif

		}

		GlobalMembersCommand.do_string_replot(s);
	}

/* makes a zoom: update zoom history, call gnuplot to set ranges + replot
*/

	public static void do_zoom(double xmin, double ymin, double x2min, double y2min, double xmax, double ymax, double x2max, double y2max)
	{
		t_zoom z;
		if (zoom_head == DefineConstants.NULL) // queue not yet created, thus make its head
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		zoom_head = GlobalMembersAlloc.gp_alloc(sizeof(t_zoom), "mouse zoom history head");
		zoom_head.prev = DefineConstants.NULL;
		zoom_head.next = DefineConstants.NULL;
		}
		if (zoom_now == DefineConstants.NULL)
		zoom_now = zoom_head;
		if (zoom_now.next == DefineConstants.NULL) // allocate new item
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		z = GlobalMembersAlloc.gp_alloc(sizeof(t_zoom), "mouse zoom history element");
		z.prev = zoom_now;
		z.next = DefineConstants.NULL;
		zoom_now.next = z;
		z.prev = zoom_now;
		} // overwrite next item
		else
		z = zoom_now.next;
		z.xmin = xmin;
		z.ymin = ymin;
		z.x2min = x2min;
		z.y2min = y2min;
		z.xmax = xmax;
		z.ymax = ymax;
		z.x2max = x2max;
		z.y2max = y2max;
		z.was_splot_map = (GlobalMembersGadgets.is_3d_plot && (GlobalMembersGraph3d.splot_map == true)); // see is_splot_map in apply_zoom()
		GlobalMembersMouse.apply_zoom(z);
	}
	public static void ZoomNext()
	{
		if (zoom_now == DefineConstants.NULL || zoom_now.next == DefineConstants.NULL)
		GlobalMembersMouse.alert();
		else
		GlobalMembersMouse.apply_zoom(zoom_now.next);
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "next zoom.\n");
		}
	}
	public static void ZoomPrevious()
	{
		if (zoom_now == DefineConstants.NULL || zoom_now.prev == DefineConstants.NULL)
		GlobalMembersMouse.alert();
		else
		GlobalMembersMouse.apply_zoom(zoom_now.prev);
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "previous zoom.\n");
		}
	}
	public static void ZoomUnzoom()
	{
		if (zoom_head == DefineConstants.NULL || zoom_now == zoom_head)
		GlobalMembersMouse.alert();
		else
		GlobalMembersMouse.apply_zoom(zoom_head);
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "unzoom.\n");
		}
	}
	public static void incr_mousemode(int amount)
	{
		int old = mouse_mode;
		mouse_mode += amount;
		if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == mouse_mode && mouse_alt_string == null)
		{
		mouse_mode += amount; // stepping over
		}
		if (mouse_mode > AnonymousEnum.MOUSE_COORDINATES_ALT)
		{
		mouse_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
		}
		else if (mouse_mode < AnonymousEnum.MOUSE_COORDINATES_REAL)
		{
		mouse_mode = AnonymousEnum.MOUSE_COORDINATES_ALT.getValue();
		if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == mouse_mode && mouse_alt_string == null)
		{
			mouse_mode--; // stepping over
		}
		}
		GlobalMembersMouse.UpdateStatusline();
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "switched mouse format from %ld to %ld\n", old, mouse_mode);
		}
	}
	public static void incr_clipboardmode(int amount)
	{
		int old = clipboard_mode;
		clipboard_mode += amount;
		if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == clipboard_mode && clipboard_alt_string == null)
		{
		clipboard_mode += amount; // stepping over
		}
		if (clipboard_mode > AnonymousEnum.MOUSE_COORDINATES_ALT)
		{
		clipboard_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
		}
		else if (clipboard_mode < AnonymousEnum.MOUSE_COORDINATES_REAL)
		{
		clipboard_mode = AnonymousEnum.MOUSE_COORDINATES_ALT.getValue();
		if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == clipboard_mode && clipboard_alt_string == null)
		{
			clipboard_mode--; // stepping over
		}
		}
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "switched clipboard format from %ld to %ld\n", old, clipboard_mode);
		}
	}
	public static void UpdateStatuslineWithMouseSetting(mouse_setting_t ms)
	{
		String s0 = new String(new char[256]);
		String sp;
		if (!GlobalMembersTerm.term_initialised)
		return;
		if (ms.on == 0)
		{
		s0 = null;
		}
		else if (!!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		String format = new String(new char[0xff]);
		format = tangible.StringFunctions.changeCharacter(format, 0, '\0');
		format += "view: ";
		format += ms.fmt;
		format += ", ";
		format += ms.fmt;
		format += "   scale: ";
		format += ms.fmt;
		format += ", ";
		format += ms.fmt;
		String.format(s0, format, GlobalMembersGraph3d.surface_rot_x, GlobalMembersGraph3d.surface_rot_z, GlobalMembersGraph3d.surface_scale, GlobalMembersGraph3d.surface_zscale);
		}
		else if (!(((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS) && !(((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
		{
		/* only first X and Y axis are in use */
		sp = GlobalMembersMouse.GetAnnotateString(s0, real_x, real_y, mouse_mode, mouse_alt_string);
		if (ruler.on)
		{
			GlobalMembersMouse.GetRulerString(sp, real_x, real_y);
		}
		}
		else
		{
		/* X2 and/or Y2 are in use: use more verbose format */
		sp = s0;
		if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
		{
			sp = stpcpy(sp, "x=");
			do
			{
				if (real_x >= DefineConstants.VERYLARGE)
					break;
					if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].is_timedata)
					{
						byte format = GlobalMembersAxis.copy_or_invent_formatstring(AXIS_INDEX.FIRST_X_AXIS);
						while (tangible.StringFunctions.strChr(format,'\n'))
							*(tangible.StringFunctions.strChr(format,'\n')) = ' ';
							GlobalMembersTime.gstrftime(sp, 40, format, real_x);
					}
					else
					{
						String.format(sp, mouse_setting.fmt,real_x);
					}
					sp += sp.length();
			} while (0);
			sp++= ' ';
		}
		if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
		{
			sp = stpcpy(sp, "y=");
			do
			{
				if (real_y >= DefineConstants.VERYLARGE)
					break;
					if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].is_timedata)
					{
						byte format = GlobalMembersAxis.copy_or_invent_formatstring(AXIS_INDEX.FIRST_Y_AXIS);
						while (tangible.StringFunctions.strChr(format,'\n'))
							*(tangible.StringFunctions.strChr(format,'\n')) = ' ';
							GlobalMembersTime.gstrftime(sp, 40, format, real_y);
					}
					else
					{
						String.format(sp, mouse_setting.fmt,real_y);
					}
					sp += sp.length();
			} while (0);
			sp++= ' ';
		}
		if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
		{
			sp = stpcpy(sp, "x2=");
			do
			{
				if (real_x2 >= DefineConstants.VERYLARGE)
					break;
					if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].is_timedata)
					{
						byte format = GlobalMembersAxis.copy_or_invent_formatstring(AXIS_INDEX.SECOND_X_AXIS);
						while (tangible.StringFunctions.strChr(format,'\n'))
							*(tangible.StringFunctions.strChr(format,'\n')) = ' ';
							GlobalMembersTime.gstrftime(sp, 40, format, real_x2);
					}
					else
					{
						String.format(sp, mouse_setting.fmt,real_x2);
					}
					sp += sp.length();
			} while (0);
			sp++= ' ';
		}
		if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
		{
			sp = stpcpy(sp, "y2=");
			do
			{
				if (real_y2 >= DefineConstants.VERYLARGE)
					break;
					if (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].is_timedata)
					{
						byte format = GlobalMembersAxis.copy_or_invent_formatstring(AXIS_INDEX.SECOND_Y_AXIS);
						while (tangible.StringFunctions.strChr(format,'\n'))
							*(tangible.StringFunctions.strChr(format,'\n')) = ' ';
							GlobalMembersTime.gstrftime(sp, 40, format, real_y2);
					}
					else
					{
						String.format(sp, mouse_setting.fmt,real_y2);
					}
					sp += sp.length();
			} while (0);
			sp++= ' ';
		}
		if (ruler.on)
		{
			/* ruler on? then also print distances to ruler */
			if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
			{
			stpcpy(sp, "dx=");
			String.format(sp + 3, mouse_setting.fmt, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log) ? ((ruler.x == 0) ? 99999 : real_x / ruler.x) : (real_x - ruler.x));
			sp += sp.length();
			}
			if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
			{
			stpcpy(sp, "dy=");
			String.format(sp + 3, mouse_setting.fmt, (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log) ? ((ruler.y == 0) ? 99999 : real_y / ruler.y) : (real_y - ruler.y));
			sp += sp.length();
			}
			if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
			{
			stpcpy(sp, "dx2=");
			String.format(sp + 4, mouse_setting.fmt, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].log) ? ((ruler.x2 == 0) ? 99999 : real_x2 / ruler.x2) : (real_x2 - ruler.x2));
			sp += sp.length();
			}
			if ((((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].ticmode) & DefineConstants.TICS_MASK) != DefineConstants.NO_TICS))
			{
			stpcpy(sp, "dy2=");
			String.format(sp + 4, mouse_setting.fmt, (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].log) ? ((ruler.y2 == 0) ? 99999 : real_y2 / ruler.y2) : (real_y2 - ruler.y2));
			sp += sp.length();
			}
		}
		*--sp = 0; // delete trailing space
		}
		if (GlobalMembersTerm.term.put_tmptext)
		{
		(GlobalMembersTerm.term.put_tmptext)(0, s0);
		}
	}

	public static void event_keypress(gp_event_t ge, boolean current)
	{
		int x;
		int y;
		int c;
		int par2;
		bind_t ptr;
		bind_t keypress = new bind_t();

		c = ge.par1;
		par2 = ge.par2;
		x = ge.mx;
		y = ge.my;

		if (bindings == null)
		{
		GlobalMembersMouse.bind_install_default_bindings();
		}

		if (modifier_mask & AnonymousEnum2.Mod_Shift != 0)
		{
		c = Character.toUpperCase(c);
		}

		GlobalMembersMouse.bind_clear(keypress);
		keypress.key = c;
		keypress.modifier = modifier_mask;

		/*
		 * On 'pause mouse keypress' in active window export current keypress
		 * and mouse coords to user variables. A key with 'bind all' terminates
		 * a pause even from non-active windows.
		 * Ignore NULL keypress.
		 *
		 * If we are paused for a keystroke, this takes precendence over normal
		 * key bindings. Otherwise, for example typing 'm' would turn off mousing,
		 * which is a bad thing if you are in the  middle of a mousing operation.
		 */

	///#ifdef _Windows
	//    if (paused_for_mouse & PAUSE_KEYSTROKE)
	//	kill_pending_Pause_dialog();
	///#endif

		if ((GlobalMembersCommand.paused_for_mouse & DefineConstants.PAUSE_KEYSTROKE) && (c > '\0') && current)
		{
		GlobalMembersMouse.load_mouse_variables(x, y, false, c);
		return;
		}

		for (ptr = bindings; ptr; ptr = ptr.next)
		{
		if (GlobalMembersMouse.bind_matches(keypress, ptr) != 0)
		{
			udvt_entry keywin;
			if ((keywin = GlobalMembersEval.add_udv_by_name("MOUSE_KEY_WINDOW")))
			{
			keywin.udv_undef = false;
			GlobalMembersEval.Ginteger(keywin.udv_value, ge.winid);
			}
			/* Always honor keys set with "bind all" */
			if (ptr.allwindows && ptr.command != null)
			{
			if (current)
				GlobalMembersMouse.load_mouse_variables(x, y, false, c);
			else
				/* FIXME - Better to clear MOUSE_[XY] than to set it wrongly. */
				/*         This may be worth a separate subroutine.           */
				GlobalMembersMouse.load_mouse_variables(0, 0, false, c);
			GlobalMembersCommand.do_string(ptr.command, false);
			/* Treat as a current event after we return to x11.trm */
			ge.type = AnonymousEnum.GE_keypress.getValue();
			break;
			/* But otherwise ignore inactive windows */
			}
			else if (!current)
			{
			break;
			/* Let user defined bindings overwrite the builtin bindings */
			}
			else if ((par2 & 1) == 0 && ptr.command != null)
			{
			GlobalMembersCommand.do_string(ptr.command, false);
			break;
			}
			else if (ptr.builtin)
			{
			ptr.builtin(ge);
			}
			else
			{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d protocol error\n", __FILE__, __LINE__);
			}
		}
		}

	}
	public static void ChangeView(int x, int z)
	{
		if (modifier_mask & AnonymousEnum2.Mod_Shift != 0)
		{
		x *= 10;
		z *= 10;
		}

		if (x != 0)
		{
		GlobalMembersGraph3d.surface_rot_x += x;
		if (GlobalMembersGraph3d.surface_rot_x < 0)
			GlobalMembersGraph3d.surface_rot_x = 0F;
		if (GlobalMembersGraph3d.surface_rot_x > 180)
			GlobalMembersGraph3d.surface_rot_x = 180F;
		}
		if (z != 0)
		{
		GlobalMembersGraph3d.surface_rot_z += z;
		if (GlobalMembersGraph3d.surface_rot_z < 0)
			GlobalMembersGraph3d.surface_rot_z += 360;
		if (GlobalMembersGraph3d.surface_rot_z > 360)
			GlobalMembersGraph3d.surface_rot_z -= 360;
		}

		if (x != 0 || z != 0)
		{
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_X", GlobalMembersGraph3d.surface_rot_x);
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_Z", GlobalMembersGraph3d.surface_rot_z);
		}

		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "changing view to %f, %f.\n", GlobalMembersGraph3d.surface_rot_x, GlobalMembersGraph3d.surface_rot_z);
		}

		GlobalMembersMouse.do_save_3dplot(GlobalMembersPlot3d.first_3dplot, GlobalMembersPlot3d.plot3d_num, 0); // not quick

		if (!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		/* 2D plot, or suitably aligned 3D plot: update statusline */
		if (!GlobalMembersTerm.term.put_tmptext)
			return;
		GlobalMembersMouse.recalc_statusline();
		}
	}
	public static void event_buttonpress(gp_event_t ge)
	{
		int b;

		motion = 0;

		b = ge.par1;
		mouse_x = ge.mx;
		mouse_y = ge.my;

		button |= (1 << b);

		GlobalMembersFit.a((stderr, "(event_buttonpress) mouse_x = %d\tmouse_y = %d\n", mouse_x, mouse_y));

		GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);

		if (!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		if (!setting_zoom_region)
		{
			if (1 == b)
			{
			/* not bound in 2d graphs */
			}
			else if (2 == b)
			{
			/* not bound in 2d graphs */
			}
			else if (3 == b && (!GlobalMembersCommand.replot_disabled || GlobalMembersGadgets.refresh_ok != 0) && !(GlobalMembersCommand.paused_for_mouse & DefineConstants.PAUSE_BUTTON3)) // Use refresh if available
			{
			/* start zoom; but ignore it when
			 *   - replot is disabled, e.g. with inline data, or
			 *   - during 'pause mouse'
			 * allow zooming during 'pause mouse key' */
			setting_zoom_x = mouse_x;
			setting_zoom_y = mouse_y;
			setting_zoom_region = true;
			if (GlobalMembersTerm.term.set_cursor)
			{
				int mv_mouse_x;
				int mv_mouse_y;
				if (mouse_setting.annotate_zoom_box && GlobalMembersTerm.term.put_tmptext)
				{
				double real_x;
				double real_y;
				double real_x2;
				double real_y2;
				String s = new String(new char[64]);
				/* tell driver annotations */
				GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);
				String.format(s, GlobalMembersMouse.zoombox_format(), real_x, real_y);
				GlobalMembersTerm.term.put_tmptext(1, s);
				GlobalMembersTerm.term.put_tmptext(2, s);
				}
				/* displace mouse in order not to start with an empty zoom box */
				mv_mouse_x = GlobalMembersTerm.term.xmax / 20;
				mv_mouse_y = (GlobalMembersTerm.term.xmax == GlobalMembersTerm.term.ymax) ? mv_mouse_x : (int)((mv_mouse_x * (double) GlobalMembersTerm.term.ymax) / GlobalMembersTerm.term.xmax);
				mv_mouse_x += mouse_x;
				mv_mouse_y += mouse_y;

				/* change cursor type */
				GlobalMembersTerm.term.set_cursor(3, 0, 0);

				/* warp pointer */
				if (mouse_setting.warp_pointer)
				GlobalMembersTerm.term.set_cursor(-2, mv_mouse_x, mv_mouse_y);

				/* turn on the zoom box */
				GlobalMembersTerm.term.set_cursor(-1, setting_zoom_x, setting_zoom_y);
			}
			if (GlobalMembersCommand.display_ipc_commands() != 0)
			{
				fprintf(stderr, "starting zoom region.\n");
			}
			}
		}
		else
		{

			/* complete zoom (any button
			 * finishes zooming.) */

			/* the following variables are used to check,
			 * if the box is big enough to be considered
			 * as zoom box. */
			int dist_x = setting_zoom_x - mouse_x;
			int dist_y = setting_zoom_y - mouse_y;
			int dist = Math.sqrt((double)(dist_x * dist_x + dist_y * dist_y));

			if (1 == b || 2 == b)
			{
			/* zoom region is finished by the `wrong' button.
			 * `trap' the next button-release event so that
			 * it won't trigger the actions which are bound
			 * to these events.
			 */
			trap_release = true;
			}

			if (GlobalMembersTerm.term.set_cursor)
			{
			GlobalMembersTerm.term.set_cursor(0, 0, 0);
			if (mouse_setting.annotate_zoom_box && GlobalMembersTerm.term.put_tmptext)
			{
				GlobalMembersTerm.term.put_tmptext(1, "");
				GlobalMembersTerm.term.put_tmptext(2, "");
			}
			}

			if (dist > 10) // more ore less arbitrary
			{

			double xmin;
			double ymin;
			double x2min;
			double y2min;
			double xmax;
			double ymax;
			double x2max;
			double y2max;

			GlobalMembersMouse.MousePosToGraphPosReal(setting_zoom_x, setting_zoom_y, xmin, ymin, x2min, y2min);
			xmax = real_x;
			x2max = real_x2;
			ymax = real_y;
			y2max = real_y2;
			/* keep the axes (no)reversed as they are now */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define sgn(x) (x==0 ? 0 : (x>0 ? 1 : -1))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define rev(a1,a2,A) if ((a2-a1==0 ? 0 : (a2-a1>0 ? 1 : -1)) != (axis_array[A].max-axis_array[A].min==0 ? 0 : (axis_array[A].max-axis_array[A].min>0 ? 1 : -1))) { double tmp = a1; a1 = a2; a2 = tmp; }
			if ((xmax - xmin == 0 ? 0 : (xmax - xmin > 0 ? 1 : -1)) != (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min == 0 ? 0 : (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min > 0 ? 1 : -1)))
			{
				double tmp = xmin;
				xmin = xmax;
				xmax = tmp;
			};
			if ((ymax - ymin == 0 ? 0 : (ymax - ymin > 0 ? 1 : -1)) != (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min == 0 ? 0 : (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min > 0 ? 1 : -1)))
			{
				double tmp = ymin;
				ymin = ymax;
				ymax = tmp;
			};
			if ((x2max - x2min == 0 ? 0 : (x2max - x2min > 0 ? 1 : -1)) != (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].min == 0 ? 0 : (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].min > 0 ? 1 : -1)))
			{
				double tmp = x2min;
				x2min = x2max;
				x2max = tmp;
			};
			if ((y2max - y2min == 0 ? 0 : (y2max - y2min > 0 ? 1 : -1)) != (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].min == 0 ? 0 : (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].min > 0 ? 1 : -1)))
			{
				double tmp = y2min;
				y2min = y2max;
				y2max = tmp;
			};
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef rev
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef sgn
			GlobalMembersMouse.do_zoom(xmin, ymin, x2min, y2min, xmax, ymax, x2max, y2max);
			if (GlobalMembersCommand.display_ipc_commands() != 0)
			{
				fprintf(stderr, "zoom region finished.\n");
			}
			}
			else
			{
			/* silently ignore a tiny zoom box. This might
			 * happen, if the user starts and finishes the
			 * zoom box at the same position. */
			}
			setting_zoom_region = false;
		}
		}
		else
		{
		if (GlobalMembersTerm.term.set_cursor)
		{
			if (button & (1 << 1) != 0)
			GlobalMembersTerm.term.set_cursor(1, 0, 0);
			else if (button & (1 << 2) != 0)
			GlobalMembersTerm.term.set_cursor(2, 0, 0);
		}
		}
		start_x = mouse_x;
		start_y = mouse_y;
		zero_rot_z = GlobalMembersGraph3d.surface_rot_z + 360.0 * mouse_x / GlobalMembersTerm.term.xmax;
		zero_rot_x = GlobalMembersGraph3d.surface_rot_x - 180.0 * mouse_y / GlobalMembersTerm.term.ymax;
	}
	public static void event_buttonrelease(gp_event_t ge)
	{
		int b;
		int doubleclick;

		b = ge.par1;
		mouse_x = ge.mx;
		mouse_y = ge.my;
		doubleclick = ge.par2;

		button &= ~(1 << b); // remove button

		if (setting_zoom_region)
		{
		return;
		}
		if (true == trap_release)
		{
		trap_release = false;
		return;
		}

		GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);

		GlobalMembersFit.a((stderr, "MOUSE.C: doublclick=%i, set=%i, motion=%i, ALMOST2D=%i\n", (int) doubleclick, (int) mouse_setting.doubleclick, (int) motion, (int)!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1))));

		if (!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		String s0 = new String(new char[256]);
		if (b == 1 && GlobalMembersTerm.term.set_clipboard && ((doubleclick <= mouse_setting.doubleclick) || !mouse_setting.doubleclick))
		{

			/* put coordinates to clipboard. For 3d plots this takes
			 * only place, if the user didn't drag (rotate) the plot */

			if (!GlobalMembersGadgets.is_3d_plot || motion == 0)
			{
			GlobalMembersMouse.GetAnnotateString(s0, real_x, real_y, clipboard_mode, clipboard_alt_string);
			GlobalMembersTerm.term.set_clipboard(s0);
			if (GlobalMembersCommand.display_ipc_commands() != 0)
			{
				fprintf(stderr, "put `%s' to clipboard.\n", s0);
			}
			}
		}
		if (b == 2)
		{

			/* draw temporary annotation or label. For 3d plots this takes
			 * only place, if the user didn't drag (scale) the plot */

			if (!GlobalMembersGadgets.is_3d_plot || motion == 0)
			{

			GlobalMembersMouse.GetAnnotateString(s0, real_x, real_y, mouse_mode, mouse_alt_string);
			if (mouse_setting.label)
			{
				if (modifier_mask & AnonymousEnum2.Mod_Ctrl != 0)
				{
				GlobalMembersMouse.remove_label(mouse_x, mouse_y);
				}
				else
				{
				GlobalMembersMouse.put_label(s0, real_x, real_y);
				}
			}
			else
			{
				int dx;
				int dy;
				int x = mouse_x;
				int y = mouse_y;
				dx = GlobalMembersTerm.term.h_tic;
				dy = GlobalMembersTerm.term.v_tic;
				(GlobalMembersTerm.term.linewidth)(GlobalMembersGadgets.border_lp.l_width);
				(GlobalMembersTerm.term.linetype)(GlobalMembersGadgets.border_lp.l_type);
				(GlobalMembersTerm.term.move)(x - dx, y);
				(GlobalMembersTerm.term.vector)(x + dx, y);
				(GlobalMembersTerm.term.move)(x, y - dy);
				(GlobalMembersTerm.term.vector)(x, y + dy);
				(GlobalMembersTerm.term.justify_text)(JUSTIFY.LEFT);
				(GlobalMembersTerm.term.put_text)(x + dx / 2, y + dy / 2 + GlobalMembersTerm.term.v_char / 3, s0);
				(GlobalMembersTerm.term.text)();
			}
			}
		}
		}
		if (GlobalMembersGadgets.is_3d_plot && (b == 1 || b == 2))
		{
		if (!!(modifier_mask & AnonymousEnum2.Mod_Ctrl) && !needreplot)
		{
			/* redraw the 3d plot if its last redraw was 'quick'
			 * (only axes) because modifier key was pressed */
			GlobalMembersMouse.do_save_3dplot(GlobalMembersPlot3d.first_3dplot, GlobalMembersPlot3d.plot3d_num, 0);
		}
		if (GlobalMembersTerm.term.set_cursor)
			GlobalMembersTerm.term.set_cursor(0, 0, 0);
		}

		/* Export current mouse coords to user-accessible variables also */
		GlobalMembersMouse.load_mouse_variables(mouse_x, mouse_y, true, b);
		GlobalMembersMouse.UpdateStatusline();

	///#ifdef _Windows
	//    if (paused_for_mouse & PAUSE_CLICK) {
	// /* remove pause message box after 'pause mouse' */
	///#ifndef WGP_CONSOLE
	//	paused_for_mouse = 0;
	///#endif
	//	kill_pending_Pause_dialog();
	//    }
	///#endif
	}
	public static void event_motion(gp_event_t ge)
	{
		motion = 1;

		mouse_x = ge.mx;
		mouse_y = ge.my;

		if (GlobalMembersGadgets.is_3d_plot && (GlobalMembersGraph3d.splot_map == false)) // Rotate the surface if it is 3D graph but not "set view map".
		{

		boolean redraw = false;

		if (button & (1 << 1) != 0)
		{
			/* dragging with button 1 -> rotate */
			GlobalMembersGraph3d.surface_rot_x = Math.floor(0.5 + zero_rot_x + 180.0 * mouse_y / GlobalMembersTerm.term.ymax);
			if (GlobalMembersGraph3d.surface_rot_x < 0)
			GlobalMembersGraph3d.surface_rot_x = 0F;
			if (GlobalMembersGraph3d.surface_rot_x > 180)
			GlobalMembersGraph3d.surface_rot_x = 180F;
			GlobalMembersGraph3d.surface_rot_z = Math.floor(0.5 + Math.IEEEremainder(zero_rot_z - 360.0 * mouse_x / GlobalMembersTerm.term.xmax, 360));
			if (GlobalMembersGraph3d.surface_rot_z < 0)
			GlobalMembersGraph3d.surface_rot_z += 360;
			redraw = true;
		}
		else if (button & (1 << 2) != 0)
		{
			/* dragging with button 2 -> scale or changing ticslevel.
			 * we compare the movement in x and y direction, and
			 * change either scale or zscale */
			double relx;
			double rely;
			relx = Math.abs(mouse_x - start_x) / GlobalMembersTerm.term.h_tic;
			rely = Math.abs(mouse_y - start_y) / GlobalMembersTerm.term.v_tic;

	///#if 0
	//// /* threshold: motion should be at least 3 pixels.
	////  * We've to experiment with this. */
	////	    if (relx < 3 && rely < 3)
	////		return;
	///#endif
			if (modifier_mask & AnonymousEnum2.Mod_Shift != 0)
			{
			GlobalMembersGraph3d.xyplane.z += (1 + Math.abs(GlobalMembersGraph3d.xyplane.z)) * (mouse_y - start_y) * 2.0 / GlobalMembersTerm.term.ymax;
			}
			else
			{

			if (relx > rely)
			{
				GlobalMembersGraph3d.surface_scale += (mouse_x - start_x) * 2.0 / GlobalMembersTerm.term.xmax;
				if (GlobalMembersGraph3d.surface_scale < 0)
				GlobalMembersGraph3d.surface_scale = 0F;
			}
			else
			{
				if (GlobalMembersHidden3d.disable_mouse_z && (mouse_y - start_y > 0))
				;
				else
				{
				GlobalMembersGraph3d.surface_zscale += (mouse_y - start_y) * 2.0 / GlobalMembersTerm.term.ymax;
				GlobalMembersHidden3d.disable_mouse_z = false;
				}
				if (GlobalMembersGraph3d.surface_zscale < 0)
				GlobalMembersGraph3d.surface_zscale = 0F;
			}
			}
			/* reset the start values */
			start_x = mouse_x;
			start_y = mouse_y;
			redraw = true;
		} // if (mousebutton 2 is down)

		if (!!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
			GlobalMembersMouse.turn_ruler_off();
		}

		if (redraw)
		{
			if (allowmotion)
			{
			/* is processing of motions allowed right now?
			 * then replot while
			 * disabling further replots until it completes */
			allowmotion = false;
			GlobalMembersMouse.do_save_3dplot(GlobalMembersPlot3d.first_3dplot, GlobalMembersPlot3d.plot3d_num, !!(modifier_mask & AnonymousEnum2.Mod_Ctrl));
			GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_X", GlobalMembersGraph3d.surface_rot_x);
			GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_Z", GlobalMembersGraph3d.surface_rot_z);
			GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_SCALE", GlobalMembersGraph3d.surface_scale);
			GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ZSCALE", GlobalMembersGraph3d.surface_zscale);
			}
			else
			{
			/* postpone the replotting */
			needreplot = true;
			}
		}
		} // if (3D plot)


		if (!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		/* 2D plot, or suitably aligned 3D plot: update
		 * statusline and possibly the zoombox annotation */
		if (!GlobalMembersTerm.term.put_tmptext)
			return;
		GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);
		GlobalMembersMouse.UpdateStatusline();

		if (setting_zoom_region && mouse_setting.annotate_zoom_box)
		{
			double real_x;
			double real_y;
			double real_x2;
			double real_y2;
			String s = new String(new char[64]);
			GlobalMembersMouse.MousePosToGraphPosReal(mouse_x, mouse_y, real_x, real_y, real_x2, real_y2);
			String.format(s, GlobalMembersMouse.zoombox_format(), real_x, real_y);
			GlobalMembersTerm.term.put_tmptext(2, s);
		}
		}
	}
	public static void event_modifier(gp_event_t ge)
	{
		modifier_mask = ge.par1;

		if (modifier_mask == 0 && GlobalMembersGadgets.is_3d_plot && (button & ((1 << 1) | (1 << 2))) && !needreplot)
		{
		/* redraw the 3d plot if modifier key released */
		GlobalMembersMouse.do_save_3dplot(GlobalMembersPlot3d.first_3dplot, GlobalMembersPlot3d.plot3d_num, 0);
		}
	}
	public static void do_save_3dplot(surface_points plots, int pcount, int quick)
	{
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define M_TEST_AXIS(A) (A.log && ((!(A.set_autoscale & AUTOSCALE_MIN) && A.set_min <= 0) || (!(A.set_autoscale & AUTOSCALE_MAX) && A.set_max <= 0)))

		if (plots == null || GlobalMembersGadgets.refresh_ok == 0)
		{
		/* !plots might happen after the `reset' command for example
		 * (reported by Franz Bakan).
		 * !refresh_ok can happen for example if log scaling is reset (EAM).
		 * replotrequest() should set up everything again in either case.
		 */
		GlobalMembersCommand.replotrequest();
		}
		else
		{
		if ((GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].log && ((!(GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN) && GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].set_min <= 0) || (!(GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX) && GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].set_max <= 0))) || (GlobalMembersAxis.axis_array[GlobalMembersAxis.y_axis.getValue()].log && ((!(GlobalMembersAxis.axis_array[GlobalMembersAxis.y_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN) && GlobalMembersAxis.axis_array[GlobalMembersAxis.y_axis.getValue()].set_min <= 0) || (!(GlobalMembersAxis.axis_array[GlobalMembersAxis.y_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX) && GlobalMembersAxis.axis_array[GlobalMembersAxis.y_axis.getValue()].set_max <= 0))) || (GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log && ((!(GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN) && GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].set_min <= 0) || (!(GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX) && GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].set_max <= 0))) || (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log && ((!(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN) && GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_min <= 0) || (!(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX) && GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_max <= 0))))
		{
			GlobalMembersUtil.graph_error("axis ranges must be above 0 for log scale!");
			return;
		}
		GlobalMembersGraph3d.do_3dplot(plots, pcount, quick);
		}

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef M_TEST_AXIS
	}

///#ifdef OS2
// /* routine required by pm.trm: fill in information needed for (un)checking
//    menu items in the Presentation Manager terminal
// */
//void 
//PM_set_gpPMmenu __PROTO((struct t_gpPMmenu * gpPMmenu))
//{
//    gpPMmenu->use_mouse = mouse_setting.on;
//    if (zoom_now == NULL)
//	gpPMmenu->where_zoom_queue = 0;
//    else {
//	gpPMmenu->where_zoom_queue = (zoom_now == zoom_head) ? 0 : 1;
//	if (zoom_now->prev != NULL)
//	    gpPMmenu->where_zoom_queue |= 2;
//	if (zoom_now->next != NULL)
//	    gpPMmenu->where_zoom_queue |= 4;
//    }
//    gpPMmenu->polar_distance = mouse_setting.polardistance;
//}
///#endif

/* Save current mouse position to user-accessible variables.
 * Save the keypress or mouse button that triggered this in MOUSE_KEY,
 * and define MOUSE_BUTTON if it was a button click.
 */
	public static void load_mouse_variables(double x, double y, boolean button, int c)
	{
		udvt_entry current;

		GlobalMembersMouse.MousePosToGraphPosReal(x, y, real_x, real_y, real_x2, real_y2);

		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_BUTTON")))
		{
		current.udv_undef = !button;
		GlobalMembersEval.Ginteger(current.udv_value, button?c:-1);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_KEY")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Ginteger(current.udv_value, c);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_CHAR")))
		{
		byte[] keychar = GlobalMembersAlloc.gp_alloc(2, "key_char");
		keychar[0] = c;
		keychar[1] = (byte)'\0';
		if (!current.udv_undef)
			GlobalMembersEval.gpfree_string(current.udv_value);
		current.udv_undef = false;
		GlobalMembersEval.Gstring(current.udv_value, keychar);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_X")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Gcomplex(current.udv_value, real_x, 0);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_Y")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Gcomplex(current.udv_value, real_y, 0);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_X2")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Gcomplex(current.udv_value, real_x2, 0);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_Y2")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Gcomplex(current.udv_value, real_y2, 0);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_SHIFT")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Ginteger(current.udv_value, modifier_mask & AnonymousEnum2.Mod_Shift);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_ALT")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Ginteger(current.udv_value, modifier_mask & AnonymousEnum2.Mod_Alt);
		}
		if ((current = GlobalMembersEval.add_udv_by_name("MOUSE_CTRL")))
		{
		current.udv_undef = false;
		GlobalMembersEval.Ginteger(current.udv_value, modifier_mask & AnonymousEnum2.Mod_Ctrl);
		}
		return;
	}

/****************** handlers for user's actions ******************/


	/* builtins */
	public static String builtin_autoscale(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-autoscale` (set autoscale keepfix; replot)";
		}
		GlobalMembersCommand.do_string_replot("set autoscale keepfix");
		return (String) 0;
	}
	public static String builtin_toggle_border(gp_event_t ge)
	{
		if (ge == null)
		return "`builtin-toggle-border`";

		/* EAM July 2009  Cycle through border settings
		 * - no border
		 * - last border requested by the user
		 * - default border
		 * - (3D only) full border
		 */
		if (GlobalMembersGadgets.draw_border == 0 && GlobalMembersGadgets.draw_border != GlobalMembersGadgets.user_border)
		GlobalMembersGadgets.draw_border = GlobalMembersGadgets.user_border;
		else if (GlobalMembersGadgets.draw_border == GlobalMembersGadgets.user_border && GlobalMembersGadgets.draw_border != 31)
		GlobalMembersGadgets.draw_border = 31;
		else if (GlobalMembersGadgets.is_3d_plot && GlobalMembersGadgets.draw_border == 31)
		GlobalMembersGadgets.draw_border = 4095;
		else
		GlobalMembersGadgets.draw_border = 0;

		GlobalMembersCommand.do_string_replot("");
		return (String) 0;
	}
	public static String builtin_replot(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-replot`";
		}
		GlobalMembersCommand.do_string_replot("");
		return (String) 0;
	}
	public static String builtin_toggle_grid(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-grid`";
		}
		if (!GlobalMembersAxis.some_grid_selected())
		GlobalMembersCommand.do_string_replot("set grid");
		else
		GlobalMembersCommand.do_string_replot("unset grid");
		return (String) 0;
	}
	public static String builtin_help(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-help`";
		}
		fprintf(stderr, "\n");
		GlobalMembersMouse.bind_display((String) 0); // display all bindings
		GlobalMembersCommand.restore_prompt();
		return (String) 0;
	}
	public static String builtin_toggle_log(gp_event_t ge)
	{
		if (ge == null)
		return "`builtin-toggle-log` y logscale for plots, z and cb for splots";

		if (GlobalMembersGadgets.volatile_data)
		GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "Cannot toggle log scale for volatile data");
		else if ((GlobalMembersGadgets.color_box.bounds.xleft < mouse_x && mouse_x < GlobalMembersGadgets.color_box.bounds.xright) && (GlobalMembersGadgets.color_box.bounds.ybot < mouse_y && mouse_y < GlobalMembersGadgets.color_box.bounds.ytop))
		GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log ? "unset log cb" : "set log cb");
		else if (GlobalMembersGadgets.is_3d_plot && GlobalMembersGraph3d.splot_map == 0)
		GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log ? "unset log z" : "set log z");
		else
		GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? "unset log y" : "set log y");

		return (String) 0;
	}
	public static String builtin_nearest_log(gp_event_t ge)
	{
		if (ge == null)
		return "`builtin-nearest-log` toggle logscale of axis nearest cursor";

		if ((GlobalMembersGadgets.color_box.bounds.xleft < mouse_x && mouse_x < GlobalMembersGadgets.color_box.bounds.xright) && (GlobalMembersGadgets.color_box.bounds.ybot < mouse_y && mouse_y < GlobalMembersGadgets.color_box.bounds.ytop))
		{
		GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log ? "unset log cb" : "set log cb");
		}
		else if (GlobalMembersGadgets.is_3d_plot && GlobalMembersGraph3d.splot_map == 0)
		{
		GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log ? "unset log z" : "set log z");
		}
		else
		{
		/* 2D-plot: figure out which axis/axes is/are
		 * close to the mouse cursor, and toggle those lin/log */
		/* note: here it is assumed that the x axis is at
		 * the bottom, x2 at top, y left and y2 right; it
		 * would be better to derive that from the ..tics settings */
		boolean change_x1 = false;
		boolean change_y1 = false;
		boolean change_x2 = false;
		boolean change_y2 = false;
		if (mouse_y < GlobalMembersGadgets.plot_bounds.ybot + (GlobalMembersGadgets.plot_bounds.ytop - GlobalMembersGadgets.plot_bounds.ybot) / 4 && mouse_x > GlobalMembersGadgets.plot_bounds.xleft && mouse_x < GlobalMembersGadgets.plot_bounds.xright)
			change_x1 = true;
		if (mouse_x < GlobalMembersGadgets.plot_bounds.xleft + (GlobalMembersGadgets.plot_bounds.xright - GlobalMembersGadgets.plot_bounds.xleft) / 4 && mouse_y > GlobalMembersGadgets.plot_bounds.ybot && mouse_y < GlobalMembersGadgets.plot_bounds.ytop)
			change_y1 = true;
		if (mouse_y > GlobalMembersGadgets.plot_bounds.ytop - (GlobalMembersGadgets.plot_bounds.ytop - GlobalMembersGadgets.plot_bounds.ybot) / 4 && mouse_x > GlobalMembersGadgets.plot_bounds.xleft && mouse_x < GlobalMembersGadgets.plot_bounds.xright)
			change_x2 = true;
		if (mouse_x > GlobalMembersGadgets.plot_bounds.xright - (GlobalMembersGadgets.plot_bounds.xright - GlobalMembersGadgets.plot_bounds.xleft) / 4 && mouse_y > GlobalMembersGadgets.plot_bounds.ybot && mouse_y < GlobalMembersGadgets.plot_bounds.ytop)
			change_y2 = true;

		if (change_x1)
			GlobalMembersCommand.do_string(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log ? "unset log x" : "set log x", false);
		if (change_y1)
			GlobalMembersCommand.do_string(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? "unset log y" : "set log y", false);
		if (change_x2 && GlobalMembersGraph3d.splot_map == 0)
			GlobalMembersCommand.do_string(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].log ? "unset log x2" : "set log x2", false);
		if (change_y2 && GlobalMembersGraph3d.splot_map == 0)
			GlobalMembersCommand.do_string(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].log ? "unset log y2" : "set log y2", false);
		if (!change_x1 && !change_y1 && GlobalMembersGraph3d.splot_map != 0)
			GlobalMembersCommand.do_string_replot(GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log ? "unset log z" : "set log z");

		if (change_x1 || change_y1 || change_x2 || change_y2)
			GlobalMembersCommand.do_string_replot("");
		}

		return (String) 0;
	}
	public static String builtin_toggle_mouse(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-mouse`";
		}
		if (!mouse_setting.on)
		{
		mouse_setting.on = 1;
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
			fprintf(stderr, "turning mouse on.\n");
		}
		}
		else
		{
		mouse_setting.on = 0;
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
			fprintf(stderr, "turning mouse off.\n");
		}
	///#if 0
	////	if (ruler.on) {
	////	    ruler.on = FALSE;
	////	    (*term->set_ruler) (-1, -1);
	////	}
	///#endif
		}
	///#ifdef OS2
	//    PM_update_menu_items();
	///#endif
		GlobalMembersMouse.UpdateStatusline();
		return (String) 0;
	}
	public static String builtin_toggle_ruler(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-ruler`";
		}
		if (!GlobalMembersTerm.term.set_ruler)
		return (String) 0;
		if (ruler.on)
		{
		GlobalMembersMouse.turn_ruler_off();
		if (GlobalMembersCommand.display_ipc_commands() != 0)
			fprintf(stderr, "turning ruler off.\n");
		}
		else if (!GlobalMembersGadgets.is_3d_plot || (Math.abs(Math.IEEEremainder(GlobalMembersGraph3d.surface_rot_z,90.0))<0.1 && (GlobalMembersGraph3d.surface_rot_x>179.9 || GlobalMembersGraph3d.surface_rot_x < 0.1)))
		{
		/* only allow ruler, if the plot
		 * is 2d or a 3d `map' */
		udvt_entry u;
		ruler.on = true;
		ruler.px = ge.mx;
		ruler.py = ge.my;
		GlobalMembersMouse.MousePosToGraphPosReal(ruler.px, ruler.py, ruler.x, ruler.y, ruler.x2, ruler.y2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*GlobalMembersTerm.term.set_ruler)(ruler.px, ruler.py);
		if ((u = GlobalMembersEval.add_udv_by_name("MOUSE_RULER_X")))
		{
			u.udv_undef = false;
			GlobalMembersEval.Gcomplex(u.udv_value, ruler.x, 0);
		}
		if ((u = GlobalMembersEval.add_udv_by_name("MOUSE_RULER_Y")))
		{
			u.udv_undef = false;
			GlobalMembersEval.Gcomplex(u.udv_value, ruler.y, 0);
		}
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
			fprintf(stderr, "turning ruler on.\n");
		}
		}
		GlobalMembersMouse.UpdateStatusline();
		return (String) 0;
	}
	public static String builtin_decrement_mousemode(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-decrement-mousemode`";
		}
		GlobalMembersMouse.incr_mousemode(-1);
		return (String) 0;
	}
	public static String builtin_increment_mousemode(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-increment-mousemode`";
		}
		GlobalMembersMouse.incr_mousemode(1);
		return (String) 0;
	}
	public static String builtin_decrement_clipboardmode(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-decrement-clipboardmode`";
		}
		GlobalMembersMouse.incr_clipboardmode(-1);
		return (String) 0;
	}
	public static String builtin_increment_clipboardmode(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-increment-clipboardmode`";
		}
		GlobalMembersMouse.incr_clipboardmode(1);
		return (String) 0;
	}
	public static String builtin_toggle_polardistance(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-polardistance`";
		}
		if (++mouse_setting.polardistance > 2)
			mouse_setting.polardistance = 0;
		/* values: 0 (no polar coordinates), 1 (polar coordinates), 2 (tangent instead of angle) */
		GlobalMembersTerm.term.set_cursor((mouse_setting.polardistance ? - 3:-4), ge.mx, ge.my); // change cursor type
	///#ifdef OS2
	//    PM_update_menu_items();
	///#endif
		GlobalMembersMouse.UpdateStatusline();
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "distance to ruler will %s be shown in polar coordinates.\n", mouse_setting.polardistance ? "" : "not");
		}
		return (String) 0;
	}
	public static String builtin_toggle_verbose(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-verbose`";
		}
		/* this is tricky as the command itself modifies
		 * the state of display_ipc_commands() */
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "echoing of communication commands is turned off.\n");
		}
		GlobalMembersCommand.toggle_display_of_ipc_commands();
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "communication commands will be echoed.\n");
		}
		return (String) 0;
	}
	public static String builtin_toggle_ratio(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-toggle-ratio`";
		}
		if (GlobalMembersGadgets.aspect_ratio == 0)
		GlobalMembersCommand.do_string_replot("set size ratio -1");
		else if (GlobalMembersGadgets.aspect_ratio == 1)
		GlobalMembersCommand.do_string_replot("set size nosquare");
		else
		GlobalMembersCommand.do_string_replot("set size square");
		return (String) 0;
	}
	public static String builtin_zoom_next(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-zoom-next` go to next zoom in the zoom stack";
		}
		GlobalMembersMouse.ZoomNext();
		return (String) 0;
	}
	public static String builtin_zoom_previous(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-zoom-previous` go to previous zoom in the zoom stack";
		}
		GlobalMembersMouse.ZoomPrevious();
		return (String) 0;
	}
	public static String builtin_unzoom(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-unzoom`";
		}
		GlobalMembersMouse.ZoomUnzoom();
		return (String) 0;
	}
	public static String builtin_rotate_right(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-rotate-right` only for splots; <shift> increases amount";
		}
		if (GlobalMembersGadgets.is_3d_plot)
		GlobalMembersMouse.ChangeView(0, -1);
		return (String) 0;
	}
	public static String builtin_rotate_up(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-rotate-up` only for splots; <shift> increases amount";
		}
		if (GlobalMembersGadgets.is_3d_plot)
		GlobalMembersMouse.ChangeView(1, 0);
		return (String) 0;
	}
	public static String builtin_rotate_left(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-rotate-left` only for splots; <shift> increases amount";
		}
		if (GlobalMembersGadgets.is_3d_plot)
		GlobalMembersMouse.ChangeView(0, 1);
		return (String) 0;
	}
	public static String builtin_rotate_down(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-rotate-down` only for splots; <shift> increases amount";
		}
		if (GlobalMembersGadgets.is_3d_plot)
		GlobalMembersMouse.ChangeView(-1, 0);
		return (String) 0;
	}
	public static String builtin_cancel_zoom(gp_event_t ge)
	{
		if (ge == null)
		{
		return "`builtin-cancel-zoom` cancel zoom region";
		}
		if (!setting_zoom_region)
		return (String) 0;
		if (GlobalMembersTerm.term.set_cursor)
		GlobalMembersTerm.term.set_cursor(0, 0, 0);
		setting_zoom_region = false;
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
		fprintf(stderr, "zooming cancelled.\n");
		}
		return (String) 0;
	}

/*
 * bind related functions
 */


	/* prototypes for bind stuff
	 * which are used only here. */
	public static void bind_install_default_bindings()
	{
		GlobalMembersMouse.bind_remove_all();
		GlobalMembersMouse.bind_append("a", (String) 0, GlobalMembersMouse.builtin_autoscale);
		GlobalMembersMouse.bind_append("b", (String) 0, GlobalMembersMouse.builtin_toggle_border);
		GlobalMembersMouse.bind_append("e", (String) 0, GlobalMembersMouse.builtin_replot);
		GlobalMembersMouse.bind_append("g", (String) 0, GlobalMembersMouse.builtin_toggle_grid);
		GlobalMembersMouse.bind_append("h", (String) 0, GlobalMembersMouse.builtin_help);
		GlobalMembersMouse.bind_append("l", (String) 0, GlobalMembersMouse.builtin_toggle_log);
		GlobalMembersMouse.bind_append("L", (String) 0, GlobalMembersMouse.builtin_nearest_log);
		GlobalMembersMouse.bind_append("m", (String) 0, GlobalMembersMouse.builtin_toggle_mouse);
		GlobalMembersMouse.bind_append("r", (String) 0, GlobalMembersMouse.builtin_toggle_ruler);
		GlobalMembersMouse.bind_append("1", (String) 0, GlobalMembersMouse.builtin_decrement_mousemode);
		GlobalMembersMouse.bind_append("2", (String) 0, GlobalMembersMouse.builtin_increment_mousemode);
		GlobalMembersMouse.bind_append("3", (String) 0, GlobalMembersMouse.builtin_decrement_clipboardmode);
		GlobalMembersMouse.bind_append("4", (String) 0, GlobalMembersMouse.builtin_increment_clipboardmode);
		GlobalMembersMouse.bind_append("5", (String) 0, GlobalMembersMouse.builtin_toggle_polardistance);
		GlobalMembersMouse.bind_append("6", (String) 0, GlobalMembersMouse.builtin_toggle_verbose);
		GlobalMembersMouse.bind_append("7", (String) 0, GlobalMembersMouse.builtin_toggle_ratio);
		GlobalMembersMouse.bind_append("n", (String) 0, GlobalMembersMouse.builtin_zoom_next);
		GlobalMembersMouse.bind_append("p", (String) 0, GlobalMembersMouse.builtin_zoom_previous);
		GlobalMembersMouse.bind_append("u", (String) 0, GlobalMembersMouse.builtin_unzoom);
		GlobalMembersMouse.bind_append("Right", (String) 0, GlobalMembersMouse.builtin_rotate_right);
		GlobalMembersMouse.bind_append("Up", (String) 0, GlobalMembersMouse.builtin_rotate_up);
		GlobalMembersMouse.bind_append("Left", (String) 0, GlobalMembersMouse.builtin_rotate_left);
		GlobalMembersMouse.bind_append("Down", (String) 0, GlobalMembersMouse.builtin_rotate_down);
		GlobalMembersMouse.bind_append("Escape", (String) 0, GlobalMembersMouse.builtin_cancel_zoom);
	}
	public static void bind_clear(bind_t b)
	{
		b.key = NO_KEY;
		b.modifier = 0;
		b.command = (String) 0;
		b.builtin = 0;
		b.prev = (bind_t) 0;
		b.next = (bind_t) 0;
	}

/* returns the enum which corresponds to the
 * string (ptr) or NO_KEY if ptr matches not
 * any of special_keys. */
	public static int lookup_key(String ptr, int len)
	{
		String[] keyptr;
		/* first, search in the table of "usual well-known" keys */
		int what = GlobalMembersTables.lookup_table_nth(usual_special_keys, ptr);
		if (what >= 0)
		{
		len = String.valueOf(usual_special_keys[what].key).length();
		return usual_special_keys[what].value;
		}
		/* second, search in the table of other keys */
		for (keyptr = special_keys; keyptr; ++keyptr)
		{
		if (!strcmp(ptr, keyptr))
		{
			len = ptr.length();
			return keyptr - special_keys + AnonymousEnum4.GP_FIRST_KEY;
		}
		}
		return NO_KEY;
	}

/* returns 1 on success, else 0. */
	public static int bind_scan_lhs(bind_t out, String in)
	{
		final byte DELIM = (byte)'-';
		int itmp = NO_KEY;
		String ptr;
		int len;
		GlobalMembersMouse.bind_clear(out);
		if (in == null)
		{
		return 0;
		}
		for (ptr = (String) in; ptr && ptr != null;) // EMPTY
		{
		if (!strncasecmp(ptr, "alt-", 4))
		{
			out.modifier |= AnonymousEnum2.Mod_Alt;
			ptr += 4;
		}
		else if (!strncasecmp(ptr, "ctrl-", 5))
		{
			out.modifier |= AnonymousEnum2.Mod_Ctrl;
			ptr += 5;
		}
		else if (NO_KEY != (itmp = GlobalMembersMouse.lookup_key(ptr, len)))
		{
			out.key = itmp;
			ptr += len;
		}
		else if ((out.key = ptr++) && ptr != null && !ptr.equals(DELIM))
		{
			fprintf(stderr, "bind: cannot parse %s\n", in);
			return 0;
		}
		}
		if (NO_KEY == out.key)
		return 0; // failed
		else
		return 1; // success
	}

/* note, that this returns a pointer
 * to the static char* `out' which is
 * modified on subsequent calls.
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String bind_fmt_lhs_out = new String(new char[0x40]);
	public static String bind_fmt_lhs(bind_t in)
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte out[0x40];
		bind_fmt_lhs_out = tangible.StringFunctions.changeCharacter(bind_fmt_lhs_out, 0, '\0'); // empty string
		if (in == null)
		return bind_fmt_lhs_out;
		if (in.modifier & AnonymousEnum2.Mod_Ctrl != 0)
		{
		String.format(bind_fmt_lhs_out, "Ctrl-");
		}
		if (in.modifier & AnonymousEnum2.Mod_Alt != 0)
		{
		bind_fmt_lhs_out += "%sAlt-";
		}
		if (in.key > AnonymousEnum4.GP_FIRST_KEY && in.key < AnonymousEnum4.GP_LAST_KEY)
		{
		bind_fmt_lhs_out += special_keys[in.key - AnonymousEnum4.GP_FIRST_KEY];
		}
		else
		{
		int k = 0;
		for (; usual_special_keys[k].value > 0; k++)
		{
			if (usual_special_keys[k].value == in.key)
			{
			bind_fmt_lhs_out += usual_special_keys[k].key;
			k = -1;
			break;
			}
		}
		if (k >= 0)
		{
			String foo = "\0";
			foo = tangible.StringFunctions.changeCharacter(foo, 0, in.key);
			bind_fmt_lhs_out += foo;
		}
		}
		return bind_fmt_lhs_out;
	}
	public static int bind_matches(bind_t a, bind_t b)
	{
		/* discard Shift modifier */
		int a_mod = a.modifier & (AnonymousEnum2.Mod_Ctrl | AnonymousEnum2.Mod_Alt);
		int b_mod = b.modifier & (AnonymousEnum2.Mod_Ctrl | AnonymousEnum2.Mod_Alt);

		if (a.key == b.key && a_mod == b_mod)
		return 1;
		else
		return 0;
	}
	public static void bind_display_one(bind_t ptr)
	{
		fprintf(stderr, " %-12s ", GlobalMembersMouse.bind_fmt_lhs(ptr));
		fprintf(stderr, "%c ", ptr.allwindows ? '*' : ' ');
		if (ptr.command != null)
		{
		fprintf(stderr, "`%s'\n", ptr.command);
		}
		else if (ptr.builtin)
		{
		fprintf(stderr, "%s\n", ptr.builtin(0));
		}
		else
		{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
		fprintf(stderr, "`%s:%d oops.'\n", __FILE__, __LINE__);
		}
	}
	public static void bind_display(String lhs)
	{
		bind_t ptr;
		bind_t lhs_scanned = new bind_t();

		if (bindings == null)
		{
		GlobalMembersMouse.bind_install_default_bindings();
		}

		if (lhs == null)
		{
		/* display all bindings */
		String fmt = " %-17s  %s\n";
		fprintf(stderr, "\n");
		fprintf(stderr, fmt, "2x<B1>", "print coordinates to clipboard using `clipboardformat`\n                    (see keys '3', '4')");
		fprintf(stderr, fmt, "<B2>", "annotate the graph using `mouseformat` (see keys '1', '2')");
		fprintf(stderr, fmt, "", "or draw labels if `set mouse labels is on`");
		fprintf(stderr, fmt, "<Ctrl-B2>", "remove label close to pointer if `set mouse labels` is on");
		fprintf(stderr, fmt, "<B3>", "mark zoom region (only for 2d-plots and maps).");
		fprintf(stderr, fmt, "<B1-Motion>", "change view (rotation). Use <ctrl> to rotate the axes only.");
		fprintf(stderr, fmt, "<B2-Motion>", "change view (scaling). Use <ctrl> to scale the axes only.");
		fprintf(stderr, fmt, "<Shift-B2-Motion>", "vertical motion -- change xyplane");
		fprintf(stderr, "\n");
	///#ifndef DISABLE_SPACE_RAISES_CONSOLE
		fprintf(stderr, " %-12s   %s\n", "Space", "raise gnuplot console window");
	///#endif
		fprintf(stderr, " %-12s * %s\n", "q", "close this plot window");
		fprintf(stderr, "\n");
		for (ptr = bindings; ptr; ptr = ptr.next)
		{
			GlobalMembersMouse.bind_display_one(ptr);
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "              * indicates this key is active from all plot windows\n");
		fprintf(stderr, "\n");
		return;
		}

		if (GlobalMembersMouse.bind_scan_lhs(lhs_scanned, lhs) == 0)
		{
		return;
		}
		for (ptr = bindings; ptr; ptr = ptr.next)
		{
		if (GlobalMembersMouse.bind_matches(lhs_scanned, ptr) != 0)
		{
			GlobalMembersMouse.bind_display_one(ptr);
			break; // only one match
		}
		}
	}
	public static void bind_all(String lhs)
	{
		bind_t ptr;
		bind_t keypress = new bind_t();

		if (GlobalMembersMouse.bind_scan_lhs(keypress, lhs) == 0)
		return;

		for (ptr = bindings; ptr; ptr = ptr.next)
		{
		if (GlobalMembersMouse.bind_matches(keypress, ptr) != 0)
			ptr.allwindows = true;
		}
	}
	public static void bind_remove(bind_t b)
	{
		if (b == null)
		{
		return;
		}
		else if (b.builtin)
		{
		/* don't remove builtins, just remove the overriding command */
		if (b.command != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(b.command);
			b.command = (String) 0;
		}
		return;
		}
		if (b.prev != null)
		b.prev.next = b.next;
		if (b.next != null)
		b.next.prev = b.prev;
		else
		bindings.prev = b.prev;
		if (b.command != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(b.command);
		b.command = (String) 0;
		}
		if (b == bindings)
		{
		bindings = b.next;
		if (bindings != null && bindings.prev != null)
		{
			bindings.prev.next = (bind_t) 0;
		}
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(b);
	}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	static void bind_append(byte * lhs, byte * rhs, byte * (*builtin)(struct gp_event_t * ge))
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		bind_t new() = (bind_t) GlobalMembersAlloc.gp_alloc(sizeof(bind_t), "bind_append->new");

		if (GlobalMembersMouse.bind_scan_lhs(new_Renamed, lhs) == 0)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(new_Renamed);
		return;
		}

		if (bindings == null)
		{
		/* first binding */
		bindings = new_Renamed;
		}
		else
		{

		bind_t ptr;
		for (ptr = bindings; ptr; ptr = ptr.next)
		{
			if (GlobalMembersMouse.bind_matches(new_Renamed, ptr) != 0)
			{
			/* overwriting existing binding */
			if (rhs == null)
			{
				ptr.builtin = builtin;
			}
			else if (rhs != null)
			{
				if (ptr.command != null)
				{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(ptr.command);
				ptr.command = (String) 0;
				}
				ptr.command = rhs;
			} // rhs is an empty string, so remove the binding
			else
			{
				GlobalMembersMouse.bind_remove(ptr);
			}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(new_Renamed); // don't need it any more
			return;
			}
		}
		/* if we're here, the binding does not exist yet */
		/* append binding ... */
		bindings.prev.next = new_Renamed;
		new_Renamed.prev = bindings.prev;
		}

		bindings.prev = new_Renamed;
		new_Renamed.next = (bind_t) 0;
		new_Renamed.allwindows = false; // Can be explicitly set later
		if (rhs == null)
		{
		new_Renamed.builtin = builtin;
		}
		else if (rhs != null)
		{
		new_Renamed.command = rhs; // was allocated in command.c
		}
		else
		{
		GlobalMembersMouse.bind_remove(new_Renamed);
		}
	}

/* Ruler is on, thus recalc its (px,py) from (x,y) for the current zoom and
   log axes.
*/
	public static void recalc_ruler_pos()
	{
		double P;
		double dummy;
		if (GlobalMembersGadgets.is_3d_plot)
		{
		/* To be exact, it is 'set view map' splot. */
		int ppx;
		int ppy;
		dummy = 1.0; // dummy value, but not 0.0 for the fear of log z-axis
		GlobalMembersUtil3d.map3d_xy(ruler.x, ruler.y, dummy, ppx, ppy);
		ruler.px = ppx;
		ruler.py = ppy;
		return;
		}
		/* It is 2D plot. */
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log && ruler.x < 0)
		ruler.px = -1;
		else
		{
		P = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log ? (Math.log(ruler.x) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].log_base) : (ruler.x));
		ruler.px = (int)((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_lower) + ((P) - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min) * GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_scale + 0.5);
		}
		if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log && ruler.y < 0)
		ruler.py = -1;
		else
		{
		P = (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log ? (Math.log(ruler.y) / GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].log_base) : (ruler.y));
		ruler.py = (int)((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_lower) + ((P) - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].min) * GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_scale + 0.5);
		}
		GlobalMembersMouse.MousePosToGraphPosReal(ruler.px, ruler.py, dummy, dummy, ruler.x2, ruler.y2);
	}
	public static void turn_ruler_off()
	{
		if (ruler.on)
		{
		udvt_entry u;
		ruler.on = false;
		if (GlobalMembersTerm.term != null && GlobalMembersTerm.term.set_ruler)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.set_ruler)(-1, -1);
		}
		if ((u = GlobalMembersEval.add_udv_by_name("MOUSE_RULER_X")))
			u.udv_undef = true;
		if ((u = GlobalMembersEval.add_udv_by_name("MOUSE_RULER_Y")))
			u.udv_undef = true;
		if (GlobalMembersCommand.display_ipc_commands() != 0)
		{
			fprintf(stderr, "turning ruler off.\n");
		}
		}
	}
	public static int nearest_label_tag(int xref, int yref, TERMENTRY t)
	{
		double min = -1;
		int min_tag = -1;
		double diff_squared;
		int x;
		int y;
		text_label this_label;
		int xd;
		int yd;

		for (this_label = GlobalMembersGadgets.first_label; this_label != DefineConstants.NULL; this_label = this_label.next)
		{
		if (GlobalMembersGadgets.is_3d_plot)
		{
			GlobalMembersGraph3d.map3d_position(this_label.place, xd, yd, "label");
			xd -= xref;
			yd -= yref;
		}
		else
		{
			GlobalMembersGraphics.map_position(this_label.place, x, y, "label");
			xd = x - xref;
			yd = y - yref;
		}
		diff_squared = xd * xd + yd * yd;
		if (-1 == min || min > diff_squared)
		{
			/* now we check if we're within a certain
			 * threshold around the label */
			double tic_diff_squared;
			int htic;
			int vtic;
			GlobalMembersGadgets.get_offsets(this_label, t, htic, vtic);
			tic_diff_squared = htic * htic + vtic * vtic;
			if (diff_squared < tic_diff_squared)
			{
			min = diff_squared;
			min_tag = this_label.tag;
			}
		}
		}

		return min_tag;
	}
	public static void remove_label(int x, int y)
	{
		int tag = GlobalMembersMouse.nearest_label_tag(x, y, GlobalMembersTerm.term);
		if (-1 != tag)
		{
		String cmd = new String(new char[0x40]);
		String.format(cmd, "unset label %d", tag);
		GlobalMembersCommand.do_string_replot(cmd);
		}
	}
	public static void put_label(String label, double x, double y)
	{
		String cmd = new String(new char[0xff]);
		String.format(cmd, "set label \"%s\" at %g,%g %s", label, x, y, mouse_setting.labelopts ? mouse_setting.labelopts : "point pt 1");
		GlobalMembersCommand.do_string_replot(cmd);
	}

	/* always include the prototype. The prototype might even not be
	 * declared if the system supports stpcpy(). E.g. on Linux I would
	 * have to define __USE_GNU before including string.h to get the
	 * prototype (joze) */
	/* HBB 20001109: *BUT* if a prototype is there, this one may easily
	 * conflict with it... */
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//String stpcpy(String s, String p);



	/* HBB 20000507: fixed a construction error. Was using the 'timefmt'
	 * string (which is for reading, not writing time data) to output the
	 * value. Code is now closer to what setup_tics does. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MKSTR(sp,x,axis) do { if (x >= VERYLARGE) break; if (axis_array[axis].is_timedata) { char *format = copy_or_invent_formatstring(axis); while (strchr(format,'\n')) *(strchr(format,'\n')) = ' '; gstrftime(sp, 40, format, x); } else { sprintf(sp, mouse_setting.fmt ,x); } sp += strlen(sp); } while (0)


	/* ratio for log, distance for linear */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIST(x,rx,axis) (axis_array[axis].log) ? ( (rx==0) ? 99999 : x / rx ) : (x - rx)


	public static t_zoom zoom_head = DefineConstants.NULL;
	public static t_zoom zoom_now = DefineConstants.NULL;
	public static axis[] axis_array_copy = new axis[DefineConstants.AXIS_ARRAY_SIZE];
}