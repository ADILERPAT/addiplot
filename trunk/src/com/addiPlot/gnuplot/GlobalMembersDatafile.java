package com.addiPlot.gnuplot;

import java.io.File;

public class GlobalMembersDatafile
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: datafile.c,v 1.172.2.8 2010/01/06 17:35:10 sfeam Exp $");
	}
	///#endif

	/* GNUPLOT - datafile.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/* AUTHOR : David Denholm */

	/*
	 * this file provides the functions to handle data-file reading..
	 * takes care of all the pipe / stdin / index / using worries
	 */

	/*{{{  notes */
	/* couldn't decide how to implement 'thru' only for 2d and 'index'
	 * for only 3d, so I did them for both - I can see a use for
	 * index in 2d, especially for fit.
	 *
	 * I keep thru for backwards compatibility, and extend it to allow
	 * more natural plot 'data' thru f(y) - I (personally) prefer
	 * my syntax, but then I'm biased...
	 *
	 * - because I needed it, I have added a range of indexes...
	 * (s)plot 'data' [index i[:j]]
	 *
	 * also every a:b:c:d:e:f  - plot every a'th point from c to e,
	 * in every b lines from d to f
	 * ie for (line=d; line<=f; line+=b)
	 *     for (point=c; point >=e; point+=a)
	 *
	 *
	 * I dont like mixing this with the time series hack... I am
	 * very into modular code, so I would prefer to not have to
	 * have _anything_ to do with time series... for example,
	 * we just look at columns in file, and that is independent
	 * of 2d/3d. I really dont want to have to pass a flag to
	 * this is plot or splot.
	 *
	 * Now that df_2dbinary() and df_3dbinary() are here, I am seriously
	 * tempted to move get_data() and get_3ddata() in here too
	 *
	 * public variables declared in this file.
	 *    int df_no_use_specs - number of columns specified with 'using'
	 *    int df_no_tic_specs - count of additional ticlabel columns
	 *    int df_line_number  - for error reporting
	 *    int df_datum        - increases with each data point
	 *    TBOOLEAN df_binary  - it's a binary file
	 *        [ might change this to return value from df_open() ]
	 *    int df_eof          - end of file
	 *
	 * functions
	 *   int df_open(char *file_name, int max_using, plot_header *plot)
	 *      parses thru / index / using on command line
	 *      max_using is max no of 'using' columns allowed (obsolete?)
	 *	plot_header is NULL if called from fit or set_palette code
	 *      returns number of 'using' cols specified, or -1 on error (?)
	 *
	 *   int df_readline(double vector[], int max)
	 *      reads a line, does all the 'index' and 'using' manipulation
	 *      deposits values into vector[]
	 *      returns
	 *          number of columns parsed  [0=not blank line, but no valid data],
	 *          DF_EOF for EOF
	 *          DF_UNDEFINED - undefined result during eval of extended using spec
	 *          DF_MISSING - requested column matched that of 'set missing <foo>'
	 *          DF_FIRST_BLANK for first consecutive blank line
	 *          DF_SECOND_BLANK for second consecutive blank line
	 *            will return FIRST before SECOND
	 *
	 * if a using spec was given, lines not fulfilling spec are ignored.
	 * we will always return exactly the number of items specified
	 *
	 * if no spec given, we return number of consecutive columns we parsed.
	 *
	 * if we are processing indexes, separated by 'n' blank lines,
	 * we will return n-1 blank lines before noticing the index change
	 *
	 *   void df_close()
	 *     closes a currently open file.
	 *
	 *    void f_dollars(x)
	 *    void f_column()    actions for expressions using $i, column(j), etc
	 *    void f_valid()
	 *
	 *
	 * line parsing slightly differently from previous versions of gnuplot...
	 * given a line containing fewer columns than asked for, gnuplot used to make
	 * up values... I say that if I have explicitly said 'using 1:2:3', then if
	 * column 3 doesn't exist, I dont want this point...
	 *
	 * a column number of 0 means generate a value... as before, this value
	 * is useful in 2d as an x value, and is reset at blank lines.
	 * a column number of -1 means the (data) line number (not the file line
	 * number).  splot 'file' using 1  is equivalent to
	 * splot 'file' using 0:-1:1
	 * column number -2 is the index. It was put in to kludge multi-branch
	 * fitting.
	 *
	 * 20/5/95 : accept 1.23d4 in place of e (but not in scanf string)
	 *         : autoextend data line buffer and MAX_COLS
	 *
	 * 11/8/96 : add 'columns' -1 for suggested y value, and -2 for
	 *           current index.
	 *           using 1:-1:-2  and  column(-1)  are supported.
	 *           $-1 and $-2 are not yet supported, because of the
	 *           way the parser works
	 *
	 */
	/*}}} */

	/* Daniel Sebald: added general binary 2d data support. (20 August 2004)
	 */

	/*
	 * $Id: datafile.h,v 1.31 2009/03/13 05:10:56 sfeam Exp $
	 */

	/* GNUPLOT - datafile.h */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif

	/* returns from DF_READLINE in datafile.c */
	/* +ve is number of columns read */
	///#define DF_EOF (-1)
	///#define DF_UNDEFINED (-2)
	///#define DF_FIRST_BLANK (-3)
	///#define DF_SECOND_BLANK (-4)
	///#define DF_MISSING (-5)
	///#define DF_FOUND_KEY_TITLE (-6)
	///#define DF_KEY_TITLE_MISSING (-7)
	///#define DF_STRINGDATA (-8)


	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX // in limits.h ?
	///#define MAXINT INT_MAX
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif

	/* Variables of datafile.c needed by other modules: */

	/* how many using columns were specified, and max possible */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int df_no_use_specs;
	///#define MAXDATACOLS 7

	/* suggested x value if none given */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int df_datum;

	/* is this a matrix splot? */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean df_matrix;

	/* is this a binary file? */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean df_binary;

	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int df_line_number;
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern AXIS_INDEX df_axis[];
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct udft_entry ydata_func; // HBB 990829: moved from command.h

	/* Returned to caller by df_readline() */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte *df_tokens[];

	/* string representing missing values, ascii datafiles */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte *missing_val;

	/* input field separator, NUL if whitespace is the separator */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte df_separator;

	/* comments chars */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte *df_commentschars;

	/* flag if any 'inline' data are in use, for the current plot */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean plotted_data_from_stdin;

	/* Setting this allows the parser to recognize Fortran D or Q   */
	/* format constants in the input file. But it slows things down */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean df_fortran_constants;

	/* Setting this disables initialization of the floating point exception */
	/* handler before every expression evaluation in a using specifier.   	 */
	/* This can speed data input significantly, but assumes valid input.    */
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean df_nofpe_trap;
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean evaluate_inside_using;

	/*{{{  int df_open(char *file_name, int max_using, plot_header *plot) */

	/* open file, parsing using/thru/index stuff return number of using
	 * specs [well, we have to return something !]
	 */

	/* Prototypes of functions exported by datafile.c */

	public static int df_open(String cmd_filename, int max_using, curve_points plot)
	{
		int name_token = GlobalMembersCommand.c_token - 1;
		boolean duplication = false;
		boolean set_index = false;
		boolean set_every = false;
		boolean set_thru = false;
		boolean set_using = false;
		boolean set_matrix = false;

		fast_columns = 1; // corey@cac

		/* close file if necessary */
		if (data_fp != null)
		{
			GlobalMembersDatafile.df_close();
			data_fp = DefineConstants.NULL;
		}

		/*{{{  initialise static variables */
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(df_format);
		df_format = DefineConstants.NULL; // no format string

		df_no_tic_specs = 0;
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(df_key_title);
		df_key_title = DefineConstants.NULL;

		GlobalMembersDatafile.initialize_use_spec();

		df_datum = -1; // it will be preincremented before use
		df_line_number = 0; // ditto

		df_lower_index = 0;
		df_index_step = 1;
		df_upper_index = (~0) >> 1;
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(indexname);
		indexname = DefineConstants.NULL;

		df_current_index = 0;
		blank_count = 2;
		/* by initialising blank_count, leading blanks will be ignored */

		everypoint = everyline = 1; // unless there is an every spec
		firstpoint = firstline = 0;
		lastpoint = lastline = (~0) >> 1;

		df_binary_file = df_matrix_file = false;
		df_datablock = DefineConstants.NULL;
		df_num_bin_records = 0;

		df_eof = 0;

		/* Save for use by df_readline(). */
		/* Perhaps it should be a parameter to df_readline? */
		df_current_plot = plot;
		column_for_key_title = DefineConstants.NO_COLUMN_HEADER;
		/*}}} */

		assert max_using <= DefineConstants.MAXDATACOLS;

		if (cmd_filename == null)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "missing filename");
		if (!cmd_filename.charAt(0))
		{
			if (df_filename == null || df_filename == null)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "No previous filename");
		}
		else
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(df_filename);
			df_filename = GlobalMembersUtil.gp_strdup(cmd_filename);
		}

		/* defer opening until we have parsed the modifiers... */

		if (ydata_func.at != null) // something for thru (?)
			GlobalMembersEval.free_at(ydata_func.at);
		ydata_func.at = DefineConstants.NULL;

		df_binary = df_matrix = false;

		/* pm 25.11.2001 allow any order of options */
		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{

			/* look for binary / matrix */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bin$ary") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (df_binary_file)
				{
					duplication = true;
					break;
				}
				df_binary_file = true;
				/* Up to the time of adding the general binary code, only matrix
				 * binary for 3d was defined.  So, use matrix binary by default.
				 */
				df_matrix_file = true;
				GlobalMembersDatafile.initialize_binary_vars();
				GlobalMembersDatafile.plot_option_binary(set_matrix, false);
				continue;
			}

			/* deal with matrix */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "mat$rix") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (set_matrix)
				{
					duplication = true;
					break;
				}
				/* `binary` default is both df_matrix_file and df_binary_file.
				 * So if df_binary_file is true, but df_matrix_file isn't, then
				 * some keyword specific to general binary has been given.
				 */
				if (!df_matrix_file && df_binary_file)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, matrix_general_binary_conflict_msg);
				df_matrix_file = true;
				set_matrix = true;
				fast_columns = 0;
				continue;
			}

			/* deal with index */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "i$ndex") != 0)
			{
				if (set_index)
				{
					duplication = true;
					break;
				}
				GlobalMembersDatafile.plot_option_index();
				set_index = true;
				continue;
			}

			/* deal with every */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ev$ery") != 0)
			{
				if (set_every)
				{
					duplication = true;
					break;
				}
				GlobalMembersDatafile.plot_option_every();
				set_every = true;
				continue;
			}

			/* deal with thru */
			/* jev -- support for passing data from file thru user function */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "thru$") != 0)
			{
				if (set_thru)
				{
					duplication = true;
					break;
				}
				GlobalMembersDatafile.plot_option_thru();
				set_thru = true;
				continue;
			}

			/* deal with using */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "u$sing") != 0)
			{
				if (set_using)
				{
					duplication = true;
					break;
				}
				GlobalMembersDatafile.plot_option_using(max_using);
				set_using = true;
				continue;
			}

			/* deal with volatile */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "volatile") != 0)
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersGadgets.volatile_data = true;
				continue;
			}

			/* Allow this plot not to affect autoscaling */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noauto$scale") != 0)
			{
				GlobalMembersCommand.c_token++;
				plot.noautoscale = true;
				continue;
			}

			break; // unknown option

		} // while (!END_OF_COMMAND)

		if (duplication)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "duplicated or contradicting arguments in datafile options");

		/* Check for auto-generation of key title from column header  */
		/* Mar 2009:  This may no longer be the best place for this!  */
		if ((GlobalMembersGadgets.keyT).auto_titles == keytitle_type.COLUMNHEAD_KEYTITLES)
		{
			if (df_no_use_specs == 1)
				column_for_key_title = use_spec[0].column;
			else if (plot != null && plot.plot_type == PLOT_TYPE.DATA3D)
				column_for_key_title = use_spec[2].column;
			else
				column_for_key_title = use_spec[1].column;
		}

		/*{{{  more variable inits */
		point_count = -1; // we preincrement
		line_count = 0;
		df_pseudodata = 0;
		df_pseudorecord = 0;
		df_pseudospan = 0;

		/* here so it's not done for every line in df_readline */
		if (max_line_len < DefineConstants.DATA_LINE_BUFSIZ)
		{
			max_line_len = DefineConstants.DATA_LINE_BUFSIZ;
			line = GlobalMembersAlloc.gp_alloc(max_line_len, "datafile line buffer");
		}
		/*}}} */

		/*{{{  open file */
		///#if defined(PIPES)
		if (df_filename.equals('<'))
		{
			if ((data_fp = GlobalMembersAmiga.popen(df_filename + 1, "r")) == (FILE) DefineConstants.NULL)
				GlobalMembersUtil.os_error(name_token, "cannot create pipe for data");
			else
				df_pipe_open = true;
		}
		else
			///#endif // PIPES
			/* I don't want to call strcmp(). Does it make a difference? */
			if (df_filename.equals('-') && df_filename.length() == 1)
			{
				plotted_data_from_stdin = true;
				GlobalMembersGadgets.volatile_data = true;
				data_fp = GlobalMembersMisc.lf_top();
				if (data_fp == null)
					data_fp = stdin;
				mixed_data_fp = true; // don't close command file
			}
			else if (df_filename.charAt(0) == '+')
			{
				if (df_filename.length() == 1)
					df_pseudodata = 1;
				else if (df_filename.charAt(1) == '+' && df_filename.length() == 2)
					df_pseudodata = 2;
			}
			else
			{
				/* filename cannot be static array! */
				tangible.RefObject<String[]> tempRef_df_filename = new tangible.RefObject<String[]>(df_filename);
				GlobalMembersPlot.gp_expand_tilde(tempRef_df_filename);
				df_filename = tempRef_df_filename.argvalue;
				///#ifdef HAVE_SYS_STAT_H
				{
					stat statbuf = new stat();
					if ((stat(df_filename, statbuf) > -1) && (((statbuf.st_mode) & S_IFMT) == S_IFDIR))
					{
						GlobalMembersUtil.os_error(name_token, "\"%s\" is a directory", df_filename);
					}
				}
				///#endif // HAVE_SYS_STAT_H

				if ((data_fp = GlobalMembersMisc.loadpath_fopen(df_filename, df_binary_file ? "rb" : "r")) == DefineConstants.NULL)
				{
					GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "Skipping unreadable file \"%s\"", df_filename);
					df_eof = 1;
					return DefineConstants.DF_EOF;
				}
			}
		/*}}} */


		/* If the data is in binary matrix form, read in some values
		 * to determine the nubmer of columns and rows.  If data is in
		 * ASCII matrix form, read in all the data to memory in preparation
		 * for using df_readbinary() routine.
		 */
		if (df_matrix_file)
			GlobalMembersDatafile.df_determine_matrix_info(data_fp);

		/* General binary, matrix binary and ASCII matrix all use the
		 * df_readbinary() routine.
		 */
		if (df_binary_file || df_matrix_file)
		{
			df_read_binary = true;
			GlobalMembersDatafile.adjust_binary_use_spec();
		}
		else
			df_read_binary = false;

		/* Make information about whether the data forms a grid or not
		 * available to the outside world.  */
		df_matrix = (df_matrix_file || ((df_num_bin_records == 1) && ((df_bin_record[0].cart_dim[1] > 0) || (df_bin_record[0].scan_dim[1] > 0))));

		/* Same idea, but try removing this one.  I can't see why it is
		 * important for the rest of the program to know if if the data
		 * came from a binary file. (DJS 20 Aug 2004) */
		df_binary = df_binary_file;

		return df_no_use_specs;
	}

	/*{{{  int df_readline(v, max) */
	public static int df_readline(double[] v, int max)
	{
		if (data_fp == null && df_pseudodata == 0)
			return DefineConstants.DF_EOF;

		if (df_read_binary)
			/* General binary, matrix binary or matrix ascii
			 * that's been converted to binary.
			 */
			return GlobalMembersDatafile.df_readbinary(v, max);
		else
			return GlobalMembersDatafile.df_readascii(v, max);
	}

	/*}}} */

	/*{{{  void df_close() */
	public static void df_close()
	{
		int i;

		/* paranoid - mark $n and column(n) as invalid */
		df_no_cols = 0;

		if (data_fp == null)
			return;

		if (ydata_func.at != null)
		{
			GlobalMembersEval.free_at(ydata_func.at);
			ydata_func.at = DefineConstants.NULL;
		}
		/*{{{  free any use expression storage */
		for (i = 0; i < DefineConstants.MAXDATACOLS; ++i)
			if (use_spec[i].at != null)
			{
				GlobalMembersEval.free_at(use_spec[i].at);
				use_spec[i].at = DefineConstants.NULL;
			}
		/*}}} */

		if (!mixed_data_fp)
		{
			///#if defined(PIPES)
			if (df_pipe_open)
			{
				() GlobalMembersAmiga.pclose(data_fp);
				df_pipe_open = false;
			}
			else
				///#endif // PIPES
				() fclose(data_fp);
		}
		mixed_data_fp = false;
		data_fp = DefineConstants.NULL;
	}

	/*}}} */

	/*{{{  void df_showdata() */
	/* display the current data file line for an error message
	 */
	public static void df_showdata()
	{
		if (data_fp != null && df_filename != null && line != null)
		{
			/* display no more than 77 characters */
			fprintf(stderr, "%.77s%s\n%s:%d:", line, (line.length() > 77) ? "..." : "", df_filename, df_line_number);
		}
	}
	//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int df_2dbinary(curve_points);
	//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int df_3dmatrix(surface_points, int NamelessParameter2);

	/*
	 * Load plot title for key box from the string found earlier by df_readline.
	 * Called from get_data().
	 */
	public static void df_set_key_title(curve_points plot)
	{
		if (plot.plot_style == PLOT_STYLE.HISTOGRAMS && GlobalMembersGadgets.histogram_opts.type == histogram_type.HT_STACKED_IN_TOWERS.getValue())
		{
			/* In this case it makes no sense to treat key titles in the usual */
			/* way, so we assume that it is supposed to be an xtic label.      */
			/* FIXME EAM - This style should default to notitle!               */
			double xpos = plot.histogram_sequence + plot.histogram.start;
			GlobalMembersAxis.add_tic_user(AXIS_INDEX.FIRST_X_AXIS, df_key_title, xpos, -1);
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(df_key_title);
			df_key_title = DefineConstants.NULL;
			return;
		}

		/* What if there was already a title specified? */
		if (plot.title != null && !plot.title_is_filename)
			return;
		if (plot.title_is_suppressed)
			return;
		if (plot.title != null)
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(plot.title);

		plot.title_no_enhanced = !GlobalMembersGadgets.keyT.enhanced;
		plot.title = df_key_title;
		df_key_title = DefineConstants.NULL;
	}

	/*
	 * Load plot title for key box from columnheader.
	 * Called from eval_plots(), eval_3dplots() while parsing the plot title option
	 */
	public static void df_set_key_title_columnhead(PLOT_TYPE plot_type)
	{
		GlobalMembersFit.a((stderr,"df_set_key_title_columnhead: column_for_key_title was %d, ",column_for_key_title));
		GlobalMembersCommand.c_token++;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "(") != 0)
		{
			GlobalMembersCommand.c_token++;
			column_for_key_title = GlobalMembersParse.int_expression();
			GlobalMembersCommand.c_token++;
		}
		else if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0)
		{
			column_for_key_title = GlobalMembersParse.int_expression();
		}
		else
		{
			if (df_no_use_specs == 1)
				column_for_key_title = use_spec[0].column;
			else if (plot_type == PLOT_TYPE.DATA3D)
				column_for_key_title = use_spec[2].column;
			else
				column_for_key_title = use_spec[1].column;
		}
		GlobalMembersFit.a((stderr," setting to %d\n",column_for_key_title));
	}

	/*
	 * Plotting routines can call this prior to invoking df_readline() to indicate
	 * that they expect a certain column to contain an ascii string rather than a
	 * number.
	 */
	public static int expect_string(byte column)
	{
		use_spec[column - 1].expected_type = COLUMN_TYPE.CT_STRING.getValue();
		return (use_spec[column - 1].column);
	}

	/* Called from int_error() */

	public static void df_reset_after_error()
	{
		() do {if (GlobalMembersUtil.numeric_locale != null && strcmp(GlobalMembersUtil.numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)();
		evaluate_inside_using = false;
	}

	/* stuff for implementing the call-backs for picking up data values
	 * do it here so we can make the variables private to this file
	 */

	/*{{{  void f_dollars(x) */
	public static void f_dollars(argument x)
	{
		int column = x.v_arg.v.int_val - 1;
		/* we checked it was an integer >= 0 at compile time */
		value a = new value();

		if (column == -1)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double) df_datum, 0.0)); // $0
		}
		else if (column >= df_no_cols || df_column[column].good != DF_GOOD)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push((x.v_arg)); // this okay ?
		}
		else
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, df_column[column].datum, 0.0));
	}

	/*}}} */

	/*{{{  void f_column() */
	public static void f_column(argument arg)
	{
		value a = new value();
		int column;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop(a);
		column = (int) GlobalMembersEval.real(a);

		if (!evaluate_inside_using)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "column() called from invalid context");

		if (column == -2)
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, df_current_index));
		else if (column == -1)
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, line_count));
		else if (column == 0) // $0 = df_datum
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double) df_datum, 0.0));
		else if (column < 1 || column > df_no_cols || df_column[column - 1].good != DF_GOOD)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a); // any objection to this ?
		}
		else
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, df_column[column - 1].datum, 0.0));
	}

	/*{{{  void f_valid() */
	public static void f_valid(argument arg)
	{
		value a = new value();
		int column;
		int good;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop(a);
		column = (int) GlobalMembersEval.magnitude(a) - 1;
		good = column >= 0 && column < df_no_cols && df_column[column].good == DF_GOOD;
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, good));
	}

	/*}}} */

	/*{{{  void f_timecolumn() */
	/* HBB NOTE 20050505: this job is excessively tricky.  We have one
	 * timefmt string per axis.  Back then, that was essentially the only
	 * possibility, but it now poses a severe limitation.  For simple
	 * using specs, the time parsing format should be a function of the
	 * column number in the datafile, not of the axis the data will be
	 * used for.  For extended using specs, the value to go on a given
	 * axis could conceivably be built from multiple time/date entries in
	 * the datafile, each with its own format. */
	/* HBB FIXME 20050505: this really should take two arguments, at
	 * least.  First, the datafile column number.  Second either a timefmt
	 * string (variable), or an axis index.  For now, we have to try to
	 * guess the right axis index */
	public static void f_timecolumn(argument arg)
	{
		value a = new value();
		int column;
		int spec;
		AXIS_INDEX whichaxis;
		tm tm = new tm();
		int limit = (df_no_use_specs != 0 ? df_no_use_specs : DefineConstants.MAXDATACOLS);

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop(a);
		column = (int) GlobalMembersEval.magnitude(a); // HBB 20050505: removed - 1

		if (!evaluate_inside_using)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "timecolumn() called from invalid context");

		/* try to match datafile column with spec field number */
		whichaxis = AXIS_INDEX.FIRST_X_AXIS;
		for (spec = 0; spec < limit; spec++)
			if (use_spec[spec].column == column)
			{
				/* Found a 'using' specifier whose (default) column number
				 * is the same as the column being referred to here.  So
				 * assume this spec's output axis is the one that we want
				 * to use the timefmt of. */
				whichaxis = df_axis[spec];
				break;
			}

		if (column < 1 || column > df_no_cols || df_column[column - 1].position == null || GlobalMembersTime.gstrptime(df_column[column - 1].position, GlobalMembersAxis.axis_array[whichaxis.getValue()].timefmt, tm) == null)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a); // any objection to this ?
		}
		else
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersTime.gtimegm(tm), 0.0));
	}
	public static void f_stringcolumn(argument arg)
	{
		value a = new value();
		int column;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop(a);
		column = (int) GlobalMembersEval.real(a);

		if (!evaluate_inside_using || df_matrix)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "stringcolumn() called from invalid context");

		if (column < 1 || column > df_no_cols)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a); // any objection to this ?
		}
		else
		{
			byte temp_string = GlobalMembersDatafile.df_parse_string_field(df_column[column - 1].position);
			GlobalMembersEval.push(GlobalMembersEval.Gstring(a, temp_string));
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(temp_string);
		}
	}

	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern df_binary_file_record_struct *df_bin_record;
	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int df_num_bin_records;

	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct use_spec_s use_spec[];

	/* Prototypes of functions exported by datafile.c */

	public static void df_show_binary(FILE fp)
	{
		int i;
		int num_record;
		df_binary_file_record_struct bin_record;

		fprintf(fp, "\tDefault binary data file settings (in-file settings may override):\n");

		if (df_num_bin_records_default == 0)
		{
			bin_record = df_bin_record_reset;
			num_record = 1;
		}
		else
		{
			bin_record = df_bin_record_default;
			num_record = df_num_bin_records_default;
		}

		fprintf(fp, "\n\t  File Type: ");
		if (df_bin_filetype_default >= 0)
			fprintf(fp, "%s", df_bin_filetype_table[df_bin_filetype_default].key);
		else
			fprintf(fp, "none");

		fprintf(fp, "\n\t  File Endianess: %s", df_endian[df_bin_file_endianess_default.getValue()]);

		fprintf(fp, "\n\t  Default binary format: %s", df_binary_format != null ? df_binary_format : "none");

		for (i = 0; i < num_record; i++)
		{
			int dimension = 1;

			fprintf(fp, "\n\t  Record %d:\n", i);
			fprintf(fp, "\t    Dimension: ");
			if (bin_record[i].cart_dim[0] < 0)
				fprintf(fp, "Inf");
			else
			{
				fprintf(fp, "%d", bin_record[i].cart_dim[0]);
				if (bin_record[i].cart_dim[1] > 0)
				{
					dimension = 2;
					fprintf(fp, "x%d", bin_record[i].cart_dim[1]);
					if (bin_record[i].cart_dim[2] > 0)
					{
						dimension = 3;
						fprintf(fp, "x%d", bin_record[i].cart_dim[2]);
					}
				}
			}
			fprintf(fp, "\n\t    Generate coordinates: %s", (bin_record[i].scan_generate_coord ? "yes" : "no"));
			if (bin_record[i].scan_generate_coord)
			{
				int j;
				boolean no_flip = true;

				fprintf(fp, "\n\t    Direction: ");
				if (bin_record[i].cart_dir[0] == -1)
				{
					fprintf(fp, "flip x");
					no_flip = false;
				}
				if ((dimension > 1) && (bin_record[i].cart_dir[1] == -1))
				{
					fprintf(fp, "%sflip y", (no_flip ? "" : ", "));
					no_flip = false;
				}
				if ((dimension > 2) && (bin_record[i].cart_dir[2] == -1))
				{
					fprintf(fp, "%sflip z", (no_flip ? "" : ", "));
					no_flip = false;
				}
				if (no_flip)
					fprintf(fp, "all forward");
				fprintf(fp, "\n\t    Sample periods: dx=%f", bin_record[i].cart_delta[0]);
				if (dimension > 1)
					fprintf(fp, ", dy=%f", bin_record[i].cart_delta[1]);
				if (dimension > 2)
					fprintf(fp, ", dz=%f", bin_record[i].cart_delta[2]);
				if (bin_record[i].cart_trans == df_translation_type.DF_TRANSLATE_VIA_ORIGIN)
					fprintf(fp, "\n\t    Origin:");
				else if (bin_record[i].cart_trans == df_translation_type.DF_TRANSLATE_VIA_CENTER)
					fprintf(fp, "\n\t    Center:");
				if ((bin_record[i].cart_trans == df_translation_type.DF_TRANSLATE_VIA_ORIGIN) || (bin_record[i].cart_trans == df_translation_type.DF_TRANSLATE_VIA_CENTER))
					fprintf(fp, " (%f, %f, %f)", bin_record[i].cart_cen_or_ori[0], bin_record[i].cart_cen_or_ori[1], bin_record[i].cart_cen_or_ori[2]);
				fprintf(fp, "\n\t    2D rotation angle: %f", bin_record[i].cart_alpha);
				fprintf(fp, "\n\t    3D normal vector: (%f, %f, %f)", bin_record[i].cart_p[0], bin_record[i].cart_p[1], bin_record[i].cart_p[2]);
				//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
				//ORIGINAL LINE: for (j = 0; j < (sizeof(df_bin_scan_table_3D) /sizeof(df_bin_scan_table_3D[0])); j++)
				for (j = 0; j < (df_bin_scan_table_3D.length); j++)
				{
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					if (!strncmp((String)bin_record[i].cart_scan, (String)df_bin_scan_table_3D[j].scan, sizeof(bin_record[0].cart_scan)))
					{
						fprintf(fp, "\n\t    Scan: ");
						fprintf(fp, (bin_record[i].cart_dim[2] != 0 ? "%s" : "%2.2s"), df_bin_scan_table_3D[j].string);
						break;
					}
				}
				fprintf(fp, "\n\t    Skip bytes: %d before record", bin_record[i].scan_skip[0]);
				if (dimension > 1)
					fprintf(fp, ", %d before line", bin_record[i].scan_skip[1]);
				if (dimension > 2)
					fprintf(fp, ", %d before plane", bin_record[i].scan_skip[2]);
			}
			fprintf(fp, "\n");
		}
	}
	public static void df_show_datasizes(FILE fp)
	{
		int i;

		fprintf(fp,"\tThe following binary data sizes are machine dependent:\n\n" + "\t  name (size in bytes)\n\n");
		//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
		//ORIGINAL LINE: for (i = 0; i < sizeof(df_binary_details)/sizeof(df_binary_details[0]); i++)
		for (i = 0; i < df_binary_details.length; i++)
		{
			int j;

			fprintf(fp,"\t  ");
			for (j = 0; j < df_binary_details[i].no_names; j++)
			{
				fprintf(fp,"\"%s\" ",df_binary_details[i].name[j]);
			}
			fprintf(fp,"(%d)\n",df_binary_details[i].type.read_size);
		}

		fprintf(fp,"\n\tThe following binary data sizes attempt to be machine independent:\n\n\t  name (size in bytes)\n\n");
		//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
		//ORIGINAL LINE: for (i = 0; i < sizeof(df_binary_details_independent) /sizeof(df_binary_details_independent[0]); i++)
		for (i = 0; i < df_binary_details_independent.length; i++)
		{
			int j;

			fprintf(fp,"\t  ");
			for (j = 0; j < df_binary_details_independent[i].no_names; j++)
			{
				fprintf(fp,"\"%s\" ",df_binary_details_independent[i].name[j]);
			}
			fprintf(fp,"(%d)",df_binary_details_independent[i].type.read_size);
			if (df_binary_details_independent[i].type.read_type == df_data_type.DF_BAD_TYPE)
				fprintf(fp," -- processor does not support this size");
			fputc('\n', fp);
		}
	}
	public static void df_show_filetypes(FILE fp)
	{
		int i = 0;

		fprintf(fp,"\tThis version of gnuplot understands the following binary file types:\n");
		while (df_bin_filetype_table[i].key != null)
			fprintf(fp, "\t  %s", df_bin_filetype_table[i++].key);
		fputs("\n",fp);
	}
	public static void df_set_datafile_binary()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "option expected");
		GlobalMembersDatafile.clear_binary_records(df_records_type.DF_CURRENT_RECORDS);
		/* Set current records to default in order to retain current default settings. */
		if (df_bin_record_default != null)
		{
			df_bin_filetype = df_bin_filetype_default;
			df_bin_file_endianess = df_bin_file_endianess_default;
			GlobalMembersDatafile.df_add_binary_records(df_num_bin_records_default, df_records_type.DF_CURRENT_RECORDS);
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memcpy(df_bin_record, df_bin_record_default, df_num_bin_records * sizeof(df_binary_file_record_struct));
		}
		else
		{
			df_bin_filetype = df_bin_filetype_reset;
			df_bin_file_endianess = (((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN;
			GlobalMembersDatafile.df_add_binary_records(1, df_records_type.DF_CURRENT_RECORDS);
		}
		/* Process the binary tokens. */
		GlobalMembersDatafile.df_set_plot_mode(MODE_PLOT_TYPE.MODE_QUERY);
		GlobalMembersDatafile.plot_option_binary(false, true);
		/* Copy the modified settings as the new default settings. */
		df_bin_filetype_default = df_bin_filetype;
		df_bin_file_endianess_default = df_bin_file_endianess;
		GlobalMembersDatafile.clear_binary_records(df_records_type.DF_DEFAULT_RECORDS);
		GlobalMembersDatafile.df_add_binary_records(df_num_bin_records, df_records_type.DF_DEFAULT_RECORDS);
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(df_bin_record_default, df_bin_record, df_num_bin_records_default * sizeof(df_binary_file_record_struct));
	}
	public static void df_unset_datafile_binary()
	{
		GlobalMembersDatafile.clear_binary_records(df_records_type.DF_DEFAULT_RECORDS);
		df_bin_filetype_default = df_bin_filetype_reset;
		df_bin_file_endianess_default = (((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN;
	}
	public static void df_add_binary_records(int num_records_to_add, df_records_type records_type)
	{
		int i;
		int new_number;
		df_binary_file_record_struct[] bin_record;
		int num_bin_records;
		int max_num_bin_records;

		if (records_type == df_records_type.DF_CURRENT_RECORDS)
		{
			bin_record = df_bin_record;
			num_bin_records = df_num_bin_records;
			max_num_bin_records = df_max_num_bin_records;
		}
		else
		{
			bin_record = df_bin_record_default;
			num_bin_records = df_num_bin_records_default;
			max_num_bin_records = df_max_num_bin_records_default;
		}

		new_number = num_bin_records + num_records_to_add;

		if (new_number > max_num_bin_records)
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			bin_record = GlobalMembersAlloc.gp_realloc(bin_record, new_number * sizeof(df_binary_file_record_struct), "binary file data records");
			if (bin_record == null)
			{
				max_num_bin_records = 0;
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Error assigning memory for binary file data records");
			}
			max_num_bin_records = new_number;
		}

		for (i = 0; i < num_records_to_add; i++)
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memcpy(bin_record + num_bin_records, df_bin_record_reset, sizeof(df_binary_file_record_struct));
			num_bin_records++;
		}
	}

	/* If the column number is greater than number of binary columns, set
	 * the unitialized columns binary info to that of the last specified
	 * column or the default if none were set.  */
	public static void df_extend_binary_columns(int no_cols)
	{
		if (no_cols > df_no_bin_cols)
		{
			int i;
			df_data_type type;
			if (df_no_bin_cols > 0)
				type = df_column_bininfo[df_no_bin_cols - 1].column.read_type;
			else
				type = df_data_type.DF_FLOAT;
			for (i = no_cols; i > df_no_bin_cols; i--)
			{
				GlobalMembersDatafile.df_set_skip_before(i + 1, 0);
				GlobalMembersDatafile.df_set_read_type(i, type);
			}
			df_no_bin_cols = no_cols;
		}
	}

	/* Set the 'bytes' to skip before column 'col'. */
	public static void df_set_skip_before(int col, int bytes)
	{
		assert col > 0;
		/* Check if we have room at least col columns */
		if (col > df_max_bininfo_cols)
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			df_column_bininfo = GlobalMembersAlloc.gp_realloc(df_column_bininfo, col * sizeof(df_column_bininfo_struct), "datafile columns binary information");
			df_max_bininfo_cols = col;
		}
		df_column_bininfo[col - 1].skip_bytes = bytes;
	}

	/* Set the column data type. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define df_set_skip_after(col,bytes) df_set_skip_before(col+1,bytes)
	public static void df_set_read_type(int col, df_data_type type)
	{
		assert col > 0;
		/* Check if we have room at least col columns */
		if (col > df_max_bininfo_cols)
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			df_column_bininfo = GlobalMembersAlloc.gp_realloc(df_column_bininfo, col * sizeof(df_column_bininfo_struct), "datafile columns binary information");
			df_max_bininfo_cols = col;
		}
		df_column_bininfo[col - 1].column.read_type = type;
		df_column_bininfo[col - 1].column.read_size = df_binary_details[type.getValue()].type.read_size;
	}

	/* Get the column data type. */
	public static df_data_type df_get_read_type(int col)
	{
		assert col > 0;
		/* Check if we have room at least col columns */
		if (col < df_max_bininfo_cols)
			return (df_column_bininfo[col].column.read_type);
		else
			return -1;
	}

	/* Get the binary column data size. */
	public static int df_get_read_size(int col)
	{
		assert col > 0;
		/* Check if we have room at least col columns */
		if (col < df_max_bininfo_cols)
			return (df_column_bininfo[col].column.read_size);
		else
			return -1;
	}
	//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int df_get_num_matrix_cols();
	public static void df_set_plot_mode(int mode)
	{
		df_plot_mode = mode;
	}

	/*}}} */

	///#if 0 // not used
	//// /*{{{  static int get_time_cols(fmt) */
	//// /* count columns in timefmt */
	////static int
	////get_time_cols(char *fmt)
	////{
	////    int cnt, i;
	////    char *p;
	////
	////    p = fmt;
	////    cnt = 0;
	////    while (isspace((unsigned char) *p))
	////	p++;
	////    if (!strlen(p))
	////	int_error(NO_CARET, "Empty time-data format");
	////    cnt++;
	////    for (i = 0; i < strlen(p) - 1; i++) {
	////	if (isspace((unsigned char) p[i])
	////	    && !isspace((unsigned char) p[i + 1]))
	////	    cnt++;
	////    }
	////    return (cnt);
	////}
	//// /*}}} */
	////
	//// /*{{{  static void mod_def_usespec(specno,jump) */
	//// /* modify default use_spec, applies for no user spec and time datacolumns */
	////static void
	////mod_def_usespec(
	////    int specno,                 // which spec in ?:?:? 
	////    int jump)                   // no of columns in timefmt (time data) 
	////{
	////    int i;
	////
	////    for (i = specno + 1; i < MAXDATACOLS; ++i)
	////	use_spec[i].column += jump;     // add no of columns in time to the rest 
	////    df_no_use_specs = 0;
	////}
	////
	//// /*}}} */
	///#endif // not used 

	/*{{{  static int check_missing(s) */



	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#ifdef USE_MOUSE
	///#ifdef _MOUSE_C
	///#endif // _MOUSE_C 
	///#if 0
	///#endif
	///#if defined(_MOUSE_C)
	///#else
	///#endif
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef LINUXVGA
	///#endif // LINUXVGA 
	///#ifdef OS2
	///#endif
	///#if defined(HAVE_LIBREADLINE)
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#include <editline/readline.h>
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#endif
	///#if defined(READLINE) && !defined(HAVE_LIBREADLINE) && !defined(HAVE_LIBEDITLINE)
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif

	/* test to see if the end of an inline datafile is reached */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_EOF(c) ((c) == 'e' || (c) == 'E')

	/* is it a comment line? */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_comment(c) ((c) && (strchr(df_commentschars, (c)) != NULL))

	/*{{{  static fns */
	///#if 0 // not used
	////static int get_time_cols __PROTO((char *fmt));
	////static void mod_def_usespec __PROTO((int specno, int jump));
	///#endif
	public static int check_missing(String s)
	{
		if (!missing_val.equals(DefineConstants.NULL))
		{
			int len = missing_val.length();
			if (strncmp(s, missing_val, len) == 0 && (Character.isWhitespace((byte) s.charAt(len)) || !s.charAt(len)))
				return 1; // store undefined point in plot
		}
		return (0);
	}

	///#endif

	/*}}} */


	/*{{{  static char *df_gets() */

	public static String df_gets()
	{
		int len = 0;

		/* HBB 20000526: prompt user for inline data, if in interactive mode */
		/* EAM 08mar2008: we'd like to call readline(), but this only works
		 * if isatty(stdin). Do all platforms have an equivalent to isatty()?
		 */
		if (mixed_data_fp && GlobalMembersPlot.interactive)
			fputs("input data ('e' ends) > ", stderr);

		/* Special pseudofiles '+' and '++' return coords of sample */
		if (df_pseudodata != 0)
			return GlobalMembersDatafile.df_generate_pseudodata();

		if (!fgets(line, max_line_len, data_fp))
			return DefineConstants.NULL;

		if (mixed_data_fp)
			++GlobalMembersCommand.inline_num;

		for (;;)
		{
			len += String.valueOf(line + len).length();

			if (len > 0 && line.charAt(len - 1) == '\n')
			{
				/* we have read an entire text-file line.
				 * Strip the trailing linefeed and return
				 */
				line = line.substring(0, len - 1);
				return line;
			}
			/* buffer we provided may not be full - dont grab extra
			 * memory un-necessarily. This may trap a problem with last
			 * line in file not being properly terminated - each time
			 * through a replot loop, it was doubling buffer size
			 */

			if ((max_line_len - len) < 32)
				line = GlobalMembersAlloc.gp_realloc(line, max_line_len *= 2, "datafile line buffer");

			if (!fgets(line + len, max_line_len - len, data_fp))
				return line; // unexpected end of file, but we have something to do
		}

		/* NOTREACHED */
		return DefineConstants.NULL;
	}

	/*}}} */

	/*{{{  static int df_tokenise(s) */
	public static int df_tokenise(String s)
	{
		/* implement our own sscanf that takes 'missing' into account,
		 * and can understand fortran quad format
		 */
		boolean in_string;
		int i;

		for (i = 0; i < DefineConstants.MAXDATACOLS; i++)
			df_tokens[i] = DefineConstants.NULL;

		///#if (0) // Mar 2009
		// /* This code was broken by moving the check for 'title columnheader' elsewhere.*/
		// /* Auto-titling of histograms is a bit tricky because the x coord did not come */
		// /* from an explicit input column. This means our previous guess of what column */
		// /* to take the title from was probably wrong.                                  */
		//    if (key_title_auto_col && df_current_plot
		//    &&  (df_current_plot->plot_style == HISTOGRAMS))
		//	column_for_key_title = use_spec[0].column;
		///#endif

		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define NOTSEP (*s != df_separator)

		df_no_cols = 0;

		while (s != null)
		{
			/* check store - double max cols or add 20, whichever is greater */
			if (df_max_cols <= df_no_cols)
			{
				int new_max = df_max_cols + (df_max_cols < 20 ? 20 : df_max_cols);
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				df_column = GlobalMembersAlloc.gp_realloc(df_column, new_max * sizeof(df_column_struct), "datafile column");
				while (df_max_cols < new_max)
					df_column[df_max_cols++].datum = 0;
			}

			/* have always skipped spaces at this point */
			df_column[df_no_cols].position = s;
			in_string = false;

			/* Keep pointer to start of this token if user wanted it for
			 * anything, particularly if it is a string */
			for (i = 0; i < DefineConstants.MAXDATACOLS; i++)
			{
				if (df_no_cols == use_spec[i].column - 1)
				{
					df_tokens[i] = s;
					if (use_spec[i].expected_type == COLUMN_TYPE.CT_STRING.getValue())
						df_column[df_no_cols].good = DF_GOOD;
				}
			}
			/* Particularly if it is supposed to be a key title */
			if (df_no_cols == column_for_key_title-1)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(df_key_title);
				df_key_title = GlobalMembersUtil.gp_strdup(s);
			}

			/* CSV files must accept numbers inside quotes also,
			 * so we step past the quote */
			if (s.equals('"') && df_separator != '\0')
			{
				in_string = true;
				df_column[df_no_cols].position = ++s;
			}

			if (s.equals('"'))
			{
				/* treat contents of a quoted string as single column */
				in_string = !in_string;
				df_column[df_no_cols].good = DefineConstants.DF_MISSING;
				/* Allow timedata input to be contained in quotes */
				if (GlobalMembersAxis.axis_array[df_axis[df_no_cols].getValue()].timefmt != null)
					df_column[df_no_cols].good = DefineConstants.DF_STRINGDATA;
			}
			else if (GlobalMembersDatafile.check_missing(s) != 0)
			{
				df_column[df_no_cols].good = DefineConstants.DF_MISSING;
				df_column[df_no_cols].datum = GlobalMembersStdfn.not_a_number();
			}
			else
			{
				int used;
				int count;
				int dfncp1 = df_no_cols + 1;

				/* optimizations by Corey Satten, corey@cac.washington.edu */
				if ((fast_columns == 0) || (df_no_use_specs == 0) || ((df_no_use_specs > 0) && (use_spec[0].column == dfncp1 || (df_no_use_specs > 1 && (use_spec[1].column == dfncp1 || (df_no_use_specs > 2 && (use_spec[2].column == dfncp1 || (df_no_use_specs > 3 && (use_spec[3].column == dfncp1 || (df_no_use_specs > 4 && (use_spec[4].column == dfncp1 || df_no_use_specs > 5)))))))))))
				{


					/* This was the [slow] code used through version 4.0
					 *   count = sscanf(s, "%lf%n", &df_column[df_no_cols].datum, &used);
					 */

					/* Use strtod() because
					 *  - it is faster than sscanf()
					 *  - sscanf(... %n ...) may not be portable
					 *  - it allows error checking
					 *  - atof() does not return a count or new position
					 */
					String next;
					tangible.RefObject<String[]> tempRef_next = new tangible.RefObject<String[]>(next);
					df_column[df_no_cols].datum = GlobalMembersStdfn.gp_strtod(s, tempRef_next);
					next = tempRef_next.argvalue;
					used = next - s;
					count = (used) ? 1 : 0;

				}
				else
				{
					/* skip any space at start of column */
					/* HBB tells me that the cast must be to
					 * unsigned char instead of int. */
					while (Character.isWhitespace((byte) s) && !s.equals(df_separator))
						++s;
					count = (s != null && !s.equals(df_separator)) ? 1 : 0;
					/* skip chars to end of column */
					used = 0;
					if (df_separator != '\0' && in_string)
					{
						do
							++s;
						while (s != null && !s.equals('"'));
						in_string = false;
					}
					while (!Character.isWhitespace((byte) s) && (!s.equals(DefineConstants.NUL)) && !s.equals(df_separator))
						++s;
				}

				/* it might be a fortran double or quad precision.
				 * 'used' is only safe if count is 1
				 */
				if (df_fortran_constants && count == 1 && (s.charAt(used) == 'd' || s.charAt(used) == 'D' || s.charAt(used) == 'q' || s.charAt(used) == 'Q'))
				{
					/* HBB 20001221: avoid breaking parsing of time/date
					 * strings like 01Dec2000 that would be caused by
					 * overwriting the 'D' with an 'e'... */
					String endptr;
					byte save_char = s.charAt(used);

					/* might be fortran double */
					s = tangible.StringFunctions.changeCharacter(s, used, 'e');
					/* and try again */
					tangible.RefObject<String[]> tempRef_endptr = new tangible.RefObject<String[]>(endptr);
					df_column[df_no_cols].datum = GlobalMembersStdfn.gp_strtod(s, tempRef_endptr);
					endptr = tempRef_endptr.argvalue;
					count = (s.equals(endptr)) ? 0 : 1;
					s = tangible.StringFunctions.changeCharacter(s, used, save_char);
				}

				df_column[df_no_cols].good = count == 1 ? DF_GOOD : DF_BAD;
				///#ifdef HAVE_ISNAN
				if (isnan(df_column[df_no_cols].datum))
					df_column[df_no_cols].good = DF_BAD;
				///#endif
			}

			++df_no_cols;

			/* EAM - 19 Aug 2002 If we are in a quoted string, skip to end
			 * of quote */
			if (in_string)
			{
				do
					s++;
				while (s != null && (byte)!s.equals('"'));
			}

			/* skip to 1st character past next separator */
			if (df_separator != '\0')
			{
				while (s != null && !s.equals(df_separator))
					++s;
				if (s.equals(df_separator))
					/* skip leading whitespace in next field */
					do
						++s;
					while (s != null && Character.isWhitespace((byte) s) && !s.equals(df_separator));
			}
			else
			{
				/* skip chars to end of column */
				while ((!Character.isWhitespace((byte) s)) && (!s.equals('\0')))
					++s;
				/* skip spaces to start of next column */
				while (Character.isWhitespace((byte) s))
					++s;
			}
		}

		return df_no_cols;
		//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
		///#undef NOTSEP
	}

	/*}}} */

	/*{{{  static float *df_read_matrix() */
	/* Reads a matrix from a text file and stores it as floats in allocated
	 * memory.
	 *
	 * IMPORTANT NOTE:  The routine returns the memory pointer for that matrix,
	 * but does not retain the pointer.  Maintenance of the memory is left to
	 * the calling code.
	 */
	//C++ TO JAVA CONVERTER WARNING: Java has no equivalent to methods returning pointers to value types:
	//ORIGINAL LINE: static float * df_read_matrix(int *rows, int *cols)
	public static float[] df_read_matrix(int rows, int cols)
	{
		int max_rows = 0;
		int c;
		float[] linearized_matrix = DefineConstants.NULL;
		int bad_data = 0;
		//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * s;
		int index = 0;

		rows = 0;
		cols = 0;

		for (;;)
		{
			if (!(s = GlobalMembersDatafile.df_gets()))
			{
				df_eof = 1;
				/* NULL if we have not read anything yet */
				return linearized_matrix;
			}

			while (Character.isWhitespace((byte) * s))
				++s;

			if (!*s || ((*s) && (tangible.StringFunctions.strChr(df_commentschars, (*s)) != DefineConstants.NULL)))
			{
				if (linearized_matrix)
					return linearized_matrix;
				else
					continue;
			}
			if (mixed_data_fp && ((*s) == 'e' || (*s) == 'E'))
			{
				df_eof = 1;
				return linearized_matrix;
			}
			c = GlobalMembersDatafile.df_tokenise(s);

			if (c == 0)
				return linearized_matrix;

			if (cols != 0 && c != cols)
			{
				/* its not regular */
				if (linearized_matrix)
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(linearized_matrix);
				GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Matrix does not represent a grid");
			}
			cols = c;

			++rows;
			if (rows > max_rows)
			{
				max_rows = ((2 * max_rows) > (1) ? (2 * max_rows) : (1));
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				linearized_matrix = GlobalMembersAlloc.gp_realloc(linearized_matrix, cols * max_rows * sizeof(float), "df_matrix");
			}

			/* store data */
			{
				int i;

				for (i = 0; i < c; ++i)
				{
					if (i < firstpoint && df_column[i].good != DF_GOOD)
					{
						/* It's going to be skipped anyhow, so... */
						linearized_matrix[index++] = 0F;
					}
					else
						linearized_matrix[index++] = (float) df_column[i].datum;

					if (df_column[i].good != DF_GOOD)
					{
						if (bad_data++== 0)
							GlobalMembersUtil.int_warn(DefineConstants.NO_CARET,"matrix contains missing or undefined values");
					}
				}
			}
		}
	}

	/*}}} */



	public static void plot_option_every()
	{
		fast_columns = 0; // corey@cac
		/* allow empty fields - every a:b:c::e we have already established
		 * the defaults */

		if (GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ":") == 0)
		{
			everypoint = GlobalMembersParse.int_expression();
			if (everypoint < 1)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected positive integer");
		}
		/* if it fails on first test, no more tests will succeed. If it
		 * fails on second test, next test will succeed with correct
		 * c_token */
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0 && GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ":") == 0)
		{
			everyline = GlobalMembersParse.int_expression();
			if (everyline < 1)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected positive integer");
		}
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0 && GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ":") == 0)
		{
			firstpoint = GlobalMembersParse.int_expression();
			if (firstpoint < 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected non-negative integer");
		}
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0 && GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ":") == 0)
		{
			firstline = GlobalMembersParse.int_expression();
			if (firstline < 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected non-negative integer");
		}
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0 && GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ":") == 0)
		{
			lastpoint = GlobalMembersParse.int_expression();
			if (lastpoint < firstpoint)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Last point must not be before first point");
		}
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0)
		{
			++GlobalMembersCommand.c_token;
			lastline = GlobalMembersParse.int_expression();
			if (lastline < firstline)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Last line must not be before first line");
		}
	}
	public static void plot_option_index()
	{
		if (df_binary_file && df_matrix_file)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Binary matrix file format does not allow more than one surface per file");

		++GlobalMembersCommand.c_token;
		/* Check for named index */
		if ((indexname = GlobalMembersUtil.try_to_get_string()))
		{
			index_found = false;
			return;
		}

		/* Numerical index list */
		df_lower_index = GlobalMembersParse.int_expression();
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0)
		{
			++GlobalMembersCommand.c_token;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0)
			{
				df_upper_index = (~0) >> 1; // If end index not specified
			}
			else
			{
				df_upper_index = GlobalMembersParse.int_expression();
				if (df_upper_index < df_lower_index)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Upper index should be bigger than lower index");
			}
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0)
			{
				++GlobalMembersCommand.c_token;
				df_index_step = Math.abs(GlobalMembersParse.int_expression());
				if (df_index_step < 1)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Index step must be positive");
			}
		}
		else
			df_upper_index = df_lower_index;
	}
	public static void plot_option_thru()
	{
		GlobalMembersCommand.c_token++;
		GlobalMembersParse.c_dummy_var[0] = GlobalMembersParse.set_dummy_var[0];
		/* allow y also as a dummy variable.
		 * during plot, c_dummy_var[0] and [1] are 'sacred'
		 * ie may be set by  splot [u=1:2] [v=1:2], and these
		 * names are stored only in c_dummy_var[]
		 * so choose dummy var 2 - can anything vital be here ?
		 */
		GlobalMembersCommand.dummy_func = ydata_func;
		GlobalMembersParse.c_dummy_var[2] = "y";
		ydata_func.at = GlobalMembersParse.perm_at();
		GlobalMembersCommand.dummy_func = DefineConstants.NULL;
	}
	public static void plot_option_using(int max_using)
	{
		int no_cols = 0; // For general binary only.

		/* The filetype function may have set the using specs, so reset
		 * them before processing tokens. */
		if (df_binary_file)
			GlobalMembersDatafile.initialize_use_spec();

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.isstring(++GlobalMembersCommand.c_token) == 0)
		{
			do // must be at least one
			{
				if (df_no_use_specs >= max_using)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Too many columns in using specification");

				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0)
				{
					/* empty specification - use default */
					use_spec[df_no_use_specs].column = df_no_use_specs;
					if (df_no_use_specs > no_cols)
						no_cols = df_no_use_specs;
					++df_no_use_specs;
					/* do not increment c+token ; let while() find the : */

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "(") != 0)
				{
					fast_columns = 0; // corey@cac
					GlobalMembersCommand.dummy_func = DefineConstants.NULL; // no dummy variables active
					/* this will match ()'s: */
					GlobalMembersParse.at_highest_column_used = DefineConstants.NO_COLUMN_HEADER;
					use_spec[df_no_use_specs].at = GlobalMembersParse.perm_at();
					if (no_cols < GlobalMembersParse.at_highest_column_used)
						no_cols = GlobalMembersParse.at_highest_column_used;
					/* Catch at least the simplest case of 'autotitle columnhead' using an expression */
					use_spec[df_no_use_specs++].column = GlobalMembersParse.at_highest_column_used;

					/* FIXME EAM - It would be nice to handle these like any other */
					/* internal function via perm_at() but there are problems.     */
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "xtic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_XTICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "x2tic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_X2TICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ytic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_YTICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "y2tic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_Y2TICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ztic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_ZTICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cbtic$labels") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_CBTICLABEL);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "key") != 0)
				{
					GlobalMembersDatafile.plot_ticlabel_using(COLUMN_TYPE.CT_KEYLABEL);
				}
				else
				{
					int col = GlobalMembersParse.int_expression();

					if (col < -2)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Column must be >= -2");
					use_spec[df_no_use_specs++].column = col;

					/* Supposed only happens for binary files, but don't bet on it */
					if (col > no_cols)
						no_cols = col;
				}
			} while (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") != 0 && ++GlobalMembersCommand.c_token);
		}

		if (df_binary_file)
		{
			/* If the highest user column number is greater than number of binary
			 * columns, set the unitialized columns binary info to that of the last
			 * specified column or the default.
			 */
			GlobalMembersDatafile.df_extend_binary_columns(no_cols);
		}

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
		{

			if (df_binary_file)
				GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Expecting \"binary format='...'\" or \"binary filetype=...\"");

			df_format = GlobalMembersUtil.try_to_get_string();
			if (!GlobalMembersDatafile.valid_format(df_format))
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Please use between 1 and 7 conversions, of type double (%%lf)");

		} // if (!EOC)
	}

	/*}}} */


	/* formerly in misc.c, but only used here */
	/* check user defined format strings for valid double conversions */
	/* HBB 20040601: Added check that the number of format specifiers is
	 * workable (between 0 and 7) */
	public static boolean valid_format(String format)
	{
		int formats_found = 0;

		for (;;)
		{
			if (!(format = tangible.StringFunctions.strChr(format, '%'))) // look for format spec
				return (formats_found > 0 && formats_found <= 7);

			/* Found a % to check --- scan past option specifiers: */
			do
			{
				format++;
			} while (tangible.StringFunctions.strChr("+-#0123456789.", format));

			/* Now at format modifier */
			switch (format)
			{
			case '*': // Ignore '*' statements
			case '%': // Char   '%' itself
				format++;
				continue;
			case 'l': // Now we found it !!!
				if (!tangible.StringFunctions.strChr("fFeEgG", format.charAt(1))) // looking for a valid format
					return false;
				formats_found++;
				format++;
				break;
			default:
				return false;
			}
		}
	}
	public static void plot_ticlabel_using(int axis)
	{
		int col = 0;

		GlobalMembersCommand.c_token += 2;

		/* FIXME: What we really want is a test for a constant expression as  */
		/* opposed to a dummy expression. This is similar to the problem with */
		/* with parsing the first argument of the plot command itself.        */
		if (GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.INTGR)
		{
			col = GlobalMembersParse.int_expression();
			use_spec[df_no_use_specs + df_no_tic_specs].at = DefineConstants.NULL;
		}
		else
		{
			use_spec[df_no_use_specs + df_no_tic_specs].at = GlobalMembersParse.perm_at();
			fast_columns = 0; // Force all columns to be evaluated
			col = 1; // Redundant because of the above
		}

		if (col < 1)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "ticlabels must come from a real column");
		GlobalMembersCommand.c_token++;
		use_spec[df_no_use_specs + df_no_tic_specs].expected_type = axis;
		use_spec[df_no_use_specs + df_no_tic_specs].column = col;
		df_no_tic_specs++;
	}
	public static String df_parse_string_field(String field)
	{
		String temp_string;

		if (field == null)
		{
			return DefineConstants.NULL;
		}
		else if (field.equals('"'))
		{
			temp_string = GlobalMembersUtil.gp_strdup(field.charAt(1));
			temp_string = tangible.StringFunctions.changeCharacter(temp_string, strcspn(temp_string,"\""), '\0');
		}
		else if (df_separator != '\0')
		{
			String eor = new String(new char[3]);
			eor = tangible.StringFunctions.changeCharacter(eor, 0, df_separator);
			eor = tangible.StringFunctions.changeCharacter(eor, 1, '"');
			eor = tangible.StringFunctions.changeCharacter(eor, 2, '\0');
			temp_string = GlobalMembersUtil.gp_strdup(field);
			temp_string = tangible.StringFunctions.changeCharacter(temp_string, strcspn(temp_string,eor), '\0');
		}
		else
		{
			temp_string = GlobalMembersUtil.gp_strdup(field);
			temp_string = tangible.StringFunctions.changeCharacter(temp_string, strcspn(temp_string,"\t "), '\0');
		}
		GlobalMembersUtil.parse_esc(temp_string);

		return temp_string;
	}
	public static void add_key_entry(String temp_string, int df_datum)
	{
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		text_label new_entry = GlobalMembersAlloc.gp_alloc(sizeof(text_label), "key entry");

		/* Associate this key list with the histogram it belongs to. */
		if (df_current_plot.labels == null)
		{
			/* The first text_label structure in the list is a place-holder */
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			df_current_plot.labels = GlobalMembersAlloc.gp_alloc(sizeof(text_label), "key entry");
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memset(df_current_plot.labels, 0, sizeof(text_label));
			df_current_plot.labels.tag = -1;
		}

		new_entry.text = GlobalMembersUtil.gp_strdup(temp_string);
		new_entry.tag = df_datum;
		new_entry.font = DefineConstants.NULL;
		new_entry.next = df_current_plot.labels.next;
		df_current_plot.labels.next = new_entry;
	}

	/* Special pseudofile '+' returns x coord of sample for 2D plots,
	 * Special pseudofile '++' returns x and y coordinates of grid for 3D plots.
	 */
	//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
	private static double df_generate_pseudodata_t;
	double t_min;
	double t_max;
	double t_step;
	//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
	private static double df_generate_pseudodata_u_min;
	double u_max;
	double u_step;
	double v_min;
	double v_max;
	double v_step;
	//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
	private static double df_generate_pseudodata_u_isostep;
	double v_isostep;
	//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
	private static int df_generate_pseudodata_nusteps;
	int nvsteps;
	public static String df_generate_pseudodata()
	{
		/* Pseudofile '+' returns a set of (samples) x coordinates */
		/* This code copied from that in second pass through eval_plots() */
		if (df_pseudodata == 1)
		{
			//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
			//	static double t, t_min, t_max, t_step;
			if (df_pseudorecord >= GlobalMembersGadgets.samples_1)
				return DefineConstants.NULL;
			if (df_pseudorecord == 0)
			{
				if (GlobalMembersGadgets.parametric || GlobalMembersGadgets.polar)
					GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Pseudodata not yet implemented for polar or parametric graphs");
				if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max == -DefineConstants.VERYLARGE)
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].max = 10;
				if (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min == DefineConstants.VERYLARGE)
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].min = -10;
				t_min = GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].min;
				t_max = GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].max;
				GlobalMembersAxis.axis_unlog_interval(GlobalMembersAxis.x_axis, t_min, t_max, 1);
				t_step = (t_max - t_min) / (GlobalMembersGadgets.samples_1 - 1);
			}
			df_generate_pseudodata_t = t_min + df_pseudorecord * t_step;
			df_generate_pseudodata_t = (GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].log ? Math.exp((df_generate_pseudodata_t) * GlobalMembersAxis.axis_array[GlobalMembersAxis.x_axis.getValue()].log_base): (df_generate_pseudodata_t));
			String.format(line,"%g",df_generate_pseudodata_t);
			++df_pseudorecord;
		}

		/* Pseudofile '++' returns a (samples X isosamples) grid of x,y coordinates */
		/* This code copied from that in second pass through eval_3dplots */
		if (df_pseudodata == 2)
		{
			//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
			//	static double u_min, u_max, u_step, v_min, v_max, v_step;
			//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
			//	static double u_isostep, v_isostep;
			//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
			//	static int nusteps, nvsteps;
			double u;
			double v;
			AXIS_INDEX u_axis = AXIS_INDEX.FIRST_X_AXIS;
			AXIS_INDEX v_axis = AXIS_INDEX.FIRST_Y_AXIS;

			if ((df_pseudorecord >= df_generate_pseudodata_nusteps) && (df_pseudorecord > 0))
			{
				df_pseudorecord = 0;
				if (++df_pseudospan >= nvsteps)
					return DefineConstants.NULL;
				else
					return ""; // blank record for end of scan line
			}

			if (df_pseudospan == 0)
			{
				if (GlobalMembersGadgets.samples_1 < 2 || GlobalMembersGadgets.samples_2 < 2 || GlobalMembersGraph3d.iso_samples_1 < 2 || GlobalMembersGraph3d.iso_samples_2 < 2)
					GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "samples or iso_samples < 2. Must be at least 2.");
				GlobalMembersAxis.axis_checked_extend_empty_range(AXIS_INDEX.FIRST_X_AXIS, "x range is invalid");
				GlobalMembersAxis.axis_checked_extend_empty_range(AXIS_INDEX.FIRST_Y_AXIS, "y range is invalid");
				df_generate_pseudodata_u_min = GlobalMembersAxis.axis_log_value_checked(u_axis, GlobalMembersAxis.axis_array[u_axis.getValue()].min, "x range");
				u_max = GlobalMembersAxis.axis_log_value_checked(u_axis, GlobalMembersAxis.axis_array[u_axis.getValue()].max, "x range");
				v_min = GlobalMembersAxis.axis_log_value_checked(v_axis, GlobalMembersAxis.axis_array[v_axis.getValue()].min, "y range");
				v_max = GlobalMembersAxis.axis_log_value_checked(v_axis, GlobalMembersAxis.axis_array[v_axis.getValue()].max, "y range");

				if (GlobalMembersGraph3d.hidden3d)
				{
					u_step = (u_max - df_generate_pseudodata_u_min) / (GlobalMembersGraph3d.iso_samples_1 - 1);
					v_step = (v_max - v_min) / (GlobalMembersGraph3d.iso_samples_2 - 1);
					df_generate_pseudodata_nusteps = GlobalMembersGraph3d.iso_samples_1;
				}
				else
				{
					u_step = (u_max - df_generate_pseudodata_u_min) / (GlobalMembersGadgets.samples_1 - 1);
					v_step = (v_max - v_min) / (GlobalMembersGadgets.samples_2 - 1);
					df_generate_pseudodata_nusteps = GlobalMembersGadgets.samples_1;
				}
				df_generate_pseudodata_u_isostep = (u_max - df_generate_pseudodata_u_min) / (GlobalMembersGraph3d.iso_samples_1 - 1);
				v_isostep = (v_max - v_min) / (GlobalMembersGraph3d.iso_samples_2 - 1);
				nvsteps = GlobalMembersGraph3d.iso_samples_2;
			}

			/* Duplicate algorithm from calculate_set_of_isolines() */
			u = df_generate_pseudodata_u_min + df_pseudorecord * u_step;
			v = v_max - df_pseudospan * v_isostep;
			String.format(line,"%g %g", (GlobalMembersAxis.axis_array[u_axis.getValue()].log ? Math.exp((u) * GlobalMembersAxis.axis_array[u_axis.getValue()].log_base): (u)), (GlobalMembersAxis.axis_array[v_axis.getValue()].log ? Math.exp((v) * GlobalMembersAxis.axis_array[v_axis.getValue()].log_base): (v)));
			++df_pseudorecord;
		}

		return line;
	}
	public static int df_skip_bytes(int nbytes)
	{
		byte cval;

		///#if defined(PIPES)
		if (df_pipe_open || plotted_data_from_stdin)
		{
			while (nbytes--)
			{
				if (1 == fread(cval, 1, 1, data_fp))
					continue;
				if (feof(data_fp))
				{
					df_eof = 1;
					return DefineConstants.DF_EOF;
				}
				GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, read_error_msg);
			}
		}
		else
			///#endif
			if (fseek(data_fp, nbytes, SEEK_CUR))
			{
				if (feof(data_fp))
				{
					df_eof = 1;
					return DefineConstants.DF_EOF;
				}
				GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, read_error_msg);
			}

		return 0;
	}

	/* public variables client might access */

	public static int df_no_use_specs; // how many using columns were specified
	public static int df_line_number;
	public static int df_datum; // suggested x value if none given
	public static AXIS_INDEX[] df_axis = new AXIS_INDEX[DefineConstants.MAXDATACOLS];
	public static boolean df_matrix = false; // indicates if data originated from a 2D or 3D format
	public static boolean df_binary = false; // this is a binary file

	public static Object df_datablock; // pixel data from an external library (e.g. libgd)

	/* jev -- the 'thru' function --- NULL means no dummy vars active */
	/* HBB 990829: moved this here, from command.c */
	public static udft_entry ydata_func = new udft_entry();

	/* string representing missing values in ascii datafiles */
	public static String missing_val = null;

	/* input field separator, NUL if whitespace is the separator */
	public static byte df_separator = (byte)'\0';

	/* comments chars */
	public static String df_commentschars = null;

	/* If any 'inline data' are in use for the current plot, flag this */
	public static boolean plotted_data_from_stdin = false;

	/* Setting this allows the parser to recognize Fortran D or Q   */
	/* format constants in the input file. But it slows things down */
	public static boolean df_fortran_constants = false;

	/* Setting this disables re-initialization of the floating point exception */
	/* handler before every expression evaluation in a using spec.             */
	public static boolean df_nofpe_trap = false;

	/* private variables */

	/* in order to allow arbitrary data line length, we need to use the heap
	 * might consider free-ing it in df_close, especially for small systems
	 */
	public static String line = null;
	public static int max_line_len = 0;
	///#define DATA_LINE_BUFSIZ 160

	public static File data_fp = null;
	///#if defined(PIPES)
	public static boolean df_pipe_open = false;
	///#endif
	public static boolean mixed_data_fp = false; // inline data
	public static String df_filename; // name of data file
	public static int df_eof = 0;

	public static int df_no_tic_specs; // ticlabel columns not counted in df_no_use_specs

	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX                 // in limits.h ? 
	///#define MAXINT INT_MAX
	///#else
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif

	/* stuff for implementing index */
	public static int blank_count = 0; // how many blank lines recently
	public static int df_lower_index = 0; // first mesh required
	public static int df_upper_index = (~0) >> 1;
				public static int df_index_step = 1; // 'every' for indices
				public static int df_current_index; // current mesh

				/* stuff for named index support */
				public static String indexname = null;
				public static boolean index_found = false;

				/* stuff for every point:line */
				public static int everypoint = 1;
				public static int firstpoint = 0;
				public static int lastpoint = (~0) >> 1;
				public static int everyline = 1;
				public static int firstline = 0;
				public static int lastline = (~0) >> 1;
					public static int point_count = -1; // point counter - preincrement and test 0
					public static int line_count = 0; // line counter

					/* for pseudo-data (1 if filename = '+'; 2 if filename = '++') */
					public static int df_pseudodata = 0;
					public static int df_pseudorecord = 0;
					public static int df_pseudospan = 0;

					/* parsing stuff */
					public static use_spec_s[] use_spec = new use_spec_s[DefineConstants.MAXDATACOLS];
					public static String df_format = null;
					public static String df_binary_format = null;
					public static boolean evaluate_inside_using = false;

					public static df_column_struct df_column = null; // we'll allocate space as needed
					public static int df_max_cols = 0; // space allocated
					public static int df_no_cols; // cols read
					public static int fast_columns; // corey@cac optimization

					public static String[] df_tokens = new String[DefineConstants.MAXDATACOLS]; // filled in by df_tokenise
					public static String[] df_stringexpression = {null,null,null,null,null,null,null};
					///#define NO_COLUMN_HEADER (-99)
					public static int column_for_key_title = DefineConstants.NO_COLUMN_HEADER;
					public static String df_key_title = null; // filled in from <col> in 1st row by df_tokenise
					public static curve_points df_current_plot; // used to process histogram labels + key entries


					/* Binary *read* variables used by df_readbinary().  The difference between matrix
					 * binary and general binary is that matrix binary requires an extra first column
					 * and extra first row giving the sample coordinates.  Furthermore, note that if
					 * ASCII matrix data is converted to floats (i.e., binary) then it really falls in
					 * the general binary class, not the matrix binary class.
					 */
					public static boolean df_read_binary;
					public static boolean df_matrix_binary;
					public static int df_plot_mode;
					/*}}} */


					/* do the hard work... read lines from file,
					 * - use blanks to get index number
					 * - ignore lines outside range of indices required
					 * - fill v[] based on using spec if given
					 */


					public static int df_readascii(double[] v, int max)
					{
						//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
						byte * s;

						assert data_fp != DefineConstants.NULL || df_pseudodata != 0;
						assert max_line_len; // alloc-ed in df_open()
						assert max <= DefineConstants.MAXDATACOLS;

						/* catch attempt to read past EOF on mixed-input */
						if (df_eof != 0)
							return DefineConstants.DF_EOF;

						/*{{{  process line */
						while ((s = GlobalMembersDatafile.df_gets()) != DefineConstants.NULL)
						{
							int line_okay = 1;
							int output = 0; // how many numbers written to v[]

							++df_line_number;
							df_no_cols = 0;

							/*{{{  check for blank lines, and reject by index/every */
							/*{{{  skip leading spaces */
							while (Character.isWhitespace((byte) * s))
								++s; // will skip the \n too, to point at \0
							/*}}} */

							/*{{{  skip comments */
							if (((*s) && (tangible.StringFunctions.strChr(df_commentschars, (*s)) != DefineConstants.NULL)))
							{
								if (indexname != null) // Look for index name in comment
								{
									while (((*s) && (tangible.StringFunctions.strChr(df_commentschars, (*s)) != DefineConstants.NULL)) || Character.isWhitespace((int) * s))
										++s;
									if (*s && !strncmp(s, indexname, indexname.length()))
										index_found = true;
								}
								continue; // ignore comments
							}
							/*}}} */

							/*{{{  check EOF on mixed data */
							if (mixed_data_fp && ((*s) == 'e' || (*s) == 'E'))
							{
								df_eof = 1; // trap attempts to read past EOF
								return DefineConstants.DF_EOF;
							}
							/*}}} */

							/*{{{  its a blank line - update counters and continue or return */
							if (*s == 0)
							{
								/* argh - this is complicated !  we need to
								 *   ignore it if we haven't reached first index
								 *   report EOF if passed last index
								 *   report blank line unless we've already done 2 blank lines
								 *
								 * - I have probably missed some obvious way of doing all this,
								 * but its getting late
								 */

								point_count = -1; // restart counter within line

								if (++blank_count == 1)
								{
									/* first blank line */
									++line_count;
								}
								/* just reached end of a group/surface */
								if (blank_count == 2)
								{
									++df_current_index;
									line_count = 0;
									df_datum = -1;

									/* Found two blank lines after a block of data with a named index */
									if (indexname != null && index_found)
									{
										df_eof = 1;
										return DefineConstants.DF_EOF;
									}

									/* ignore line if current_index has just become
									 * first required one - client doesn't want this
									 * blank line. While we're here, check for <=
									 * - we need to do it outside this conditional, but
									 * probably no extra cost at assembler level
									 */
									if (df_current_index <= df_lower_index)
										continue; // dont tell client

									/* df_upper_index is MAXINT-1 if we are not doing index */
									if (df_current_index > df_upper_index)
									{
										/* oops - need to gobble rest of input if mixed */
										if (mixed_data_fp)
											continue;
										else
										{
											df_eof = 1;
											return DefineConstants.DF_EOF; // no point continuing
										}
									}
								}
								/* dont tell client if we haven't reached first index */
								if (indexname != null && !index_found)
									continue;
								if (df_current_index < df_lower_index)
									continue;

								/* ignore blank lines after blank_index */
								if (blank_count > 2)
									continue;

								return DefineConstants.DF_FIRST_BLANK - (blank_count - 1);
							}
							/*}}} */

							/* get here => was not blank */

							blank_count = 0;

							/*{{{  ignore points outside range of index */
							/* we try to return end-of-file as soon as we pass upper index,
							 * but for mixed input stream, we must skip garbage
							 */

							if (indexname != null && !index_found)
								continue;
							if (df_current_index < df_lower_index || df_current_index > df_upper_index || ((df_current_index - df_lower_index) % df_index_step) != 0)
								continue;
							/*}}} */

							/*{{{  reject points by every */
							/* accept only lines with (line_count%everyline) == 0 */

							if (line_count < firstline || line_count > lastline || (line_count - firstline) % everyline != 0)
								continue;

							/* update point_count. ignore point if point_count%everypoint != 0 */

							if (++point_count < firstpoint || point_count > lastpoint || (point_count - firstpoint) % everypoint != 0)
								continue;
							/*}}} */
							/*}}} */

							++df_datum;

							if (df_format != null)
							{
								/*{{{  do a sscanf */
								int i;

								assert DefineConstants.MAXDATACOLS == 7;

								/* check we have room for at least 7 columns */
								if (df_max_cols < 7)
								{
									df_max_cols = 7;
									//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
									df_column = GlobalMembersAlloc.gp_realloc(df_column, df_max_cols * sizeof(df_column_struct), "datafile columns");
								}

								df_no_cols = sscanf(line, df_format, df_column[0].datum, df_column[1].datum, df_column[2].datum, df_column[3].datum, df_column[4].datum, df_column[5].datum, df_column[6].datum);

								if (df_no_cols == EOF)
								{
									df_eof = 1;
									return DefineConstants.DF_EOF; // tell client
								}
								for (i = 0; i < df_no_cols; ++i) // may be zero
								{
									df_column[i].good = DF_GOOD;
									df_column[i].position = DefineConstants.NULL; // cant get a time
								}
								/*}}} */
							}
							else
								GlobalMembersDatafile.df_tokenise(s);

							/* If we are supposed to read plot or key titles from the
							 * first line of the data then do that and nothing else.  */
							if (column_for_key_title != DefineConstants.NO_COLUMN_HEADER)
							{
								String temp_string = df_key_title;
								df_datum--;
								if (df_key_title == null)
								{
									GlobalMembersFit.a((stderr, "df_readline: missing column head for key title\n"));
									return (DefineConstants.DF_KEY_TITLE_MISSING);
								}
								df_key_title = GlobalMembersDatafile.df_parse_string_field(df_key_title);
								//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
								free(temp_string);
								GlobalMembersFit.a((stderr, "df_readline: Found key title in col %d %s\n", column_for_key_title, df_key_title));
								column_for_key_title = DefineConstants.NO_COLUMN_HEADER;
								return (DefineConstants.DF_FOUND_KEY_TITLE);
							}

							/*{{{  copy column[] to v[] via use[] */
							{
								int limit = (df_no_use_specs != 0 ? df_no_use_specs + df_no_tic_specs : DefineConstants.MAXDATACOLS);

								if (limit > max + df_no_tic_specs)
									limit = max + df_no_tic_specs;

								for (output = 0; output < limit; ++output)
								{
									/* if there was no using spec, column is output+1 and
									 * at=NULL */
									int column = use_spec[output].column;

									/* Handle cases where column holds a meta-data string */
									/* Axis labels, plot titles, etc.                     */
									if (use_spec[output].expected_type >= COLUMN_TYPE.CT_XTICLABEL)
									{
										int axis;
										int axcol;
										float xpos;

										switch (use_spec[output].expected_type)
										{
										default:
										case CT_XTICLABEL:
											axis = AXIS_INDEX.FIRST_X_AXIS.getValue();
											axcol = 0;
											break;
										case CT_X2TICLABEL:
											axis = AXIS_INDEX.SECOND_X_AXIS.getValue();
											axcol = 0;
											break;
										case CT_YTICLABEL:
											axis = AXIS_INDEX.FIRST_Y_AXIS.getValue();
											axcol = 1;
											break;
										case CT_Y2TICLABEL:
											axis = AXIS_INDEX.SECOND_Y_AXIS.getValue();
											axcol = 1;
											break;
										case CT_ZTICLABEL:
											axis = AXIS_INDEX.FIRST_Z_AXIS.getValue();
											axcol = 2;
											break;
										case CT_CBTICLABEL:
											/* EAM FIXME - Which column to set for cbtic? */
											axis = AXIS_INDEX.COLOR_AXIS.getValue();
											axcol = 3;
											break;
										}
										/* FIXME EAM - Trap special case of only a single
										 * 'using' column. But really we need to handle
										 * general case of implicit column 0 */
										if (output == 1)
											xpos = (axcol == 0) ? df_datum : v[axcol - 1];
										else
											xpos = v[axcol];

										if (df_current_plot != null && df_current_plot.plot_style == PLOT_STYLE.HISTOGRAMS)
										{
											if (output > 1) // Can only happen for HT_ERRORBARS
												xpos = (axcol == 0) ? df_datum : v[axcol - 1];
											xpos += df_current_plot.histogram.start;
										}

										/* Tic label is generated by a string-valued function */
										if (use_spec[output].at != null)
										{
											value a = new value();
											evaluate_inside_using = true;
											GlobalMembersEval.evaluate_at(use_spec[output].at, a);
											evaluate_inside_using = false;
											if (a.type == DATA_TYPES.STRING)
											{
												GlobalMembersAxis.add_tic_user(axis, a.v.string_val, xpos, -1);
												GlobalMembersEval.gpfree_string(a);
											}
											else
												fprintf(stderr,"Tic label does not evaluate as string!\n");
										}
										else
										{
											byte temp_string = GlobalMembersDatafile.df_parse_string_field(df_tokens[output]);
											GlobalMembersAxis.add_tic_user(axis, temp_string, xpos, -1);
											//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
											free(temp_string);
										}

									}
									else if (use_spec[output].expected_type == COLUMN_TYPE.CT_KEYLABEL.getValue())
									{
										byte temp_string = GlobalMembersDatafile.df_parse_string_field(df_tokens[output]);
										if (df_current_plot != null)
											GlobalMembersDatafile.add_key_entry(temp_string, df_datum);
										//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
										free(temp_string);

									}
									else

										if (use_spec[output].at != null)
										{
											value a = new value();
											/* no dummy values to set up prior to... */
											evaluate_inside_using = true;
											GlobalMembersEval.evaluate_at(use_spec[output].at, a);
											evaluate_inside_using = false;
											if (GlobalMembersEval.undefined)
												return DefineConstants.DF_UNDEFINED; // store undefined point in plot

											if (a.type == DATA_TYPES.STRING)
											{
												/* This string value will get parsed as if it were a data column */
												/* so put it in quotes to allow embedded whitespace.             */
												if (use_spec[output].expected_type == COLUMN_TYPE.CT_STRING.getValue())
												{
													byte s = GlobalMembersAlloc.gp_alloc(a.v.string_val.length() + 3, "quote");
													s = (byte)'"';
													s + 1 = a.v.string_val;
													s += "\"";
													//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
													free(df_stringexpression[output]);
													df_tokens[output] = df_stringexpression[output] = s;
												}

												/* Check for timefmt string generated by a function */
												if ((df_axis[output] != DefineConstants.NO_AXIS) && GlobalMembersAxis.axis_array[df_axis[output].getValue()].is_timedata)
												{
													tm tm = new tm();
													if (GlobalMembersTime.gstrptime(a.v.string_val, GlobalMembersAxis.axis_array[df_axis[output].getValue()].timefmt, tm) != null)
														v[output] = (double) GlobalMembersTime.gtimegm(tm);
													else // FIXME - Is this correct? Is it needed?
														line_okay = 0;
												}
												GlobalMembersEval.gpfree_string(a);
											}
											else
												v[output] = GlobalMembersEval.real(a);

										}
										else if (column == -2)
										{
											v[output] = df_current_index;
										}
										else if (column == -1)
										{
											v[output] = line_count;
										}
										else if (column == 0)
										{
											v[output] = df_datum; // using 0
										} // really < -2, but
										else if (column <= 0)
											GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: column <= 0 in datafile.c");
										else if ((df_axis[output] != DefineConstants.NO_AXIS) && (GlobalMembersAxis.axis_array[df_axis[output].getValue()].is_timedata))
										{
											tm tm = new tm();
											if (column > df_no_cols || df_column[column - 1].good == DefineConstants.DF_MISSING || df_column[column - 1].position == null || GlobalMembersTime.gstrptime(df_column[column - 1].position, GlobalMembersAxis.axis_array[df_axis[output].getValue()].timefmt, tm) == null)
											{
												/* line bad only if user explicitly asked for this column */
												if (df_no_use_specs != 0)
													line_okay = 0;

												/* return or ignore line depending on line_okay */
												break;
											}
											v[output] = (double) GlobalMembersTime.gtimegm(tm);

										}
										else if (use_spec[output].expected_type == COLUMN_TYPE.CT_STRING.getValue())
										{
											/* Do nothing. */
											/* String tokens were loaded into df_tokens already. */

										}
										else
										{
											/* column > 0 */
											if ((column <= df_no_cols) && df_column[column - 1].good == DF_GOOD)
												v[output] = df_column[column - 1].datum;
											/* EAM - Oct 2002 Distinguish between
											 * DF_MISSING and DF_BAD.  Previous versions
											 * would never notify caller of either case.
											 * Now missing data will be noted. Bad data
											 * should arguably be noted also, but that
											 * would change existing default behavior.  */
											else if ((column <= df_no_cols) && (df_column[column - 1].good == DefineConstants.DF_MISSING))
												return DefineConstants.DF_MISSING;
											else
											{
												/* line bad only if user explicitly asked
												 * for this column */
												if (df_no_use_specs != 0)
													line_okay = 0;
												break; // return or ignore depending on line_okay
											}
										}
								}
							}
							/*}}} */

							if (line_okay == 0)
								continue;

							/* output == df_no_use_specs if using was specified -
							 * actually, smaller of df_no_use_specs and max */
							/* FIXME EAM - In theory it might be useful for the caller to
							 * know whether or not tic specs were read from this line, but
							 * all callers would have to be modified to deal with it one
							 * way or the other. */
							output -= df_no_tic_specs;
							assert df_no_use_specs == 0 || output == df_no_use_specs || output == max;

							return output;

						}
						/*}}} */

						/* get here => fgets failed */

						/* no longer needed - mark column(x) as invalid */
						df_no_cols = 0;

						df_eof = 1;
						return DefineConstants.DF_EOF;
					}

					/*{{{  int df_readbinary(v, max) */
					/* do the hard work... read lines from file,
					 * - use blanks to get index number
					 * - ignore lines outside range of indices required
					 * - fill v[] based on using spec if given
					 */

					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int[] df_readbinary_scan_size = new int[3];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[] df_readbinary_delta = new double[3];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[] df_readbinary_o = new double[3];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[] df_readbinary_c = new double[3];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[][] df_readbinary_P = new double[3][3];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[][] df_readbinary_R = new double[2][2];
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int df_readbinary_read_order;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int df_readbinary_record_skip;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int df_readbinary_end_of_scan_line;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int df_readbinary_end_of_block;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static boolean df_readbinary_translation_required;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static String df_readbinary_memory_data;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double df_readbinary_first_matrix_column;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static float df_readbinary_scanned_matrix_row = 0F;
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static int df_readbinary_first_matrix_row_col_count;
					public static int df_readbinary(double[] v, int max)
					{
						/* For general column structured binary. */
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int scan_size[3];
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double delta[3]; // sampling periods
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double o[3]; // add after rotations
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double c[3]; // subtract before doing rotations
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double P[3][3]; // 3D rotation matrix (perpendicular)
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double R[2][2]; // 2D rotation matrix (rotate)
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int read_order;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int record_skip;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int end_of_scan_line;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int end_of_block;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static boolean translation_required;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static sbyte *memory_data;

						/* For matrix data structure (i.e., gnuplot binary). */
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double first_matrix_column;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static float *scanned_matrix_row = 0;
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static int first_matrix_row_col_count;
						boolean saved_first_matrix_column = false;

						assert data_fp != DefineConstants.NULL;
						assert max <= DefineConstants.MAXDATACOLS;
						assert df_max_bininfo_cols > df_no_bin_cols;
						assert df_no_bin_cols;

						/* catch attempt to read past EOF on mixed-input */
						if (df_eof != 0)
							return DefineConstants.DF_EOF;

						/* Check if we have room for at least df_no_bin_cols columns */
						if (df_max_cols < df_no_bin_cols)
						{
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							df_column = GlobalMembersAlloc.gp_realloc(df_column, df_no_bin_cols * sizeof(df_column_struct), "datafile columns");
							df_max_cols = df_no_bin_cols;
						}

						/* In binary mode, the number of user specs was increased by the
						 * number of dimensions in the underlying uniformly sampled grid
						 * previously.  Fill in those values.  Also, compute elements of
						 * formula x' = P*R*(x - c) + o */
						if (df_M_count == 0 && df_N_count == 0 && df_O_count == 0)
						{
							int i;
							boolean D2;
							boolean D3;
							df_binary_file_record_struct this_record = df_bin_record + df_bin_record_count;

							df_readbinary_scan_size[0] = df_readbinary_scan_size[1] = df_readbinary_scan_size[2] = 0;

							D2 = GlobalMembersDatafile.rotation_matrix_2D(df_readbinary_R, this_record.cart_alpha);
							D3 = GlobalMembersDatafile.rotation_matrix_3D(df_readbinary_P, this_record.cart_p);
							df_readbinary_translation_required = D2 || D3;

							if (df_matrix_file)
							{
								/* Dimensions */
								df_readbinary_scan_size[0] = this_record.scan_dim[0];
								df_readbinary_scan_size[1] = this_record.scan_dim[1];

								if (df_readbinary_scan_size[0] == 0)
									GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Scan size of matrix is zero");

								/* To accomplish flipping in this case, multiply the
								 * appropriate column of the rotation matrix by -1.  */
								for (i = 0; i < 2; i++)
								{
									int j;

									for (j = 0; j < 2; j++)
									{
										df_readbinary_R[i][j] *= this_record.cart_dir[i];
									}
								}
								/* o */
								for (i = 0; i < 3; i++)
								{
									if (this_record.cart_trans != df_translation_type.DF_TRANSLATE_DEFAULT)
									{
										df_readbinary_o[i] = this_record.cart_cen_or_ori[i];
									}
									else
									{
										/* Default is translate by center. */
										if (i < 2)
											df_readbinary_o[i] = (df_matrix_corner[1][i] + df_matrix_corner[0][i]) / 2;
										else
											df_readbinary_o[i] = 0;
									}
								}
								/* c */
								for (i = 0; i < 3; i++)
								{
									if (this_record.cart_trans == df_translation_type.DF_TRANSLATE_VIA_ORIGIN)
									{
										if (i < 2)
											df_readbinary_c[i] = df_matrix_corner[0][i];
										else
											df_readbinary_c[i] = 0;
									}
									else
									{
										if (i < 2)
											df_readbinary_c[i] = (df_matrix_corner[1][i] + df_matrix_corner[0][i]) / 2;
										else
											df_readbinary_c[i] = 0;
									}
								}

								df_readbinary_first_matrix_row_col_count = 0;
							} // general binary
							else
							{
								for (i = 0; i < 3; i++)
								{
									int map;

									/* How to direct the generated coordinates in regard
									 * to scan direction */
									if (this_record.cart_dim[i] != 0 || this_record.scan_dim[i] != 0)
									{
										if (this_record.scan_generate_coord)
											use_spec[i].column = (int)this_record.cart_scan[i];
									}
									/* Dimensions */
									map = df_sample_scan_type.DF_SCAN_POINT .getValue() - this_record.cart_scan[i];
									if (this_record.cart_dim[i] > 0)
										df_readbinary_scan_size[map] = this_record.cart_dim[i];
									else if (this_record.cart_dim[i] < 0)
										df_readbinary_scan_size[map] = (~0) >> 1;
									else
										df_readbinary_scan_size[map] = this_record.scan_dim[map];
									/* Sample periods */
									if (this_record.cart_delta[i] != 0)
										df_readbinary_delta[map] = this_record.cart_delta[i];
									else
										df_readbinary_delta[map] = this_record.scan_delta[map];
									df_readbinary_delta[map] *= this_record.scan_dir[map] * this_record.cart_dir[i];
									/* o */
									if (this_record.cart_trans != df_translation_type.DF_TRANSLATE_DEFAULT)
										df_readbinary_o[i] = this_record.cart_cen_or_ori[i];
									else if (this_record.scan_trans != df_translation_type.DF_TRANSLATE_DEFAULT)
										df_readbinary_o[i] = this_record.scan_cen_or_ori[map];
									else if (df_readbinary_scan_size[map] > 0)
										df_readbinary_o[i] = (df_readbinary_scan_size[map] - 1) * Math.abs(df_readbinary_delta[map]) / 2;
									else
										df_readbinary_o[i] = 0;
									/* c */
									if (this_record.cart_trans == df_translation_type.DF_TRANSLATE_VIA_ORIGIN || (this_record.cart_trans == df_translation_type.DF_TRANSLATE_DEFAULT && this_record.scan_trans == df_translation_type.DF_TRANSLATE_VIA_ORIGIN))
									{
										if ((df_readbinary_scan_size[map] > 0) && (df_readbinary_delta[map] < 0))
											df_readbinary_c[i] = (df_readbinary_scan_size[map] - 1) * df_readbinary_delta[map];
										else
											df_readbinary_c[i] = 0;
									}
									else
									{
										if (df_readbinary_scan_size[map] > 0)
											df_readbinary_c[i] = (df_readbinary_scan_size[map] - 1) * (df_readbinary_delta[map] / 2);
										else
											df_readbinary_c[i] = 0;
									}
								}
							}

							/* Check if c and o are the same. */
							for (i = 0; i < 3; i++)
								df_readbinary_translation_required = df_readbinary_translation_required || (df_readbinary_c[i] != df_readbinary_o[i]);

							/* Should data come from memory? */
							df_readbinary_memory_data = this_record.memory_data;

							/* byte read order */
							df_readbinary_read_order = GlobalMembersDatafile.byte_read_order(df_bin_file_endianess);

							/* amount to skip before record */
							df_readbinary_record_skip = this_record.scan_skip[0];

							df_readbinary_end_of_scan_line = false;
							df_readbinary_end_of_block = false;
							point_count = -1;
							line_count = 0;
							df_current_index = df_bin_record_count;
						}

						while (df_eof == 0)
						{
							/*{{{  process line */
							int line_okay = 1;
							int output = 0; // how many numbers written to v[]
							int i;
							int fread_ret = 0;
							int m_value;
							int n_value;
							int o_value;
							//C++ TO JAVA CONVERTER TODO TASK: Unions are not supported in Java.
							//	union io_val
							//	{
							//		sbyte ch;
							//		byte uc;
							//		short sh;
							//		short us;
							//		int in;
							//		int ui;
							//		int lo;
							//		int ul;
							//		long llo;
							//		long ull;
							//		float fl;
							//		double db;
							//	}
							io_val;

							/* Scan in a number of floats based upon the largest index in
							 * the use_specs array.  If the largest index in the array is
							 * greater than maximum columns then issue an error.
							 */

							/* Handle end of line or end of block on previous read. */
							if (df_readbinary_end_of_scan_line != 0)
							{
								df_readbinary_end_of_scan_line = false;
								point_count = -1;
								line_count++;
								return DefineConstants.DF_FIRST_BLANK;
							}
							if (df_readbinary_end_of_block != 0)
							{
								df_readbinary_end_of_block = false;
								line_count = 0;
								return DefineConstants.DF_SECOND_BLANK;
							}

							/* Possibly skip bytes before starting to read record. */
							if (df_readbinary_record_skip != 0)
							{
								if (df_readbinary_memory_data != null)
									df_readbinary_memory_data += df_readbinary_record_skip;
								else if (GlobalMembersDatafile.df_skip_bytes(df_readbinary_record_skip) != 0)
									return DefineConstants.DF_EOF;
								df_readbinary_record_skip = 0;
							}

							/* Bring in variables as described by the field parameters.
							 * If less than than the appropriate number of bytes have been
							 * read, issue an error stating not enough columns were found.  */
							for (i = 0; ; i++)
							{
								int skip_bytes = df_column_bininfo[i].skip_bytes;

								if (skip_bytes != 0)
								{
									if (df_readbinary_memory_data != null)
										df_readbinary_memory_data += skip_bytes;
									else if (GlobalMembersDatafile.df_skip_bytes(skip_bytes) != 0)
										return DefineConstants.DF_EOF;
								}

								/* Last entry only has skip bytes, no data. */
								if (i == df_no_bin_cols)
									break;

								/* Read in a "column", i.e., a binary value of various types. */
								if (df_datablock != null)
								{
									io_val.uc = GlobalMembersBreaders.df_libgd_get_pixel(df_M_count, df_N_count, i);
								}
								else

									if (df_readbinary_memory_data != null)
									{
										for (fread_ret = 0; fread_ret < df_column_bininfo[i].column.read_size; fread_ret++)
											(io_val.ch)[fread_ret] = df_readbinary_memory_data++;
									}
									else
									{
										fread_ret = fread(io_val.ch, df_column_bininfo[i].column.read_size, 1, data_fp);
										if (fread_ret != 1)
										{
											df_eof = 1;
											return DefineConstants.DF_EOF;
										}
									}

								GlobalMembersDatafile.df_swap_bytes_by_endianess(io_val.ch, df_readbinary_read_order, df_column_bininfo[i].column.read_size);

								switch (df_column_bininfo[i].column.read_type)
								{
								case DF_CHAR:
									df_column[i].datum = io_val.ch;
									break;
								case DF_UCHAR:
									df_column[i].datum = io_val.uc;
									break;
								case DF_SHORT:
									df_column[i].datum = io_val.sh;
									break;
								case DF_USHORT:
									df_column[i].datum = io_val.us;
									break;
								case DF_INT:
									df_column[i].datum = io_val.in;
									break;
								case DF_UINT:
									df_column[i].datum = io_val.ui;
									break;
								case DF_LONG:
									df_column[i].datum = io_val.lo;
									break;
								case DF_ULONG:
									df_column[i].datum = io_val.ul;
									break;
								case DF_LONGLONG:
									df_column[i].datum = io_val.llo;
									break;
								case DF_ULONGLONG:
									df_column[i].datum = io_val.ull;
									break;
								case DF_FLOAT:
									df_column[i].datum = io_val.fl;
									break;
								case DF_DOUBLE:
									df_column[i].datum = io_val.db;
									break;
								default:
									GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Binary data type unknown");
								}

								df_column[i].good = DF_GOOD;
								df_column[i].position = DefineConstants.NULL; // cant get a time

								/* Matrix file data is a special case. After reading in just
								 * one binary value, stop and decide on what to do with it. */
								if (df_matrix_file)
									break;

							} // for(i)

							if (df_matrix_file)
							{
								if (df_matrix_binary)
								{
									/* Store just first column? */
									if (df_M_count == 0 && !saved_first_matrix_column)
									{
										df_readbinary_first_matrix_column = df_column[i].datum;
										saved_first_matrix_column = true;
										continue;
									}

									/* Read reset of first row? */
									if (df_M_count == 0 && df_N_count == 0 && df_O_count == 0 && df_readbinary_first_matrix_row_col_count < df_readbinary_scan_size[0])
									{
										//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
										if (df_readbinary_first_matrix_row_col_count == 0 && !(df_readbinary_scanned_matrix_row = GlobalMembersAlloc.gp_realloc(df_readbinary_scanned_matrix_row, df_readbinary_scan_size[0] * sizeof(float), "gpbinary matrix row")))
											GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "not enough memory to create vector");
										df_readbinary_scanned_matrix_row[df_readbinary_first_matrix_row_col_count] = df_column[i].datum;
										df_readbinary_first_matrix_row_col_count++;
										if (df_readbinary_first_matrix_row_col_count == df_readbinary_scan_size[0])
										{
											/* Start of the second row. */
											saved_first_matrix_column = false;
										}
										continue;
									}

								}

								/* Update all the binary columns.  Matrix binary and
								 * matrix ASCII is a slight abuse of notation.  At the
								 * command line, 1 means first row, 2 means first
								 * column.  There can only be one column of data input
								 * because it is a matrix of data, not columns.  */
								{
									int j;

									df_datum = df_column[i].datum;

									/* Fill backward so that current read value is not
									 * overwritten. */
									for (j = df_no_bin_cols - 1; j >= 0; j--)
									{
										if (j == 0)
											df_column[j].datum = df_matrix_binary ? df_readbinary_scanned_matrix_row[df_M_count] : df_M_count;
											else if (j == 1)
												df_column[j].datum = df_matrix_binary ? df_readbinary_first_matrix_column : df_N_count;
											else
												df_column[j].datum = df_column[i].datum;
										df_column[j].good = DF_GOOD;
										df_column[j].position = DefineConstants.NULL;
									}
								}
							} // Not matrix file, general binray.
							else
							{
								df_datum = point_count + 1;
								if (i != df_no_bin_cols)
								{
									if (feof(data_fp))
									{
										if (i != 0)
											GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Last point in the binary file did not match the specified `using` columns");
										df_eof = 1;
										return DefineConstants.DF_EOF;
									}
									else
									{
										GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, read_error_msg);
									}
								}
							}

							m_value = df_M_count;
							n_value = df_N_count;
							o_value = df_O_count;
							df_M_count++;
							if ((df_readbinary_scan_size[0] > 0) && (df_M_count >= df_readbinary_scan_size[0]))
							{
								/* This is a new "line". */
								df_M_count = 0;
								df_N_count++;
								df_readbinary_end_of_scan_line = true;
								if ((df_readbinary_scan_size[1] >= 0) && (df_N_count >= df_readbinary_scan_size[1]))
								{
									/* This is a "block". */
									df_N_count = 0;
									df_O_count++;
									if ((df_readbinary_scan_size[2] >= 0) && (df_O_count >= df_readbinary_scan_size[2]))
									{
										df_O_count = 0;
										df_readbinary_end_of_block = true;
										if (++df_bin_record_count >= df_num_bin_records)
										{
											df_eof = 1;
										}
									}
								}
							}

							/*{{{  ignore points outside range of index */
							/* we try to return end-of-file as soon as we pass upper
							 * index, but for mixed input stream, we must skip garbage */

							if (df_current_index < df_lower_index || df_current_index > df_upper_index || ((df_current_index - df_lower_index) % df_index_step) != 0)
								continue;
							/*}}} */

							/*{{{  reject points by every */
							/* accept only lines with (line_count%everyline) == 0 */
							if (line_count < firstline || line_count > lastline || (line_count - firstline) % everyline != 0)
								continue;

							/* update point_count. ignore point if
		   point_count%everypoint != 0 */
							if (++point_count < firstpoint || point_count > lastpoint || (point_count - firstpoint) % everypoint != 0)
								continue;
							/*}}} */

							/* At this point the binary columns have been read
							 * successfully.  Set df_no_cols to df_no_bin_cols for use
							 * in the interpretation code.  */
							df_no_cols = df_no_bin_cols;

							/*{{{  copy column[] to v[] via use[] */
							{
								int limit = (df_no_use_specs != 0 ? df_no_use_specs : DefineConstants.MAXDATACOLS);

								if (limit > max)
									limit = max;

								for (output = 0; output < limit; ++output)
								{
									int column = use_spec[output].column;

									/* if there was no using spec, column is output+1 and at=NULL */
									if (use_spec[output].at != null)
									{
										value a = new value();

										/* no dummy values to set up prior to... */
										evaluate_inside_using = true;
										GlobalMembersEval.evaluate_at(use_spec[output].at, a);
										evaluate_inside_using = false;
										if (GlobalMembersEval.undefined)
											return DefineConstants.DF_UNDEFINED;

										v[output] = GlobalMembersEval.real(a);
									}
									else if (column == df_sample_scan_type.DF_SCAN_PLANE.getValue())
									{
										if ((df_current_plot.plot_style == PLOT_STYLE.IMAGE) || (df_current_plot.plot_style == PLOT_STYLE.RGBIMAGE))
											v[output] = o_value * df_readbinary_delta[2];
										/* EAM August 2009
										 * This was supposed to be "z" in a 3D grid holding a binary
										 * value at each voxel.  But in fact the binary code does not
										 * support 3D grids, only 2D. So this always got set to 0,
										 * making the whole thing pretty useless except for inherently.
										 * planar objects like 2D images.
										 * Now I set Z to be the pixel value, which allows you
										 * to draw surfaces described by a 2D binary array.
										 */
										else
											v[output] = df_column[0].datum;
									}
									else if (column == df_sample_scan_type.DF_SCAN_LINE.getValue())
									{
										v[output] = n_value * df_readbinary_delta[1];
									}
									else if (column == df_sample_scan_type.DF_SCAN_POINT.getValue())
									{
										v[output] = m_value * df_readbinary_delta[0];
									}
									else if (column == -2)
									{
										v[output] = df_current_index;
									}
									else if (column == -1)
									{
										v[output] = line_count;
									}
									else if (column == 0)
									{
										v[output] = df_datum;
									}
									else if (column <= 0)
										GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: unkown column type");
									else if ((df_axis[output] != DefineConstants.NO_AXIS) && (GlobalMembersAxis.axis_array[df_axis[output].getValue()].is_timedata))
									{
										tm tm = new tm();

										if (column > df_no_cols || df_column[column - 1].good == DefineConstants.DF_MISSING || df_column[column - 1].position == null || GlobalMembersTime.gstrptime(df_column[column - 1].position, GlobalMembersAxis.axis_array[df_axis[output].getValue()].timefmt, tm) == null)
										{
											/* line bad only if user explicitly asked
											 * for this column */
											if (df_no_use_specs != 0)
												line_okay = 0;

											/* return or ignore line depending on line_okay */
											break;
										}
										v[output] = (double) GlobalMembersTime.gtimegm(tm);
									}
									else if ((column <= df_no_cols) && df_column[column - 1].good == DF_GOOD)
										v[output] = df_column[column - 1].datum;

									/* EAM - Oct 2002 Distinguish between DF_MISSING
									 * and DF_BAD.  Previous versions would never
									 * notify caller of either case.  Now missing data
									 * will be noted. Bad data should arguably be
									 * noted also, but that would change existing
									 * default behavior.  */
									else if ((column <= df_no_cols) && (df_column[column - 1].good == DefineConstants.DF_MISSING))
										return DefineConstants.DF_MISSING;
									else
									{
										/* line bad only if user explicitly asked for this column */
										if (df_no_use_specs != 0)
											line_okay = 0;
										break; // return or ignore depending on line_okay
									}
								}

								/* Linear translation. */
								if (df_readbinary_translation_required)
								{
									double[] p = new double[0];
									double[] p = new double[1];
									double[] p = new double[2];

									p[0] = v[0] - df_readbinary_c[0];
									p[1] = v[1] - df_readbinary_c[1];

									v[0] = df_readbinary_R[0][0] * p[0] + df_readbinary_R[0][1] * p[1];
									v[1] = df_readbinary_R[1][0] * p[0] + df_readbinary_R[1][1] * p[1];
									if (df_plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
									{
										p[0] = v[0];
										p[1] = v[1];
										p[2] = v[2] - df_readbinary_c[2];
										v[0] = df_readbinary_P[0][0] * p[0] + df_readbinary_P[0][1] * p[1] + df_readbinary_P[0][2] * p[2];
										v[1] = df_readbinary_P[1][0] * p[0] + df_readbinary_P[1][1] * p[1] + df_readbinary_P[1][2] * p[2];
										v[2] = df_readbinary_P[2][0] * p[0] + df_readbinary_P[2][1] * p[1] + df_readbinary_P[2][2] * p[2];
									}

									v[0] += df_readbinary_o[0];
									v[1] += df_readbinary_o[1];
									if (df_plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
										v[2] += df_readbinary_o[2];
								}

							}
							/*}}} */

							if (line_okay == 0)
								continue;

							/* output == df_no_use_specs if using was specified -
							 * actually, smaller of df_no_use_specs and max */
							assert df_no_use_specs == 0 || output == df_no_use_specs || output == max;

							return output;

						}
						/*}}} */

						df_eof = 1;
						return DefineConstants.DF_EOF;

					}
					/*}}} */



					public static void initialize_use_spec()
					{
						int i;

						df_no_use_specs = 0;
						for (i = 0; i < DefineConstants.MAXDATACOLS; ++i)
						{
							use_spec[i].column = i + 1; // default column
							use_spec[i].expected_type = COLUMN_TYPE.CT_DEFAULT.getValue(); // no particular expectation
							if (use_spec[i].at != null)
							{
								GlobalMembersEval.free_at(use_spec[i].at);
								use_spec[i].at = DefineConstants.NULL; // no expression
							}
							df_axis[i] = DefineConstants.NO_AXIS; // no timefmt for this output column
						}
					}

					public static void initialize_binary_vars()
					{
						/* Initialize for the df_readline() routine. */
						df_bin_record_count = 0;
						df_M_count = df_N_count = df_O_count = 0;

						/* Set default binary data widths and skip paratemers. */
						df_no_bin_cols = 0;
						GlobalMembersDatafile.df_set_skip_before(1, 0);

						/* Copy the default binary records to the active binary records.  The number
						 * of records will always be at least one in case "record", "array",
						 * or "filetype" are not issued by the user.
						 */
						GlobalMembersDatafile.clear_binary_records(df_records_type.DF_CURRENT_RECORDS);
						if (df_num_bin_records_default != 0)
						{
							df_bin_filetype = df_bin_filetype_default;
							df_bin_file_endianess = df_bin_file_endianess_default;
							GlobalMembersDatafile.df_add_binary_records(df_num_bin_records_default, df_records_type.DF_CURRENT_RECORDS);
							//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							memcpy(df_bin_record, df_bin_record_default, df_num_bin_records * sizeof(df_binary_file_record_struct));
						}
						else
						{
							df_bin_filetype = df_bin_filetype_reset;
							df_bin_file_endianess = (((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN;
							GlobalMembersDatafile.df_add_binary_records(1, df_records_type.DF_CURRENT_RECORDS);
						}
					}

					/* Place a special marker in the using list to derive the x/y/z value
					 * from the appropriate dimensional counter.
					 */
					public static void df_insert_scanned_use_spec(int uspec)
					{
						/* Place a special marker in the using list to derive the z value
						 * from the third dimensional counter, which will be zero.
						 */
						if (df_no_use_specs >= DefineConstants.MAXDATACOLS)
							GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, too_many_cols_msg);
						else
						{
							int j;
							for (j = df_no_use_specs; j > uspec; j--)
								use_spec[j] = use_spec[j - 1];
							use_spec[uspec].column = (uspec == 2 ? df_sample_scan_type.DF_SCAN_PLANE : df_sample_scan_type.DF_SCAN_LINE);
							/* The at portion is set to NULL here, but this doesn't mash
							 * a valid memory pointer because any valid memory pointers
							 * were copied to new locations in the previous for loop.
							 */
							use_spec[uspec].at = DefineConstants.NULL; // Not a bad memory pointer overwrite!!
							df_no_use_specs++;
						}
					}

					/* FIXME!!!
					 * EAM Feb 2008:
					 * This whole routine is a disaster.  It makes so many broken assumptions it's not funny.
					 * Other than filling in the first two columns of an implicit matrix, I suspect we can
					 * do away with it altogether. Frankly, we _don't care_ how many columns there are,
					 * so long as the ones that are present are mapped to the right ordering.
					 */

					public static void adjust_binary_use_spec()
					{

						String nothing_known = "No default columns known for that plot style";
						PLOT_STYLE plot_style;
						int ps_index;
						int c_token_copy;

						/* This may appear strange, but ASCII matrix is not the same
						 * format as gnuplot matrix binary.  So, although the ASCII
						 * *file* may be matrix, it's data structure is similar to
						 * an M x N general binary file, i.e., no extra row and column
						 * for sample coordinates.
						 */
						df_matrix_binary = (df_matrix_file && df_binary_file);

						c_token_copy = GlobalMembersCommand.c_token;

						for (; !GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0; GlobalMembersCommand.c_token++)
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "w$ith") != 0)
								break;
						if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
							plot_style = GlobalMembersMisc.get_style();
						else
							plot_style = PLOT_STYLE.LINES;
						GlobalMembersCommand.c_token = c_token_copy;

						/* Determine index. */
						//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
						//ORIGINAL LINE: for (ps_index = 0; ps_index < sizeof(default_style_cols)/sizeof(default_style_cols[0]); ps_index++)
						for (ps_index = 0; ps_index < default_style_cols.length; ps_index++)
						{
							if (default_style_cols[ps_index].plot_style == plot_style)
								break;
						}
						//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
						//ORIGINAL LINE: if (ps_index == sizeof(default_style_cols)/sizeof(default_style_cols[0]))
						if (ps_index == default_style_cols.length)
							GlobalMembersBf_test.int_error(c_token_copy, nothing_known);

						/* Matrix format is interpretted as always having three columns. */
						if (df_matrix_file)
						{
							if (df_no_bin_cols > 3)
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Matrix data contains only three columns");
							GlobalMembersDatafile.df_extend_binary_columns(3);
						}

						/* If nothing has been done to set the using specs, use the default using
						 * characteristics for the style.
						 */
						if (df_no_use_specs == 0)
						{

							if (!df_matrix_file)
							{

								int no_cols = default_style_cols[ps_index].excluding_gen_coords;
								if (no_cols == 0)
									GlobalMembersBf_test.int_error(c_token_copy, nothing_known);

								/* If coordinates are generated, make sure this plot style allows it.
								 * Otherwise, add in the number of generated coordinates and add an
								 * extra column if using `splot`.
								 */
								if (df_num_bin_records != 0 && df_bin_record[0].scan_generate_coord)
								{
									if (default_style_cols[ps_index].dimen_in_2d == 0)
										GlobalMembersBf_test.int_error(c_token_copy, "Cannot generate coords for that plot style");
								}
								else
								{
									/* If there aren't generated coordinates, then add the
									 * amount of columns that would be generated.
									 */
									no_cols += default_style_cols[ps_index].dimen_in_2d;
									if (df_plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
										no_cols++;
								}

								assert no_cols <= DefineConstants.MAXDATACOLS;

								/* Nothing need be done here to set the using specs because they
								 * will have been initialized appropriately and left unaltered.
								 * So just set the number of specs.
								 */
								df_no_use_specs = no_cols;
								GlobalMembersDatafile.df_extend_binary_columns(no_cols);

							}
							else
							{

								/* Number of columns is fixed at three and no using specs given.  Do what we can.
								 * The obvious best combination is two dimensional coordinates and one information
								 * value.  One wonders what to do if a matrix is only one column; can be treated
								 * as linear?  This isn't implemented here, but if it were, this is where it
								 * should go.
								 */

								if ((default_style_cols[ps_index].dimen_in_2d == 2) && (default_style_cols[ps_index].excluding_gen_coords == 1))
								{
									df_no_use_specs = 3;
								}
								else if ((default_style_cols[ps_index].dimen_in_2d == 1) && (default_style_cols[ps_index].excluding_gen_coords == 1))
								{
									if (df_plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
										df_no_use_specs = 3;
									else
									{
										/* Command:  plot 'foo' matrix       with no using spec */
										/* Matix element treated as y value rather than z value */
										df_no_use_specs = 2;
										use_spec[1].column = 3;
									}
								}
								else
									GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Plot style does not conform to three column data in this graph mode");
							}

						}

						/* Adjust for ASCII matrix format.  The first two "columns" come from indices. */
						if (df_matrix_file && !df_binary_file)
						{
						}

						if (df_num_bin_records != 0 && df_bin_record[0].scan_generate_coord && !df_matrix_file)
						{

							int i;

							use_spec_s[] original_use_spec = new use_spec_s[DefineConstants.MAXDATACOLS];
							int added_columns = 0;

							/* Keep record of the original using specs. */
							//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							memcpy(original_use_spec, use_spec, sizeof(use_spec));

							/* Put in columns at front for generated variables. */
							for (i = 0; i < 3; i++)
							{
								if (df_bin_record[0].cart_dim[i] != 0 || df_bin_record[0].scan_dim[i] != 0)
									added_columns++;
								else
									break;
							}
							if ((df_no_use_specs + added_columns) >= DefineConstants.MAXDATACOLS)
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, too_many_cols_msg);
							else
							{

								/* Shift the original columns over by added number of columns, but only
								 * if not matrix data.
								 */
								//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
								//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
								memcpy(use_spec[added_columns], original_use_spec, df_no_use_specs * sizeof(use_spec[0]));

								/* The at portion is set to NULL here, but this doesn't mash
								 * a valid memory pointer because any valid memory pointers
								 * were copied to new locations in the previous memcpy().
								 */
								for (i = 0; i < added_columns; i++)
								{
									use_spec[i].column = (int)df_bin_record[0].cart_scan[i];
									use_spec[i].at = DefineConstants.NULL; // Not a bad memory pointer overwrite!!
								}

								df_no_use_specs += added_columns; // Do not extend columns for generated coordinates.
							}

							if (df_plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
							{

								/* For binary data having an implied uniformly sampled grid, treat
								 * less than three-dimensional data in special ways based upon what
								 * is being plotted.
								 */
								int k;
								for (k = 0; k < df_num_bin_records; k++)
								{
									if ((df_bin_record[k].cart_dim[2] == 0) && (df_bin_record[k].scan_dim[2] == 0))
									{
										if (default_style_cols[ps_index].dimen_in_2d > 2)
											GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Plot style requires higher than two-dimensional sampling array");
										else
										{
											if ((df_bin_record[k].cart_dim[1] == 0) && (df_bin_record[k].scan_dim[1] == 0))
											{
												if (default_style_cols[ps_index].dimen_in_2d > 1)
													GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Plot style requires higher than one-dimensional sampling array");
												else
												{
													/* Place a special marker in the using list to derive the y value
													 * from the second dimensional counter.
													 */
													GlobalMembersDatafile.df_insert_scanned_use_spec(1);
												}
											}
											/* Place a special marker in the using list to derive the z value
											 * from the third dimensional counter.
											 */
											GlobalMembersDatafile.df_insert_scanned_use_spec(2);
										}
									}
								}
							}
						}
					}
					public static void clear_binary_records(df_records_type records_type)
					{
						df_binary_file_record_struct temp_bin_record;
						int temp_num_bin_records;
						int i;

						if (records_type == df_records_type.DF_CURRENT_RECORDS)
						{
							temp_bin_record = df_bin_record;
							temp_num_bin_records = df_num_bin_records;
						}
						else
						{
							temp_bin_record = df_bin_record_default;
							temp_num_bin_records = df_num_bin_records_default;
						}

						for (i = 0; i < temp_num_bin_records; i++)
						{
							if (!temp_bin_record[i].memory_data.equals(DefineConstants.NULL))
							{
								//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
								free(temp_bin_record[i].memory_data);
								temp_bin_record[i].memory_data = DefineConstants.NULL;
							}
						}
						temp_num_bin_records = 0;
					}

					/* Determine binary data widths from the `using` (or `binary`) format
					 * specification. */
					public static void plot_option_binary_format(String format_string)
					{

						int prev_read_type = df_data_type.DF_FLOAT.getValue(); // Defaults when none specified.
						int no_fields = 0;
						//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
						byte * substr = format_string;

						while (*substr != '\0' && *substr != '\"' && *substr != '\'')
						{

							if (*substr == ' ')
							{
								substr++;
								continue;
							} // Ignore spaces.

							if (*substr == '%')
							{
								int ignore;
								int field_repeat;
								int j = 0;
								int k = 0;
								int m = 0;
								int breakout;

								substr++;
								ignore = (*substr == '*');
								if (ignore != 0)
									substr++;

								/* Check for field repeat number. */
								field_repeat = Character.isDigit(*substr) ? strtol(substr, substr, 10) : 1;

								/* Try finding the word among the valid type names. */
								//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
								//ORIGINAL LINE: for (j = 0, breakout = 0; j < (sizeof(df_binary_tables) /sizeof(df_binary_tables[0])); j++)
								for (j = 0, breakout = 0; j < (df_binary_tables.length); j++)
								{
									for (k = 0, breakout = 0; k < df_binary_tables[j].group_length; k++)
									{
										for (m = 0; m < df_binary_tables[j].group[k].no_names; m++)
										{
											int strl = String.valueOf(df_binary_tables[j].group[k].name[m]).length();

											/* Check for exact match, which includes character
											 * after the substring being non-alphanumeric. */
											if (!strncmp(substr, df_binary_tables[j].group[k].name[m], strl) && tangible.StringFunctions.strChr("%\'\" ", *(substr + strl)))
											{
												substr += strl; // Advance pointer in array to next text.
												if (ignore == 0)
												{
													int n;

													for (n = 0; n < field_repeat; n++)
													{
														no_fields++;
														GlobalMembersDatafile.df_set_skip_before(no_fields + 1, 0);
														GlobalMembersDatafile.df_set_read_type(no_fields, df_binary_tables[j].group[k].type.read_type);
														prev_read_type = (int)df_binary_tables[j].group[k].type.read_type;
													}
												}
												else
												{
													if (df_column_bininfo == null)
														GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Failure in binary table initialization");
													df_column_bininfo[no_fields].skip_bytes += field_repeat * df_binary_tables[j].group[k].type.read_size;
												}
												breakout = 1;
												break;
											}
										}
										if (breakout != 0)
											break;
									}
									if (breakout != 0)
										break;
								}

								//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
								//ORIGINAL LINE: if (j == (sizeof(df_binary_tables) /sizeof(df_binary_tables[0])) && (k == df_binary_tables[j-1].group_length) && (m == df_binary_tables[j-1].group[k-1].no_names))
								if (j == (df_binary_tables.length) && (k == df_binary_tables[j - 1].group_length) && (m == df_binary_tables[j - 1].group[k - 1].no_names))
								{
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognized binary format specification");
								}
							}
							else
							{
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Format specifier must begin with '%'");
							}
						}

						/* Any remaining unspecified fields are assumed to be of the same type
						 * as the last specified field.
						 */
						for (; no_fields < df_no_bin_cols; no_fields++)
						{
							GlobalMembersDatafile.df_set_skip_before(no_fields + 1, 0);
							GlobalMembersDatafile.df_set_skip_before(no_fields, 0);
							GlobalMembersDatafile.df_set_read_type(no_fields, prev_read_type);
						}
						df_no_bin_cols = no_fields;

					}
					public static void plot_option_binary(boolean set_matrix, boolean set_default)
					{
						boolean duplication = false;
						boolean set_record = false;
						boolean set_array = false;
						boolean set_dx = false;
						boolean set_dy = false;
						boolean set_dz = false;
						boolean set_center = false;
						boolean set_origin = false;
						boolean set_skip = false;
						boolean set_endian = false;
						boolean set_rotation = false;
						boolean set_perpendicular = false;
						boolean set_flip = false;
						boolean set_noflip = false;
						boolean set_flipx = false;
						boolean set_flipy = false;
						boolean set_flipz = false;
						boolean set_scan = false;
						boolean set_format = false;

						/* Binary file type must be the first word in the command following `binary`" */
						if (df_bin_filetype_default >= 0)
							df_bin_filetype = df_bin_filetype_default;
						if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "file$type") != 0 || (df_bin_filetype >= 0))
						{
							int i;
							String file_ext = "\0\0\0\0\0\0\0";

							/* Above keyword not part of pre-existing binary definition.
							 * So use general binary. */
							if (set_matrix)
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, matrix_general_binary_conflict_msg);
							df_matrix_file = false;

							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "file$type") != 0)
							{
								if (GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, "=") == 0)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, equal_symbol_msg);

								GlobalMembersUtil.copy_str(file_ext, ++GlobalMembersCommand.c_token, 8);
								for (i = 0; df_bin_filetype_table[i].key; i++)
									if (!strcasecmp(file_ext, df_bin_filetype_table[i].key))
									{
										binary_input_function = df_bin_filetype_table[i].value;
										df_bin_filetype = i;
										break;
									}

								if (df_bin_filetype != i)
									/* Maybe set to "auto" and continue? */
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognized filetype; try \"show datafile binary filetypes\"");

								GlobalMembersCommand.c_token++;
							}

							if (df_plot_mode != MODE_PLOT_TYPE.MODE_QUERY.getValue() && !strcmp("auto", df_bin_filetype_table[df_bin_filetype].key))
							{
								int i;
								//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
								byte file_ext = tangible.StringFunctions.strRChr(df_filename, '.');
								if (file_ext++)
								{
									for (i = 0; df_bin_filetype_table[i].key; i++)
										if (!strcasecmp(file_ext, df_bin_filetype_table[i].key))
											binary_input_function = df_bin_filetype_table[i].value;
								}
								if (binary_input_function == GlobalMembersDatafile.auto_filetype_function)
									GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "Unrecognized filetype; try \"show datafile binary filetypes\"");
							}

							/* Unless only querying settings, call the routine to prep binary data parameters. */
							if (df_plot_mode != MODE_PLOT_TYPE.MODE_QUERY.getValue())
								//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
								//		(*binary_input_function)();

								/* Now, at this point anything that was filled in for "scan" should
								 * override the "cart" variables.
								 */
								for (i = 0; i < df_num_bin_records; i++)
								{
									int j;
									/* Dimension */
									if (df_bin_record[i].scan_dim[0] != df_bin_record_reset.scan_dim[0])
										for (j = 0; j < 3; j++)
											df_bin_record[i].cart_dim[j] = 0;
									/* Delta */
									for (j = 0; j < 3; j++)
										if (df_bin_record[i].scan_delta[j] != 0.0)
										{
											int k;
											for (k = 0; k < 3; k++)
												if (df_bin_record[i].cart_scan[k] == (df_sample_scan_type.DF_SCAN_POINT - j))
													df_bin_record[i].cart_delta[k] = 0;
										}
									/* Translation */
									if (df_bin_record[i].scan_trans != df_translation_type.DF_TRANSLATE_DEFAULT)
										df_bin_record[i].cart_trans = df_translation_type.DF_TRANSLATE_DEFAULT;
								}
						}


						while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
						{
							String origin_and_center_conflict_message = "Can specify `origin` or `center`, but not both";

							/* look for record */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rec$ord") != 0)
							{
								if (set_record)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								/* Above keyword not part of pre-existing binary definition.  So use general binary. */
								if (set_matrix)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, matrix_general_binary_conflict_msg);
								df_matrix_file = false;
								GlobalMembersDatafile.plot_option_array();
								set_record = true;
								continue;
							}

							/* look for array */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "arr$ay") != 0)
							{
								if (set_array)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								/* Above keyword not part of pre-existing binary definition.  So use general binary. */
								if (set_matrix)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, matrix_general_binary_conflict_msg);
								df_matrix_file = false;
								GlobalMembersDatafile.plot_option_array();
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].scan_generate_coord = true; // Indicate that coordinate info should be generated by gnuplot code.
								}
								set_array = true;
								continue;
							}

							/* deal with spacing between array points */
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "dx") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "dt") != 0)
							{
								if (set_dx)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_DELTA, 0);
								if (!set_dy)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_delta[1] = df_bin_record[i].cart_delta[0];
								}
								if (!set_dz)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_delta[2] = df_bin_record[i].cart_delta[0];
								}
								set_dx = true;
								continue;
							}

							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "dy") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "dr") != 0)
							{
								if (set_dy)
								{
									duplication = true;
									break;
								}
								if (!set_array && df_bin_record == null)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Must specify a sampling array size before indicating spacing in second dimension");
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_DELTA, 1);
								if (!set_dz)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_delta[2] = df_bin_record[i].cart_delta[1];
								}
								set_dy = true;
								continue;
							}

							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "dz") != 0)
							{
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Currently not supporting three-dimensional sampling");
								if (set_dz)
								{
									duplication = true;
									break;
								}
								if (!set_array && df_bin_record == null)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Must specify a sampling array size before indicating spacing in third dimension");
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_DELTA, 2);
								set_dz = true;
								continue;
							}

							/* deal with direction in which sampling increments */
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "flipx") != 0)
							{
								if (set_flipx)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								/* If no equal sign, then set flip true for all records. */
								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_dir[0] = -1;
								}
								else
								{
									GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_FLIP_AXIS, 0);
								}
								set_flipx = true;
								continue;
							}

							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "flipy") != 0)
							{
								if (set_flipy)
								{
									duplication = true;
									break;
								}
								if (!set_array && df_bin_record == null)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Must specify a sampling array size before indicating flip in second dimension");
								GlobalMembersCommand.c_token++;
								/* If no equal sign, then set flip true for all records. */
								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_dir[1] = -1;
								}
								else
								{
									GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_FLIP_AXIS, 1);
								}
								set_flipy = true;
								continue;
							}

							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "flipz") != 0)
							{
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Currently not supporting three-dimensional sampling");
								if (set_flipz)
								{
									duplication = true;
									break;
								}
								if (!set_array && df_bin_record == null)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Must specify a sampling array size before indicating spacing in third dimension");
								GlobalMembersCommand.c_token++;
								/* If no equal sign, then set flip true for all records. */
								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
								{
									int i;
									for (i = 0; i < df_num_bin_records; i++)
										df_bin_record[i].cart_dir[2] = -1;
								}
								else
								{
									GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_FLIP_AXIS, 2);
								}
								set_flipz = true;
								continue;
							}

							/* Deal with flipping data for individual records. */
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "flip") != 0)
							{
								if (set_flip)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_FLIP, -1);
								set_flip = true;
								continue;
							}

							/* Deal with flipping data for individual records. */
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "noflip") != 0)
							{
								if (set_noflip)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_FLIP, 1);
								set_noflip = true;
								continue;
							}

							/* Deal with manner in which dimensions are scanned from file. */
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "scan") != 0)
							{
								if (set_scan)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_SCAN, 0);
								set_scan = true;
								continue;
							}

							/* Deal with manner in which dimensions are scanned from file. */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "trans$pose") != 0)
							{
								int i;
								if (set_scan)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								for (i = 0; i < df_num_bin_records; i++)
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
									//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
									memcpy(df_bin_record[i].cart_scan, df_bin_scan_table_2D[DefineConstants.TRANSPOSE_INDEX].scan, sizeof(df_bin_record[0].cart_scan));
								set_scan = true;
								continue;
							}

							/* deal with origin */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "orig$in") != 0)
							{
								if (set_center)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, origin_and_center_conflict_message);
								if (set_origin)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_ORIGIN, df_plot_mode);
								set_origin = true;
								continue;
							}

							/* deal with origin */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cen$ter") != 0)
							{
								if (set_origin)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, origin_and_center_conflict_message);
								if (set_center)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_CENTER, df_plot_mode);
								set_center = true;
								continue;
							}

							/* deal with rotation angle */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rot$ation") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rot$ate") != 0)
							{
								if (set_rotation)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_ROTATION, 0);
								set_rotation = true;
								continue;
							}

							/* deal with rotation angle */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "perp$endicular") != 0)
							{
								if (df_plot_mode == MODE_PLOT_TYPE.MODE_PLOT.getValue())
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Key word `perpendicular` is not allowed with `plot` command");
								if (set_perpendicular)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_PERPENDICULAR, 0);
								set_perpendicular = true;
								continue;
							}

							/* deal with number of bytes to skip before record */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "skip") != 0)
							{
								if (set_skip)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								GlobalMembersDatafile.plot_option_multivalued(df_multivalue_type.DF_SKIP, 0);
								set_skip = true;
								continue;
							}

							/* deal with byte order */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "end$ian") != 0)
							{
								if (set_endian)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;

								/* Require equal symbol. */
								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, equal_symbol_msg);
								GlobalMembersCommand.c_token++;

								if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
									df_bin_file_endianess = (((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN;
								else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "swap") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "swab") != 0)
									df_bin_file_endianess = (~df_bin_file_endianess) & 3; // complement and isolate lowest two bits
								else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "lit$tle") != 0)
									df_bin_file_endianess = df_endianess_type.DF_LITTLE_ENDIAN;
								else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "big") != 0)
									df_bin_file_endianess = df_endianess_type.DF_BIG_ENDIAN;
								///#if SUPPORT_MIDDLE_ENDIAN
								else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "mid$dle") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pdp") != 0)
									df_bin_file_endianess = df_endianess_type.DF_PDP_ENDIAN;
								else
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Options are default, swap (swab), little, big, middle (pdp)");
								///#else
								//	    else
								//		int_error(c_token, "Options are default, swap (swab), little, big");
								///#endif
								GlobalMembersCommand.c_token++;
								set_endian = true;
								continue;
							}

							/* deal with various types of binary files */
							if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "form$at") != 0)
							{
								if (set_format)
								{
									duplication = true;
									break;
								}
								GlobalMembersCommand.c_token++;
								/* Format string not part of pre-existing binary definition.  So use general binary. */
								if (set_matrix)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, matrix_general_binary_conflict_msg);
								df_matrix_file = false;

								/* Require equal sign */
								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, equal_symbol_msg);
								GlobalMembersCommand.c_token++;

								if (set_default)
								{
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
									free(df_binary_format);
									df_binary_format = GlobalMembersUtil.try_to_get_string();
								}
								else
								{
									byte format_string = GlobalMembersUtil.try_to_get_string();
									if (format_string == 0)
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "missing format string");
									GlobalMembersDatafile.plot_option_binary_format(format_string);
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
									free(format_string);
								}
								set_format = true;
								continue;
							}

							break; // unknown option

						} // while (!END_OF_COMMAND)

						if (duplication)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Duplicated or contradicting arguments in datafile options");

						if (!set_default && !set_matrix && df_num_bin_records_default != 0)
						{
							GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "using default binary record/array structure");
						}

						if (!set_format && !df_matrix_file)
						{
							if (df_binary_format != null)
							{
								GlobalMembersDatafile.plot_option_binary_format(df_binary_format);
								GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "using default binary format");
							}
						}

					}

					/* EAM DEBUG - replacement for earlier ugly code
					 *             Syntax is now:   array=(xdim,ydim):(xdim,ydim):CONST:(xdim) etc
					 *
					 * For previously documented but broken "Inf", use -1
					 * Bug in original: need to reset # of dimensions each time
					 */
					public static void plot_option_array()
					{
						int number_of_records = 0;

						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, equal_symbol_msg);

						GlobalMembersDatafile.clear_binary_records(df_records_type.DF_CURRENT_RECORDS);

						do
						{
							GlobalMembersCommand.c_token++;

							/* Partial backward compatibility with syntax up to 4.2.4 */
							if (GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0)
							{
								if (++number_of_records > df_num_bin_records)
									GlobalMembersDatafile.df_add_binary_records(1, df_records_type.DF_CURRENT_RECORDS);
								df_bin_record[df_num_bin_records - 1].cart_dim[0] = GlobalMembersParse.int_expression();
								/* Handle the old syntax:  array=123x456 */
								if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
								{
									String xguy = new String(new char[8]);
									int itmp = 0;
									GlobalMembersUtil.copy_str(xguy, GlobalMembersCommand.c_token, 6);
									if (xguy.charAt(0) == 'x')
									{
										sscanf(xguy.charAt(1), "%d", itmp);
										df_bin_record[df_num_bin_records - 1].cart_dim[1] = itmp;
										GlobalMembersCommand.c_token++;
									}
								}
							}
							else

								if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "(") != 0)
								{
									GlobalMembersCommand.c_token++;
									if (++number_of_records > df_num_bin_records)
										GlobalMembersDatafile.df_add_binary_records(1, df_records_type.DF_CURRENT_RECORDS);
									df_bin_record[df_num_bin_records - 1].cart_dim[0] = GlobalMembersParse.int_expression();
									if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
									{
										GlobalMembersCommand.c_token++;
										df_bin_record[df_num_bin_records - 1].cart_dim[1] = GlobalMembersParse.int_expression();
									}
									if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ")") == 0)
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tuple syntax error");
									GlobalMembersCommand.c_token++;
								}

						} while (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":"));
					}

					/* Construct 2D rotation matrix. */
					/* R - Matrix to construct. */
					/* alpha - Rotation angle. */
					/* return - TRUE means a translation is required. */
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[][] rotation_matrix_2D_I = {{1, 0}, {0, 1}};
					public static boolean rotation_matrix_2D(double[][] R, double alpha)
					{
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double I[2][2] = {{1, 0}, {0, 1}};
						///#define ANGLE_TOLERANCE 0.001
						if (Math.abs(alpha) < DefineConstants.ANGLE_TOLERANCE)
						{
							/* Zero angle.  Unity rotation. */
							//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							memcpy(R, rotation_matrix_2D_I, sizeof(rotation_matrix_2D_I));
							return false;
						}
						else
						{
							R[0][0] = Math.cos(alpha);
							R[0][1] = -Math.sin(alpha);
							R[1][0] = Math.sin(alpha);
							R[1][1] = Math.cos(alpha);
							return true;
						}
					}

					/* Construct 3D rotation matrix. */
					/* P - Matrix to construct. */
					/* p - Pointer to perpendicular vector. */
					/* return - TRUE means a translation is required. */
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static double[][] rotation_matrix_3D_I = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
					public static boolean rotation_matrix_3D(double[][] P, double[] p)
					{
						//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
						//	static double I[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
						double scale;
						double C1;
						double C2;
						//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
						///#define x p[0]
						//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
						///#define y p[1]
						//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
						///#define z p[2]
						C1 = Math.sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]);
						C2 = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
						/* ????? Is there a precision constant for doubles similar to what is in limits.h for other types? */
						if ((C1 < 10e-10) || (C2 < (10e-5 * C1)))
						{
							/* Zero vector (invalid) || vector perpendiculat to x/y plane.  Unity rotation. */
							//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							memcpy(P, rotation_matrix_3D_I, sizeof(rotation_matrix_3D_I));
							return false;
						}
						else
						{
							scale = 1.0 / (C1 * C2);
							P[0][0] = p[0] * p[2] * scale;
							P[0][1] = -p[1] * C1 * scale;
							P[0][2] = p[0] * C2 * scale;
							P[1][0] = p[1] * p[2] * scale;
							P[1][1] = p[0] * C1 * scale;
							P[1][2] = p[1] * C2 * scale;
							P[2][0] = -C2 * C2 * scale;
							P[2][1] = 0;
							P[2][2] = p[2] * C2 * scale;
							return true;
						}
						//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
						///#undef x
						//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
						///#undef y
						//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
						///#undef z
					}
					public static int token2tuple(double tuple, int dimension)
					{
						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, DefineConstants.LEFT_TUPLE_CHAR) != 0)
						{
							boolean expecting_number = true;
							int N = 0;

							GlobalMembersCommand.c_token++;
							while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
							{
								if (expecting_number)
								{
									if (++N <= dimension)
										tuple++= GlobalMembersParse.real_expression();
									else
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "More than %d elements", N);
									expecting_number = false;
								}
								else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
								{
									GlobalMembersCommand.c_token++;
									expecting_number = true;
								}
								else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, DefineConstants.RIGHT_TUPLE_CHAR) != 0)
								{
									GlobalMembersCommand.c_token++;
									return N;
								}
								else
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expecting ',' or '" DefineConstants.RIGHT_TUPLE_CHAR "'");
							}
						}

						/* Not a tuple */
						return 0;
					}
					//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
					private static float df_determine_matrix_info_matrix = DefineConstants.NULL;
					public static void df_determine_matrix_info(FILE fin)
					{

						if (df_binary_file)
						{

							/* Binary matrix format. */
							float fdummy;
							int nc;
							int nr;
							int flength;

							/* Read first value for number of columns. */
							fdummy = GlobalMembersDatafile.df_read_a_float(fin);
							nc = ((int) fdummy);
							if (nc == 0)
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Read grid of zero width");
							else if (nc > 1e8)
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Read grid width too large");

							/* Read second value for corner_0 x. */
							fdummy = GlobalMembersDatafile.df_read_a_float(fin);
							df_matrix_corner[0][0] = fdummy;

							/* Read nc+1 value for corner_1 x. */
							if (nc > 1)
							{
								//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
								fseek(fin, (nc - 2) * sizeof(float), SEEK_CUR);
								fdummy = GlobalMembersDatafile.df_read_a_float(fin);
							}
							df_matrix_corner[1][0] = fdummy;

							/* Read nc+2 value for corner_0 y. */
							df_matrix_corner[0][1] = GlobalMembersDatafile.df_read_a_float(fin);

							/* Compute length of file and number of columns. */
							fseek(fin, 0, SEEK_END);
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							flength = ftell(fin) / sizeof(float);
							nr = flength / (nc + 1);
							if (nr * (nc + 1) != flength)
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "File doesn't factorize into full matrix");

							/* Read last value for corner_1 y */
							//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
							fseek(fin, -(nc + 1) * sizeof(float), SEEK_END);
							df_matrix_corner[1][1] = GlobalMembersDatafile.df_read_a_float(fin);

							/* Set up scan information for df_readbinary(). */
							df_bin_record[0].scan_dim[0] = nc;
							df_bin_record[0].scan_dim[1] = nr;

							/* Reset counter file pointer. */
							fseek(fin, 0, SEEK_SET);

						}
						else
						{

							/* ASCII matrix format, converted to binary memory format. */
							//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
							//	static float *matrix = DefineConstants.NULL;
							int nr;
							int nc;

							/* Insurance against creating a matrix with df_read_matrix()
							 * and then erroring out through df_add_binary_records().
							 */
							if (df_determine_matrix_info_matrix != 0F)
								//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
								free(df_determine_matrix_info_matrix);

							/* Set important binary variables, then free memory for all default
							 * binary records and set number of records to 0. */
							GlobalMembersDatafile.initialize_binary_vars();
							GlobalMembersDatafile.clear_binary_records(df_records_type.DF_CURRENT_RECORDS);

							/* Keep reading matrices until file is empty. */
							while (true)
							{
								if ((df_determine_matrix_info_matrix = GlobalMembersDatafile.df_read_matrix(nr, nc)) != DefineConstants.NULL)
								{
									int index = df_num_bin_records;
									/* *** Careful!  Could error out in next step.  "matrix" should
									 * be static and test next time. ***
									 */
									GlobalMembersDatafile.df_add_binary_records(1, df_records_type.DF_CURRENT_RECORDS);
									df_bin_record[index].memory_data = (String) df_determine_matrix_info_matrix;
									df_determine_matrix_info_matrix = DefineConstants.NULL;
									df_bin_record[index].scan_dim[0] = nc;
									df_bin_record[index].scan_dim[1] = nr;
									df_bin_record[index].scan_dim[2] = 0;
									df_bin_file_endianess = (((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN;
								}
								else
									break;
							}

							/* Data from file is now in memory.  Make the rest of gnuplot think
							 * that the data stream has not yet reached the end of file.
							 */
							df_eof = 0;

						}

					}
					public static void df_swap_bytes_by_endianess(String data, int read_order, int read_size)
					{
						///#if SUPPORT_MIDDLE_ENDIAN
						if ((read_order == df_byte_read_order_type.DF_3210.getValue()) || (read_order == df_byte_read_order_type.DF_2301.getValue()))
							///#else
							//    if ((read_order == DF_3210)
							///#endif
						{
							int j = 0;
							int k = read_size - 1;

							for (; j < k; j++, k--)
							{
								byte temp = data.charAt(j);

								data = tangible.StringFunctions.changeCharacter(data, j, data.charAt(k));
								data = tangible.StringFunctions.changeCharacter(data, k, temp);
							}
						}

						///#if SUPPORT_MIDDLE_ENDIAN
						if ((read_order == df_byte_read_order_type.DF_1032.getValue()) || (read_order == df_byte_read_order_type.DF_2301.getValue()))
						{
							int j = read_size - 1;

							for (; j > 0; j -= 2)
							{
								byte temp = data.charAt(j - 1);

								data = tangible.StringFunctions.changeCharacter(data, j - 1, data.charAt(j));
								data = tangible.StringFunctions.changeCharacter(data, j, temp);
							}
						}
						///#endif
					}

					/* Determine the 2D rotational matrix from the "rotation" qualifier. */
					public static void plot_option_multivalued(df_multivalue_type type, int arg)
					{
						int bin_record_count = 0;
						int test_val;

						/* Require equal symbol. */
						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, equal_symbol_msg);
						GlobalMembersCommand.c_token++;

						while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
						{
							double[] tuple = new double[3];

							switch (type)
							{
							case DF_ORIGIN:
							case DF_CENTER:
							case DF_PERPENDICULAR:
								//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
								//ORIGINAL LINE: test_val = token2tuple(tuple, sizeof(tuple)/sizeof(tuple[0]));
								test_val = GlobalMembersDatafile.token2tuple(tuple, tuple.length);
								break;
							case DF_SCAN:
							case DF_FLIP:
								/* Will check later */
								test_val = 1;
								break;
							default:
							{
								/* Check if a valid number. */
								tuple[0] = GlobalMembersParse.real_expression();
								test_val = 1;
							}
							}

							if (test_val != 0)
							{
								String cannot_flip_msg = "Cannot flip a non-existent dimension";
								String flip_list = new String(new char[4]);

								if (bin_record_count >= df_num_bin_records)
									GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "More parameters specified than data records specified");

								switch (type)
								{
								case DF_DELTA:
									/* Set the spacing between grid points in the
									 * specified dimension. */
									*(df_bin_record[bin_record_count].cart_delta + arg) = tuple[0];
									if (df_bin_record[bin_record_count].cart_delta[arg] <= 0)
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 2, "Sample period must be positive. Try `flip` for changing direction");
									break;

								case DF_FLIP_AXIS:
									/* Set the direction of grid points increment in
									 * the specified dimension. */
									if (df_bin_record[bin_record_count].cart_dim[0] != 0)
									{
										if (tuple[0] == 0.0)
											df_bin_record[bin_record_count].cart_dir[arg] = 0;
										else if (tuple[0] == 1.0)
											df_bin_record[bin_record_count].cart_dir[arg] = 1;
										else
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Flipping dimension direction must be 1 or 0");
									}
									else
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, cannot_flip_msg);
									break;

								case DF_FLIP:
									/* Set the direction of grid points increment in
									 * based upon letters for axes. Check if there are
									 * any characters in string that shouldn't be. */
									GlobalMembersUtil.copy_str(flip_list, GlobalMembersCommand.c_token, 4);
									if (flip_list.length() != strspn(flip_list, "xXyYzZ"))
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Can only flip x, y, and/or z");
									/* Check for valid dimensions. */
									if (strpbrk(flip_list, "xX"))
									{
										if (df_bin_record[bin_record_count].cart_dim[0] != 0)
											df_bin_record[bin_record_count].cart_dir[0] = arg;
										else
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, cannot_flip_msg);
									}
									if (strpbrk(flip_list, "yY"))
									{
										if (df_bin_record[bin_record_count].cart_dim[1] != 0)
											df_bin_record[bin_record_count].cart_dir[1] = arg;
										else
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, cannot_flip_msg);
									}
									if (strpbrk(flip_list, "zZ"))
									{
										if (df_bin_record[bin_record_count].cart_dim[2] != 0)
											df_bin_record[bin_record_count].cart_dir[2] = arg;
										else
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, cannot_flip_msg);
									}
									GlobalMembersCommand.c_token++;
									break;

								case DF_SCAN:
								{
									/* Set the method in which data is scanned from
									 * file.  Compare against a set number of strings.  */
									int i;

									if (!(df_bin_record[bin_record_count].cart_dim[0] != 0 || df_bin_record[bin_record_count].scan_dim[0] != 0) || !(df_bin_record[bin_record_count].cart_dim[1] != 0 || df_bin_record[bin_record_count].scan_dim[1] != 0))
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Cannot alter scanning method for one-dimensional data");
									else if (df_bin_record[bin_record_count].cart_dim[2] != 0 || df_bin_record[bin_record_count].scan_dim[2] != 0)
									{
										//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
										//ORIGINAL LINE: for (i = 0; i < sizeof(df_bin_scan_table_3D) /sizeof(df_bin_scan_table_3D_struct); i++)
										for (i = 0; i < df_bin_scan_table_3D.length; i++)
											if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, df_bin_scan_table_3D[i].string) != 0)
											{
												//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												memcpy(df_bin_record[bin_record_count].cart_scan, df_bin_scan_table_3D[i].scan, sizeof(df_bin_record[0].cart_scan));
												break;
											}
										//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
										//ORIGINAL LINE: if (i == sizeof(df_bin_scan_table_3D) / sizeof(df_bin_scan_table_3D_struct))
										if (i == df_bin_scan_table_3D.length)
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Improper scanning string. Try 3 character string for 3D data");
									}
									else
									{
										//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
										//ORIGINAL LINE: for (i = 0; i < sizeof(df_bin_scan_table_2D) /sizeof(df_bin_scan_table_2D_struct); i++)
										for (i = 0; i < df_bin_scan_table_2D.length; i++)
											if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, df_bin_scan_table_2D[i].string) != 0)
											{
												//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												memcpy(df_bin_record[bin_record_count].cart_scan, df_bin_scan_table_2D[i].scan, sizeof(df_bin_record[0].cart_scan));
												break;
											}
										//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
										//ORIGINAL LINE: if (i == sizeof(df_bin_scan_table_2D) / sizeof(df_bin_scan_table_2D_struct))
										if (i == df_bin_scan_table_2D.length)
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Improper scanning string. Try 2 character string for 2D data");
									}
									/* Remove the file supplied scan direction. */
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
									//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
									memcpy(df_bin_record[bin_record_count].scan_dir, df_bin_record_reset.scan_dir, sizeof(df_bin_record[0].scan_dir));
									GlobalMembersCommand.c_token++;
									break;
								}

								case DF_SKIP:
									/* Set the number of bytes to skip before reading
									 * record. */
									df_bin_record[bin_record_count].scan_skip[0] = tuple[0];
									if ((df_bin_record[bin_record_count].scan_skip[0] != tuple[0]) || (df_bin_record[bin_record_count].scan_skip[0] < 0))
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Number of bytes to skip must be positive integer");
									break;

								case DF_ORIGIN:
								case DF_CENTER:
									/* Set the origin or center of the image based upon
									 * the plot mode. */
									if (type == df_multivalue_type.DF_ORIGIN)
										df_bin_record[bin_record_count].cart_trans = df_translation_type.DF_TRANSLATE_VIA_ORIGIN;
									else
										df_bin_record[bin_record_count].cart_trans = df_translation_type.DF_TRANSLATE_VIA_CENTER;
									if (arg == MODE_PLOT_TYPE.MODE_PLOT.getValue())
									{
										if (test_val != 2)
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Two-dimensional tuple required for 2D plot");
										tuple[2] = 0.0;
									}
									else if (arg == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
									{
										if (test_val != 3)
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Three-dimensional tuple required for 3D plot");
									}
									else if (arg == MODE_PLOT_TYPE.MODE_QUERY.getValue())
									{
										if (test_val != 3)
											GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Three-dimensional tuple required for setting binary parameters");
									}
									else
									{
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Internal error (datafile.c): Unknown plot mode");
									}
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
									//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
									memcpy(df_bin_record[bin_record_count].cart_cen_or_ori, tuple, sizeof(tuple));
									break;

								case DF_ROTATION:
									/* Allow user to enter angle in terms of pi or degrees. */
									if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pi") != 0)
									{
										tuple[0] *= DefineConstants.M_PI;
										GlobalMembersCommand.c_token++;
									}
									else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "d$egrees") != 0)
									{
										tuple[0] *= DefineConstants.M_PI / 180;
										GlobalMembersCommand.c_token++;
									}
									/* Construct 2D rotation matrix. */
									df_bin_record[bin_record_count].cart_alpha = tuple[0];
									break;

								case DF_PERPENDICULAR:
									/* Make sure in three dimensional plotting mode before
									 * accepting the perpendicular vector for translation. */
									if (test_val != 3)
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Three-dimensional tuple required");
									/* Compare vector length against variable precision
									 * to determine if this is the null vector */
									if ((tuple[0] * tuple[0] + tuple[1] * tuple[1] + tuple[2] * tuple[2]) < 100.*DefineConstants.DBL_EPSILON)
										GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Perpendicular vector cannot be zero");
									//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
									//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
									memcpy(df_bin_record[bin_record_count].cart_p, tuple, sizeof(tuple));
									break;

								default:
									GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Internal error: Invalid comma separated type");
								} // switch()
							}
							else
							{
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Invalid numeric or tuple form");
							}

							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, DefineConstants.TUPLE_SEPARATOR_CHAR) != 0)
							{
								bin_record_count++;
								GlobalMembersCommand.c_token++;
							}
							else
								break;

						} // while(!EOC)

						return;
					}

					public static String[] df_endian = {"little", "pdp (middle)", "swapped pdp (dimmle)", "big"};

					/* First argument, this program's endianess.  Second argument, file's endianess.
					 * Don't use directly.  Use 'byte_read_order()' function instead.*/
					public static byte[][] df_byte_read_order_map = {{(byte) df_byte_read_order_type.DF_0123.getValue(), (byte) df_byte_read_order_type.DF_1032.getValue(), (byte) df_byte_read_order_type.DF_2301.getValue(), (byte) df_byte_read_order_type.DF_3210.getValue()}, {(byte) df_byte_read_order_type.DF_1032.getValue(), (byte) df_byte_read_order_type.DF_0123.getValue(), (byte) df_byte_read_order_type.DF_1032.getValue(), (byte) df_byte_read_order_type.DF_2301.getValue()}, {(byte) df_byte_read_order_type.DF_2301.getValue(), (byte) df_byte_read_order_type.DF_1032.getValue(), (byte) df_byte_read_order_type.DF_0123.getValue(), (byte) df_byte_read_order_type.DF_1032.getValue()}, {(byte) df_byte_read_order_type.DF_3210.getValue(), (byte) df_byte_read_order_type.DF_2301.getValue(), (byte) df_byte_read_order_type.DF_1032.getValue(), (byte) df_byte_read_order_type.DF_0123.getValue()}};

					public static int long_0x2468 = 0x2468;
					//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
					///#define TEST_BIG_PDP ( (((char *)&long_0x2468)[0] < 3) ? DF_BIG_ENDIAN : DF_PDP_ENDIAN )
					//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
					///#define THIS_COMPILER_ENDIAN ( (((char *)&long_0x2468)[0] < 5) ? TEST_BIG_PDP : DF_LITTLE_ENDIAN )


					/* Argument is file's endianess type. */
					public static df_byte_read_order_type byte_read_order(df_endianess_type file_endian)
					{
						/* Range limit file endianess to ensure that future file type function
						 * programmer doesn't incorrectly access array and cause segmentation
						 * fault unknowingly.
						 */
						return df_byte_read_order_map[(((String) & long_0x2468)[0] < 5) ? (((String) & long_0x2468)[0] < 3) ? df_endianess_type.DF_BIG_ENDIAN : df_endianess_type.DF_PDP_ENDIAN : df_endianess_type.DF_LITTLE_ENDIAN][((file_endian) < (df_endianess_type.DF_ENDIAN_TYPE_LENGTH - 1) ? (file_endian) : (df_endianess_type.DF_ENDIAN_TYPE_LENGTH - 1))];
					}

					/* Logical variables indicating information about data file. */
					public static boolean df_binary_file;
					public static boolean df_matrix_file;

					public static int df_M_count;
					public static int df_N_count;
					public static int df_O_count;

					/* Initially set to default and then possibly altered by command line. */
					public static df_binary_file_record_struct df_bin_record = null;
					/* Default settings. */
					public static df_binary_file_record_struct df_bin_record_default = null;
					/* Settings that are transferred to default upon reset. */
					public static df_binary_file_record_struct df_bin_record_reset = new df_binary_file_record_struct({-1, 0, 0}, {1, 1, 1}, {1, 1, 1}, df_translation_type.DF_TRANSLATE_DEFAULT, {0, 0, 0}, 0, {0, 0, 1}, {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE}, false, {0, 0, 0}, {0, 0, 0}, {1, 1, 1}, {0, 0, 0}, df_translation_type.DF_TRANSLATE_DEFAULT, {0, 0, 0}, DefineConstants.NULL);

					public static int df_max_num_bin_records = 0;
					public static int df_num_bin_records;
					public static int df_bin_record_count;
					public static int df_max_num_bin_records_default = 0;
					public static int df_num_bin_records_default;

					public static void gpbin_filetype_function()
					{
						/* Gnuplot binary. */
						df_matrix_file = true;
						df_binary_file = true;
					}
					public static void raw_filetype_function()
					{
						/* No information in file, just data. */
						df_matrix_file = false;
						df_binary_file = true;
					}
					public static void avs_filetype_function()
					{
						/* A very simple file format:
						 * 8 byte header (width and height, 4 bytes each), unknown endian
						 * followed by 4 bytes per pixel (alpha, red, green, blue).
						 */

						FILE fp;
						int M;
						int N;
						int read_order = 0;

						/* open (header) file */
						fp = GlobalMembersMisc.loadpath_fopen(df_filename, "rb");
						if (fp == null)
							GlobalMembersUtil.os_error(DefineConstants.NO_CARET, "Can't open data file \"%s\"", df_filename);

						/* read header: it is only 8 bytes */
						if (!fread(M, 4, 1, fp))
							GlobalMembersUtil.os_error(DefineConstants.NO_CARET, "Can't read first dimension in data file \"%s\"", df_filename);
						if (M > 0xFFFF)
							read_order = df_byte_read_order_type.DF_3210.getValue();
						GlobalMembersDatafile.df_swap_bytes_by_endianess((String) & M, read_order, 4);
						if (!fread(N, 4, 1, fp))
							GlobalMembersUtil.os_error(DefineConstants.NO_CARET, "Can't read second dimension in data file \"%s\"", df_filename);
						GlobalMembersDatafile.df_swap_bytes_by_endianess((String) & N, read_order, 4);

						fclose(fp);

						df_matrix_file = false;
						df_binary_file = true;

						df_bin_record[0].scan_skip[0] = 8;
						df_bin_record[0].scan_dim[0] = M;
						df_bin_record[0].scan_dim[1] = N;

						df_bin_record[0].scan_dir[0] = 1;
						df_bin_record[0].scan_dir[1] = -1;
						df_bin_record[0].scan_generate_coord = true;
						df_bin_record[0].cart_scan[0] = df_sample_scan_type.DF_SCAN_POINT;
						df_bin_record[0].cart_scan[1] = df_sample_scan_type.DF_SCAN_LINE;

						/* The four components are 1 byte each. Permute ARGB to RGBA */
						GlobalMembersDatafile.df_extend_binary_columns(4);
						GlobalMembersDatafile.df_set_read_type(1, df_data_type.DF_UCHAR);
						GlobalMembersDatafile.df_set_read_type(2, df_data_type.DF_UCHAR);
						GlobalMembersDatafile.df_set_read_type(3, df_data_type.DF_UCHAR);
						GlobalMembersDatafile.df_set_read_type(4, df_data_type.DF_UCHAR);
						GlobalMembersDatafile.df_set_skip_before(1, 0);

						df_no_use_specs = 4;
						use_spec[0].column = 2;
						use_spec[1].column = 3;
						use_spec[2].column = 4;
						use_spec[3].column = 1;

					}
					public static void auto_filetype_function() // Just a placeholder for auto
					{
					}

					public static gen_ftable[] df_bin_filetype_table = {new gen_ftable("avs", avs_filetype_function), new gen_ftable("bin", raw_filetype_function), new gen_ftable("edf", edf_filetype_function), new gen_ftable("ehf", edf_filetype_function), new gen_ftable("gif", gif_filetype_function), new gen_ftable("gpbin", gpbin_filetype_function), new gen_ftable("jpeg", jpeg_filetype_function), new gen_ftable("jpg", jpeg_filetype_function), new gen_ftable("png", png_filetype_function), new gen_ftable("raw", raw_filetype_function), new gen_ftable("rgb", raw_filetype_function), new gen_ftable("auto", auto_filetype_function), new gen_ftable(DefineConstants.NULL, DefineConstants.NULL)};
					///#define RAW_FILETYPE 1

					/* Initially set to default and then possibly altered by command line. */
					public static int df_bin_filetype;
					public static df_endianess_type df_bin_file_endianess;
					/* Default setting. */
					public static int df_bin_filetype_default;
					public static df_endianess_type df_bin_file_endianess_default;
					/* Setting that is transferred to default upon reset. */
					public static int df_bin_filetype_reset = -1;

					public static df_bin_scan_table_2D_struct[] df_bin_scan_table_2D = { new df_bin_scan_table_2D_struct("xy", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, "yx", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE, "tr", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, "rt", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE) };

					public static df_bin_scan_table_3D_struct[] df_bin_scan_table_3D = { new df_bin_scan_table_3D_struct("xyz", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, "zxy", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_POINT, "yzx", {df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, "yxz", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE, "xzy", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_LINE, "zyx", {df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT, "trz", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, "ztr", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_POINT, "rzt", {df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_LINE, "rtz", {df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE, "tzr", {df_sample_scan_type.DF_SCAN_POINT, df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_LINE, "zrt", {df_sample_scan_type.DF_SCAN_PLANE, df_sample_scan_type.DF_SCAN_LINE, df_sample_scan_type.DF_SCAN_POINT) };

					/* Names for machine dependent field sizes. */
					public static String[] ch_names = {"char","schar","c"};
					public static String[] uc_names = {"uchar"};
					public static String[] sh_names = {"short"};
					public static String[] us_names = {"ushort"};
					public static String[] in_names = {"int","sint","i","d"};
					public static String[] ui_names = {"uint","u"};
					public static String[] lo_names = {"long","ld"};
					public static String[] ul_names = {"ulong","lu"};
					public static String[] fl_names = {"float","f"};
					public static String[] db_names = {"double","lf"};

					/* Machine independent names. */
					public static String[] byte_names = {"int8","byte"};
					public static String[] ubyte_names = {"uint8","ubyte"};
					public static String[] word_names = {"int16","word"};
					public static String[] uword_names = {"uint16","uword"};
					public static String[] word2_names = {"int32"};
					public static String[] uword2_names = {"uint32"};
					public static String[] word4_names = {"int64"};
					public static String[] uword4_names = {"uint64"};
					public static String[] float_names = {"float32"};
					public static String[] float2_names = {"float64"};

					//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
					//ORIGINAL LINE: df_binary_details_struct df_binary_details[] = { {ch_names,sizeof(ch_names)/sizeof(ch_names[0]),{DF_CHAR,sizeof(sbyte)}}, {uc_names,sizeof(uc_names)/sizeof(uc_names[0]),{DF_UCHAR,sizeof(byte)}}, {sh_names,sizeof(sh_names)/sizeof(sh_names[0]),{DF_SHORT,sizeof(short)}}, {us_names,sizeof(us_names)/sizeof(us_names[0]),{DF_USHORT,sizeof(short)}}, {in_names,sizeof(in_names)/sizeof(in_names[0]),{DF_INT,sizeof(int)}}, {ui_names,sizeof(ui_names)/sizeof(ui_names[0]),{DF_UINT,sizeof(int)}}, {lo_names,sizeof(lo_names)/sizeof(lo_names[0]),{DF_LONG,sizeof(int)}}, {ul_names,sizeof(ul_names)/sizeof(ul_names[0]),{DF_ULONG,sizeof(int)}}, {fl_names,sizeof(fl_names)/sizeof(fl_names[0]),{DF_FLOAT,sizeof(float)}}, {db_names,sizeof(db_names)/sizeof(db_names[0]),{DF_DOUBLE,sizeof(double)}} };
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					public static df_binary_details_struct[] df_binary_details = { new df_binary_details_struct(ch_names, ch_names.length, {df_data_type.DF_CHAR,sizeof(byte), uc_names, uc_names.length, {df_data_type.DF_UCHAR,sizeof(byte), sh_names, sh_names.length, {df_data_type.DF_SHORT,sizeof(short), us_names, us_names.length, {df_data_type.DF_USHORT,sizeof(short), in_names, in_names.length, {df_data_type.DF_INT,sizeof(int), ui_names, ui_names.length, {df_data_type.DF_UINT,sizeof(int), lo_names, lo_names.length, {df_data_type.DF_LONG,sizeof(int), ul_names, ul_names.length, {df_data_type.DF_ULONG,sizeof(int), fl_names, fl_names.length, {df_data_type.DF_FLOAT,sizeof(float), db_names, db_names.length, {df_data_type.DF_DOUBLE,sizeof(double)) };

					//C++ TO JAVA CONVERTER TODO TASK: Java does not allow bit fields:
					//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
					//ORIGINAL LINE: df_binary_details_struct df_binary_details_independent[] = { {byte_names,sizeof(byte_names)/sizeof(byte_names[0]),{((1)==sizeof(int) ? DF_LONG : ((1)==sizeof(long) ? DF_LONGLONG : ((1)==sizeof(int) ? DF_INT : ((1)==sizeof(short) ? DF_SHORT : ((1)==sizeof(sbyte) ? DF_CHAR : DF_BAD_TYPE))))),1}}, {ubyte_names,sizeof(ubyte_names)/sizeof(ubyte_names[0]),{((1)==sizeof(int) ? DF_ULONG : ((1)==sizeof(long) ? DF_ULONGLONG : ((1)==sizeof(int) ? DF_UINT : ((1)==sizeof(short) ? DF_USHORT : ((1)==sizeof(byte) ? DF_UCHAR : DF_BAD_TYPE))))),1}}, {word_names,sizeof(word_names)/sizeof(word_names[0]),{((2)==sizeof(int) ? DF_LONG : ((2)==sizeof(long) ? DF_LONGLONG : ((2)==sizeof(int) ? DF_INT : ((2)==sizeof(short) ? DF_SHORT : ((2)==sizeof(sbyte) ? DF_CHAR : DF_BAD_TYPE))))),2}}, {uword_names,sizeof(uword_names)/sizeof(uword_names[0]),{((2)==sizeof(int) ? DF_ULONG : ((2)==sizeof(long) ? DF_ULONGLONG : ((2)==sizeof(int) ? DF_UINT : ((2)==sizeof(short) ? DF_USHORT : ((2)==sizeof(byte) ? DF_UCHAR : DF_BAD_TYPE))))),2}}, {word2_names,sizeof(word2_names)/sizeof(word2_names[0]),{((4)==sizeof(int) ? DF_LONG : ((4)==sizeof(long) ? DF_LONGLONG : ((4)==sizeof(int) ? DF_INT : ((4)==sizeof(short) ? DF_SHORT : ((4)==sizeof(sbyte) ? DF_CHAR : DF_BAD_TYPE))))),4}}, {uword2_names,sizeof(uword2_names)/sizeof(uword2_names[0]),{((4)==sizeof(int) ? DF_ULONG : ((4)==sizeof(long) ? DF_ULONGLONG : ((4)==sizeof(int) ? DF_UINT : ((4)==sizeof(short) ? DF_USHORT : ((4)==sizeof(byte) ? DF_UCHAR : DF_BAD_TYPE))))),4}}, {word4_names,sizeof(word4_names)/sizeof(word4_names[0]),{((8)==sizeof(int) ? DF_LONG : ((8)==sizeof(long) ? DF_LONGLONG : ((8)==sizeof(int) ? DF_INT : ((8)==sizeof(short) ? DF_SHORT : ((8)==sizeof(sbyte) ? DF_CHAR : DF_BAD_TYPE))))),8}}, {uword4_names,sizeof(uword4_names)/sizeof(uword4_names[0]),{((8)==sizeof(int) ? DF_ULONG : ((8)==sizeof(long) ? DF_ULONGLONG : ((8)==sizeof(int) ? DF_UINT : ((8)==sizeof(short) ? DF_USHORT : ((8)==sizeof(byte) ? DF_UCHAR : DF_BAD_TYPE))))),8}}, {float_names,sizeof(float_names)/sizeof(float_names[0]),{((4)==sizeof(float) ? DF_FLOAT : ((4)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE)),4}}, {float2_names,sizeof(float2_names)/sizeof(float2_names[0]),{((8)==sizeof(float) ? DF_FLOAT : ((8)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE)),8}} };
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					public static df_binary_details_struct df_binary_details_independent[] = {{byte_names,byte_names.length,{((1) == sizeof(int) ? df_data_type.DF_LONG : ((1) == sizeof(long) ? df_data_type.DF_LONGLONG : ((1) == sizeof(int) ? df_data_type.DF_INT : ((1) == sizeof(short) ? df_data_type.DF_SHORT : ((1) == sizeof(byte) ? df_data_type.DF_CHAR : df_data_type.DF_BAD_TYPE))))),1}}, {ubyte_names,ubyte_names.length,{((1) == sizeof(int) ? df_data_type.DF_ULONG : ((1) == sizeof(long) ? df_data_type.DF_ULONGLONG : ((1) == sizeof(int) ? df_data_type.DF_UINT : ((1) == sizeof(short) ? df_data_type.DF_USHORT : ((1) == sizeof(byte) ? df_data_type.DF_UCHAR : df_data_type.DF_BAD_TYPE))))),1}}, {word_names,word_names.length,{((2) == sizeof(int) ? df_data_type.DF_LONG : ((2) == sizeof(long) ? df_data_type.DF_LONGLONG : ((2) == sizeof(int) ? df_data_type.DF_INT : ((2) == sizeof(short) ? df_data_type.DF_SHORT : ((2) == sizeof(byte) ? df_data_type.DF_CHAR : df_data_type.DF_BAD_TYPE))))),2}}, {uword_names,uword_names.length,{((2) == sizeof(int) ? df_data_type.DF_ULONG : ((2) == sizeof(long) ? df_data_type.DF_ULONGLONG : ((2) == sizeof(int) ? df_data_type.DF_UINT : ((2) == sizeof(short) ? df_data_type.DF_USHORT : ((2) == sizeof(byte) ? df_data_type.DF_UCHAR : df_data_type.DF_BAD_TYPE))))),2}}, {word2_names,word2_names.length,{((4) == sizeof(int) ? df_data_type.DF_LONG : ((4) == sizeof(long) ? df_data_type.DF_LONGLONG : ((4) == sizeof(int) ? df_data_type.DF_INT : ((4) == sizeof(short) ? df_data_type.DF_SHORT : ((4) == sizeof(byte) ? df_data_type.DF_CHAR : df_data_type.DF_BAD_TYPE))))),4}}, {uword2_names,uword2_names.length,{((4) == sizeof(int) ? df_data_type.DF_ULONG : ((4) == sizeof(long) ? df_data_type.DF_ULONGLONG : ((4) == sizeof(int) ? df_data_type.DF_UINT : ((4) == sizeof(short) ? df_data_type.DF_USHORT : ((4) == sizeof(byte) ? df_data_type.DF_UCHAR : df_data_type.DF_BAD_TYPE))))),4}}, {word4_names,word4_names.length,{((8) == sizeof(int) ? df_data_type.DF_LONG : ((8) == sizeof(long) ? df_data_type.DF_LONGLONG : ((8) == sizeof(int) ? df_data_type.DF_INT : ((8) == sizeof(short) ? df_data_type.DF_SHORT : ((8) == sizeof(byte) ? df_data_type.DF_CHAR : df_data_type.DF_BAD_TYPE))))),8}}, {uword4_names,uword4_names.length,{((8) == sizeof(int) ? df_data_type.DF_ULONG : ((8) == sizeof(long) ? df_data_type.DF_ULONGLONG : ((8) == sizeof(int) ? df_data_type.DF_UINT : ((8) == sizeof(short) ? df_data_type.DF_USHORT : ((8) == sizeof(byte) ? df_data_type.DF_UCHAR : df_data_type.DF_BAD_TYPE))))),8}}, {float_names,float_names.length,{((4) == sizeof(float) ? df_data_type.DF_FLOAT : ((4) == sizeof(double) ? df_data_type.DF_DOUBLE : df_data_type.DF_BAD_TYPE)),4}}, {float2_names,float2_names.length,{((8) == sizeof(float) ? df_data_type.DF_FLOAT : ((8) == sizeof(double) ? df_data_type.DF_DOUBLE : df_data_type.DF_BAD_TYPE)),8}}};

					public static int df_no_bin_cols; // binary columns to read

					//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
					//ORIGINAL LINE: df_binary_tables_struct df_binary_tables[] = { {df_binary_details,sizeof(df_binary_details)/sizeof(df_binary_details[0])}, {df_binary_details_independent,sizeof(df_binary_details_independent)/sizeof(df_binary_details_independent[0])} };
					public static df_binary_tables_struct[] df_binary_tables = {new df_binary_tables_struct(df_binary_details, df_binary_details.length), new df_binary_tables_struct(df_binary_details_independent, df_binary_details_independent.length)};

					/* Information about binary data structure, to be determined by the
					 * using and format options.  This should be one greater than df_no_bin_cols.
					 */
					public static df_column_bininfo_struct df_column_bininfo = DefineConstants.NULL; // allocate space as needed
					public static int df_max_bininfo_cols = 0; // space allocated

					public static String matrix_general_binary_conflict_msg = "Conflict between some matrix binary and general binary keywords";
					/*}}} */


					public static String read_error_msg = "Data file read error";
					public static double[][] df_matrix_corner = new double[2][2]; // First argument is corner, second argument is x (0) or y(1).

					public static float df_read_a_float(FILE fin)
					{
						float fdummy;
						//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
						if (fread(fdummy, sizeof(fdummy), 1, fin) != 1)
						{
							if (feof(fin))
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Data file is empty");
							else
								GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, read_error_msg);
						}
						//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
						GlobalMembersDatafile.df_swap_bytes_by_endianess((String) & fdummy, GlobalMembersDatafile.byte_read_order(df_bin_file_endianess), sizeof(fdummy));
						return fdummy;
					}


					public static String too_many_cols_msg = "Too many columns in using specification and implied sampling array";
					///#ifdef EAM_OBJECTS
					///#endif
					public static df_bin_default_columns[] default_style_cols = {new df_bin_default_columns(PLOT_STYLE.LINES, 1, 1), new df_bin_default_columns(PLOT_STYLE.POINTSTYLE, 1, 1), new df_bin_default_columns(PLOT_STYLE.IMPULSES, 1, 1), new df_bin_default_columns(PLOT_STYLE.LINESPOINTS, 1, 1), new df_bin_default_columns(PLOT_STYLE.DOTS, 1, 1), new df_bin_default_columns(PLOT_STYLE.XERRORBARS, 2, 1), new df_bin_default_columns(PLOT_STYLE.YERRORBARS, 2, 1), new df_bin_default_columns(PLOT_STYLE.XYERRORBARS, 3, 1), new df_bin_default_columns(PLOT_STYLE.BOXXYERROR, 3, 1), new df_bin_default_columns(PLOT_STYLE.BOXES, 1, 1), new df_bin_default_columns(PLOT_STYLE.BOXERROR, 3, 1), new df_bin_default_columns(PLOT_STYLE.STEPS, 1, 1), new df_bin_default_columns(PLOT_STYLE.FSTEPS, 1, 1), new df_bin_default_columns(PLOT_STYLE.HISTEPS, 1, 1), new df_bin_default_columns(PLOT_STYLE.VECTOR, 2, 2), new df_bin_default_columns(PLOT_STYLE.CANDLESTICKS, 4, 1), new df_bin_default_columns(PLOT_STYLE.FINANCEBARS, 4, 1), new df_bin_default_columns(PLOT_STYLE.XERRORLINES, 2, 1), new df_bin_default_columns(PLOT_STYLE.YERRORLINES, 2, 1), new df_bin_default_columns(PLOT_STYLE.XYERRORLINES, 3, 1), new df_bin_default_columns(PLOT_STYLE.FILLEDCURVES, 1, 1), new df_bin_default_columns(PLOT_STYLE.PM3DSURFACE, 1, 2), new df_bin_default_columns(PLOT_STYLE.LABELPOINTS, 2, 1), new df_bin_default_columns(PLOT_STYLE.HISTOGRAMS, 1, 0), new df_bin_default_columns(PLOT_STYLE.IMAGE, 1, 2), new df_bin_default_columns(PLOT_STYLE.RGBIMAGE, 3, 2), new df_bin_default_columns(PLOT_STYLE.RGBA_IMAGE, 4, 2), new df_bin_default_columns(PLOT_STYLE.CIRCLES, 2, 1)};

					public static String equal_symbol_msg = "Equal ('=') symbol required";
					}