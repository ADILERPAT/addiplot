package com.addiPlot.gnuplot;

public class GlobalMembersAxis
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: axis.c,v 1.77.2.4 2009/11/04 16:11:25 mikulik Exp $");
	}
	///#endif

	/* Function pointer type for callback functions doing operations for a
	 * single ticmark */
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//typedef void(*tic_callback NamelessParameter) __PROTO((AXIS_INDEX, double, sbyte *, struct lp_style_type, struct ticmark *));



	/* global variables in axis.c */

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern axis axis_array[DefineConstants.AXIS_ARRAY_SIZE];
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const axis_defaults axis_defaults[DefineConstants.AXIS_ARRAY_SIZE];

	/* A parsing table for mapping axis names into axis indices. For use
	 * by the set/show machinery, mainly */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const struct gen_table axisname_tbl[DefineConstants.AXIS_ARRAY_SIZE+1];


//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const struct ticdef default_axis_ticdef;

	/* default format for tic mark labels */
	///#define DEF_FORMAT "% g"

	/* default parse timedata string */
	///#define TIMEFMT "%d/%m/%y,%H:%M"

	/* axis labels */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const text_label default_axis_label;

	/* zeroaxis linetype (flag type==-3 if none wanted) */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const lp_style_type default_axis_zeroaxis;

	/* default grid linetype, to be used by 'unset grid' and 'reset' */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const struct lp_style_type default_grid_lp;

	/* grid layer: -1 default, 0 back, 1 front */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int grid_layer;

	/* global variables for communication with the tic callback functions */
	/* FIXME HBB 20010806: had better be collected into a struct that's
	 * passed to the callback */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int tic_start, tic_direction, tic_mirror;
	/* These are for passing on to write_multiline(): */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int tic_text, rotate_tics, tic_hjust, tic_vjust;
	/* The remaining ones are for grid drawing; controlled by 'set grid': */
	/* extern int grid_selection; --- comm'ed out, HBB 20010806 */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct lp_style_type grid_lp; // linestyle for major grid lines
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct lp_style_type mgrid_lp; // linestyle for minor grid lines
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern double polar_grid_angle; // angle step in polar grid in radians

	/* Length of the longest tics label, set by widest_tic_callback(): */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int widest_tic_strlen;

	/* axes being used by the current plot */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern AXIS_INDEX x_axis, y_axis, z_axis;
/* }}} */


/* {{{ load_range() */
/* loads a range specification from the input line into variables 'a'
 * and 'b' */
	/* macros to reduce code clutter caused by the array notation, mainly
	 * in graphics.c and fit.c */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]

	/* -------- macros using these variables: */

	/* Macros to map from user to terminal coordinates and back */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)

	/* these are the old names for these: */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)

	/* write current min/max_array contents into the set/show status
	 * variables */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)

	/* HBB 20000430: New macros, logarithmize a value into a stored
	 * coordinate*/
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)

	/* HBB 20000430: same, but these test if the axis is log, first: */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))


	/* copy scalar data to arrays. The difference between 3D and 2D
	 * versions is: dont know we have to support ranges [10:-10] - lets
	 * reverse it for now, then fix it at the end.  */
	/* FIXME HBB 20000426: unknown if this distinction makes any sense... */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)

	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	/* why multiply by 1e-3: if an already VERYLARGE x2 and y2 ranges are
	   calculated after zoom-out by mouse, then they would become even larger
	*/

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)

	///#endif
	/* handle reversed ranges */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)

	/* HBB NEW 20050316: macros to always access the actual minimum, even
	 * if 'set view map' or something else flipped things around behind
	 * our back */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)

	/* HBB 20000725: new macro, built upon ULIG's SAVE_WRITEBACK(axis),
	 * but easier to use. Code like this occured twice, in plot2d and
	 * plot3d: */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)

	/* get optional [min:max] */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)

	/* HBB 20000430: new macro, like PARSE_RANGE, but for named ranges as
	 * in 'plot [phi=3.5:7] sin(phi)' */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)

	/* parse a position of the form
	 *    [coords] x, [coords] y {,[coords] z}
	 * where coords is one of first,second.graph,screen,character
	 * if first or second, we need to take axis_is_timedata into account
	 */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)

	/* This is one is very similar to GET_NUMBER_OR_TIME, but has slightly
	 * different usage: it writes out '0' in case of inparsable time data,
	 * and it's used when the target axis is fixed without a 'first' or
	 * 'second' keyword in front of it. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);

	/* store VALUE or log(VALUE) in STORE, set TYPE as appropriate
	 * Do OUT_ACTION or UNDEF_ACTION as appropriate
	 * adjust range provided type is INRANGE (ie dont adjust y if x is outrange
	 * VALUE must not be same as STORE
	 * NOAUTOSCALE is per-plot property, whereas AUTOSCALE_XXX is per-axis.
	 * Note: see the particular implementation for COLOR AXIS below.
	 */

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)

	/* Implementation of the above for the color axis. It should not change
	 * the type of the point (out-of-range color is plotted with the color
	 * of the min or max color value).
	 */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }

	/* Empty macro arguments triggered NeXT cpp bug       */
	/* #define NOOP (0) caused many warnings from gcc 3.2 */
	/* Now trying ((void)0) */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)

	/* HBB 20000506: new macro, initializes one variable to the same
	 * value, for all axes. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)

	/* HBB 20000506: new macro to automatically build intializer lists
	 * for arrays of AXIS_ARRAY_SIZE equal elements */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }

	/* used by set.c */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }


	/* 'roundoff' check tolerance: less than one hundredth of a tic mark */
	///#define SIGNIF (0.01)
	/* (DFK) Watch for cancellation error near zero on axes labels */
	/* FIXME HBB 20000521: these seem not to be used much, anywhere... */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))


	/* ------------ functions exported by axis.c */
	public static e_autoscale load_range(AXIS_INDEX axis, double a, double b, e_autoscale autoscale)
	{
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "]") != 0)
		return (autoscale);

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "starting range value or ':' or 'to' expected");
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") == 0)
		{
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "*") != 0)
		{
			autoscale |= e_autoscale.AUTOSCALE_MIN;
			GlobalMembersCommand.c_token++;
		}
		else
		{
			do
			{
				a = 0;
				do
				{
					if (((DefineConstants.FIRST_AXES) >= 0) && (axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					{
						tm tm = new tm();
						byte ss = GlobalMembersUtil.try_to_get_string();
						if (GlobalMembersTime.gstrptime(ss, axis_array[axis.getValue()].timefmt, tm) != null)
							a = (double) GlobalMembersTime.gtimegm(tm);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
							free(ss);
					}
					else
					{
						a = GlobalMembersParse.real_expression();
					}
				} while (0);
			} while (0);
			autoscale &= ~e_autoscale.AUTOSCALE_MIN;
		}
		}

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ":") == 0)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "':' or keyword 'to' expected");
		GlobalMembersCommand.c_token++;

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "]") == 0)
		{
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "*") != 0)
		{
			autoscale |= e_autoscale.AUTOSCALE_MAX;
			GlobalMembersCommand.c_token++;
		}
		else
		{
			do
			{
				b = 0;
				do
				{
					if (((DefineConstants.FIRST_AXES) >= 0) && (axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					{
						tm tm = new tm();
						byte ss = GlobalMembersUtil.try_to_get_string();
						if (GlobalMembersTime.gstrptime(ss, axis_array[axis.getValue()].timefmt, tm) != null)
							b = (double) GlobalMembersTime.gtimegm(tm);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
							free(ss);
					}
					else
					{
						b = GlobalMembersParse.real_expression();
					}
				} while (0);
			} while (0);
			autoscale &= ~e_autoscale.AUTOSCALE_MAX;
		}
		}

		/* HBB 20030127: If range input backwards, automatically turn on
		   the "reverse" option, too. */
		if ((autoscale & e_autoscale.AUTOSCALE_BOTH) == e_autoscale.AUTOSCALE_NONE)
		{
		  if (b < a)
		  {
		double temp = a;

		a = b;
		b = temp;
		axis_array[axis.getValue()].range_flags |= RANGE_REVERSE;
		  }
		}

		return (autoscale);
	}

/* {{{ axis_unlog_interval() */

/* this is used in a few places all over the code: undo logscaling of
 * a given range if necessary. If checkrange is TRUE, will int_error() if
 * range is invalid */
	public static void axis_unlog_interval(AXIS_INDEX axis, double min, double max, boolean checkrange)
	{
		if (axis_array[axis.getValue()].log)
		{
		if (checkrange && (min <= 0.0 || max <= 0.0))
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "%s range must be greater than 0 for log scale", axis_defaults[axis.getValue()].name);
		min = (min <= 0) ? - DefineConstants.VERYLARGE : (Math.log(min) / axis_array[axis.getValue()].log_base);
		max = (max <= 0) ? - DefineConstants.VERYLARGE : (Math.log(max) / axis_array[axis.getValue()].log_base);
		}
	}

/* }}} */

/* {{{ axis_revert_and_unlog_range() */

	public static void axis_revert_and_unlog_range(AXIS_INDEX axis)
	{
	  if (axis_array[axis.getValue()].range_is_reverted)
	  {
		double temp = axis_array[axis.getValue()].min;
		axis_array[axis.getValue()].min = axis_array[axis.getValue()].max;
		axis_array[axis.getValue()].max = temp;
	  }
	  GlobalMembersAxis.axis_unlog_interval(axis, axis_array[axis.getValue()].min, axis_array[axis.getValue()].max, 1);
	}

/* }}} */

/* {{{ axis_log_value_checked() */
	public static double axis_log_value_checked(AXIS_INDEX axis, double coord, String what)
	{
		if (axis_array[axis.getValue()].log)
		{
		if (coord <= 0.0)
		{
			GlobalMembersUtil.graph_error("%s has %s coord of %g; must be above 0 for log scale!", what, axis_defaults[axis.getValue()].name, coord);
		}
		else
			return ((Math.log(coord) / axis_array[axis.getValue()].log_base));
		}
		return (coord);
	}

/* }}} */

/* {{{ axis_checked_extend_empty_range() */
/*
 * === SYNOPSIS ===
 *
 * This function checks whether the data and/or plot range in a given axis
 * is too small (which would cause divide-by-zero and/or infinite-loop
 * problems later on).  If so,
 * - if autoscaling is in effect for this axis, we widen the range
 * - otherwise, we abort with a call to  int_error()  (which prints out
 *   a suitable error message, then (hopefully) aborts this command and
 *   returns to the command prompt or whatever).
 *
 *
 * === HISTORY AND DESIGN NOTES ===
 *
 * 1998 Oct 4, Jonathan Thornburg <jthorn@galileo.thp.univie.ac.at>
 *
 * This function used to be a (long) macro  FIXUP_RANGE(AXIS, WHICH)
 * which was (identically!) defined in  plot2d.c  and  plot3d.c .  As
 * well as now being a function instead of a macro, the logic is also
 * changed:  The "too small" range test no longer depends on 'set zero'
 * and is now properly scaled relative to the data magnitude.
 *
 * The key question in designing this function is the policy for just how
 * much to widen the data range by, as a function of the data magnitude.
 * This is to some extent a matter of taste.  IMHO the key criterion is
 * that (at least) all of the following should (a) not infinite-loop, and
 * (b) give correct plots, regardless of the 'set zero' setting:
 *      plot 6.02e23            # a huge number >> 1 / FP roundoff level
 *      plot 3                  # a "reasonable-sized" number
 *      plot 1.23e-12           # a small number still > FP roundoff level
 *      plot 1.23e-12 * sin(x)  # a small function still > FP roundoff level
 *      plot 1.23e-45           # a tiny number << FP roundoff level
 *      plot 1.23e-45 * sin(x)  # a tiny function << FP roundoff level
 *      plot 0          # or (more commonly) a data file of all zeros
 * That is, IMHO gnuplot should *never* infinite-loop, and it should *never*
 * producing an incorrect or misleading plot.  In contrast, the old code
 * would infinite-loop on most of these examples with 'set zero 0.0' in
 * effect, or would plot the small-amplitude sine waves as the zero function
 * with 'zero' set larger than the sine waves' amplitude.
 *
 * The current code plots all the above examples correctly and without
 * infinite looping.
 *
 * HBB 2000/05/01: added an additional up-front test, active only if
 *   the new 'mesg' parameter is non-NULL.
 *
 * === USAGE ===
 *
 * Arguments:
 * axis = (in) An integer specifying which axis (x1, x2, y1, y2, z, etc)
 *             we should do our stuff for.  We use this argument as an
 *             index into the global arrays  {min,max,auto}_array .  In
 *             practice this argument will typically be one of the constants
 *              {FIRST,SECOND}_{X,Y,Z}_AXIS  defined in plot.h.
 * mesg = (in) if non-NULL, will check if the axis range is valid (min
 *             not +VERYLARGE, max not -VERYLARGE), and int_error() out
 *             if it isn't.
 *
 * Global Variables:
 * auto_array, min_array, max_array (in out) (defined in axis.[ch]):
 *    variables describing the status of autoscaling and range ends, for
 *    each of the possible axes.
 *
 * c_token = (in) (defined in plot.h) Used in formatting an error message.
 *
 */
	public static void axis_checked_extend_empty_range(AXIS_INDEX axis, String mesg)
	{
		/* These two macro definitions set the range-widening policy: */

		/* widen [0:0] by +/- this absolute amount */
	///#define FIXUP_RANGE__WIDEN_ZERO_ABS 1.0
		/* widen [nonzero:nonzero] by -/+ this relative amount */
	///#define FIXUP_RANGE__WIDEN_NONZERO_REL 0.01

		double dmin = axis_array[axis.getValue()].min;
		double dmax = axis_array[axis.getValue()].max;

		/* HBB 20000501: this same action was taken just before most of
		 * the invocations of this function, so I moved it into here.
		 * Only do this if 'mesg' is non-NULL --> pass NULL if you don't
		 * want the test */
		if (mesg != null && (axis_array[axis.getValue()].min == DefineConstants.VERYLARGE || axis_array[axis.getValue()].max == -DefineConstants.VERYLARGE))
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, mesg);

		if (dmax - dmin == 0.0)
		{
		/* empty range */
		if (((int)axis_array[axis.getValue()].autoscale) != 0)
		{
			/* range came from autoscaling ==> widen it */
			double widen = (dmax == 0.0) ? DefineConstants.FIXUP_RANGE__WIDEN_ZERO_ABS : DefineConstants.FIXUP_RANGE__WIDEN_NONZERO_REL * dmax;
			if (!(axis == AXIS_INDEX.FIRST_Z_AXIS && mesg == null)) // set view map
			fprintf(stderr, "Warning: empty %s range [%g:%g], ", axis_defaults[axis.getValue()].name, dmin, dmax);
			/* HBB 20010525: correctly handle single-ended
			 * autoscaling, too: */
			if (axis_array[axis.getValue()].autoscale & e_autoscale.AUTOSCALE_MIN != 0)
			axis_array[axis.getValue()].min -= widen;
			if (axis_array[axis.getValue()].autoscale & e_autoscale.AUTOSCALE_MAX != 0)
			axis_array[axis.getValue()].max += widen;
			if (!(axis == AXIS_INDEX.FIRST_Z_AXIS && mesg == null)) // set view map
			fprintf(stderr, "adjusting to [%g:%g]\n", axis_array[axis.getValue()].min, axis_array[axis.getValue()].max);
		}
		else
		{
			/* user has explicitly set the range (to something empty)
				   ==> we're in trouble */
			/* FIXME HBB 20000416: is c_token always set properly,
			 * when this is called? We might be better off using
			 * NO_CARET..., here */
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Can't plot with an empty %s range!", axis_defaults[axis.getValue()].name);
		}
		}
	}
/* }}} */

/* {{{ copy_or_invent_formatstring() */
/* Either copies the axis formatstring over to the ticfmt[] array, or
 * in case that's not applicable because the format hasn't been
 * specified correctly, invents a time/date output format by looking
 * at the range of values.  Considers time/date fields that don't
 * change across the range to be unimportant */
/* HBB 20010803: removed two arguments, and renamed function */
	public static String copy_or_invent_formatstring(AXIS_INDEX axis)
	{
		tm t_min = new tm();
		tm t_max = new tm();

		/* HBB 20010803: moved this here ... was done whenever this was called,
		 * anyway */
		if (!axis_array[axis.getValue()].is_timedata || !axis_array[axis.getValue()].format_is_numeric)
		{
		/* The simple case: formatstring is usable, so use it! */
		ticfmt[axis.getValue()] = axis_array[axis.getValue()].formatstring;
		return ticfmt[axis.getValue()];
		}

		/* Else, have to invent an output format string. */
		*ticfmt[axis.getValue()] = 0; // make sure we strcat to empty string

		GlobalMembersTime.ggmtime(t_min, GlobalMembersAxis.time_tic_just(timelevel[axis.getValue()], axis_array[axis.getValue()].min));
		GlobalMembersTime.ggmtime(t_max, GlobalMembersAxis.time_tic_just(timelevel[axis.getValue()], axis_array[axis.getValue()].max));

		if (t_max.tm_year == t_min.tm_year && t_max.tm_yday == t_min.tm_yday)
		{
		/* same day, skip date */
		if (t_max.tm_hour != t_min.tm_hour)
		{
			ticfmt[axis.getValue()] = "%H";
		}
		if (timelevel[axis.getValue()] < e_timelevel.TIMELEVEL_DAYS)
		{
			if (ticfmt[axis.getValue()][0] != 0)
			ticfmt[axis.getValue()] += ":";
			ticfmt[axis.getValue()] += "%M";
		}
		if (timelevel[axis.getValue()] < e_timelevel.TIMELEVEL_HOURS)
		{
			ticfmt[axis.getValue()] += ":%S";
		}
		}
		else
		{
		if (t_max.tm_year != t_min.tm_year)
		{
			/* different years, include year in ticlabel */
			/* check convention, day/month or month/day */
			if (tangible.StringFunctions.strChr(axis_array[axis.getValue()].timefmt, 'm') < tangible.StringFunctions.strChr(axis_array[axis.getValue()].timefmt, 'd'))
			{
			ticfmt[axis.getValue()] = "%m/%d/%";
			}
			else
			{
			ticfmt[axis.getValue()] = "%d/%m/%";
			}
			if (((int)(t_max.tm_year / 100)) != ((int)(t_min.tm_year / 100)))
			{
			ticfmt[axis.getValue()] += "Y";
			}
			else
			{
			ticfmt[axis.getValue()] += "y";
			}

		}
		else
		{
			/* Copy day/month order over from input format */
			if (tangible.StringFunctions.strChr(axis_array[axis.getValue()].timefmt, 'm') < tangible.StringFunctions.strChr(axis_array[axis.getValue()].timefmt, 'd'))
			{
			ticfmt[axis.getValue()] = "%m/%d";
			}
			else
			{
			ticfmt[axis.getValue()] = "%d/%m";
			}
		}
		if (timelevel[axis.getValue()] < e_timelevel.TIMELEVEL_WEEKS)
		{
			/* Note: seconds can't be useful if there's more than 1
			 * day's worth of data... */
			ticfmt[axis.getValue()] += "\n%H:%M";
		}
		}
		return ticfmt[axis.getValue()];
	}

/* }}} */

/* {{{ quantize_normal_tics() */
/* the guide parameter was intended to allow the number of tics
 * to depend on the relative sizes of the plot and the font.
 * It is the approximate upper limit on number of tics allowed.
 * But it did not go down well with the users.
 * A value of 20 gives the same behaviour as 3.5, so that is
 * hardwired into the calls to here. Maybe we will restore it
 * to the automatic calculation one day
 */

/* HBB 20020220: Changed to use value itself as first argument, not
 * log10(value).  Done to allow changing the calculation method
 * to avoid numerical problems */
	public static double quantize_normal_tics(double arg, int guide)
	{
		/* order of magnitude of argument: */
		double power = GlobalMembersAxis.dbl_raise(10.0, Math.floor(Math.log10(arg)));
		double xnorm = arg / power; // approx number of decades
		/* we expect 1 <= xnorm <= 10 */
		double posns = guide / xnorm; // approx number of tic posns per decade
		/* with guide=20, we expect 2 <= posns <= 20 */
		double tics;

		/* FIXME HBB 20020220: Looking at these, I would normally expect
		 * to see posns*tics to be always about the same size. But we
		 * rather suddenly drop from 2.0 to 1.0 at tic step 0.5. Why? */
		/* JRV 20021117: fixed this by changing next to last threshold
		   from 1 to 2.  However, with guide=20, this doesn't matter. */
		if (posns > 40)
		tics = 0.05; // eg 0, .05, .10, ...
		else if (posns > 20)
		tics = 0.1; // eg 0, .1, .2, ...
		else if (posns > 10)
		tics = 0.2; // eg 0,0.2,0.4,...
		else if (posns > 4)
		tics = 0.5; // 0,0.5,1,
		else if (posns > 2)
		tics = 1; // 0,1,2,....
		else if (posns > 0.5)
		tics = 2; // 0, 2, 4, 6
		else
		/* getting desperate... the ceil is to make sure we
		 * go over rather than under - eg plot [-10:10] x*x
		 * gives a range of about 99.999 - tics=xnorm gives
		 * tics at 0, 99.99 and 109.98  - BAD !
		 * This way, inaccuracy the other way will round
		 * up (eg 0->100.0001 => tics at 0 and 101
		 * I think latter is better than former
		 */
		tics = Math.ceil(xnorm);

		return (tics * power);
	}

/* }}} */

/* {{{ setup_tics */
/* setup_tics allows max number of tics to be specified but users dont
 * like it to change with size and font, so we use value of 20, which
 * is 3.5 behaviour.  Note also that if format is '', yticlin = 0, so
 * this gives division by zero.  */

	public static void setup_tics(AXIS_INDEX axis, int max)
	{
		double tic = 0;
		axis this_Renamed = axis_array + axis;
		ticdef ticdef = (this_Renamed.ticdef);

		/* HBB 20010703: New: allow _not_ to autoextend the axis endpoints
		 * to an integer multiple of the ticstep, for autoscaled axes with
		 * automatic tics */
		boolean autoextend_min = (this_Renamed.autoscale & e_autoscale.AUTOSCALE_MIN) && !(this_Renamed.autoscale & e_autoscale.AUTOSCALE_FIXMIN);
		boolean autoextend_max = (this_Renamed.autoscale & e_autoscale.AUTOSCALE_MAX) && !(this_Renamed.autoscale & e_autoscale.AUTOSCALE_FIXMAX);

		/* HBB 20000506: if no tics required for this axis, do
		 * nothing. This used to be done exactly before each call of
		 * setup_tics, anyway... */
		if (this_Renamed.ticmode == 0)
		return;

		if (ticdef.type == en_ticseries_type.TIC_SERIES)
		{
		ticstep[axis.getValue()] = tic = ticdef.def.series.incr;
		autoextend_min = autoextend_min && (ticdef.def.series.start == -DefineConstants.VERYLARGE);
		autoextend_max = autoextend_max && (ticdef.def.series.end == DefineConstants.VERYLARGE);
		}
		else if (ticdef.type == en_ticseries_type.TIC_COMPUTED)
		{
		ticstep[axis.getValue()] = tic = GlobalMembersAxis.make_tics(axis, max);
		}
		else
		{
		/* user-defined, day or month */
		autoextend_min = autoextend_max = false;
		}

		/* If an explicit stepsize was set, timelevel[axis] wasn't defined,
		 * leading to strange misbehaviours of minor tics on time axes.
		 * We used to call quantize_time_tics, but that also caused strangeness.
		 */
		if (this_Renamed.is_timedata && ticdef.type == en_ticseries_type.TIC_SERIES)
		{
		if (tic >= 365 * 24 * 60 * 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_YEARS;
		else if (tic >= 28 * 24 * 60 * 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_MONTHS;
		else if (tic >= 7 * 24 * 60 * 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_WEEKS;
		else if (tic >= 24 * 60 * 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_DAYS;
		else if (tic >= 60 * 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_HOURS;
		else if (tic >= 60.)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_MINUTES;
		else
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_SECONDS;
		}

		if (autoextend_min)
		this_Renamed.min = GlobalMembersAxis.round_outward(axis, !(this_Renamed.min < this_Renamed.max), this_Renamed.min);

		if (autoextend_max)
		this_Renamed.max = GlobalMembersAxis.round_outward(axis, this_Renamed.min < this_Renamed.max, this_Renamed.max);


		/* Set up ticfmt[axis] correctly. If necessary (time axis, but not
		 * time/date output format), make up a formatstring that suits the
		 * range of data */
		GlobalMembersAxis.copy_or_invent_formatstring(axis);
	}

/* }}} */

/* {{{  gen_tics */
/* uses global arrays ticstep[], ticfmt[], axis_array[], 
 * we use any of GRID_X/Y/X2/Y2 and  _MX/_MX2/etc - caller is expected
 * to clear the irrelevent fields from global grid bitmask
 * note this is also called from graph3d, so we need GRID_Z too
 */
	public static void gen_tics(AXIS_INDEX axis, tic_callback callback)
	{
		/* separate main-tic part of grid */
		lp_style_type lgrd = new lp_style_type();
		lp_style_type mgrd = new lp_style_type();
		/* tic defn */
		ticdef def = axis_array[axis.getValue()].ticdef;
		/* minitics - off/default/auto/explicit */
		int minitics = axis_array[axis.getValue()].minitics;
		/* minitic frequency */
		double minifreq = axis_array[axis.getValue()].mtic_freq;


//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(lgrd, grid_lp, sizeof(grid_lp));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(mgrd, mgrid_lp, sizeof(mgrid_lp));
		if (!axis_array[axis.getValue()].gridmajor)
		lgrd.l_type = DefineConstants.LT_NODRAW;
		if (!axis_array[axis.getValue()].gridminor)
		mgrd.l_type = DefineConstants.LT_NODRAW;


		if (def.def.user != null) // user-defined tic entries
		{
		ticmark mark = def.def.user;
		double uncertain = (axis_array[axis.getValue()].max - axis_array[axis.getValue()].min) / 10;
		double internal_min = axis_array[axis.getValue()].min - DefineConstants.SIGNIF * uncertain;
		double internal_max = axis_array[axis.getValue()].max + DefineConstants.SIGNIF * uncertain;
		double log10_base = axis_array[axis.getValue()].log ? Math.log10(axis_array[axis.getValue()].base) : 1.0;

		/* polar labels always +ve, and if rmin has been set, they are
		 * relative to rmin. position is as user specified, but must
		 * be translated. I dont think it will work at all for
		 * log scale, so I shan't worry about it !
		 */
		double polar_shift = (GlobalMembersGadgets.polar && !(axis_array[AXIS_INDEX.R_AXIS.getValue()].autoscale & e_autoscale.AUTOSCALE_MIN)) ? axis_array[AXIS_INDEX.R_AXIS.getValue()].min : 0;

		for (mark = def.def.user; mark; mark = mark.next)
		{
			String label = new String(new char[64]);
			double internal = (axis_array[axis.getValue()].log ? (Math.log(mark.position) / axis_array[axis.getValue()].log_base) : (mark.position));

			public -= polar_shift;

			if (!(((internal_min)<(internal_max)) ? (((internal) >= (internal_min)) && ((internal) <= (internal_max))) : (((internal) >= (internal_max)) && ((internal) <= (internal_min)))))
			continue;

			if (mark.level < 0) // label read from data file
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			label = mark.label.substring(0, sizeof(label));
			else if (axis_array[axis.getValue()].is_timedata)
			GlobalMembersTime.gstrftime(label, 24, mark.label != null ? mark.label : ticfmt[axis.getValue()], mark.position);
			else
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersUtil.gprintf(label, sizeof(label), mark.label != null ? mark.label : ticfmt[axis.getValue()], log10_base, mark.position);
			/* use NULL instead of label for minitic */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*callback)(axis, internal, (mark.level>0)?DefineConstants.NULL:label, (mark.level>0)?mgrd:lgrd, DefineConstants.NULL);
		}
		if (def.type == en_ticseries_type.TIC_USER)
			return;
		}

		/* series-tics
		 * need to distinguish user co-ords from internal co-ords.
		 * - for logscale, internal = log(user), else internal = user
		 *
		 * The minitics are a bit of a drag - we need to distinuish
		 * the cases step>1 from step == 1.
		 * If step = 1, we are looking at 1,10,100,1000 for example, so
		 * minitics are 2,5,8, ...  - done in user co-ordinates
		 * If step>1, we are looking at 1,1e6,1e12 for example, so
		 * minitics are 10,100,1000,... - done in internal co-ords
		 */

		{
		double tic; // loop counter
		double internal; // in internal co-ords
		double user; // in user co-ords
		double start;
		double step;
		double end;
		double lmin = axis_array[axis.getValue()].min;
		double lmax = axis_array[axis.getValue()].max;
		double internal_min; // to allow for rounding errors
		double internal_max;
		double ministart = 0; // internal or user - depends on step
		double ministep = 1;
		double miniend = 1;

		/* gprintf uses log10() of base - log_base_array is log() */
		double log10_base = axis_array[axis.getValue()].log ? Math.log10(axis_array[axis.getValue()].base) : 1.0;

		if (lmax < lmin)
		{
			/* hmm - they have set reversed range for some reason */
			double temp = lmin;
			lmin = lmax;
			lmax = temp;
		}
		/* {{{  choose start, step and end */
		switch (def.type)
		{
		case TIC_SERIES:
			if (axis_array[axis.getValue()].log)
			{
			/* we can tolerate start <= 0 if step and end > 0 */
			if (def.def.series.end <= 0 || def.def.series.incr <= 0)
				return; // just quietly ignore
			step = (Math.log(def.def.series.incr) / axis_array[axis.getValue()].log_base);
			if (def.def.series.start <= 0) // includes case 'undefined, i.e. -VERYLARGE
				start = step * Math.floor(lmin / step);
			else
				start = (Math.log(def.def.series.start) / axis_array[axis.getValue()].log_base);
			if (def.def.series.end == DefineConstants.VERYLARGE)
				end = step * Math.ceil(lmax / step);
			else
				end = (Math.log(def.def.series.end) / axis_array[axis.getValue()].log_base);
			}
			else
			{
			start = def.def.series.start;
			step = def.def.series.incr;
			end = def.def.series.end;
			if (start == -DefineConstants.VERYLARGE)
				start = step * Math.floor(lmin / step);
			if (end == DefineConstants.VERYLARGE)
				end = step * Math.ceil(lmax / step);
			}
			break;
		case TIC_COMPUTED:
			/* round to multiple of step */
			start = ticstep[axis.getValue()] * Math.floor(lmin / ticstep[axis.getValue()]);
			step = ticstep[axis.getValue()];
			end = ticstep[axis.getValue()] * Math.ceil(lmax / ticstep[axis.getValue()]);
			break;
		case TIC_MONTH:
			start = Math.floor(lmin);
			end = Math.ceil(lmax);
			step = Math.floor((end - start) / 12);
			if (step < 1)
			step = 1;
			break;
		case TIC_DAY:
			start = Math.floor(lmin);
			end = Math.ceil(lmax);
			step = Math.floor((end - start) / 14);
			if (step < 1)
			step = 1;
			break;
		default:
			GlobalMembersUtil.graph_error("Internal error : unknown tic type");
			return; // avoid gcc -Wall warning about start
		}
		/* }}} */

		/* {{{  ensure ascending order */
		if (end < start)
		{
			double temp;
			temp = end;
			end = start;
			start = temp;
		}
		step = Math.abs(step);
		/* }}} */

		if (minitics != 0 && axis_array[axis.getValue()].miniticscale != 0)
		{
			/* {{{  figure out ministart, ministep, miniend */
			if (minitics == en_minitics_status.MINI_USER.getValue())
			{
			/* they have said what they want */
			if (minifreq <= 0)
				minitics = 0; // not much else we can do
			 else if (axis_array[axis.getValue()].log)
			 {
				 ministart = ministep = step / minifreq * axis_array[axis.getValue()].base;
				 miniend = step * axis_array[axis.getValue()].base;
			 }
			 else
			 {
				ministart = ministep = step / minifreq;
				miniend = step;
			 }
			}
			else if (axis_array[axis.getValue()].log)
			{
			if (step > 1.5) // beware rounding errors
			{
				/* {{{  10,100,1000 case */
				/* no more than five minitics */
				if (step < 65535) // should be MAXINT
				ministart = ministep = (int)(0.2 * step);
				else
				ministart = ministep = 0.2 * step;
				if (ministep < 1)
				ministart = ministep = 1;
				miniend = step;
				/* }}} */
			}
			else
			{
				/* {{{  2,5,8 case */
				miniend = axis_array[axis.getValue()].base;
				if (end - start >= 10)
				minitics = 0; // none
				else if (end - start >= 5)
				{
				ministart = 2;
				ministep = 3;
				}
				else
				{
				ministart = 2;
				ministep = 1;
				}
				/* }}} */
			}
			}
			else if (axis_array[axis.getValue()].is_timedata)
			{
			ministart = ministep = GlobalMembersAxis.make_auto_time_minitics(timelevel[axis.getValue()], step);
			miniend = step * 0.9;
			}
			else if (minitics == en_minitics_status.MINI_AUTO.getValue())
			{
			int k = Math.abs(step) / Math.pow(10.,Math.floor(Math.log10(Math.abs(step))));

			/* so that step == k times some power of 10 */
			ministart = ministep = (k == 2 ? 0.5 : 0.2) * step;
			miniend = step;
			}
			else
			minitics = 0;

			if (ministep <= 0)
			minitics = 0; // dont get stuck in infinite loop
			/* }}} */
		}

		/* {{{  a few tweaks and checks */
		/* watch rounding errors */
		end += DefineConstants.SIGNIF * step;
		/* HBB 20011002: adjusting the endpoints doesn't make sense if
		 * some oversmart user used a ticstep (much) larger than the
		 * yrange itself */
		if (step < (Math.abs(lmax) + Math.abs(lmin)))
		{
			internal_max = lmax + step * DefineConstants.SIGNIF;
			internal_min = lmin - step * DefineConstants.SIGNIF;
		}
		else
		{
			internal_max = lmax;
			internal_min = lmin;
		}

		if (step == 0)
			return; // just quietly ignore them !
		/* }}} */

		/* This protects against user error, not precision errors */
		if ((internal_max - internal_min) / step > GlobalMembersTerm.term.xmax)
		{
			GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "Too many axis ticks requested (>%.0g)", (internal_max - internal_min) / step);
			return;
		}

		/* This protects against infinite loops if the separation between   */
		/* two ticks is less than the precision of the control variables.   */
		/* The for(...) loop here must be identical to the true loop below. */
		if (true) // (some-test-for-range-and-or-step-size)
		{
			int anyticput = 0;
			double previous_tic = 0;

			for (tic = start; tic <= end; tic += step)
			{
			/* EAM Oct 2008: Previous code (2001) checked only the start and end
			 * points, but rounding error can strike at any point in the range.
			 */
			if (anyticput == 0)
				anyticput = 1;
			else if (Math.abs(tic - previous_tic) < (step / 4.))
			{
				step = end - start;
				GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "tick interval too small for machine precision");
				break;
			}
			previous_tic = tic;
			}
		}

		for (tic = start; tic <= end; tic += step)
		{

			/* {{{  calc internal and user co-ords */
			if (!axis_array[axis.getValue()].log)
			{
			public = (axis_array[axis.getValue()].is_timedata) ? GlobalMembersAxis.time_tic_just(timelevel[axis.getValue()], tic) : tic;
			user = (Math.abs(internal) < ((step) * DefineConstants.SIGNIF) ? 0.0 : (internal));
			}
			else
			{
			/* log scale => dont need to worry about zero ? */
			public = tic;
			user = Math.exp((internal) * axis_array[axis.getValue()].log_base);
			}
			/* }}} */
			if (internal > internal_max)
			break; // gone too far - end of series = VERYLARGE perhaps
			if (internal >= internal_min)
			{
			/* {{{  draw tick via callback */
			switch (def.type)
			{
			case TIC_DAY:
			{
				int d = (int) Math.floor(user + 0.5) % 7;
				if (d < 0)
					d += 7;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*callback)(axis, internal, GlobalMembersVariable.abbrev_day_names[d], lgrd, def.def.user);
				break;
			}
			case TIC_MONTH:
			{
				int m = (int) Math.floor(user - 1) % 12;
				if (m < 0)
					m += 12;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*callback)(axis, internal, GlobalMembersVariable.abbrev_month_names[m], lgrd, def.def.user);
				break;
			}
			default: // comp or series
			{
				String label = new String(new char[64]);
				if (axis_array[axis.getValue()].is_timedata)
				{
					/* If they are doing polar time plot, good luck to them */
					GlobalMembersTime.gstrftime(label, 24, ticfmt[axis.getValue()], (double) user);
				}
				else if (GlobalMembersGadgets.polar)
				{
					/* if rmin is set, we stored internally with r-rmin */
					double r = Math.abs(user) + ((axis_array[AXIS_INDEX.R_AXIS.getValue()].autoscale & e_autoscale.AUTOSCALE_MIN) ? 0 : axis_array[AXIS_INDEX.R_AXIS.getValue()].min);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					GlobalMembersUtil.gprintf(label, sizeof(label), ticfmt[axis.getValue()], log10_base, r);
				}
				else
				{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					GlobalMembersUtil.gprintf(label, sizeof(label), ticfmt[axis.getValue()], log10_base, user);
				}

				/* Range-limited tic placement */
				if (def.rangelimited && !(((axis_array[axis.getValue()].data_min)<(axis_array[axis.getValue()].data_max)) ? (((internal) >= (axis_array[axis.getValue()].data_min)) && ((internal) <= (axis_array[axis.getValue()].data_max))) : (((internal) >= (axis_array[axis.getValue()].data_max)) && ((internal) <= (axis_array[axis.getValue()].data_min)))))
					continue;

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*callback)(axis, internal, label, lgrd, def.def.user);
			}
			}
			/* }}} */

			}
			if (minitics != 0 && axis_array[axis.getValue()].miniticscale != 0)
			{
			/* {{{  process minitics */
			double mplace;
			double mtic;
			for (mplace = ministart; mplace < miniend; mplace += ministep)
			{
				if (axis_array[axis.getValue()].is_timedata)
				mtic = GlobalMembersAxis.time_tic_just(timelevel[axis.getValue()] - 1, internal + mplace);
				else
				mtic = internal + (axis_array[axis.getValue()].log && step <= 1.5 ? (Math.log(mplace) / axis_array[axis.getValue()].log_base) : mplace);
				if ((((internal_min)<(internal_max)) ? (((mtic) >= (internal_min)) && ((mtic) <= (internal_max))) : (((mtic) >= (internal_max)) && ((mtic) <= (internal_min)))) && (((start - step * DefineConstants.SIGNIF)<(end + step * DefineConstants.SIGNIF)) ? (((mtic) >= (start - step * DefineConstants.SIGNIF)) && ((mtic) <= (end + step * DefineConstants.SIGNIF))) : (((mtic) >= (end + step * DefineConstants.SIGNIF)) && ((mtic) <= (start - step * DefineConstants.SIGNIF)))))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*callback)(axis, mtic, DefineConstants.NULL, mgrd, DefineConstants.NULL);
			}
			/* }}} */
			}
		}
		}
	}
/* }}} */


/* {{{ axis_output_tics() */
/* HBB 20000416: new routine. Code like this appeared 4 times, once
 * per 2D axis, in graphics.c. Always slightly different, of course,
 * but generally, it's always the same. I distinguish two coordinate
 * directions, here. One is the direction of the axis itself (the one
 * it's "running" along). I refer to the one orthogonal to it as
 * "non-running", below. */
	public static void axis_output_tics(AXIS_INDEX axis, int ticlabel_position, AXIS_INDEX zeroaxis_basis, tic_callback callback)
					 * zeroaxis on */
	{
		TERMENTRY t = GlobalMembersTerm.term;
		boolean axis_is_vertical = ((axis % DefineConstants.SECOND_AXES) == AXIS_INDEX.FIRST_Y_AXIS);
		boolean axis_is_second = ((axis / DefineConstants.SECOND_AXES) == 1);
		int axis_position; // 'non-running' coordinate
		int mirror_position; // 'non-running' coordinate, 'other' side

		if (zeroaxis_basis / DefineConstants.SECOND_AXES)
		{
		axis_position = axis_array[zeroaxis_basis.getValue()].term_upper;
		mirror_position = axis_array[zeroaxis_basis.getValue()].term_lower;
		}
		else
		{
		axis_position = axis_array[zeroaxis_basis.getValue()].term_lower;
		mirror_position = axis_array[zeroaxis_basis.getValue()].term_upper;
		}

		if (axis_array[axis.getValue()].ticmode != 0)
		{
		/* set the globals needed by the _callback() function */

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if (axis_array[axis.getValue()].tic_rotate == DefineConstants.TEXT_VERTICAL && (*t.text_angle)(DefineConstants.TEXT_VERTICAL))
		{
			tic_hjust = axis_is_vertical ? JUSTIFY.CENTRE : (axis_is_second ? JUSTIFY.LEFT : JUSTIFY.RIGHT);
			tic_vjust = axis_is_vertical ? (axis_is_second ? VERT_JUSTIFY.JUST_TOP : VERT_JUSTIFY.JUST_BOT) : VERT_JUSTIFY.JUST_CENTRE;
			rotate_tics = DefineConstants.TEXT_VERTICAL;
			/* FIXME HBB 20000501: why would we want this? */
			if (axis == AXIS_INDEX.FIRST_Y_AXIS)
			ticlabel_position += t.v_char / 2;
		/* EAM - allow rotation by arbitrary angle in degrees      */
		/*       Justification of ytic labels is a problem since   */
		/*	 the position is already [mis]corrected for length */
		}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	else if (axis_array[axis.getValue()].tic_rotate != 0 && (*t.text_angle)(axis_array[axis.getValue()].tic_rotate))
		{
			switch (axis)
			{
			case FIRST_Y_AXIS: // EAM Purely empirical shift - is there a better?
							ticlabel_position += t.h_char * 2.5;
							tic_hjust = JUSTIFY.RIGHT.getValue();
							break;
			case SECOND_Y_AXIS:
				tic_hjust = JUSTIFY.LEFT.getValue();
				break;
			case FIRST_X_AXIS:
				tic_hjust = JUSTIFY.LEFT.getValue();
				break;
			case SECOND_X_AXIS:
				tic_hjust = JUSTIFY.LEFT.getValue();
				break;
			default:
				tic_hjust = JUSTIFY.LEFT.getValue();
				break;
			}
			tic_vjust = VERT_JUSTIFY.JUST_CENTRE.getValue();
			rotate_tics = axis_array[axis.getValue()].tic_rotate;
		}
		else
		{
			tic_hjust = axis_is_vertical ? (axis_is_second ? JUSTIFY.LEFT : JUSTIFY.RIGHT) : JUSTIFY.CENTRE;
			tic_vjust = axis_is_vertical ? VERT_JUSTIFY.JUST_CENTRE : (axis_is_second ? VERT_JUSTIFY.JUST_BOT : VERT_JUSTIFY.JUST_TOP);
			rotate_tics = 0;
		}

		if (axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MIRROR != 0)
			tic_mirror = mirror_position;
		else
			tic_mirror = -1; // no thank you

		if ((axis_array[axis.getValue()].ticmode & DefineConstants.TICS_ON_AXIS) && !axis_array[zeroaxis_basis.getValue()].log && (((axis_array[zeroaxis_basis.getValue()].min)<(axis_array[zeroaxis_basis.getValue()].max)) ? (((0.0) >= (axis_array[zeroaxis_basis.getValue()].min)) && ((0.0) <= (axis_array[zeroaxis_basis.getValue()].max))) : (((0.0) >= (axis_array[zeroaxis_basis.getValue()].max)) && ((0.0) <= (axis_array[zeroaxis_basis.getValue()].min)))))
		{
			tic_start = (int)((axis_array[zeroaxis_basis.getValue()].term_lower) + ((0.0) - axis_array[zeroaxis_basis.getValue()].min) * axis_array[zeroaxis_basis.getValue()].term_scale + 0.5);
			tic_direction = axis_is_second ? 1 : -1;
			if (axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MIRROR != 0)
			tic_mirror = tic_start;
			/* put text at boundary if axis is close to boundary and the
			 * corresponding boundary is switched on */
			if (axis_is_vertical)
			{
			if (((axis_is_second ? - 1 : 1) * (tic_start - axis_position) > (3 * t.h_char)) || (!axis_is_second && (!(GlobalMembersGadgets.draw_border & 2))) || (axis_is_second && (!(GlobalMembersGadgets.draw_border & 8))))
				tic_text = tic_start;
			else
				tic_text = axis_position;
			tic_text += (axis_is_second ? 1 : -1) * t.h_char;
			}
			else
			{
			if (((axis_is_second ? - 1 : 1) * (tic_start - axis_position) > (2 * t.v_char)) || (!axis_is_second && (!(GlobalMembersGadgets.draw_border & 1))) || (axis_is_second && (!(GlobalMembersGadgets.draw_border & 4))))
				tic_text = tic_start + (axis_is_second ? 0 : - axis_array[axis.getValue()].ticscale * t.v_tic);
			else
				tic_text = axis_position;
			tic_text -= t.v_char;
			}
		}
		else
		{
			/* tics not on axis --> on border */
			tic_start = axis_position;
			tic_direction = (axis_array[axis.getValue()].tic_in ? 1 : -1) * (axis_is_second ? - 1 : 1);
			tic_text = (ticlabel_position);
		}
		/* go for it */
		GlobalMembersAxis.gen_tics(axis, callback);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.text_angle)(0); // reset rotation angle
		}
	}

/* }}} */

/* {{{ axis_set_graphical_range() */

	public static void axis_set_graphical_range(AXIS_INDEX axis, int lower, int upper)
	{
		axis_array[axis.getValue()].term_lower = lower;
		axis_array[axis.getValue()].term_upper = upper;
	}
/* }}} */


/* {{{ axis_draw_2d_zeroaxis() */
	public static void axis_draw_2d_zeroaxis(AXIS_INDEX axis, AXIS_INDEX crossaxis)
	{
		axis this_Renamed = axis_array + axis;

		if (GlobalMembersAxis.axis_position_zeroaxis(crossaxis) && (this_Renamed.zeroaxis.l_type > DefineConstants.LT_NODRAW))
		{
		GlobalMembersTerm.term_apply_lp_properties(this_Renamed.zeroaxis);
		if ((axis % DefineConstants.SECOND_AXES) == AXIS_INDEX.FIRST_X_AXIS)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.move)(this_Renamed.term_lower, axis_array[crossaxis.getValue()].term_zero);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.vector)(this_Renamed.term_upper, axis_array[crossaxis.getValue()].term_zero);
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.move)(axis_array[crossaxis.getValue()].term_zero, this_Renamed.term_lower);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.vector)(axis_array[crossaxis.getValue()].term_zero, this_Renamed.term_upper);
		}
		}
	}
	public static boolean some_grid_selected()
	{
		AXIS_INDEX i;
		/* Old version would have been just this: */
		/* return (grid_selection != GRID_OFF); */
		for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; i++)
		if (axis_array[i.getValue()].gridmajor || axis_array[i.getValue()].gridminor)
		{
			return true;
		}
		return false;
	}

/*
 * Add a single tic mark, with label, to the list for this axis.
 * To avoid duplications and overprints, sort the list and allow
 * only one label per position.
 * EAM - called from set.c during `set xtics` (level = 0 or 1)
 *       called from datafile.c during `plot using ::xtic()` (level = -1)
 */
	public static void add_tic_user(AXIS_INDEX axis, String label, double position, int level)
	{
		ticmark tic;
		ticmark newtic;
		ticmark listhead = new ticmark();

		if (label == null && level < 0)
		return;

		/* Mark this axis as user-generated ticmarks only, unless the */
		/* mix flag indicates that both user- and auto- tics are OK.  */
		if (!axis_array[axis.getValue()].ticdef.def.mix)
		axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_USER;

		/* Walk along list to sorted positional order */
		listhead.next = axis_array[axis.getValue()].ticdef.def.user;
		listhead.position = -DBL_MAX;
		for (tic = listhead; tic.next && (position > tic.next.position); tic = tic.next)
		{
		}

		if ((tic.next == DefineConstants.NULL) || (position < tic.next.position))
		{
		/* Make a new ticmark */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		newtic = (GlobalMembersMouse.struct ticmark *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct ticmark), (String) DefineConstants.NULL);
		newtic.position = position;
		newtic.level = level;
		/* Insert it in the list */
		newtic.next = tic.next;
		tic.next = newtic;
		}
		else
		{
		/* The new tic must duplicate position of tic->next */
		if (position != tic.next.position)
			GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "add_tic_user: list sort error");
		newtic = tic.next;
		/* Don't over-write a major tic with a minor tic */
		if (newtic.level < level)
			return;
		if (newtic.label != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(newtic.label);
			newtic.label = DefineConstants.NULL;
		}
		}

		if (label != null)
		newtic.label = GlobalMembersUtil.gp_strdup(label);
		else
		newtic.label = DefineConstants.NULL;

		/* Make sure the listhead is kept */
		axis_array[axis.getValue()].ticdef.def.user = listhead.next;
	}

/*
 * get and set routines for range writeback
 * ULIG *
 */


	public static double get_writeback_min(AXIS_INDEX axis)
	{
		/* printf("get min(%d)=%g\n",axis,axis_array[axis].writeback_min); */
		return axis_array[axis.getValue()].writeback_min;
	}
	public static double get_writeback_max(AXIS_INDEX axis)
	{
		/* printf("get max(%d)=%g\n",axis,axis_array[axis].writeback_min); */
		return axis_array[axis.getValue()].writeback_max;
	}
	public static void set_writeback_min(AXIS_INDEX axis)
	{
		double val = (axis_array[axis.getValue()].log ? Math.exp((axis_array[axis.getValue()].min) * axis_array[axis.getValue()].log_base): (axis_array[axis.getValue()].min));
		/* printf("set min(%d)=%g\n",axis,val); */
		axis_array[axis.getValue()].writeback_min = val;
	}
	public static void set_writeback_max(AXIS_INDEX axis)
	{
		double val = (axis_array[axis.getValue()].log ? Math.exp((axis_array[axis.getValue()].max) * axis_array[axis.getValue()].log_base): (axis_array[axis.getValue()].max));
		/* printf("set max(%d)=%g\n",axis,val); */
		axis_array[axis.getValue()].writeback_max = val;
	}

/* }}} */


/* we determine length of the widest tick label by getting gen_ticks to
 * call this routine with every label
 */


	/* set widest_tic_label: length of the longest tics label */
	public static void widest_tic_callback(AXIS_INDEX axis, double place, String text, lp_style_type grid, ticmark userlabels)
	{
		() axis; // avoid "unused parameter" warnings
		() place;
		() grid;
		if (text != null) // minitics have no text at all
		{
		int len = GlobalMembersGraphics.label_width(text, DefineConstants.NULL);
		if (len > widest_tic_strlen)
			widest_tic_strlen = len;
		}
	}

/* get_position() - reads a position for label,arrow,key,... */


	public static void get_position(position pos)
	{
		GlobalMembersAxis.get_position_default(pos, position_type.first_axes);
	}

/* get_position() - reads a position for label,arrow,key,... 
 * with given default coordinate system
 */
	public static void get_position_default(position pos, position_type default_type)
	{
		int axes;
		position_type type = default_type;

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memset(pos, 0, sizeof(GlobalMembersMouse.struct position));

		GlobalMembersAxis.get_position_type(type, axes);
		pos.scalex = type;
		do
		{
			if (((axes) >= 0) && (axis_array[(axes) + (AXIS_INDEX.FIRST_X_AXIS)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
			{
				tm tm = new tm();
				byte ss = GlobalMembersUtil.try_to_get_string();
				if (GlobalMembersTime.gstrptime(ss, axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].timefmt, tm) != null)
					(pos.x) = (double) GlobalMembersTime.gtimegm(tm);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
			}
			else
			{
				(pos.x) = GlobalMembersParse.real_expression();
			}
		} while (0);

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
		{
		++GlobalMembersCommand.c_token;
		GlobalMembersAxis.get_position_type(type, axes);
		pos.scaley = type;
		do
		{
			if (((axes) >= 0) && (axis_array[(axes) + (AXIS_INDEX.FIRST_Y_AXIS)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
			{
				tm tm = new tm();
				byte ss = GlobalMembersUtil.try_to_get_string();
				if (GlobalMembersTime.gstrptime(ss, axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].timefmt, tm) != null)
					(pos.y) = (double) GlobalMembersTime.gtimegm(tm);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
			}
			else
			{
				(pos.y) = GlobalMembersParse.real_expression();
			}
		} while (0);
		}
		else
		{
		pos.y = 0;
		pos.scaley = type;
		}

		/* z is not really allowed for a screen co-ordinate, but keep it simple ! */
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0 && !((GlobalMembersUtil.isstring(GlobalMembersCommand.c_token + 1) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token + 1) == DATA_TYPES.STRING)) && !(GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token + 1, "newhist$ogram")) && !(GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token + 1, "for")))
		   /* Partial fix for ambiguous syntax when trailing comma ends a plot command */
		{
		++GlobalMembersCommand.c_token;
		GlobalMembersAxis.get_position_type(type, axes);
		pos.scalez = type;
		do
		{
			if (((axes) >= 0) && (axis_array[(axes) + (AXIS_INDEX.FIRST_Z_AXIS)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
			{
				tm tm = new tm();
				byte ss = GlobalMembersUtil.try_to_get_string();
				if (GlobalMembersTime.gstrptime(ss, axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].timefmt, tm) != null)
					(pos.z) = (double) GlobalMembersTime.gtimegm(tm);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
			}
			else
			{
				(pos.z) = GlobalMembersParse.real_expression();
			}
		} while (0);
		}
		else
		{
		pos.z = 0;
		pos.scalez = type; // same as y
		}
	}

/*
   Check and set the cb-range for use by pm3d or other palette using styles.
   Return 0 on wrong range, otherwise 1.
 */

	/* ------------ autoscaling of the color axis */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	public static int set_cbminmax()
	{
		if (axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MIN != 0)
		{
		/* -VERYLARGE according to AXIS_INI3D */
		if (axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min >= DefineConstants.VERYLARGE)
			axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min = (axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].log ? Math.exp((axis_array[z_axis.getValue()].min) * axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].log_base): (axis_array[z_axis.getValue()].min));
		}
		axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min = GlobalMembersAxis.axis_log_value_checked(AXIS_INDEX.COLOR_AXIS, axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min, "color axis");

		if (axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].set_autoscale & e_autoscale.AUTOSCALE_MAX != 0)
		{
		/* -VERYLARGE according to AXIS_INI3D */
		if (axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max <= -DefineConstants.VERYLARGE)
			axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max = (axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].log ? Math.exp((axis_array[z_axis.getValue()].max) * axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].log_base): (axis_array[z_axis.getValue()].max));
		}
		axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max = GlobalMembersAxis.axis_log_value_checked(AXIS_INDEX.COLOR_AXIS, axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max, "color axis");

		if (axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min > axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max)
		{
		/* exchange min and max values */
		double tmp = axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max;
		axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max = axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min;
		axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min = tmp;
		}

		return 1;
	}




	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	/*  #include "setshow.h" */
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif

	/* HBB 20000416: this is the start of my try to centralize everything
	 * related to axes, once and for all. It'll probably end up as a
	 * global array of OO-style 'axis' objects, when it's done */

	/* HBB 20000725: gather all per-axis variables into a struct, and set
	 * up a single large array of such structs. Next step might be to use
	 * isolated AXIS structs, instead of an array. At least for *some* of
	 * the axes... */
	public static axis[] axis_array = {{e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}, {e_autoscale.AUTOSCALE_BOTH, e_autoscale.AUTOSCALE_BOTH, 0, false, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, false, 0.0, 0.0, 0, 1, DefineConstants.DEF_FORMAT, DefineConstants.TIMEFMT, DefineConstants.NO_TICS, {en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false}, 0, false, false, en_minitics_status.MINI_DEFAULT, 10, 1.0, 0.5, true, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, {0, -3, 0, 1.0, 1.0, 0}}};

	/* Keep defaults varying by axis in their own array, to ease initialization
	 * of the main array */
	public static final axis_defaults[] axis_defaults = {new axis_defaults(-10, 10, "z", DefineConstants.TICS_ON_BORDER), new axis_defaults(-10, 10, "y", DefineConstants.TICS_ON_BORDER | DefineConstants.TICS_MIRROR), new axis_defaults(-10, 10, "x", DefineConstants.TICS_ON_BORDER | DefineConstants.TICS_MIRROR), new axis_defaults(- 5, 5, "t", DefineConstants.NO_TICS), new axis_defaults(-10, 10, "z2", DefineConstants.NO_TICS), new axis_defaults(-10, 10, "y2", DefineConstants.NO_TICS), new axis_defaults(-10, 10, "x2", DefineConstants.NO_TICS), new axis_defaults(- 0, 10, "r", DefineConstants.NO_TICS), new axis_defaults(- 5, 5, "u", DefineConstants.NO_TICS), new axis_defaults(- 5, 5, "v", DefineConstants.NO_TICS), new axis_defaults(-10, 10, "cb", DefineConstants.TICS_ON_BORDER | DefineConstants.TICS_MIRROR)};


	/* either the 'set format <axis>' or an automatically invented time
	 * format string */
	public static byte[][] ticfmt = new byte[DefineConstants.AXIS_ARRAY_SIZE][DefineConstants.MAX_ID_LEN + 1];
	public static e_timelevel[] timelevel = new e_timelevel[DefineConstants.AXIS_ARRAY_SIZE];

	/* The <increment> given in a 'set {x|y|...}tics', or an automatically
	 * generated one, if automatic tic placement is active */
	public static double[] ticstep = new double[DefineConstants.AXIS_ARRAY_SIZE];

	/* HBB 20000506 new variable: parsing table for use with the table
	 * module, to help generalizing set/show/unset/save, where possible */
	public static final gen_table[] axisname_tbl = {new gen_table("z", AXIS_INDEX.FIRST_Z_AXIS), new gen_table("y", AXIS_INDEX.FIRST_Y_AXIS), new gen_table("x", AXIS_INDEX.FIRST_X_AXIS), new gen_table("t", AXIS_INDEX.T_AXIS), new gen_table("z2", AXIS_INDEX.SECOND_Z_AXIS), new gen_table("y2", AXIS_INDEX.SECOND_Y_AXIS), new gen_table("x2", AXIS_INDEX.SECOND_X_AXIS), new gen_table("r", AXIS_INDEX.R_AXIS), new gen_table("u", AXIS_INDEX.U_AXIS), new gen_table("v", AXIS_INDEX.V_AXIS), new gen_table("cb", AXIS_INDEX.COLOR_AXIS), new gen_table(DefineConstants.NULL, -1)};


	/* penalty for doing tics by callback in gen_tics is need for global
	 * variables to communicate with the tic routines. Dont need to be
	 * arrays for this */
	/* HBB 20000416: they may not need to be array[]ed, but it'd sure
	 * make coding easier, in some places... */
	/* HBB 20000416: for the testing, these are global... */
	/* static */	 public static int tic_start;
	 public static int tic_direction;
	 public static int tic_text;
	 public static int rotate_tics;
	 public static int tic_hjust;
	 public static int tic_vjust;
	 public static int tic_mirror;

	public static final ticdef default_axis_ticdef = new ticdef(en_ticseries_type.TIC_COMPUTED, DefineConstants.NULL, {DefineConstants.TC_DEFAULT, 0, 0}, {DefineConstants.NULL, {0,0}, false}, {position_type.character, position_type.character, position_type.character, 0., 0., 0.}, false);

	/* axis labels */
	public static final text_label default_axis_label = new text_label(DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false);

	/* zeroaxis drawing */
	public static final lp_style_type default_axis_zeroaxis = new lp_style_type(0, -3, 0, 1.0, 1.0, 0);

	/* grid drawing */
	/* int grid_selection = GRID_OFF; */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_GRID_LP { 0, -1, 0, 1.0, 1.0, 0 }
	public static final lp_style_type default_grid_lp = new lp_style_type(0, -1, 0, 1.0, 1.0, 0);
	public static lp_style_type grid_lp = new lp_style_type(0, -1, 0, 1.0, 1.0, 0);
	public static lp_style_type mgrid_lp = new lp_style_type(0, -1, 0, 1.0, 1.0, 0);
	public static int grid_layer = -1;
	public static double polar_grid_angle = 0; // nonzero means a polar grid

	/* Length of the longest tics label, set by widest_tic_callback(): */
	public static int widest_tic_strlen;

	/* axes being used by the current plot */
	/* These are mainly convenience variables, replacing separate copies of
	 * such variables originally found in the 2D and 3D plotting code */
	public static AXIS_INDEX x_axis = AXIS_INDEX.FIRST_X_AXIS;
	public static AXIS_INDEX y_axis = AXIS_INDEX.FIRST_Y_AXIS;
	public static AXIS_INDEX z_axis = AXIS_INDEX.FIRST_Z_AXIS;

/* }}} */

/* {{{ dbl_raise() used by quantize_normal_tics */
/* FIXME HBB 20000426: is this really useful? */

	/* --------- internal prototypes ------------------------- */
	public static double dbl_raise(double x, int y)
	{
		int i = Math.abs(y);
		double val = 1.0;

		while (--i >= 0)
		val *= x;

		if (y < 0)
		return (1.0 / val);
		return (val);
	}

/* }}} */

/* {{{ make smalltics for time-axis */
	public static double make_auto_time_minitics(e_timelevel tlevel, double incr)
	{
		double tinc = 0.0;

		if (tlevel.getValue() < e_timelevel.TIMELEVEL_SECONDS)
		tlevel = e_timelevel.TIMELEVEL_SECONDS;
		switch (tlevel)
		{
		case TIMELEVEL_SECONDS:
		case TIMELEVEL_MINUTES:
		if (incr >= 5)
			tinc = 1;
		if (incr >= 10)
			tinc = 5;
		if (incr >= 20)
			tinc = 10;
		if (incr >= 60)
			tinc = 20;
		if (incr >= 2 * 60)
			tinc = 60;
		if (incr >= 6 * 60)
			tinc = 2 * 60;
		if (incr >= 12 * 60)
			tinc = 3 * 60;
		if (incr >= 24 * 60)
			tinc = 6 * 60;
		break;
		case TIMELEVEL_HOURS:
		if (incr >= 20 * 60)
			tinc = 10 * 60;
		if (incr >= 3600)
			tinc = 30 * 60;
		if (incr >= 2 * 3600)
			tinc = 3600;
		if (incr >= 6 * 3600)
			tinc = 2 * 3600;
		if (incr >= 12 * 3600)
			tinc = 3 * 3600;
		if (incr >= 24 * 3600)
			tinc = 6 * 3600;
		break;
		case TIMELEVEL_DAYS:
		if (incr > 2 * 3600)
			tinc = 3600;
		if (incr > 4 * 3600)
			tinc = 2 * 3600;
		if (incr > 7 * 3600)
			tinc = 3 * 3600;
		if (incr > 13 * 3600)
			tinc = 6 * 3600;
		if (incr > DefineConstants.DAY_SEC)
			tinc = 12 * 3600;
		if (incr > 2 * DefineConstants.DAY_SEC)
			tinc = DefineConstants.DAY_SEC;
		break;
		case TIMELEVEL_WEEKS:
		if (incr > 2 * DefineConstants.DAY_SEC)
			tinc = DefineConstants.DAY_SEC;
		if (incr > 7 * DefineConstants.DAY_SEC)
			tinc = 7 * DefineConstants.DAY_SEC;
		break;
		case TIMELEVEL_MONTHS:
		if (incr > 2 * DefineConstants.DAY_SEC)
			tinc = DefineConstants.DAY_SEC;
		if (incr > 15 * DefineConstants.DAY_SEC)
			tinc = 10 * DefineConstants.DAY_SEC;
		if (incr > 2 * DefineConstants.MON_SEC)
			tinc = DefineConstants.MON_SEC;
		if (incr > 6 * DefineConstants.MON_SEC)
			tinc = 3 * DefineConstants.MON_SEC;
		if (incr > 2 * DefineConstants.YEAR_SEC)
			tinc = DefineConstants.YEAR_SEC;
		break;
		case TIMELEVEL_YEARS:
		if (incr > 2 * DefineConstants.MON_SEC)
			tinc = DefineConstants.MON_SEC;
		if (incr > 6 * DefineConstants.MON_SEC)
			tinc = 3 * DefineConstants.MON_SEC;
		if (incr > 2 * DefineConstants.YEAR_SEC)
			tinc = DefineConstants.YEAR_SEC;
		if (incr > 10 * DefineConstants.YEAR_SEC)
			tinc = 5 * DefineConstants.YEAR_SEC;
		if (incr > 50 * DefineConstants.YEAR_SEC)
			tinc = 10 * DefineConstants.YEAR_SEC;
		if (incr > 100 * DefineConstants.YEAR_SEC)
			tinc = 20 * DefineConstants.YEAR_SEC;
		if (incr > 200 * DefineConstants.YEAR_SEC)
			tinc = 50 * DefineConstants.YEAR_SEC;
		if (incr > 300 * DefineConstants.YEAR_SEC)
			tinc = 100 * DefineConstants.YEAR_SEC;
		break;
		}
		return (tinc);
	}

/* }}} */

/* {{{ make_tics() */
/* Implement TIC_COMPUTED case, i.e. automatically choose a usable
 * ticking interval for the given axis. For the meaning of the guide
 * parameter, see the comment on quantize_normal_tics() */
	public static double make_tics(AXIS_INDEX axis, int guide)
	{
		double xr;
		double tic;

		xr = Math.abs(axis_array[axis.getValue()].min - axis_array[axis.getValue()].max);
		if (xr == 0)
		return 1; // Anything will do, since we'll never use it
		if (xr >= DefineConstants.VERYLARGE)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET,"%s axis range undefined or overflow", axis_defaults[axis.getValue()].name);
		tic = GlobalMembersAxis.quantize_normal_tics(xr, guide);
		/* FIXME HBB 20010831: disabling this might allow short log axis
		 * to receive better ticking... */
		if (axis_array[axis.getValue()].log && tic < 1.0)
		  tic = 1.0;

		if (axis_array[axis.getValue()].is_timedata)
		return GlobalMembersAxis.quantize_time_tics(axis, tic, xr, guide);
		else
		return tic;
	}
/* }}} */

/* {{{ quantize_time_tics */
/* HBB 20010831: newly isolated subfunction. Used to be part of
 * make_tics() */
/* Look at the tic interval given, and round it to a nice figure
 * suitable for time/data axes, i.e. a small integer number of
 * seconds, minutes, hours, days, weeks or months. As a side effec,
 * this routine also modifies the static timelevel[axis] to indicate
 * the units these tics are calculated in. */
	public static double quantize_time_tics(AXIS_INDEX axis, double tic, double xr, int guide)
	{
		int guide12 = guide * 3 / 5; // --> 12 for default of 20

		timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_SECONDS;
		if (tic > 5)
		{
		/* turn tic into units of minutes */
		tic = GlobalMembersAxis.quantize_duodecimal_tics(xr / 60.0, guide12) * 60;
		if (tic >= 60)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_MINUTES;
		}
		if (tic > 5 * 60)
		{
		/* turn tic into units of hours */
		tic = GlobalMembersAxis.quantize_duodecimal_tics(xr / 3600.0, guide12) * 3600;
		if (tic >= 3600)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_HOURS;
		}
		if (tic > 3600)
		{
		/* turn tic into units of days */
			tic = GlobalMembersAxis.quantize_duodecimal_tics(xr / DefineConstants.DAY_SEC, guide12) * DefineConstants.DAY_SEC;
		if (tic >= DefineConstants.DAY_SEC)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_DAYS;
		}
		if (tic > 2 * DefineConstants.DAY_SEC)
		{
		/* turn tic into units of weeks */
		tic = GlobalMembersAxis.quantize_normal_tics(xr / DefineConstants.WEEK_SEC, guide) * DefineConstants.WEEK_SEC;
		if (tic < DefineConstants.WEEK_SEC) // force
		{
			tic = DefineConstants.WEEK_SEC;
		}
		if (tic >= DefineConstants.WEEK_SEC)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_WEEKS;
		}
		if (tic > 3 * DefineConstants.WEEK_SEC)
		{
		/* turn tic into units of month */
		tic = GlobalMembersAxis.quantize_normal_tics(xr / DefineConstants.MON_SEC, guide) * DefineConstants.MON_SEC;
		if (tic < DefineConstants.MON_SEC) // force
		{
			tic = DefineConstants.MON_SEC;
		}
		if (tic >= DefineConstants.MON_SEC)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_MONTHS;
		}
		if (tic > DefineConstants.MON_SEC)
		{
		/* turn tic into units of years */
		tic = GlobalMembersAxis.quantize_duodecimal_tics(xr / DefineConstants.YEAR_SEC, guide12) * DefineConstants.YEAR_SEC;
		if (tic >= DefineConstants.YEAR_SEC)
			timelevel[axis.getValue()] = e_timelevel.TIMELEVEL_YEARS;
		}
		return (tic);
	}

/* }}} */

/* {{{ time_tic_just() */
/* justify ticplace to a proper date-time value */
	public static double time_tic_just(e_timelevel level, double ticplace)
	{
		tm tm = new tm();

		if (level <= e_timelevel.TIMELEVEL_SECONDS)
		{
		return (ticplace);
		}
		GlobalMembersTime.ggmtime(tm, ticplace);
		if (level >= e_timelevel.TIMELEVEL_MINUTES) // units of minutes
		{
		if (tm.tm_sec > 55)
			tm.tm_min++;
		tm.tm_sec = 0;
		}
		if (level >= e_timelevel.TIMELEVEL_HOURS) // units of hours
		{
		if (tm.tm_min > 55)
			tm.tm_hour++;
		tm.tm_min = 0;
		}
		if (level >= e_timelevel.TIMELEVEL_DAYS) // units of days
		{
		if (tm.tm_hour > 22)
		{
			tm.tm_hour = 0;
			tm.tm_mday = 0;
			tm.tm_yday++;
			GlobalMembersTime.ggmtime(tm, GlobalMembersTime.gtimegm(tm));
		}
		}
		/* skip it, I have not bothered with weekday so far */
		if (level >= e_timelevel.TIMELEVEL_MONTHS) // units of month
		{
		if (tm.tm_mday > 25)
		{
			tm.tm_mon++;
			if (tm.tm_mon > 11)
			{
			tm.tm_year++;
			tm.tm_mon = 0;
			}
		}
		tm.tm_mday = 1;
		}

		ticplace = GlobalMembersTime.gtimegm(tm);
		return (ticplace);
	}

/* }}} */


/* {{{ round_outward */
/* HBB 20011204: new function (repeated code ripped out of setup_tics)
 * that rounds an axis endpoint outward. If the axis is a time/date
 * one, take care to round towards the next whole time unit, not just
 * a multiple of the (averaged) tic size */
	public static double round_outward(AXIS_INDEX axis, boolean upwards, double input)
	{
		double tic = ticstep[axis.getValue()];
		double result = tic * (upwards ? Math.ceil(input / tic) : Math.floor(input / tic));

		if (axis_array[axis.getValue()].is_timedata)
		{
		double ontime = GlobalMembersAxis.time_tic_just(timelevel[axis.getValue()], result);

		/* FIXME: how certain is it that we don't want to *always*
		 * return 'ontime'? */
		if ((upwards && (ontime > result)) || (!upwards && (ontime < result)))
			return ontime;
		}

		return result;
	}
/* }}} */


/* {{{ axis_position_zeroaxis */
	public static boolean axis_position_zeroaxis(AXIS_INDEX axis)
	{
		boolean is_inside = false;
		axis this_Renamed = axis_array + axis;

		/* HBB 20020215: correctly treat reversed axes, too! */
		/* EAM Sep 2005: Nothing wrong with 0 at extreme of the range */
		if ((this_Renamed.min > 0.0 && this_Renamed.max > 0.0) || this_Renamed.log)
		{
		this_Renamed.term_zero = (this_Renamed.max < this_Renamed.min) ? this_Renamed.term_upper : this_Renamed.term_lower;
		}
		else if (this_Renamed.min < 0.0 && this_Renamed.max < 0.0)
		{
		this_Renamed.term_zero = (this_Renamed.max < this_Renamed.min) ? this_Renamed.term_lower : this_Renamed.term_upper;
		}
		else
		{
		this_Renamed.term_zero = (int)((axis_array[axis.getValue()].term_lower) + ((0.0) - axis_array[axis.getValue()].min) * axis_array[axis.getValue()].term_scale + 0.5);
		is_inside = true;
		}

		return is_inside;
	}
/* }}} */

/* {{{ quantize_duodecimal_tics */
/* HBB 20020220: New function, to be used to properly tic axes with a
 * duodecimal reference, as used in times (60 seconds, 60 minuts, 24
 * hours, 12 months). Derived from quantize_normal_tics(). The default
 * guide is assumed to be 12, here, not 20 */
	public static double quantize_duodecimal_tics(double arg, int guide)
	{
		/* order of magnitude of argument: */
		double power = GlobalMembersAxis.dbl_raise(12.0, Math.floor(Math.log(arg) / Math.log(12.0)));
		double xnorm = arg / power; // approx number of decades
		double posns = guide / xnorm; // approx number of tic posns per decade

		if (posns > 24)
		return power / 24; // half a smaller unit --- shouldn't happen
		else if (posns > 12)
		return power / 12; // one smaller unit
		else if (posns > 6)
		return power / 6; // 2 smaller units = one-6th of a unit
		else if (posns > 4)
		return power / 4; // 3 smaller units = quarter unit
		else if (posns > 2)
		return power / 2; // 6 smaller units = half a unit
		else if (posns > 1)
		return power; // 0, 1, 2, ..., 11
		else if (posns > 0.5)
		return power * 2; // 0, 2, 4, ..., 10
		else if (posns > 1.0 / 3)
		return power * 3; // 0, 3, 6, 9
		else
		/* getting desperate... the ceil is to make sure we
		 * go over rather than under - eg plot [-10:10] x*x
		 * gives a range of about 99.999 - tics=xnorm gives
		 * tics at 0, 99.99 and 109.98  - BAD !
		 * This way, inaccuracy the other way will round
		 * up (eg 0->100.0001 => tics at 0 and 101
		 * I think latter is better than former
		 */
		return power * Math.ceil(xnorm);
	}
	public static void get_position_type(position_type type, int axes)
	{
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fir$st") != 0)
		{
		++GlobalMembersCommand.c_token;
		type = position_type.first_axes;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sec$ond") != 0)
		{
		++GlobalMembersCommand.c_token;
		type = position_type.second_axes;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "gr$aph") != 0)
		{
		++GlobalMembersCommand.c_token;
		type = position_type.graph;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sc$reen") != 0)
		{
		++GlobalMembersCommand.c_token;
		type = position_type.screen;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "char$acter") != 0)
		{
		++GlobalMembersCommand.c_token;
		type = position_type.character;
		}
		switch (type)
		{
		case first_axes:
		axes = DefineConstants.FIRST_AXES;
		return;
		case second_axes:
		axes = DefineConstants.SECOND_AXES;
		return;
		default:
		axes = (-1);
		return;
		}
	}
}