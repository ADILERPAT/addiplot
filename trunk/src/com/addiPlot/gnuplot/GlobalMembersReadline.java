package com.addiPlot.gnuplot;

public class GlobalMembersReadline
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: readline.c,v 1.46 2008/12/12 21:06:13 sfeam Exp $");
	}
///#endif // HAVE_LIBREADLINE || HAVE_LIBEDITLINE 

///#if defined(HAVE_LIBREADLINE) || defined(HAVE_LIBEDITLINE) || defined(READLINE)
	///#endif

	/* GNUPLOT - readline.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/*
	 * AUTHORS
	 *
	 *   Original Software:
	 *     Tom Tkacik
	 *
	 *   Msdos port and some enhancements:
	 *     Gershon Elber and many others.
	 *
	 */


	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	/*
	 * $Id: readline.h,v 1.11 2008/12/12 21:06:13 sfeam Exp $
	 */

	/* GNUPLOT - readline.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	/* Type definitions */

	/* Variables of readline.c needed by other modules: */

	/* Prototypes of functions exported by readline.c */

	///#if defined(HAVE_LIBREADLINE)
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#include <editline/readline.h>
	///#endif

	///#if defined(HAVE_LIBEDITLINE)
	//int getc_wrapper __PROTO((FILE* fp));
	///#endif

	///#if defined(READLINE) && !defined(HAVE_LIBREADLINE) && !defined(HAVE_LIBEDITLINE)
	//char *readline __PROTO((const char *));
	///#endif

	/*
	 * The following 'readline_ipc' routine is usual 'readline' for OS2_IPC,
	 * and a special one for IPC communication.
	 */
	public static String readline_ipc(String prompt)
	{
	///#if defined(PIPE_IPC) && defined(HAVE_LIBREADLINE)
		rl_getc_function = getc_wrapper;
	///#endif
		return readline((String) prompt);
	}
//C++ TO JAVA CONVERTER WARNING: The following constructor is declared outside of its associated class:
	static



	///#ifdef GNUPLOT_HISTORY
	///#endif
	///#ifdef HAVE_LIBREADLINE
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#include <editline/readline.h>
	///#endif
	///#if defined(READLINE) && !defined(HAVE_LIBREADLINE) && !defined(HAVE_LIBEDITLINE)
	///#elif defined(HAVE_LIBREADLINE) || defined(HAVE_LIBEDITLINE)
	///#endif // READLINE && !HAVE_LIBREADLINE 
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef USE_MOUSE
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef _MOUSE_C
	///#endif // _MOUSE_C 
	///#if 0
	///#endif
	///#if defined(_MOUSE_C)
	///#else
	///#endif
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef LINUXVGA
	///#endif // LINUXVGA 
	///#ifdef OS2
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif

	///#if defined(HAVE_LIBREADLINE) || defined(HAVE_LIBEDITLINE)
	///#if defined(HAVE_LIBEDITLINE)
	//int
	///#else
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	//static intgetc_wrapper(FILE* fp // is NULL, supplied by libedit 
	//)
	///#else
	///#endif
	{
		int c;

		while (true)
		{
	///#ifdef USE_MOUSE
		if (GlobalMembersTerm.term != null && GlobalMembersTerm.term.waitforinput && GlobalMembersPlot.interactive)
		{
			c = GlobalMembersTerm.term.waitforinput();
		}
		else
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	//	    c = getchar();
	///#else
			c = getc(fp);
	///#endif
		if (c == EOF && errno == EINTR)
			continue;
		return c;
		}
	}
	///#endif  // defined(HAVE_LIBREADLINE) || define(READLINE) 
	///#endif
}
///#if defined(READLINE) && !(defined(HAVE_LIBREADLINE) || defined(HAVE_LIBEDITLINE))
//
// /* a small portable version of GNU's readline
//  * this is not the BASH or GNU EMACS version of READLINE due to Copyleft
//  * restrictions
//  * do not need any terminal capabilities except backspace,
//  * and space overwrites a character
//  */
//
// /* NANO-EMACS line editing facility
//  * printable characters print as themselves (insert not overwrite)
//  * ^A moves to the beginning of the line
//  * ^B moves back a single character
//  * ^E moves to the end of the line
//  * ^F moves forward a single character
//  * ^K kills from current position to the end of line
//  * ^P moves back through history
//  * ^N moves forward through history
//  * ^H and DEL delete the previous character
//  * ^D deletes the current character, or EOF if line is empty
//  * ^L/^R redraw line in case it gets trashed
//  * ^U kills the entire line
//  * ^W kills last word
//  * LF and CR return the entire line regardless of the cursor postition
//  * EOF with an empty line returns (char *)NULL
//  *
//  * all other characters are ignored
//  */
//
///#ifdef HAVE_SYS_IOCTL_H
// /* For ioctl() prototype under Linux (and BeOS?) */
///#include <sys/ioctl.h>
//
// /* replaces the previous klugde in configure */
///#if defined(HAVE_TERMIOS_H) && defined(HAVE_TCGETATTR)
///#define TERMIOS
///#else // not HAVE_TERMIOS_H && HAVE_TCGETATTR 
///#ifdef HAVE_SGTTY_H
///#define SGTTY
///#endif
///#endif // not HAVE_TERMIOS_H && HAVE_TCGETATTR 
//
///#if !defined(MSDOS) && !defined(_Windows) && !defined(DOS386) && !defined(OSK)
//
// /*
//  * Set up structures using the proper include file
//  */
///#if defined(_IBMR2) || defined(alliant)
///#define SGTTY
///#endif
//
// /*  submitted by Francois.Dagorn@cicb.fr */
///#ifdef SGTTY
///#include <sgtty.h>
//static struct sgttyb orig_termio, rl_termio;
// /* define terminal control characters */
//static struct tchars s_tchars;
///#ifndef VERASE
///#define VERASE    0
///#endif			// not VERASE 
///#ifndef VEOF
///#define VEOF      1
///#endif			// not VEOF 
///#ifndef VKILL
///#define VKILL     2
///#endif			// not VKILL 
///#ifdef TIOCGLTC		// available only with the 'new' line discipline 
//static struct ltchars s_ltchars;
///#ifndef VWERASE
///#define VWERASE   3
///#endif			// not VWERASE 
///#ifndef VREPRINT
///#define VREPRINT  4
///#endif			// not VREPRINT 
///#ifndef VSUSP
///#define VSUSP     5
///#endif			// not VSUP 
///#endif			// TIOCGLTC 
///#ifndef NCCS
///#define NCCS      6
///#endif			// not NCCS 
//
///#else				// not SGTTY 
//
// /* SIGTSTP defines job control
//  * if there is job control then we need termios.h instead of termio.h
//  * (Are there any systems with job control that use termio.h?  I hope not.)
//  */
///#if defined(SIGTSTP) || defined(TERMIOS)
///#ifndef TERMIOS
///#define TERMIOS
///#endif			// not TERMIOS 
///#include <termios.h>
// /* Added by Robert Eckardt, RobertE@beta.TP2.Ruhr-Uni-Bochum.de */
///#ifdef ISC22
///#ifndef ONOCR		// taken from sys/termio.h 
///#define ONOCR 0000020	// true at least for ISC 2.2 
///#endif			// not ONOCR 
///#ifndef IUCLC
///#define IUCLC 0001000
///#endif			// not IUCLC 
///#endif			// ISC22 
///#if !defined(IUCLC)
// /* translate upper to lower case not supported */
///#define IUCLC 0
///#endif			// not IUCLC 
//
//static struct termios orig_termio, rl_termio;
///#else				// not SIGSTP || TERMIOS 
///#include <termio.h>
//static struct termio orig_termio, rl_termio;
// /* termio defines NCC instead of NCCS */
///#define NCCS    NCC
///#endif			// not SIGTSTP || TERMIOS 
///#endif				// SGTTY 
//
// /* ULTRIX defines VRPRNT instead of VREPRINT */
///#if defined(VRPRNT) && !defined(VREPRINT)
///#define VREPRINT VRPRNT
///#endif				// VRPRNT 
//
// /* define characters to use with our input character handler */
//static char term_chars[NCCS];
//
//static int term_set = 0;	// =1 if rl_termio set 
//
///#define special_getc() ansi_getc()
//static int ansi_getc __PROTO((void));
//
///#else // MSDOS or _Windows or DOS386 or OSK 
//
///#ifdef _Windows
///#include <windows.h>
///#include "win/wtext.h"
///#include "win/winmain.h"
///#define TEXTUSER 0xf1
///#define TEXTGNUPLOT 0xf0
///#ifdef WGP_CONSOLE
///#define special_getc() win_getch()
//static char win_getch __PROTO((void));
///#else
///#define special_getc() msdos_getch()
///#endif // WGP_CONSOLE 
//static char msdos_getch __PROTO((void));	// HBB 980308: PROTO'ed it 
///#endif				// _Windows 
//
///#if defined(MSDOS) || defined(DOS386)
// /* MSDOS specific stuff */
///#ifdef DJGPP
///#include <pc.h>
///#endif			// DJGPP 
///#if defined(__EMX__) || defined (__WATCOMC__)
///#include <conio.h>
///#endif			// __EMX__ 
///#define special_getc() msdos_getch()
//static char msdos_getch();
///#endif				// MSDOS || DOS386 
//
///#ifdef OSK
///#include <sgstat.h>
///#include <modes.h>
//
///#define STDIN	0
//static int term_set = 0;	// =1 if new_settings is set 
//
//static struct _sgs old_settings;	// old terminal settings        
//static struct _sgs new_settings;	// new terminal settings        
//
///#define special_getc() ansi_getc()
//static int ansi_getc __PROTO((void));
//
// /* On OS9 a '\n' is a character 13 and '\r' == '\n'. This gives troubles
//    here, so we need a new putc wich handles this correctly and print a
//    character 10 on each place we want a '\n'.
//  */
///#undef putc			// Undefine the macro for putc 
//
//static int
//putc(char c, FILE *fp)
//{
//    write(fileno(fp), &c, 1);
//    if (c == '\012') {		// A normal ASCII '\n' 
//	c = '\r';
//	write(fileno(fp), &c, 1);
//    }
//}
//
///#endif				// OSK 
//
///#endif // MSDOS or _Windows or DOS386 or OSK 
//
///#ifdef OS2
///#if defined( special_getc )
///#undef special_getc()
///#endif				// special_getc 
///#define special_getc() os2_getch()
//static char msdos_getch __PROTO((void));	// HBB 980308: PROTO'ed it 
//static char os2_getch __PROTO((void));
///#endif // OS2 
//
//
// /* initial size and increment of input line length */
///#define MAXBUF	1024
///#define BACKSPACE 0x08   // ^H 
///#define SPACE	' '
//
///#ifdef OSK
///#define NEWLINE	'\012'
///#else // OSK 
///#define NEWLINE	'\n'
///#endif // not OSK 
//
//static char *cur_line;		// current contents of the line 
//static size_t line_len = 0;
//static size_t cur_pos = 0;	// current position of the cursor 
//static size_t max_pos = 0;	// maximum character position 
//
//static void fix_line __PROTO((void));
//static void redraw_line __PROTO((const char *prompt));
//static void clear_line __PROTO((const char *prompt));
//static void clear_eoline __PROTO((void));
//static void copy_line __PROTO((char *line));
//static void set_termio __PROTO((void));
//static void reset_termio __PROTO((void));
//static int user_putc __PROTO((int ch));
//static int user_puts __PROTO((char *str));
//static void backspace __PROTO((void));
//static void extend_cur_line __PROTO((void));
//
//
// /* user_putc and user_puts should be used in the place of
//  * fputc(ch,stderr) and fputs(str,stderr) for all output
//  * of user typed characters.  This allows MS-Windows to
//  * display user input in a different color.
//  */
//static int
//user_putc(int ch)
//{
//    int rv;
///#ifdef _Windows
///#ifndef WGP_CONSOLE
//    TextAttr(&textwin, TEXTUSER);
///#endif
///#endif
//    rv = fputc(ch, stderr);
///#ifdef _Windows
///#ifndef WGP_CONSOLE
//    TextAttr(&textwin, TEXTGNUPLOT);
///#endif
///#endif
//    return rv;
//}
//
//static int
//user_puts(char *str)
//{
//    int rv;
///#ifdef _Windows
///#ifndef WGP_CONSOLE
//    TextAttr(&textwin, TEXTUSER);
///#endif
///#endif
//    rv = fputs(str, stderr);
///#ifdef _Windows
///#ifndef WGP_CONSOLE
//    TextAttr(&textwin, TEXTGNUPLOT);
///#endif
///#endif
//    return rv;
//}
//
// /* This function provides a centralized non-destructive backspace capability
//  * M. Castro
//  */
//static void
//backspace()
//{
//    user_putc(BACKSPACE);
//}
//
//static void
//extend_cur_line()
//{
//    char *new_line;
//
// /* extent input line length */
//    new_line = gp_realloc(cur_line, line_len + MAXBUF, NULL);
//    if (!new_line) {
//	reset_termio();
//	int_error(NO_CARET, "Can't extend readline length");
//    }
//    cur_line = new_line;
//    line_len += MAXBUF;
//    FPRINTF((stderr, "\nextending readline length to %d chars\n", line_len));
//}
//
//char *
//readline(const char *prompt)
//{
//    int cur_char;
//    char *new_line;
//
//
// /* start with a string of MAXBUF chars */
//    if (line_len != 0) {
//	free(cur_line);
//	line_len = 0;
//    }
//    cur_line = gp_alloc(MAXBUF, "readline");
//    line_len = MAXBUF;
//
// /* set the termio so we can do our own input processing */
//    set_termio();
//
// /* print the prompt */
//    fputs(prompt, stderr);
//    cur_line[0] = '\0';
//    cur_pos = 0;
//    max_pos = 0;
//    cur_entry = NULL;
//
// /* get characters */
//    for (;;) {
//
//	cur_char = special_getc();
//
// /* The #define CHARSET7BIT should be used when one encounters
//  * problems with 8bit characters that should not be entered on
//  * the commandline. I cannot think on any reasonable example
//  * where this could happen, but what do I know?  After all,
//  * the unix world still ignores 8bit chars in most
//  * applications.
//  *
//  * Note that latin1 defines the chars 0x80-0x9f as control
//  * chars. For the benefit of MSDOS, Windows and NeXT I
//  * have decided to ignore this, since it would require more
//  * #ifs. */
//
//	if (isprint(cur_char)
///#ifndef CHARSET7BIT
// /* || ((unsigned char) cur_char == 011) //Tangible continue code after comment*/
// /* EAM allowing <tab> breaks auto-completion! */
//	    || (((unsigned char) cur_char > 0x7f) && cur_char != EOF)
///#endif // CHARSET7BIT 
//	    ) {
//	    size_t i;
//
//	    if (max_pos + 1 >= line_len) {
//		extend_cur_line();
//	    }
//	    for (i = max_pos; i > cur_pos; i--) {
//		cur_line[i] = cur_line[i - 1];
//	    }
//	    user_putc(cur_char);
//	    cur_line[cur_pos] = cur_char;
//	    cur_pos += 1;
//	    max_pos += 1;
//	    if (cur_pos < max_pos)
//		fix_line();
//	    cur_line[max_pos] = '\0';
//
// /* else interpret unix terminal driver characters */
///#ifdef VERASE
//	} else if (cur_char == term_chars[VERASE]) {	// DEL? 
//	    if (cur_pos > 0) {
//		size_t i;
//		cur_pos -= 1;
//		backspace();
//		for (i = cur_pos; i < max_pos; i++)
//		    cur_line[i] = cur_line[i + 1];
//		max_pos -= 1;
//		fix_line();
//	    }
///#endif // VERASE 
///#ifdef VEOF
//	} else if (cur_char == term_chars[VEOF]) {	// ^D? 
//	    if (max_pos == 0) {
//		reset_termio();
//		return ((char *) NULL);
//	    }
//	    if ((cur_pos < max_pos) && (cur_char == 004)) {	// ^D 
//		size_t i;
//		for (i = cur_pos; i < max_pos; i++)
//		    cur_line[i] = cur_line[i + 1];
//		max_pos -= 1;
//		fix_line();
//	    }
///#endif // VEOF 
///#ifdef VKILL
//	} else if (cur_char == term_chars[VKILL]) {	// ^U? 
//	    clear_line(prompt);
///#endif // VKILL 
///#ifdef VWERASE
//	} else if (cur_char == term_chars[VWERASE]) {	// ^W? 
//	    while ((cur_pos > 0) &&
//		   (cur_line[cur_pos - 1] == SPACE)) {
//		cur_pos -= 1;
//		backspace();
//	    }
//	    while ((cur_pos > 0) &&
//		   (cur_line[cur_pos - 1] != SPACE)) {
//		cur_pos -= 1;
//		backspace();
//	    }
//	    clear_eoline();
//	    max_pos = cur_pos;
///#endif // VWERASE 
///#ifdef VREPRINT
//	} else if (cur_char == term_chars[VREPRINT]) {	// ^R? 
//	    putc(NEWLINE, stderr);	// go to a fresh line 
//	    redraw_line(prompt);
///#endif // VREPRINT 
///#ifdef VSUSP
//	} else if (cur_char == term_chars[VSUSP]) {
//	    reset_termio();
//	    kill(0, SIGTSTP);
//
// /* process stops here */
//
//	    set_termio();
// /* print the prompt */
//	    redraw_line(prompt);
///#endif // VSUSP 
//	} else {
// /* do normal editing commands */
// /* some of these are also done above */
//	    size_t i;
//	    switch (cur_char) {
//	    case EOF:
//		reset_termio();
//		return ((char *) NULL);
//	    case 001:		// ^A 
//		while (cur_pos > 0) {
//		    cur_pos -= 1;
//		    backspace();
//		}
//		break;
//	    case 002:		// ^B 
//		if (cur_pos > 0) {
//		    cur_pos -= 1;
//		    backspace();
//		}
//		break;
//	    case 005:		// ^E 
//		while (cur_pos < max_pos) {
//		    user_putc(cur_line[cur_pos]);
//		    cur_pos += 1;
//		}
//		break;
//	    case 006:		// ^F 
//		if (cur_pos < max_pos) {
//		    user_putc(cur_line[cur_pos]);
//		    cur_pos += 1;
//		}
//		break;
//	    case 013:		// ^K 
//		clear_eoline();
//		max_pos = cur_pos;
//		break;
//	    case 020:		// ^P 
//		if (history != NULL) {
//		    if (cur_entry == NULL) {
//			cur_entry = history;
//			clear_line(prompt);
//			copy_line(cur_entry->line);
//		    } else if (cur_entry->prev != NULL) {
//			cur_entry = cur_entry->prev;
//			clear_line(prompt);
//			copy_line(cur_entry->line);
//		    }
//		}
//		break;
//	    case 016:		// ^N 
//		if (cur_entry != NULL) {
//		    cur_entry = cur_entry->next;
//		    clear_line(prompt);
//		    if (cur_entry != NULL)
//			copy_line(cur_entry->line);
//		    else
//			cur_pos = max_pos = 0;
//		}
//		break;
//	    case 014:		// ^L 
//	    case 022:		// ^R 
//		putc(NEWLINE, stderr);	// go to a fresh line 
//		redraw_line(prompt);
//		break;
//	    case 0177:		// DEL 
//	    case 010:		// ^H 
//		if (cur_pos > 0) {
//		    cur_pos -= 1;
//		    backspace();
//		    for (i = cur_pos; i < max_pos; i++)
//			cur_line[i] = cur_line[i + 1];
//		    max_pos -= 1;
//		    fix_line();
//		}
//		break;
//	    case 004:		// ^D 
//		if (max_pos == 0) {
//		    reset_termio();
//		    return ((char *) NULL);
//		}
//		if (cur_pos < max_pos) {
//		    for (i = cur_pos; i < max_pos; i++)
//			cur_line[i] = cur_line[i + 1];
//		    max_pos -= 1;
//		    fix_line();
//		}
//		break;
//	    case 025:		// ^U 
//		clear_line(prompt);
//		break;
//	    case 027:		// ^W 
//		while ((cur_pos > 0) &&
//		       (cur_line[cur_pos - 1] == SPACE)) {
//		    cur_pos -= 1;
//		    backspace();
//		}
//		while ((cur_pos > 0) &&
//		       (cur_line[cur_pos - 1] != SPACE)) {
//		    cur_pos -= 1;
//		    backspace();
//		}
//		clear_eoline();
//		max_pos = cur_pos;
//		break;
//	    case '\n':		// ^J 
///#ifndef OSK
//	    case '\r':		// ^M 
///#endif
//		cur_line[max_pos + 1] = '\0';
///#ifdef OS2
//		while (cur_pos < max_pos) {
//		    user_putc(cur_line[cur_pos]);
//		    cur_pos += 1;
//		}
///#endif
//		putc(NEWLINE, stderr);
//
// /* Shrink the block down to fit the string ?
//  * if the alloc fails, we still own block at cur_line,
//  * but this shouldn't really fail.
//  */
//		new_line = (char *) gp_realloc(cur_line, strlen(cur_line) + 1,
//					       "line resize");
//		if (new_line)
//		    cur_line = new_line;
// /* else we just hang on to what we had - it's not a problem */
//
//		line_len = 0;
//		FPRINTF((stderr, "Resizing input line to %d chars\n", strlen(cur_line)));
//		reset_termio();
//		return (cur_line);
//	    default:
//		break;
//	    }
//	}
//    }
//}
//
// /* fix up the line from cur_pos to max_pos
//  * do not need any terminal capabilities except backspace,
//  * and space overwrites a character
//  */
//static void
//fix_line()
//{
//    size_t i;
//
// /* write tail of string */
//    for (i = cur_pos; i < max_pos; i++)
//	user_putc(cur_line[i]);
//
// /* write a space at the end of the line in case we deleted one */
//    user_putc(SPACE);
//
// /* backup to original position */
//    for (i = max_pos + 1; i > cur_pos; i--)
//	backspace();
//
//}
//
// /* redraw the entire line, putting the cursor where it belongs */
//static void
//redraw_line(const char *prompt)
//{
//    size_t i;
//
//    fputs(prompt, stderr);
//    user_puts(cur_line);
//
// /* put the cursor where it belongs */
//    for (i = max_pos; i > cur_pos; i--)
//	backspace();
//}
//
// /* clear cur_line and the screen line */
//static void
//clear_line(const char *prompt)
//{
//    size_t i;
//    for (i = 0; i < max_pos; i++)
//	cur_line[i] = '\0';
//
//    for (i = cur_pos; i > 0; i--)
//	backspace();
//
//    for (i = 0; i < max_pos; i++)
//	putc(SPACE, stderr);
//
//    putc('\r', stderr);
//    fputs(prompt, stderr);
//
//    cur_pos = 0;
//    max_pos = 0;
//}
//
// /* clear to end of line and the screen end of line */
//static void
//clear_eoline()
//{
//    size_t i;
//    for (i = cur_pos; i < max_pos; i++)
//	cur_line[i] = '\0';
//
//    for (i = cur_pos; i < max_pos; i++)
//	putc(SPACE, stderr);
//    for (i = cur_pos; i < max_pos; i++)
//	backspace();
//}
//
// /* copy line to cur_line, draw it and set cur_pos and max_pos */
//static void
//copy_line(char *line)
//{
//    while (strlen(line) + 1 > line_len) {
//	extend_cur_line();
//    }
//    strcpy(cur_line, line);
//    user_puts(cur_line);
//    cur_pos = max_pos = strlen(cur_line);
//}
//
///#if !defined(MSDOS) && !defined(_Windows) && !defined(DOS386) && !defined(OSK)
// /* Convert ANSI arrow keys to control characters */
//static int
//ansi_getc()
//{
//    int c;
//
///#ifdef USE_MOUSE
//    if (term && term->waitforinput && interactive)
//	c = term->waitforinput();
//    else
///#endif
//    c = getc(stdin);
//
//    if (c == 033) {
//	c = getc(stdin);	// check for CSI 
//	if (c == '[') {
//	    c = getc(stdin);	// get command character 
//	    switch (c) {
//	    case 'D':		// left arrow key 
//		c = 002;
//		break;
//	    case 'C':		// right arrow key 
//		c = 006;
//		break;
//	    case 'A':		// up arrow key 
//		c = 020;
//		break;
//	    case 'B':		// down arrow key 
//		c = 016;
//		break;
//	    case 'F':		// end key 
//		c = 005;
//		break;
//	    case 'H':		// home key 
//		c = 001;
//		break;
//	    }
//	}
//    }
//    return c;
//}
///#endif
//
///#if defined(MSDOS) || defined(_Windows) || defined(DOS386) || defined(OS2)
//
///#ifdef WGP_CONSOLE
//static char
//win_getch()
//{
//    if (term && term->waitforinput)
//        return term->waitforinput();
//    else
//        return ConsoleGetch();
//}
///#endif
//
// /* Convert Arrow keystrokes to Control characters: */
//static char
//msdos_getch()
//{
//	char c;
//	
///#ifdef DJGPP
//    int ch = getkey();
//    c = (ch & 0xff00) ? 0 : ch & 0xff;
///#elif defined (OS2)
//    c = getc(stdin);
///#else // not OS2, not DJGPP
///#if defined (_Windows) && defined (USE_MOUSE)
//    if (term && term->waitforinput && interactive)
//	c = term->waitforinput();
//    else
///#endif // not _Windows && not USE_MOUSE 
//    c = getch();
///#endif // not DJGPP, not OS2 
//
//    if (c == 0) {
///#ifdef DJGPP
//	c = ch & 0xff;
///#else // not DJGPP 
///#ifdef OS2
//	c = getc(stdin);
///#else				// not OS2 
//	c = getch();		// Get the extended code. 
///#endif				// OS2 
///#endif // not DJGPP 
//
//	switch (c) {
//	case 75:		// Left Arrow. 
//	    c = 002;
//	    break;
//	case 77:		// Right Arrow. 
//	    c = 006;
//	    break;
//	case 72:		// Up Arrow. 
//	    c = 020;
//	    break;
//	case 80:		// Down Arrow. 
//	    c = 016;
//	    break;
//	case 115:		// Ctl Left Arrow. 
//	case 71:		// Home 
//	    c = 001;
//	    break;
//	case 116:		// Ctl Right Arrow. 
//	case 79:		// End 
//	    c = 005;
//	    break;
//	case 83:		// Delete 
//	    c = 004;
//	    break;
//	default:
//	    c = 0;
//	    break;
//	}
//    } else if (c == 033) {	// ESC 
//	c = 025;
//    }
//    return c;
//}
//
///#endif // MSDOS || _Windows || DOS386 || OS2 
//
///#ifdef OS2
// /* We need to call different procedures, dependent on the
//    session type: VIO/window or an (XFree86) xterm */
//static char
//os2_getch() {
//  static int IsXterm = 0;
//  static int init = 0;
//
//  if (!init) {
//     if (getenv("WINDOWID")) {
//        IsXterm = 1;
//     }
//     init = 1;
//  }
//  if (IsXterm) {
//     return ansi_getc();
//  } else {
//     return msdos_getch();
//  }
//}
///#endif // OS2 
//
//
// /* set termio so we can do our own input processing */
//static void
//set_termio()
//{
///#if !defined(MSDOS) && !defined(_Windows) && !defined(DOS386)
// /* set termio so we can do our own input processing */
// /* and save the old terminal modes so we can reset them later */
//    if (term_set == 0) {
// /*
//  * Get terminal modes.
//  */
///#ifndef OSK
///#ifdef SGTTY
//	ioctl(0, TIOCGETP, &orig_termio);
///#else				// not SGTTY 
///#ifdef TERMIOS
///#ifdef TCGETS
//	ioctl(0, TCGETS, &orig_termio);
///#else			// not TCGETS 
//	tcgetattr(0, &orig_termio);
///#endif			// not TCGETS 
///#else			// not TERMIOS 
//	ioctl(0, TCGETA, &orig_termio);
///#endif			// TERMIOS 
///#endif			// not SGTTY 
///#else				// OSK 
//	setbuf(stdin, (char *) 0);	// Make stdin and stdout unbuffered 
//	setbuf(stderr, (char *) 0);
//	_gs_opt(STDIN, &new_settings);
///#endif				// OSK 
//
// /*
//  * Save terminal modes
//  */
///#ifndef OSK
//	rl_termio = orig_termio;
///#else				// OSK 
//	_gs_opt(STDIN, &old_settings);
///#endif				// OSK 
//
// /*
//  * Set the modes to the way we want them
//  *  and save our input special characters
//  */
///#ifndef OSK
///#ifdef SGTTY
//	rl_termio.sg_flags |= CBREAK;
//	rl_termio.sg_flags &= ~(ECHO | XTABS);
//	ioctl(0, TIOCSETN, &rl_termio);
//
//	ioctl(0, TIOCGETC, &s_tchars);
//	term_chars[VERASE] = orig_termio.sg_erase;
//	term_chars[VEOF] = s_tchars.t_eofc;
//	term_chars[VKILL] = orig_termio.sg_kill;
///#ifdef TIOCGLTC
//	ioctl(0, TIOCGLTC, &s_ltchars);
//	term_chars[VWERASE] = s_ltchars.t_werasc;
//	term_chars[VREPRINT] = s_ltchars.t_rprntc;
//	term_chars[VSUSP] = s_ltchars.t_suspc;
//
// /* disable suspending process on ^Z */
//	s_ltchars.t_suspc = 0;
//	ioctl(0, TIOCSLTC, &s_ltchars);
///#endif			// TIOCGLTC 
///#else				// not SGTTY 
//	rl_termio.c_iflag &= ~(BRKINT | PARMRK | INPCK | IUCLC | IXON | IXOFF);
//	rl_termio.c_iflag |= (IGNBRK | IGNPAR);
//
// /* rl_termio.c_oflag &= ~(ONOCR); Costas Sphocleous Irvine,CA */
//
//	rl_termio.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL | NOFLSH);
///#ifdef OS2
// /* for emx: remove default terminal processing */
//	rl_termio.c_lflag &= ~(IDEFAULT);
///#endif			// OS2 
//	rl_termio.c_lflag |= (ISIG);
//	rl_termio.c_cc[VMIN] = 1;
//	rl_termio.c_cc[VTIME] = 0;
//
///#ifndef VWERASE
///#define VWERASE 3
///#endif			// VWERASE 
//	term_chars[VERASE] = orig_termio.c_cc[VERASE];
//	term_chars[VEOF] = orig_termio.c_cc[VEOF];
//	term_chars[VKILL] = orig_termio.c_cc[VKILL];
///#ifdef TERMIOS
//	term_chars[VWERASE] = orig_termio.c_cc[VWERASE];
///#ifdef VREPRINT
//	term_chars[VREPRINT] = orig_termio.c_cc[VREPRINT];
///#else			// not VREPRINT 
///#ifdef VRPRNT
//	term_chars[VRPRNT] = orig_termio.c_cc[VRPRNT];
///#endif			// VRPRNT 
///#endif			// not VREPRINT 
//	term_chars[VSUSP] = orig_termio.c_cc[VSUSP];
//
// /* disable suspending process on ^Z */
//	rl_termio.c_cc[VSUSP] = 0;
///#endif			// TERMIOS 
///#endif			// not SGTTY 
///#else				// OSK 
//	new_settings._sgs_echo = 0;	// switch off terminal echo 
//	new_settings._sgs_pause = 0;	// inhibit page pause 
//	new_settings._sgs_eofch = 0;	// inhibit eof  
//	new_settings._sgs_kbich = 0;	// inhibit ^C   
//	new_settings._sgs_kbach = 0;	// inhibit ^E   
///#endif				// OSK 
//
// /*
//  * Set the new terminal modes.
//  */
///#ifndef OSK
///#ifdef SGTTY
//	ioctl(0, TIOCSLTC, &s_ltchars);
///#else				// not SGTTY 
///#ifdef TERMIOS
///#ifdef TCSETSW
//	ioctl(0, TCSETSW, &rl_termio);
///#else			// not TCSETSW 
//	tcsetattr(0, TCSADRAIN, &rl_termio);
///#endif			// not TCSETSW 
///#else			// not TERMIOS 
//	ioctl(0, TCSETAW, &rl_termio);
///#endif			// not TERMIOS 
///#endif			// not SGTTY 
///#else				// OSK 
//	_ss_opt(STDIN, &new_settings);
///#endif				// OSK 
//	term_set = 1;
//    }
///#endif // not MSDOS && not _Windows && not DOS386 
//}
//
//static void
//reset_termio()
//{
///#if !defined(MSDOS) && !defined(_Windows) && !defined(DOS386)
// /* reset saved terminal modes */
//    if (term_set == 1) {
///#ifndef OSK
///#ifdef SGTTY
//	ioctl(0, TIOCSETN, &orig_termio);
///#ifdef TIOCGLTC
// /* enable suspending process on ^Z */
//	s_ltchars.t_suspc = term_chars[VSUSP];
//	ioctl(0, TIOCSLTC, &s_ltchars);
///#endif			// TIOCGLTC 
///#else				// not SGTTY 
///#ifdef TERMIOS
///#ifdef TCSETSW
//	ioctl(0, TCSETSW, &orig_termio);
///#else			// not TCSETSW 
//	tcsetattr(0, TCSADRAIN, &orig_termio);
///#endif			// not TCSETSW 
///#else			// not TERMIOS 
//	ioctl(0, TCSETAW, &orig_termio);
///#endif			// TERMIOS 
///#endif			// not SGTTY 
///#else				// OSK 
//	_ss_opt(STDIN, &old_settings);
///#endif				// OSK 
//	term_set = 0;
//    }
///#endif // not MSDOS && not _Windows && not DOS386 
//}
//
///#endif // READLINE && !HAVE_LIBREADLINE 
