package com.addiPlot.gnuplot;

public class GlobalMembersMisc
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: misc.c,v 1.108.2.1 2009/08/02 23:38:51 sfeam Exp $");
	}

/*
 * iso_alloc() allocates a iso_curve structure that can hold 'num'
 * points.
 */
	///#endif

	/* GNUPLOT - misc.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * $Id: misc.h,v 1.32 2009/03/26 00:49:16 sfeam Exp $
	 */

	/* GNUPLOT - misc.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif

	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif


	/* Variables of misc.c needed by other modules: */


	/* Prototypes from file "misc.c" */

	public static iso_curve iso_alloc(int num)
	{
		iso_curve ip;
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		ip = (GlobalMembersMouse.struct iso_curve *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct iso_curve), "iso curve");
		ip.p_max = (num >= 0 ? num : 0);
		ip.p_count = 0;
		if (num > 0)
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		ip.points = (GlobalMembersMouse.struct coordinate  *) GlobalMembersAlloc.gp_alloc(num * sizeof(GlobalMembersMouse.struct coordinate), "iso curve points");
		}
		else
		ip.points = (GlobalMembersMouse.struct coordinate  *) DefineConstants.NULL;
		ip.next = DefineConstants.NULL;
		return (ip);
	}

/*
 * iso_extend() reallocates a iso_curve structure to hold "num"
 * points. This will either expand or shrink the storage.
 */
	public static void iso_extend(iso_curve ip, int num)
	{
		if (num == ip.p_max)
		return;

	///#if defined(DOS16) || defined(WIN16)
	// /* Make sure we do not allocate more than 64k points in msdos since
	//    * indexing is done with 16-bit int
	//    * Leave some bytes for malloc maintainance.
	//  */
	//    if (num > 32700)
	//	int_error(NO_CARET, "Array index must be less than 32k in msdos");
	///#endif // 16bit (Win)Doze

		if (num > 0)
		{
		if (ip.points == DefineConstants.NULL)
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			ip.points = (GlobalMembersMouse.struct coordinate  *) GlobalMembersAlloc.gp_alloc(num * sizeof(GlobalMembersMouse.struct coordinate), "iso curve points");
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			ip.points = (GlobalMembersMouse.struct coordinate  *) GlobalMembersAlloc.gp_realloc(ip.points, num * sizeof(GlobalMembersMouse.struct coordinate), "expanding curve points");
		}
		ip.p_max = num;
		}
		else
		{
		if (ip.points != (GlobalMembersMouse.struct coordinate  *) DefineConstants.NULL)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(ip.points);
		ip.points = (GlobalMembersMouse.struct coordinate  *) DefineConstants.NULL;
		ip.p_max = 0;
		}
	}

/*
 * iso_free() releases any memory which was previously malloc()'d to hold
 *   iso curve points.
 */
	public static void iso_free(iso_curve ip)
	{
		if (ip != null)
		{
		if (ip.points != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free((String) ip.points);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) ip);
		}
	}
	public static void load_file(FILE fp, String name, boolean can_do_args)
	{
		int len;

		int start;
		int left;
		int more;
		int stop = false;

		GlobalMembersMisc.lf_push(fp); // save state for errors and recursion
		do_load_arg_substitution = can_do_args;

		if (fp == (FILE) DefineConstants.NULL)
		{
		GlobalMembersUtil.os_error(GlobalMembersCommand.c_token, "Cannot open %s file '%s'", can_do_args ? "call" : "load", name);
		}
		else if (fp == stdin)
		{
		/* DBT 10-6-98  go interactive if "-" named as load file */
		GlobalMembersPlot.interactive = true;
		while (GlobalMembersCommand.com_line() == 0);
		}
		else
		{
		/* go into non-interactive mode during load */
		/* will be undone below, or in load_file_error */
		int argc = 0; // number arguments passed by "call"
		GlobalMembersPlot.interactive = false;
		GlobalMembersCommand.inline_num = 0;
		lf_head.name = name;

		if (can_do_args)
		{
			/* Gnuplot "call" command can have up to 10 arguments "$0" to "$9" */
			while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && argc <= 9)
			{
			if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
				GlobalMembersUtil.m_quote_capture(call_args[argc++], GlobalMembersCommand.c_token, GlobalMembersCommand.c_token);
			else
				GlobalMembersUtil.m_capture(call_args[argc++], GlobalMembersCommand.c_token, GlobalMembersCommand.c_token);
			GlobalMembersCommand.c_token++;
			}
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(++GlobalMembersCommand.c_token, "too many arguments for 'call <file>'");
		}

		/* These were initialized to NULL in lf_push(); will be freed in lf_pop() */
		lf_head.c_token = GlobalMembersCommand.c_token;
		lf_head.num_tokens = GlobalMembersCommand.num_tokens;
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		lf_head.tokens = GlobalMembersAlloc.gp_alloc(GlobalMembersCommand.num_tokens * sizeof(GlobalMembersMouse.struct lexical_unit), "lf tokens");
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(lf_head.tokens, GlobalMembersCommand.token, GlobalMembersCommand.num_tokens * sizeof(GlobalMembersMouse.struct lexical_unit));
		lf_head.input_line = GlobalMembersUtil.gp_strdup(GlobalMembersCommand.gp_input_line);

		while (stop == 0) // read all commands in file
		{
			/* read one command */
			left = GlobalMembersCommand.gp_input_line_len;
			start = 0;
			more = true;

			while (more != 0)
			{
			if (fgets((GlobalMembersCommand.gp_input_line.charAt(start)), left, fp) == (String) DefineConstants.NULL)
			{
				stop = true; // EOF in file
				GlobalMembersCommand.gp_input_line = tangible.StringFunctions.changeCharacter(GlobalMembersCommand.gp_input_line, start, '\0');
				more = false;
			}
			else
			{
				GlobalMembersCommand.inline_num++;
				len = GlobalMembersCommand.gp_input_line.length() - 1;
				if (GlobalMembersCommand.gp_input_line.charAt(len) == '\n') // remove any newline
				{
				GlobalMembersCommand.gp_input_line = tangible.StringFunctions.changeCharacter(GlobalMembersCommand.gp_input_line, len, '\0');
				/* Look, len was 1-1 = 0 before, take care here! */
				if (len > 0)
					--len;
				if (GlobalMembersCommand.gp_input_line.charAt(len) == '\r') // remove any carriage return
				{
					GlobalMembersCommand.gp_input_line = tangible.StringFunctions.changeCharacter(GlobalMembersCommand.gp_input_line, len, DefineConstants.NUL);
					if (len > 0)
					--len;
				}
				}
				else if (len + 2 >= left)
				{
				GlobalMembersCommand.extend_input_line();
				left = GlobalMembersCommand.gp_input_line_len - len - 1;
				start = len + 1;
				continue; // don't check for '\'
				}
				if (GlobalMembersCommand.gp_input_line.charAt(len) == '\\')
				{
				/* line continuation */
				start = len;
				left = GlobalMembersCommand.gp_input_line_len - start;
				}
				else
				more = false;
			}
			}

			if (GlobalMembersCommand.gp_input_line.length() > 0)
			{
			if (can_do_args)
			{
				int il = 0;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * rl;
				byte raw_line = GlobalMembersUtil.gp_strdup(GlobalMembersCommand.gp_input_line);

				rl = raw_line;
				GlobalMembersCommand.gp_input_line = '\0';
				while (*rl)
				{
				int aix;
				if (*rl == '$' && ((aix = *(++rl)) != 0) && ((aix >= '0' && aix <= '9') || aix == '#')) // HBB 980308: quiet BCC warning
				{
					if (aix == '#')
					{
					/* replace $# by number of passed arguments */
					len = argc < 10 ? 1 : 2; // argc can be 0 .. 10
					while (GlobalMembersCommand.gp_input_line_len - il < len + 1)
					{
						GlobalMembersCommand.extend_input_line();
					}
					String.format(GlobalMembersCommand.gp_input_line + il, "%i", argc);
					il += len;
					}
					else
					if (call_args[aix -= '0'] != 0)
					{
					/* replace $n for n=0..9 by the passed argument */
					len = String.valueOf(call_args[aix]).length();
					while (GlobalMembersCommand.gp_input_line_len - il < len + 1)
					{
						GlobalMembersCommand.extend_input_line();
					}
					GlobalMembersCommand.gp_input_line + il = call_args[aix];
					il += len;
					}
				}
				else
				{
					/* substitute for $<n> here */
					if (il + 1 > GlobalMembersCommand.gp_input_line_len)
					{
					GlobalMembersCommand.extend_input_line();
					}
					GlobalMembersCommand.gp_input_line = tangible.StringFunctions.changeCharacter(GlobalMembersCommand.gp_input_line, il++, *rl);
				}
				rl++;
				}
				if (il + 1 > GlobalMembersCommand.gp_input_line_len)
				{
				GlobalMembersCommand.extend_input_line();
				}
				GlobalMembersCommand.gp_input_line = tangible.StringFunctions.changeCharacter(GlobalMembersCommand.gp_input_line, il, '\0');
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(raw_line);
			}
			GlobalMembersUtil.screen_ok = false; /* make sure command line is
						   echoed on error */
			if (GlobalMembersCommand.do_line() != 0)
				stop = true;
			}
		}
		}

		/* pop state */
		() GlobalMembersMisc.lf_pop(); // also closes file fp
	}

/* used for reread  vsnyder@math.jpl.nasa.gov */
	public static FILE lf_top()
	{
		if (lf_head == (lf_state_struct) DefineConstants.NULL)
		return ((FILE) DefineConstants.NULL);
		return (lf_head.fp);
	}

/* pop from load_file state stack
   FALSE if stack was empty
   called by load_file and load_file_error */
	public static boolean lf_pop()
	{
		lf_state_struct lf;

		if (lf_head == DefineConstants.NULL)
		return (false);
		else
		{
		int argindex;
		lf = lf_head;
		if (lf.fp != (FILE) DefineConstants.NULL && lf.fp != stdin)
		{
			/* DBT 10-6-98  do not close stdin in the case
			 * that "-" is named as a load file
			 */
			() fclose(lf.fp);
		}
		for (argindex = 0; argindex < 10; argindex++)
		{
			if (call_args[argindex] != 0)
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(call_args[argindex]);
			}
			call_args[argindex] = lf.call_args[argindex];
		}
		do_load_arg_substitution = lf.do_load_arg_substitution;
		GlobalMembersPlot.interactive = lf.interactive;
		GlobalMembersCommand.inline_num = lf.inline_num;

		/* Restore saved input state and free the copy */
		if (lf.tokens != null)
		{
			GlobalMembersCommand.num_tokens = lf.num_tokens;
			GlobalMembersCommand.c_token = lf.c_token;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memcpy(GlobalMembersCommand.token, lf.tokens, lf.num_tokens * sizeof(GlobalMembersMouse.struct lexical_unit));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(lf.tokens);
		}
		if (lf.input_line != null)
		{
			GlobalMembersCommand.gp_input_line = lf.input_line;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(lf.input_line);
		}
		if (lf.name != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(lf.name);

		lf_head = lf.prev;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) lf);
		return (true);
		}
	}

/* push onto load_file state stack
   essentially, we save information needed to undo the load_file changes
   called by load_file */
	public static void lf_push(FILE fp)
	{
		lf_state_struct lf;
		int argindex;

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		lf = (lf_state_struct) GlobalMembersAlloc.gp_alloc(sizeof(lf_state_struct), (String) DefineConstants.NULL);
		if (lf == (lf_state_struct) DefineConstants.NULL)
		{
		if (fp != (FILE) DefineConstants.NULL)
			() fclose(fp); // it won't be otherwise
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "not enough memory to load file");
		}
		lf.fp = fp; // save this file pointer
		lf.interactive = GlobalMembersPlot.interactive; // save current state
		lf.inline_num = GlobalMembersCommand.inline_num; // save current line number
		lf.do_load_arg_substitution = do_load_arg_substitution;
		for (argindex = 0; argindex < 10; argindex++)
		{
		lf.call_args[argindex] = call_args[argindex];
		call_args[argindex] = DefineConstants.NULL; // initially no args
		}
		lf.depth = lf_head != null ? lf_head.depth + 1 : 0; // recursion depth
		lf.c_token = GlobalMembersCommand.c_token; // Will be updated by caller
		lf.num_tokens = GlobalMembersCommand.num_tokens; // Will be updated by caller
		lf.input_line = DefineConstants.NULL; // Will be filled in by caller
		lf.tokens = DefineConstants.NULL; // Will be filled in by caller
		lf.name = DefineConstants.NULL; // Will be filled in by caller
		lf.prev = lf_head; // link to stack
		lf_head = lf;
	}

/* called from main */
	public static void load_file_error()
	{
		/* clean up from error in load_file */
		/* pop off everything on stack */
		while (GlobalMembersMisc.lf_pop());
	}

/* find max len of keys and count keys with len > 0 */

/* FIXME HBB 2000508: by design, this one belongs into 'graphics', and the
 * next to into 'graph3d'. Actually, the existence of a module like this
 * 'misc' is almost always a sign of bad design, IMHO */
/* may return NULL */
	public static FILE loadpath_fopen(String filename, String mode)
	{
		FILE fp;

	///#if defined(PIPES)
		if (filename.equals('<'))
		{
		if ((fp = GlobalMembersAmiga.popen(filename + 1, "r")) == (FILE) DefineConstants.NULL)
			return (FILE) 0;
		}
		else
	///#endif // PIPES
		if ((fp = fopen(filename, mode)) == (FILE) DefineConstants.NULL)
		{
		/* try 'loadpath' variable */
		String fullname = DefineConstants.NULL;
		String path;

		while ((path = () GlobalMembersVariable.loadpath_handler(1 << 3, DefineConstants.NULL)()) != DefineConstants.NULL)
		{
			/* length of path, dir separator, filename, \0 */
			fullname = GlobalMembersAlloc.gp_realloc(fullname, path.length() + 1 + filename.length() + 1, "loadpath_fopen");
			fullname = path;
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * p = fullname;
				p += fullname.length();
				if (!fullname.equals(p))
					p--;
					if (*p && (*p != DefineConstants.DIRSEP1) && (*p != DefineConstants.NUL))
					{
						if (*p)
							p++;
							*p++= DefineConstants.DIRSEP1;
							*p = DefineConstants.NUL;
					}
					fullname += filename;
			};
			if ((fp = fopen(fullname, mode)) != DefineConstants.NULL)
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(fullname);
			fullname = DefineConstants.NULL;
			/* reset loadpath internals!
			 * maybe this can be replaced by calling get_loadpath with
			 * a NULL argument and some loadpath_handler internal logic */
			while (() GlobalMembersVariable.loadpath_handler(1 << 3, DefineConstants.NULL)());
			break;
			}
		}

		if (fullname != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(fullname);

		}

		return fp;
	}

/* may return NULL */
	public static String fontpath_fullname(String filename)
	{
		FILE fp;
		String fullname = DefineConstants.NULL;

	///#if defined(PIPES)
		if (filename.equals('<'))
		{
		GlobalMembersUtil.os_error(DefineConstants.NO_CARET, "fontpath_fullname: No Pipe allowed");
		}
		else
	///#endif // PIPES
		if ((fp = fopen(filename, "r")) == (FILE) DefineConstants.NULL)
		{
		/* try 'fontpath' variable */
		String tmppath;
		String path = DefineConstants.NULL;

		while ((tmppath = () GlobalMembersVariable.fontpath_handler(1 << 3, DefineConstants.NULL)()) != DefineConstants.NULL)
		{
			boolean subdirs = false;
			path = GlobalMembersUtil.gp_strdup(tmppath);
			if (path.charAt(path.length() - 1) == '!')
			{
			path = tangible.StringFunctions.changeCharacter(path, path.length() - 1, '\0');
			subdirs = true;
			} // if
			fullname = GlobalMembersMisc.recursivefullname(path, filename, subdirs);
			if (!fullname.equals(DefineConstants.NULL))
			{
			while (() GlobalMembersVariable.fontpath_handler(1 << 3, DefineConstants.NULL)());
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(path);
			break;
			}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(path);
		}

		}
		else
		fullname = GlobalMembersUtil.gp_strdup(filename);

		return fullname;
	}
	public static void push_terminal(int is_interactive)
	{
		if (GlobalMembersTerm.term != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(push_term_name);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(push_term_opts);
		push_term_name = GlobalMembersUtil.gp_strdup(GlobalMembersTerm.term.name);
		push_term_opts = GlobalMembersUtil.gp_strdup(GlobalMembersTerm.term_options);
		if (is_interactive != 0)
			fprintf(stderr, "   pushed terminal %s %s\n", push_term_name, push_term_opts);
		}
		else
		{
		if (is_interactive != 0)
			fputs("\tcurrent terminal type is unknown\n", stderr);
		}
	}

/* Pop the terminal.
 * Called anytime by user command "set term pop".
 */
	public static void pop_terminal()
	{
		if (!push_term_name.equals(DefineConstants.NULL))
		{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * s;
		int i = push_term_name.length() + 11;
		if (push_term_opts != null)
		{
			/* do_string() does not like backslashes -- thus remove them */
			for (s = push_term_opts; * s; s++)
			if (*s == '\\' || *s == '\n')
				*s = (byte)' ';
			i += push_term_opts.length();
		}
		s = GlobalMembersAlloc.gp_alloc(i, "pop");
		i = GlobalMembersPlot.interactive;
		GlobalMembersPlot.interactive = false;
		String.format(s,"set term %s %s", push_term_name, (push_term_opts != null ? push_term_opts : ""));
		GlobalMembersCommand.do_string(s, true);
		GlobalMembersPlot.interactive = i;
		if (GlobalMembersPlot.interactive)
			fprintf(stderr,"   restored terminal is %s %s\n", GlobalMembersTerm.term.name, ((GlobalMembersTerm.term_options) ? GlobalMembersTerm.term_options : ""));
		}
		else
		fprintf(stderr,"No terminal has been pushed yet\n");
	}

/* Parse a plot style. Used by 'set style {data|function}' and by
 * (s)plot.  */

	/* moved here, from setshow */
	public static PLOT_STYLE get_style()
	{
		/* defined in plot.h */
		PLOT_STYLE ps;

		GlobalMembersCommand.c_token++;

//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: ps = lookup_table(&plotstyle_tbl[0], c_token);
		ps = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.plotstyle_tbl[0]), GlobalMembersCommand.c_token);

		GlobalMembersCommand.c_token++;

		if (ps == -1)
		{
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'lines', 'points', 'linespoints', 'dots', 'impulses',\n\t'yerrorbars', 'xerrorbars', 'xyerrorbars', 'steps', 'fsteps',\n\t'histeps', 'filledcurves', 'boxes', 'boxerrorbars', 'boxxyerrorbars',\n\t'vectors', 'financebars', 'candlesticks', 'errorlines', 'xerrorlines',\n\t'yerrorlines', 'xyerrorlines', 'pm3d', 'labels', 'histograms'" + ",\n\t 'image', 'rgbimage'");
		ps = PLOT_STYLE.LINES;
		}

		return ps;
	}

/* Parse options for style filledcurves and fill fco accordingly.
 * If no option given, then set fco->opt_given to 0.
 */
	public static void get_filledcurves_style_options(filledcurves_opts fco)
	{
		int p;
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: p = lookup_table(&filledcurves_opts_tbl[0], c_token);
		p = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.filledcurves_opts_tbl[0]), GlobalMembersCommand.c_token);

		if (p == filledcurves_opts_id.FILLEDCURVES_ABOVE.getValue())
		{
		fco.oneside = 1;
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: p = lookup_table(&filledcurves_opts_tbl[0], ++c_token);
		p = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.filledcurves_opts_tbl[0]), ++GlobalMembersCommand.c_token);
		}
		else if (p == filledcurves_opts_id.FILLEDCURVES_BELOW.getValue())
		{
		fco.oneside = -1;
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: p = lookup_table(&filledcurves_opts_tbl[0], ++c_token);
		p = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.filledcurves_opts_tbl[0]), ++GlobalMembersCommand.c_token);
		}
		else
		fco.oneside = 0;

		if (p == -1)
		{
		fco.opt_given = 0;
		return; // no option given
		}
		else
		fco.opt_given = 1;

		GlobalMembersCommand.c_token++;

		fco.closeto = p;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "=") == 0)
		return;
		/* parameter required for filledcurves x1=... and friends */
		if (p != filledcurves_opts_id.FILLEDCURVES_ATXY.getValue())
		fco.closeto += 4;
		GlobalMembersCommand.c_token++;
		fco.at = GlobalMembersParse.real_expression();
		if (p != filledcurves_opts_id.FILLEDCURVES_ATXY.getValue())
		return;
		/* two values required for FILLEDCURVES_ATXY */
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "syntax is xy=<x>,<y>");
		GlobalMembersCommand.c_token++;
		fco.aty = GlobalMembersParse.real_expression();
		return;
	}

/* Print filledcurves style options to a file (used by 'show' and 'save'
 * commands).
 */
	public static void filledcurves_options_tofile(filledcurves_opts fco, FILE fp)
	{
		if (fco.opt_given == 0)
		return;
		if (fco.oneside != 0)
		fputs(fco.oneside > 0 ? "above " : "below ", fp);
		if (fco.closeto == filledcurves_opts_id.FILLEDCURVES_CLOSED.getValue())
		{
		fputs("closed", fp);
		return;
		}
		if (fco.closeto <= filledcurves_opts_id.FILLEDCURVES_Y2)
		{
		fputs(GlobalMembersTables.filledcurves_opts_tbl[fco.closeto].key, fp);
		return;
		}
		if (fco.closeto <= filledcurves_opts_id.FILLEDCURVES_ATY2)
		{
		fprintf(fp, "%s=%g", GlobalMembersTables.filledcurves_opts_tbl[fco.closeto - 4].key, fco.at);
		return;
		}
		if (fco.closeto == filledcurves_opts_id.FILLEDCURVES_ATXY.getValue())
		{
		fprintf(fp, "xy=%g,%g", fco.at, fco.aty);
		return;
		}
	}

/*
 * allow_ls controls whether we are allowed to accept linestyle in
 * the current context [ie not when doing a  set linestyle command]
 * allow_point is whether we accept a point command
 * allow any order of options - pm 24.11.2001
 * EAM Oct 2005 - Require that default values have been placed in lp by the caller
 */
	public static void lp_parse(lp_style_type lp, boolean allow_ls, boolean allow_point)
	{
		/* avoid duplicating options */
		int set_lt = 0;
		int set_pal = 0;
		int set_lw = 0;
		int set_pt = 0;
		int set_ps = 0;

		if (allow_ls && (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "lines$tyle") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "ls") != 0))
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersTerm.lp_use_properties(lp, GlobalMembersParse.int_expression());
		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linet$ype") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lt") != 0)
			{
			if (set_lt++)
				break;
			GlobalMembersCommand.c_token++;
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rgb$color") != 0)
			{
				if (set_pal++)
				break;
				GlobalMembersCommand.c_token--;
				GlobalMembersMisc.parse_colorspec(lp.pm3d_color, DefineConstants.TC_RGB);
				lp.use_palette = true;
			}
			else
			/* both syntaxes allowed: 'with lt pal' as well as 'with pal' */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pal$ette") != 0)
			{
				if (set_pal++)
				break;
				GlobalMembersCommand.c_token--;
				GlobalMembersMisc.parse_colorspec(lp.pm3d_color, DefineConstants.TC_Z);
				lp.use_palette = true;
	///#ifdef KEYWORD_BGND
	//		} else if (equals(c_token,"bgnd")) {
	//		    lp->l_type = LT_BACKGROUND;
	//		    c_token++;
	///#endif
			}
			else
			{
				int lt = GlobalMembersParse.int_expression();
				lp.l_type = lt - 1;
				/* user may prefer explicit line styles */
				if (GlobalMembersGadgets.prefer_line_styles && allow_ls)
				GlobalMembersTerm.lp_use_properties(lp, lt);
			}
			} // linetype, lt

			/* both syntaxes allowed: 'with lt pal' as well as 'with pal' */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pal$ette") != 0)
			{
			if (set_pal++)
				break;
			GlobalMembersCommand.c_token--;
			GlobalMembersMisc.parse_colorspec(lp.pm3d_color, DefineConstants.TC_Z);
			lp.use_palette = true;
			continue;
			}

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lc") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linec$olor") != 0)
			{
			lp.use_palette = true;
			if (set_pal++)
				break;
			GlobalMembersCommand.c_token++;
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rgb$color") != 0)
			{
				GlobalMembersCommand.c_token--;
				GlobalMembersMisc.parse_colorspec(lp.pm3d_color, DefineConstants.TC_RGB);
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pal$ette") != 0)
			{
				GlobalMembersCommand.c_token--;
				GlobalMembersMisc.parse_colorspec(lp.pm3d_color, DefineConstants.TC_Z);
	///#ifdef KEYWORD_BGND
	//		} else if (equals(c_token,"bgnd")) {
	//		    lp->pm3d_color.type = TC_LT;
	//		    lp->pm3d_color.lt = LT_BACKGROUND;
	//		    c_token++;
	///#endif
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "var$iable") != 0)
			{
				GlobalMembersCommand.c_token++;
				lp.l_type = DefineConstants.LT_COLORFROMCOLUMN;
				lp.pm3d_color.type = DefineConstants.TC_LINESTYLE;
			}
			else
			{
				lp.pm3d_color.type = DefineConstants.TC_LT;
				lp.pm3d_color.lt = GlobalMembersParse.int_expression() - 1;
			}
			continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linew$idth") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lw") != 0)
			{
			if (set_lw++)
				break;
			GlobalMembersCommand.c_token++;
			lp.l_width = GlobalMembersParse.real_expression();
			if (lp.l_width < 0)
				lp.l_width = 0;
			continue;
			}

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "bgnd") != 0)
			{
			lp.l_type = DefineConstants.LT_BACKGROUND;
			lp.use_palette = false;
			GlobalMembersCommand.c_token++;
			continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pointt$ype") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pt") != 0)
			{
			if (allow_point)
			{
				if (set_pt++)
				break;
				GlobalMembersCommand.c_token++;
				lp.p_type = GlobalMembersParse.int_expression() - 1;
			}
			else
			{
				GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "No pointtype specifier allowed, here");
				GlobalMembersCommand.c_token += 2;
			}
			continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "points$ize") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "ps") != 0)
			{
			if (allow_point)
			{
				if (set_ps++)
				break;
				GlobalMembersCommand.c_token++;
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "var$iable") != 0)
				{
				lp.p_size = DefineConstants.PTSZ_VARIABLE;
				GlobalMembersCommand.c_token++;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
				{
				lp.p_size = DefineConstants.PTSZ_DEFAULT;
				GlobalMembersCommand.c_token++;
				}
				else
				{
				lp.p_size = GlobalMembersParse.real_expression();
				if (lp.p_size < 0)
					lp.p_size = 0;
				}
			}
			else
			{
				GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "No pointsize specifier allowed, here");
				GlobalMembersCommand.c_token += 2;
			}
			continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pointi$nterval") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pi") != 0)
			{
			GlobalMembersCommand.c_token++;
			if (allow_point)
			{
				lp.p_interval = GlobalMembersParse.int_expression();
			}
			else
			{
				GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "No pointinterval specifier allowed, here");
				GlobalMembersParse.int_expression();
			}
			continue;
			}


			/* unknown option catched -> quit the while(1) loop */
			break;
		}

		if (set_lt > 1 || set_pal > 1 || set_lw > 1 || set_pt > 1 || set_ps > 1)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "duplicated arguments in style specification");
	}

	public static void arrow_parse(arrow_style_type arrow, boolean allow_as)
	{
		if (allow_as && (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "arrows$tyle") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "as") != 0))
		{
		GlobalMembersCommand.c_token++;
		GlobalMembersMisc.arrow_use_properties(arrow, GlobalMembersParse.int_expression());
		}
		else
		{
		/* avoid duplicating options */
		int set_layer = 0;
		int set_line = 0;
		int set_head = 0;
		int set_headsize = 0;
		int set_headfilled = 0;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "nohead") != 0)
			{
			if (set_head++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head = e_arrow_head.NOHEAD;
			continue;
			}
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "head") != 0)
			{
			if (set_head++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head = e_arrow_head.END_HEAD;
			continue;
			}
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "backhead") != 0)
			{
			if (set_head++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head = e_arrow_head.BACKHEAD;
			continue;
			}
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "heads") != 0)
			{
			if (set_head++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head = e_arrow_head.BACKHEAD | e_arrow_head.END_HEAD;
			continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fill$ed") != 0)
			{
			if (set_headfilled++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head_filled = 2;
			continue;
			}
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "empty") != 0)
			{
			if (set_headfilled++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head_filled = 1;
			continue;
			}
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nofill$ed") != 0)
			{
			if (set_headfilled++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.head_filled = 0;
			continue;
			}

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "size") != 0)
			{
			position hsize = new position();
			if (set_headsize++)
				break;
			hsize.scalex = hsize.scaley = hsize.scalez = position_type.first_axes;
			/* only scalex used; scaley is angle of the head in [deg] */
			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "head size expected");
			GlobalMembersAxis.get_position(hsize);
			arrow.head_length = hsize.x;
			arrow.head_lengthunit = (int)hsize.scalex;
			arrow.head_angle = hsize.y;
			arrow.head_backangle = hsize.z;
			/* invalid backangle --> default of 90.0 */
			if (arrow.head_backangle <= arrow.head_angle)
				arrow.head_backangle = 90.0;
			continue;
			}

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
			if (set_layer++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.layer = 0;
			continue;
			}
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
			if (set_layer++)
				break;
			GlobalMembersCommand.c_token++;
			arrow.layer = 1;
			continue;
			}

			/* pick up a line spec - allow ls, but no point. */
			{
			int stored_token = GlobalMembersCommand.c_token;
			GlobalMembersMisc.lp_parse(arrow.lp_properties, true, false);
			if (stored_token == GlobalMembersCommand.c_token || set_line++)
				break;
			continue;
			}

			/* unknown option caught -> quit the while(1) loop */
			break;
		}

		if (set_layer > 1 || set_line > 1 || set_head > 1 || set_headsize > 1 || set_headfilled > 1)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "duplicated arguments in style specification");

		}
	}

/* <fillstyle> = {empty | solid {<density>} | pattern {<n>}} {noborder | border {<lt>}} */

	public static void parse_fillstyle(fill_style_type fs, int def_style, int def_density, int def_pattern, t_colorspec def_bordertype)
	{
		boolean set_fill = false;
		boolean set_param = false;
		boolean transparent = false;

		/* Set defaults */
		fs.fillstyle = def_style;
		fs.filldensity = def_density;
		fs.fillpattern = def_pattern;
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
//ORIGINAL LINE: fs->border_color = def_bordertype;
		fs.border_color.copyFrom(def_bordertype);

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		return;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "fs") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fill$style") == 0)
		return;
		GlobalMembersCommand.c_token++;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "trans$parent") != 0)
		{
			transparent = true;
			GlobalMembersCommand.c_token++;
		}

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "e$mpty") != 0)
		{
			fs.fillstyle = t_fillstyle.FS_EMPTY.getValue();
			GlobalMembersCommand.c_token++;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "s$olid") != 0)
		{
			fs.fillstyle = transparent ? t_fillstyle.FS_TRANSPARENT_SOLID : t_fillstyle.FS_SOLID;
			set_fill = true;
			GlobalMembersCommand.c_token++;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "p$attern") != 0)
		{
			fs.fillstyle = transparent ? t_fillstyle.FS_TRANSPARENT_PATTERN : t_fillstyle.FS_PATTERN;
			set_fill = true;
			GlobalMembersCommand.c_token++;
		}

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			continue;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bo$rder") != 0)
		{
			fs.border_color.type = DefineConstants.TC_DEFAULT;
			GlobalMembersCommand.c_token++;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "-") != 0 || GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0)
			{
			fs.border_color.type = DefineConstants.TC_LT;
			fs.border_color.lt = GlobalMembersParse.int_expression() - 1;
			}
			else if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
			GlobalMembersCommand.c_token--;
			GlobalMembersMisc.parse_colorspec(fs.border_color, DefineConstants.TC_Z);
			}
			continue;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nobo$rder") != 0)
		{
			fs.border_color.type = DefineConstants.TC_LT;
			fs.border_color.lt = DefineConstants.LT_NODRAW;
			GlobalMembersCommand.c_token++;
			continue;
		}

		/* We hit something unexpected */
		if (!set_fill || set_param)
			break;
		if (!(GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.INTGR || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.CMPLX))
			break;

		if (fs.fillstyle == t_fillstyle.FS_SOLID.getValue() || fs.fillstyle == t_fillstyle.FS_TRANSPARENT_SOLID.getValue())
		{
			/* user sets 0...1, but is stored as an integer 0..100 */
			fs.filldensity = 100.0 * GlobalMembersParse.real_expression() + 0.5;
			if (fs.filldensity < 0)
			fs.filldensity = 0;
			if (fs.filldensity > 100)
			fs.filldensity = 100;
			set_param = true;
		}
		else if (fs.fillstyle == t_fillstyle.FS_PATTERN.getValue() || fs.fillstyle == t_fillstyle.FS_TRANSPARENT_PATTERN.getValue())
		{
			fs.fillpattern = GlobalMembersParse.int_expression();
			if (fs.fillpattern < 0)
			fs.fillpattern = 0;
			set_param = true;
		}
		}
	}

/*
 * Parse the sub-options of text color specification
 *   { def$ault | lt <linetype> | pal$ette { cb <val> | frac$tion <val> | z }
 * The ordering of alternatives shown in the line above is kept in the symbol definitions
 * TC_DEFAULT TC_LT TC_RGB TC_CB TC_FRAC TC_Z  (0 1 2 3 4 5)
 * and the "options" parameter to parse_colorspec limits legal input to the
 * corresponding point in the series. So TC_LT allows only default or linetype
 * coloring, while TC_Z allows all coloring options up to and including pal z
 */
	public static void parse_colorspec(t_colorspec tc, int options)
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected colorspec");
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
		{
		GlobalMembersCommand.c_token++;
		tc.type = DefineConstants.TC_DEFAULT;
	///#ifdef KEYWORD_BGND
	//    } else if (equals(c_token,"bgnd")) {
	//	c_token++;
	//	tc->type = TC_LT;
	//	tc->lt = LT_BACKGROUND;
	///#endif
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lt") != 0)
		{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected linetype");
		tc.type = DefineConstants.TC_LT;
		tc.lt = GlobalMembersParse.int_expression() - 1;
		if (tc.lt < DefineConstants.LT_BACKGROUND)
		{
			tc.type = DefineConstants.TC_DEFAULT;
			GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token,"illegal linetype");
		}
		}
		else if (options <= DefineConstants.TC_LT)
		{
		tc.type = DefineConstants.TC_DEFAULT;
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "only tc lt <n> possible here");
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "ls") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "lines$tyle") != 0)
		{
		GlobalMembersCommand.c_token++;
		tc.type = DefineConstants.TC_LINESTYLE;
		tc.lt = GlobalMembersParse.real_expression();
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rgb$color") != 0)
		{
		String color;
		int rgbtriple;
		GlobalMembersCommand.c_token++;
		tc.type = DefineConstants.TC_RGB;
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "var$iable") != 0)
		{
			tc.value = -1.0;
			GlobalMembersCommand.c_token++;
			return;
		}
		else
			tc.value = 0.0;
		if (!(color = GlobalMembersUtil.try_to_get_string()))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected a color name or a string of form \"#RRGGBB\"");
		if ((rgbtriple = GlobalMembersTables.lookup_table_nth(GlobalMembersTables.pm3d_color_names_tbl, color)) >= 0)
			rgbtriple = GlobalMembersTables.pm3d_color_names_tbl[rgbtriple].value;
		else
			sscanf(color, "#%x", rgbtriple);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(color);
		if (rgbtriple < 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected a known color name or a string of form \"#RRGGBB\"");
		tc.type = DefineConstants.TC_RGB;
		tc.lt = rgbtriple;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pal$ette") != 0)
		{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "z") != 0)
		{
			/* The actual z value is not yet known, fill it in later */
			if (options >= DefineConstants.TC_Z)
			{
			tc.type = DefineConstants.TC_Z;
			}
			else
			{
			tc.type = DefineConstants.TC_DEFAULT;
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "palette z not possible here");
			}
			GlobalMembersCommand.c_token++;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "cb") != 0)
		{
			tc.type = DefineConstants.TC_CB;
			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected cb value");
			tc.value = GlobalMembersParse.real_expression();
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "frac$tion") != 0)
		{
			tc.type = DefineConstants.TC_FRAC;
			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected palette fraction");
			tc.value = GlobalMembersParse.real_expression();
			if (tc.value < 0.|| tc.value > 1.0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "palette fraction out of range");
		}
		else
		{
			/* END_OF_COMMAND or palette <blank> */
			if (options >= DefineConstants.TC_Z)
			tc.type = DefineConstants.TC_Z;
		}
		}
		else
		{
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "colorspec option not recognized");
		}
	}
	public static boolean need_fill_border(fill_style_type fillstyle)
	{
		/* Doesn't want a border at all */
		if (fillstyle.border_color.type == DefineConstants.TC_LT && fillstyle.border_color.lt == DefineConstants.LT_NODRAW)
		return false;

		/* Wants a border in a new color */
		if (fillstyle.border_color.type != DefineConstants.TC_DEFAULT)
		GlobalMembersGadgets.apply_pm3dcolor(fillstyle.border_color, GlobalMembersTerm.term);

		return true;
	}

	public static void get_image_options(t_image image)
	{
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "failsafe") != 0)
		{
		GlobalMembersCommand.c_token++;
		image.fallback = true;
		}

	}
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern lf_state_struct *lf_head;

/* arrow parsing...
 *
 * allow_as controls whether we are allowed to accept arrowstyle in
 * the current context [ie not when doing a  set style arrow command]
 */




	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	///#ifdef USE_MOUSE
	///#ifdef _MOUSE_C
	///#endif // _MOUSE_C 
	///#if 0
	///#endif
	///#if defined(_MOUSE_C)
	///#else
	///#endif
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef LINUXVGA
	///#endif // LINUXVGA 
	///#ifdef OS2
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)

	///#if defined(HAVE_DIRENT_H)
	///#elif defined(_Windows)
	///#include <windows.h>
	///#endif

	public static void arrow_use_properties(arrow_style_type arrow, int tag)
	{
		/*  This function looks for an arrowstyle defined by 'tag' and
		 *  copies its data into the structure 'ap'. */
		arrowstyle_def this_Renamed;

		this_Renamed = GlobalMembersGadgets.first_arrowstyle;
		while (this_Renamed != DefineConstants.NULL)
		{
		if (this_Renamed.tag == tag)
		{
			arrow = this_Renamed.arrow_properties;
			return;
		}
		else
		{
			this_Renamed = this_Renamed.next;
		}
		}

		/* tag not found: */
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET,"arrowstyle not found", DefineConstants.NO_CARET);
	}

/* Harald Harders <h.harders@tu-bs.de> */
/* Thanks to John Bollinger <jab@bollingerbands.com> who has tested the
   windows part */
	public static String recursivefullname(String path, String filename, boolean recursive)
	{
		String fullname = DefineConstants.NULL;
		FILE fp;

		/* length of path, dir separator, filename, \0 */
		fullname = GlobalMembersAlloc.gp_alloc(path.length() + 1 + filename.length() + 1, "recursivefullname");
		fullname = path;
		{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * p = fullname;
			p += fullname.length();
			if (!fullname.equals(p))
				p--;
				if (*p && (*p != DefineConstants.DIRSEP1) && (*p != DefineConstants.NUL))
				{
					if (*p)
						p++;
						*p++= DefineConstants.DIRSEP1;
						*p = DefineConstants.NUL;
				}
				fullname += filename;
		};

		if ((fp = fopen(fullname, "r")) != DefineConstants.NULL)
		{
		fclose(fp);
		return fullname;
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(fullname);
		fullname = DefineConstants.NULL;
		}

		if (recursive)
		{
	///#ifdef HAVE_DIRENT_H
		DIR dir;
		dirent direntry;
		stat buf = new stat();

		dir = opendir(path);
		if (dir != null)
		{
			while ((direntry = readdir(dir)) != DefineConstants.NULL)
			{
			byte fulldir = GlobalMembersAlloc.gp_alloc(path.length() + 1 + direntry.d_name.length() + 1, "fontpath_fullname");
			fulldir = path;
	///#if defined(VMS)
	//		if (fulldir[strlen(fulldir) - 1] == ']')
	//		    fulldir[strlen(fulldir) - 1] = '\0';
	//		strcpy(&(fulldir[strlen(fulldir)]), ".");
	//		strcpy(&(fulldir[strlen(fulldir)]), direntry->d_name);
	//		strcpy(&(fulldir[strlen(fulldir)]), "]");
	///#else
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * p = fulldir;
				p += fulldir.length();
				if (p != fulldir)
					p--;
					if (*p && (*p != DefineConstants.DIRSEP1) && (*p != DefineConstants.NUL))
					{
						if (*p)
							p++;
							*p++= DefineConstants.DIRSEP1;
							*p = DefineConstants.NUL;
					}
					fulldir += direntry.d_name;
			};
	///#endif
			stat(fulldir, buf);
			if (((((buf.st_mode) & S_IFMT) == S_IFDIR)) && (strcmp(direntry.d_name, ".") != 0) && (strcmp(direntry.d_name, "..") != 0))
			{
				fullname = GlobalMembersMisc.recursivefullname(fulldir, filename, true);
				if (!fullname.equals(DefineConstants.NULL))
				break;
			}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(fulldir);
			}
			closedir(dir);
		}
	///#elif defined(_Windows)
	//	HANDLE filehandle;
	//	WIN32_FIND_DATA finddata;
	//	char *pathwildcard = gp_alloc(strlen(path) + 2, "fontpath_fullname");
	//
	//	strcpy(pathwildcard, path);
	//	PATH_CONCAT(pathwildcard, "*");
	//
	//	filehandle = FindFirstFile(pathwildcard, &finddata);
	//	free(pathwildcard);
	//	if (filehandle != INVALID_HANDLE_VALUE)
	//	    do {
	//		if ((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
	//		    (strcmp(finddata.cFileName, ".") != 0) &&
	//		    (strcmp(finddata.cFileName, "..") != 0)) {
	//		    char *fulldir = gp_alloc(strlen(path) + 1 + strlen(finddata.cFileName) + 1,
	//					     "fontpath_fullname");
	//		    strcpy(fulldir, path);
	//		    PATH_CONCAT(fulldir, finddata.cFileName);
	//
	//		    fullname = recursivefullname(fulldir, filename, TRUE);
	//		    free(fulldir);
	//		    if (fullname != NULL)
	//			break;
	//		}
	//	    } while (FindNextFile(filehandle, &finddata) != 0);
	//	FindClose(filehandle);
	//
	///#else
	//	int_warn(NO_CARET, "Recursive directory search not supported\n\t('%s!')", path);
	///#endif
		}
		return fullname;
	}

	/* A copy of the declaration from set.c */
	/* There should only be one declaration in a header file. But I do not know
	 * where to put it */
	/* void get_position __PROTO((struct position * pos)); */

	/* State information for load_file(), to recover from errors
	 * and properly handle recursive load_file calls
	 */
	public static lf_state_struct lf_head = DefineConstants.NULL; // NULL if not in load_file

	/* these two could be in load_file, except for error recovery */
	public static boolean do_load_arg_substitution = false;
	public static String[] call_args = {DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL, DefineConstants.NULL};


	/* Push current terminal.
	 * Called 1. in main(), just after init_terminal(),
	 *        2. from load_rcfile(),
	 *        3. anytime by user command "set term push".
	 */
	public static String push_term_name = DefineConstants.NULL;
	public static String push_term_opts = DefineConstants.NULL;
}