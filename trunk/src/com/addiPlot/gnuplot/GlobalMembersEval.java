package com.addiPlot.gnuplot;

public class GlobalMembersEval
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: eval.c,v 1.74.2.1 2010/01/06 17:35:10 sfeam Exp $");
	}
	///#endif


	/* This type definition has to come after union argument has been declared. */
	///#ifdef __ZTC__
	//typedef void (*FUNC_PTR)(...);
	///#else
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//typedef void(*FUNC_PTR NamelessParameter) __PROTO((union argument *arg));
	///#endif


	/* Variables of eval.c needed by other modules: */

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const struct ft_entry  ft[]; // The table of builtin functions
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct udft_entry *first_udf; // user-def'd functions
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct udvt_entry *first_udv; // user-def'd variables
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct udvt_entry udv_pi; // 'pi' variable
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct udvt_entry *udv_NaN; // 'NaN' variable
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean undefined;

/* some machines have trouble with exp(-x) for large x
 * if E_MINEXP is defined at compile time, use gp_exp(x) instead,
 * which returns 0 for exp(x) with x < E_MINEXP
 * exp(x) will already have been defined as gp_exp(x) in plot.h
 */


	/* Prototypes of functions exported by eval.c */

	public static double gp_exp(double x)
	{
	///#ifdef E_MINEXP
	//    return (x < (E_MINEXP)) ? 0.0 : exp(x);
	///#else  // E_MINEXP
		int old_errno = errno;
		double result = Math.exp(x);

		/* exp(-large) quite uselessly raises ERANGE --- stop that */
		if (result == 0.0)
		errno = old_errno;
		return result;
	///#endif // E_MINEXP
	}

/* FIXME HBB 20010724: do we really want this in *here*? Maybe it
 * should be in syscfg.c or somewhere similar. */
///#ifdef APOLLO
///#include <apollo/base.h>
///#include <apollo/pfm.h>
///#include <apollo/fault.h>
//
// /*
//  * On an Apollo, the OS can signal a couple errors that are not mapped into
//  * SIGFPE, namely signalling NaN and branch on an unordered comparison.  I
//  * suppose there are others, but none of these are documented, so I handle
//  * them as they arise.
//  *
//  * Anyway, we need to catch these faults and signal SIGFPE.
//  */
//
//static pfm_$fh_func_val_t
//apollo_sigfpe(pfm_$fault_rec_t & fault_rec)
//{
//    kill(getpid(), SIGFPE);
//    return pfm_$continue_fault_handling;
//}
//
// /* This is called from main(), if the platform is an APOLLO */
//void
//apollo_pfm_catch()
//{
//    status_$t status;
//    pfm_$establish_fault_handler(fault_$fp_bsun, pfm_$fh_backstop,
//				 apollo_sigfpe, &status);
//    pfm_$establish_fault_handler(fault_$fp_sig_nan, pfm_$fh_backstop,
//				 apollo_sigfpe, &status);
//}
///#endif // APOLLO 

/* Exported functions */

/* First, some functions that help other modules use 'struct value' ---
 * these might justify a separate module, but I'll stick with this,
 * for now */

/* returns the real part of val */

	/* HBB 20010726: Moved these here, from util.h. */
	public static double real(value val)
	{
		switch (val.type)
		{
		case INTGR:
		return ((double) val.v.int_val);
		case CMPLX:
		return (val.v.cmplx_val.real);
		case STRING: // is this ever used?
		return (Double.parseDouble(val.v.string_val));
		default:
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "unknown type in real()");
		}
		/* NOTREACHED */
		return ((double) 0.0);
	}

/* returns the imag part of val */
	public static double imag(value val)
	{
		switch (val.type)
		{
		case INTGR:
		return (0.0);
		case CMPLX:
		return (val.v.cmplx_val.imag);
		case STRING:
		/* This is where we end up if the user tries: */
		/*     x = 2;  plot sprintf(format,x)         */
		GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "encountered a string when expecting a number");
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Did you try to generate a file name using dummy variable x or y?");
		default:
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "unknown type in imag()");
		}
		/* NOTREACHED */
		return ((double) 0.0);
	}

/* returns the magnitude of val */
	public static double magnitude(value val)
	{
		switch (val.type)
		{
		case INTGR:
		return ((double) Math.abs(val.v.int_val));
		case CMPLX:
		return (Math.sqrt(val.v.cmplx_val.real * val.v.cmplx_val.real + val.v.cmplx_val.imag * val.v.cmplx_val.imag));
		default:
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "unknown type in magnitude()");
		}
		/* NOTREACHED */
		return ((double) 0.0);
	}

/* returns the angle of val */
	public static double angle(value val)
	{
		switch (val.type)
		{
		case INTGR:
		return ((val.v.int_val >= 0) ? 0.0 : DefineConstants.M_PI);
		case CMPLX:
		if (val.v.cmplx_val.imag == 0.0)
		{
			if (val.v.cmplx_val.real >= 0.0)
			return (0.0);
			else
			return (DefineConstants.M_PI);
		}
		return (Math.atan2(val.v.cmplx_val.imag, val.v.cmplx_val.real));
		default:
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "unknown type in angle()");
		}
		/* NOTREACHED */
		return ((double) 0.0);
	}
	public static value Gcomplex(value a, double realpart, double imagpart)
	{
		a.type = DATA_TYPES.CMPLX;
		a.v.cmplx_val.real = realpart;
		a.v.cmplx_val.imag = imagpart;
		return (a);
	}
	public static value Ginteger(value a, int i)
	{
		a.type = DATA_TYPES.INTGR;
		a.v.int_val = i;
		return (a);
	}
	public static value Gstring(value a, String s)
	{
		a.type = DATA_TYPES.STRING;
		a.v.string_val = s;
		return (a);
	}

/*
 * Allow autoconversion of string variables to floats if they
 * are dereferenced in a numeric context.
 */
	public static value pop_or_convert_from_string(value v)
	{
		() GlobalMembersEval.pop(v);
		if (v.type == DATA_TYPES.STRING)
		{
		String eov;
		double d = strtod(v.v.string_val, eov);
		if (v.v.string_val.equals(eov))
		{
			GlobalMembersEval.gpfree_string(v);
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Non-numeric string found where a numeric expression was expected");
		}
		GlobalMembersEval.gpfree_string(v);
		GlobalMembersEval.Gcomplex(v, d, 0.);
		GlobalMembersFit.a((stderr,"converted string to CMPLX value %g\n",GlobalMembersEval.real(v)));
		}
		return (v);
	}

/* It is always safe to call gpfree_string with a->type is INTGR or CMPLX.
 * However it would be fatal to call it with a->type = STRING if a->string_val
 * was not obtained by a previous call to gp_alloc(), or has already been freed.
 * Thus 'a->type' is set to INTGR afterwards to make subsequent calls safe.
 */
	public static value gpfree_string(value a)
	{
		if (a.type == DATA_TYPES.STRING)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(a.v.string_val);
		/* I would have set it to INVALID if such a type existed */
		a.type = DATA_TYPES.INTGR;
		}
		return a;
	}

	public static void reset_stack()
	{
		s_p = -1;
	}
	public static void check_stack()
	{ // make sure stack's empty
		if (s_p != -1)
		fprintf(stderr, "\nwarning:  internal error--stack not empty!\n          (function called with too many parameters?)\n");
	}
	public static boolean more_on_stack()
	{
		return (s_p >= 0);
	}
	public static value pop(value x)
	{
		if (s_p < 0)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "stack underflow (function call with missing parameters?)");
		x = stack[s_p--];
		return (x);
	}
	public static void push(value x)
	{
		if (s_p == DefineConstants.STACK_DEPTH - 1)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "stack overflow");
		stack[++s_p] = x;
		/* WARNING - This is a memory leak if the string is not later freed */
		if (x.type == DATA_TYPES.STRING && x.v.string_val != null)
		stack[s_p].v.string_val = GlobalMembersUtil.gp_strdup(x.v.string_val);
	}
	public static void int_check(value v)
	{
		if (v.type != DATA_TYPES.INTGR)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "non-integer passed to boolean operator");
	}

/* Internal operators of the stack-machine, not directly represented
 * by any user-visible operator, or using private status variables
 * directly */

/* converts top-of-stack to boolean */

	public static void f_bool(argument x)
	{
		() x; // avoid -Wunused warning

		GlobalMembersEval.int_check(stack[s_p]);
		stack[s_p].v.int_val = !stack[s_p].v.int_val == 0;
	}
	public static void f_jump(argument x)
	{
		() x; // avoid -Wunused warning
		jump_offset = x.j_arg;
	}
	public static void f_jumpz(argument x)
	{
		value a = new value();

		() x; // avoid -Wunused warning
		GlobalMembersEval.int_check(stack[s_p]);
		if (stack[s_p].v.int_val != 0) // non-zero --> no jump
		{
		() GlobalMembersEval.pop(a);
		}
		else
		jump_offset = x.j_arg; // leave the argument on TOS
	}
	public static void f_jumpnz(argument x)
	{
		value a = new value();

		() x; // avoid -Wunused warning
		GlobalMembersEval.int_check(stack[s_p]);
		if (stack[s_p].v.int_val != 0) // non-zero
		jump_offset = x.j_arg; // leave the argument on TOS
		else
		{
		() GlobalMembersEval.pop(a);
		}
	}
	public static void f_jtern(argument x)
	{
		value a = new value();

		() x; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		if (a.v.int_val == 0)
		jump_offset = x.j_arg; // go jump to FALSE code
	}

/* This is the heart of the expression evaluation module: the stack
   program execution loop.

  'ft' is a table containing C functions within this program.

   An 'action_table' contains pointers to these functions and
   arguments to be passed to them.

   at_ptr is a pointer to the action table which must be executed
   (evaluated).

   so the iterated line executes the function indexed by the at_ptr
   and passes the address of the argument which is pointed to by the
   arg_ptr

*/


	public static void execute_at(at_type at_ptr)
	{
		int instruction_index;
		int operator;
		int count;
		int saved_jump_offset = jump_offset;

		count = at_ptr.a_count;
		for (instruction_index = 0; instruction_index < count;)
		{
		operator = (int) at_ptr.actions[instruction_index].index;
		jump_offset = 1; // jump operators can modify this
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*ft[operator].func)((at_ptr.actions[instruction_index].arg));
		assert ((operator) >= operators.JUMP.getValue() && (operator) < operators.SF_START.getValue()) || (jump_offset == 1);
		instruction_index += jump_offset;
		}

		jump_offset = saved_jump_offset;
	}

/* 20010724: moved here from parse.c, where it didn't belong */
	public static void evaluate_at(at_type at_ptr, value val_ptr)
	{
		double temp = 0;

		undefined = false;
		errno = 0;
		GlobalMembersEval.reset_stack();

	///#ifndef DOSX286
		if (!GlobalMembersDatafile.evaluate_inside_using || !GlobalMembersDatafile.df_nofpe_trap)
		{
		if (sigsetjmp(fpe_env, 1))
			return;
		() signal(SIGFPE, (sigfunc) GlobalMembersEval.fpe);
		}
	///#endif

		GlobalMembersEval.execute_at(at_ptr);

	///#ifndef DOSX286
		if (!GlobalMembersDatafile.evaluate_inside_using || !GlobalMembersDatafile.df_nofpe_trap)
		{
		() signal(SIGFPE, SIG_DFL);
		}
	///#endif

		if (errno == EDOM || errno == ERANGE)
		{
		undefined = true;
		} // undefined (but not errno) may have been set by matherr
		else if (!undefined)
		{
		() GlobalMembersEval.pop(val_ptr);
		GlobalMembersEval.check_stack();
		/* At least one machine (ATT 3b1) computes Inf without a SIGFPE */
		if (val_ptr.type != DATA_TYPES.STRING)
		temp = GlobalMembersEval.real(val_ptr);
		if (temp > DefineConstants.VERYLARGE || temp < -DefineConstants.VERYLARGE)
		{
			undefined = true;
		}
		}
	///#if defined(NeXT) || defined(ultrix)
	// /*
	//  * linux was able to fit curves which NeXT gave up on -- traced it to
	//  * silently returning NaN for the undefined cases and plowing ahead
	//  * I can force that behavior this way.  (0.0/0.0 generates NaN)
	//  */
	//    if (undefined && (errno == EDOM || errno == ERANGE)) {	// corey@cac
	//	undefined = FALSE;
	//	errno = 0;
	//	Gcomplex(val_ptr, 0.0 / 0.0, 0.0 / 0.0);
	//    }
	///#endif // NeXT || ultrix

	}
	public static void free_at(at_type at_ptr)
	{
		int i;
		/* All string constants belonging to this action table have to be
		 * freed before destruction. */
		if (at_ptr == null)
			return;
		for (i = 0; i < at_ptr.a_count; i++)
		{
		at_entry a = (at_ptr.actions[i]);
		/* if union a->arg is used as a->arg.v_arg free potential string */
		if (a.index == operators.PUSHC || a.index == operators.DOLLARS)
			GlobalMembersEval.gpfree_string((a.arg.v_arg));
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(at_ptr);
	}

/* EAM July 2003 - Return pointer to udv with this name; if the key does not
 * match any existing udv names, create a new one and return a pointer to it.
 */
	///#ifdef APOLLO
	//void apollo_pfm_catch __PROTO((void));
	///#endif
	public static udvt_entry add_udv_by_name(String key)
	{
		udvt_entry[] udv_ptr = first_udv;

		/* check if it's already in the table... */

		while (udv_ptr != null)
		{
		if (!strcmp(key, (udv_ptr).udv_name))
			return (udv_ptr);
		udv_ptr = &((udv_ptr).next_udv);
		}

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		udv_ptr = (GlobalMembersMouse.struct udvt_entry *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct udvt_entry), "value");
		udv_ptr.next_udv = DefineConstants.NULL;
		udv_ptr.udv_name = GlobalMembersUtil.gp_strdup(key);
		udv_ptr.udv_undef = true;
		udv_ptr.udv_value.type = 0;
		return (udv_ptr);
	}

/*
 * Put all the handling for GPVAL_* variables in this one routine.
 * We call it from one of several contexts:
 * 0: following a successful set/unset command
 * 1: following a successful plot/splot
 * 2: following an unsuccessful command (int_error)
 * 3: program entry
 * 4: explicit reset of error status
 * 5: directory changed
 * 6: X11 Window ID changed
 */

	/* update GPVAL_ variables available to user */
	public static void update_gpval_variables(int context)
	{
		/* These values may change during a plot command due to auto range */
		if (context == 1)
		{
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.FIRST_X_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.FIRST_Y_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.SECOND_X_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.SECOND_Y_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.FIRST_Z_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.COLOR_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.T_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.U_AXIS);
		GlobalMembersEval.fill_gpval_axis(AXIS_INDEX.V_AXIS);
		GlobalMembersEval.update_plot_bounds();
		GlobalMembersEval.fill_gpval_integer("GPVAL_PLOT", GlobalMembersGadgets.is_3d_plot ? 0:1);
		GlobalMembersEval.fill_gpval_integer("GPVAL_SPLOT", GlobalMembersGadgets.is_3d_plot ? 1:0);
		GlobalMembersEval.fill_gpval_integer("GPVAL_VIEW_MAP", GlobalMembersGraph3d.splot_map != 0 ? 1:0);
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_X", GlobalMembersGraph3d.surface_rot_x);
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ROT_Z", GlobalMembersGraph3d.surface_rot_z);
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_SCALE", GlobalMembersGraph3d.surface_scale);
		GlobalMembersEval.fill_gpval_float("GPVAL_VIEW_ZSCALE", GlobalMembersGraph3d.surface_zscale);
		return;
		}

		/* These are set after every "set" command, which is kind of silly */
		/* because they only change after 'set term' 'set output' ...      */
		if (context == 0 || context == 2 || context == 3)
		{
		/* FIXME! This prevents a segfault if term==NULL, which can */
		/* happen if set_terminal() exits via int_error().          */
		if (GlobalMembersTerm.term == null)
			GlobalMembersEval.fill_gpval_string("GPVAL_TERM", "unknown");
		else
			GlobalMembersEval.fill_gpval_string("GPVAL_TERM", (String)(GlobalMembersTerm.term.name));

		GlobalMembersEval.fill_gpval_string("GPVAL_TERMOPTIONS", GlobalMembersTerm.term_options);
		GlobalMembersEval.fill_gpval_string("GPVAL_OUTPUT", (GlobalMembersTerm.outstr) ? GlobalMembersTerm.outstr : "");
		}

		/* If we are called from int_error() then set the error state */
		if (context == 2)
		GlobalMembersEval.fill_gpval_integer("GPVAL_ERRNO", 1);

		/* These initializations need only be done once, on program entry */
		if (context == 3)
		{
		udvt_entry v = GlobalMembersEval.add_udv_by_name("GPVAL_VERSION");
		String tmp;
		if (v != null && v.udv_undef == true)
		{
			v.udv_undef = false;
			GlobalMembersEval.Gcomplex(v.udv_value, Double.parseDouble(GlobalMembersVersion.gnuplot_version), 0);
		}
		v = GlobalMembersEval.add_udv_by_name("GPVAL_PATCHLEVEL");
		if (v != null && v.udv_undef == true)
			GlobalMembersEval.fill_gpval_string("GPVAL_PATCHLEVEL", GlobalMembersVersion.gnuplot_patchlevel);
		v = GlobalMembersEval.add_udv_by_name("GPVAL_COMPILE_OPTIONS");
		if (v != null && v.udv_undef == true)
			GlobalMembersEval.fill_gpval_string("GPVAL_COMPILE_OPTIONS", GlobalMembersVersion.compile_options);

		/* Start-up values */
		GlobalMembersEval.fill_gpval_integer("GPVAL_MULTIPLOT", 0);
		GlobalMembersEval.fill_gpval_integer("GPVAL_PLOT", 0);
		GlobalMembersEval.fill_gpval_integer("GPVAL_SPLOT", 0);

		tmp = GlobalMembersTerm.get_terminals_names();
		GlobalMembersEval.fill_gpval_string("GPVAL_TERMINALS", tmp);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(tmp);

		/* Permanent copy of user-clobberable variables pi and NaN */
		GlobalMembersEval.fill_gpval_float("GPVAL_pi", DefineConstants.M_PI);
	///#ifdef HAVE_ISNAN
		GlobalMembersEval.fill_gpval_float("GPVAL_NaN", GlobalMembersStdfn.not_a_number());
	///#endif
		}

		if (context == 3 || context == 4)
		{
		GlobalMembersEval.fill_gpval_integer("GPVAL_ERRNO", 0);
		GlobalMembersEval.fill_gpval_string("GPVAL_ERRMSG", "");
		}

		if (context == 3 || context == 5)
		{
		String save_file = DefineConstants.NULL;
		save_file = (String) GlobalMembersAlloc.gp_alloc(DefineConstants.PATH_MAX, "filling GPVAL_PWD");
		if (save_file != null)
		{
			getcwd(save_file, DefineConstants.PATH_MAX);
			GlobalMembersEval.fill_gpval_string("GPVAL_PWD", save_file);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(save_file);
		}
		}

		if (context == 6)
		{
		GlobalMembersEval.fill_gpval_integer("GPVAL_TERM_WINDOWID", GlobalMembersGadgets.current_x11_windowid);
		}
	}

/* Fill variable "var" visible by "show var" or "show var all" ("GPVAL_*")
 * by the given value (string, integer, float, complex).
 */
	/* note: the routines below work for any variable name, not just those beginning GPVAL_ */
	public static void fill_gpval_string(String var, String stringvalue)
	{
		udvt_entry v = GlobalMembersEval.add_udv_by_name(var);
		if (v == null)
		return;
		if (v.udv_undef == false && !strcmp(v.udv_value.v.string_val, stringvalue))
		return;
		if (v.udv_undef)
		v.udv_undef = false;
		else
		GlobalMembersEval.gpfree_string(v.udv_value);
		GlobalMembersEval.Gstring(v.udv_value, GlobalMembersUtil.gp_strdup(stringvalue));
	}
	public static void fill_gpval_integer(String var, int value)
	{
		udvt_entry v = GlobalMembersEval.add_udv_by_name(var);
		if (v == null)
		return;
		v.udv_undef = false;
		GlobalMembersEval.Ginteger(v.udv_value, value);
	}
	public static void fill_gpval_float(String var, double value)
	{
		udvt_entry v = GlobalMembersEval.add_udv_by_name(var);
		if (v == null)
		return;
		v.udv_undef = false;
		GlobalMembersEval.Gcomplex(v.udv_value, value, 0);
	}
	public static void fill_gpval_complex(String var, double areal, double aimag)
	{
		udvt_entry v = GlobalMembersEval.add_udv_by_name(var);
		if (v == null)
		return;
		v.udv_undef = false;
		GlobalMembersEval.Gcomplex(v.udv_value, areal, aimag);
	}

/* Callable wrapper for the word() internal function */

	/* C-callable versions of internal gnuplot functions word() and words() */
	public static String gp_word(String String, int i)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Gstring(a, String));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, i));
		GlobalMembersInternal.f_words((union argument *)DefineConstants.NULL);
		GlobalMembersEval.pop(a);

		return a.v.string_val;
	}

/* Callable wrapper for the words() internal function */
	public static int gp_words(String String)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Gstring(a, String));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, -1));
		GlobalMembersInternal.f_words((union argument *)DefineConstants.NULL);
		GlobalMembersEval.pop(a);

		return a.v.int_val;
	}
///#endif

/* Internal helper functions: */




	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#define DF_EOF (-1)
	///#define DF_UNDEFINED (-2)
	///#define DF_FIRST_BLANK (-3)
	///#define DF_SECOND_BLANK (-4)
	///#define DF_MISSING (-5)
	///#define DF_FOUND_KEY_TITLE (-6)
	///#define DF_KEY_TITLE_MISSING (-7)
	///#define DF_STRINGDATA (-8)
	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX // in limits.h ?
	///#define MAXINT INT_MAX
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif
	///#define MAXDATACOLS 7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DF_DEFAULT_TYPE DF_FLOAT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SIGNED_TEST(val) ((val)==sizeof(long) ? DF_LONG : ((val)==sizeof(long long) ? DF_LONGLONG : ((val)==sizeof(int) ? DF_INT : ((val)==sizeof(short) ? DF_SHORT : ((val)==sizeof(char) ? DF_CHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define UNSIGNED_TEST(val) ((val)==sizeof(unsigned long) ? DF_ULONG : ((val)==sizeof(unsigned long long) ? DF_ULONGLONG : ((val)==sizeof(unsigned int) ? DF_UINT : ((val)==sizeof(unsigned short) ? DF_USHORT : ((val)==sizeof(unsigned char) ? DF_UCHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLOAT_TEST(val) ((val)==sizeof(float) ? DF_FLOAT : ((val)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define df_set_skip_after(col,bytes) df_set_skip_before(col+1,bytes)


	/* Internal prototypes */
	public static void fpe(int an_int)
	{
	///#if defined(MSDOS) && !defined(__EMX__) && !defined(DJGPP) && !defined(_Windows) || defined(DOS386)
	// /* thanks to lotto@wjh12.UUCP for telling us about this  */
	//    _fpreset();
	///#endif

		() an_int; // avoid -Wunused warning
		() signal(SIGFPE, (sigfunc) GlobalMembersEval.fpe);
		undefined = true;
		siglongjmp(fpe_env, true);
	}
	///#ifdef APOLLO
	//static pfm_$fh_func_val_t apollo_sigfpe(pfm_$fault_rec_t & fault_rec)
	///#endif

	/* Global variables exported by this module */
	public static udvt_entry udv_pi = new udvt_entry(DefineConstants.NULL, "pi", false, {DATA_TYPES.INTGR, {0}});
	public static udvt_entry udv_NaN;
	/* first in linked list */
	public static udvt_entry first_udv = udv_pi;
	public static udft_entry first_udf = null;

	public static boolean undefined;

	/* The stack this operates on */
	public static value[] stack = new value[DefineConstants.STACK_DEPTH];
	public static int s_p = -1; // stack pointer
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define top_of_stack stack[s_p]

	public static int jump_offset; // to be modified by 'jump' operators

	/* The table of built-in functions */
	/* HBB 20010725: I've removed all the casts to type (FUNC_PTR) ---
	 * According to ANSI/ISO C Standards it causes undefined behaviour if
	 * you cast a function pointer to any other type, including a function
	 * pointer with a different set of arguments, and then call the
	 * function.  Instead, I made all these functions adhere to the common
	 * type, directly */
	///#ifdef BACKWARDS_COMPATIBLE
	///#endif
	public static final ft_entry[] ft = {new ft_entry("push", f_push), new ft_entry("pushc", f_pushc), new ft_entry("pushd1", f_pushd1), new ft_entry("pushd2", f_pushd2), new ft_entry("pushd", f_pushd), new ft_entry("pop", f_pop), new ft_entry("call", f_call), new ft_entry("calln", f_calln), new ft_entry("lnot", f_lnot), new ft_entry("bnot", f_bnot), new ft_entry("uminus", f_uminus), new ft_entry("lor", f_lor), new ft_entry("land", f_land), new ft_entry("bor", f_bor), new ft_entry("xor", f_xor), new ft_entry("band", f_band), new ft_entry("eq", f_eq), new ft_entry("ne", f_ne), new ft_entry("gt", f_gt), new ft_entry("lt", f_lt), new ft_entry("ge", f_ge), new ft_entry("le", f_le), new ft_entry("plus", f_plus), new ft_entry("minus", f_minus), new ft_entry("mult", f_mult), new ft_entry("div", f_div), new ft_entry("mod", f_mod), new ft_entry("power", f_power), new ft_entry("factorial", f_factorial), new ft_entry("bool", f_bool), new ft_entry("dollars", f_dollars), new ft_entry("concatenate", f_concatenate), new ft_entry("eqs", f_eqs), new ft_entry("nes", f_nes), new ft_entry("[]", f_range), new ft_entry("assign", f_assign), new ft_entry("jump", f_jump), new ft_entry("jumpz", f_jumpz), new ft_entry("jumpnz", f_jumpnz), new ft_entry("jtern", f_jtern), new ft_entry("real", f_real), new ft_entry("imag", f_imag), new ft_entry("arg", f_arg), new ft_entry("conjg", f_conjg), new ft_entry("sin", f_sin), new ft_entry("cos", f_cos), new ft_entry("tan", f_tan), new ft_entry("asin", f_asin), new ft_entry("acos", f_acos), new ft_entry("atan", f_atan), new ft_entry("atan2", f_atan2), new ft_entry("sinh", f_sinh), new ft_entry("cosh", f_cosh), new ft_entry("tanh", f_tanh), new ft_entry("EllipticK", f_ellip_first), new ft_entry("EllipticE", f_ellip_second), new ft_entry("EllipticPi", f_ellip_third), new ft_entry("int", f_int), new ft_entry("abs", f_abs), new ft_entry("sgn", f_sgn), new ft_entry("sqrt", f_sqrt), new ft_entry("exp", f_exp), new ft_entry("log10", f_log10), new ft_entry("log", f_log), new ft_entry("besj0", f_besj0), new ft_entry("besj1", f_besj1), new ft_entry("besy0", f_besy0), new ft_entry("besy1", f_besy1), new ft_entry("erf", f_erf), new ft_entry("erfc", f_erfc), new ft_entry("gamma", f_gamma), new ft_entry("lgamma", f_lgamma), new ft_entry("ibeta", f_ibeta), new ft_entry("igamma", f_igamma), new ft_entry("rand", f_rand), new ft_entry("floor", f_floor), new ft_entry("ceil", f_ceil), new ft_entry("defined", f_exists), new ft_entry("norm", f_normal), new ft_entry("inverf", f_inverse_erf), new ft_entry("invnorm", f_inverse_normal), new ft_entry("asinh", f_asinh), new ft_entry("acosh", f_acosh), new ft_entry("atanh", f_atanh), new ft_entry("lambertw", f_lambertw), new ft_entry("column", f_column), new ft_entry("valid", f_valid), new ft_entry("timecolumn", f_timecolumn), new ft_entry("tm_sec", f_tmsec), new ft_entry("tm_min", f_tmmin), new ft_entry("tm_hour", f_tmhour), new ft_entry("tm_mday", f_tmmday), new ft_entry("tm_mon", f_tmmon), new ft_entry("tm_year", f_tmyear), new ft_entry("tm_wday", f_tmwday), new ft_entry("tm_yday", f_tmyday), new ft_entry("stringcolumn", f_stringcolumn), new ft_entry("strcol", f_stringcolumn), new ft_entry("sprintf", f_sprintf), new ft_entry("gprintf", f_gprintf), new ft_entry("strlen", f_strlen), new ft_entry("strstrt", f_strstrt), new ft_entry("substr", f_range), new ft_entry("word", f_words), new ft_entry("words", f_words), new ft_entry("strftime", f_strftime), new ft_entry("strptime", f_strptime), new ft_entry("system", f_system), new ft_entry("exist", f_exists), new ft_entry("exists", f_exists), new ft_entry(DefineConstants.NULL, DefineConstants.NULL)};
		/* internal functions: */
	/* standard functions: */

	/* Module-local variables: */

	///#if defined(_Windows) && !defined(WIN32)
	//static JMP_BUF far fpe_env;
	///#else
	public static sigjmp_buf fpe_env = new sigjmp_buf();

/*
 * Export axis bounds in terminal coordinates from previous plot.
 * This allows offline mapping of pixel coordinates onto plot coordinates.
 */


	public static void update_plot_bounds()
	{
		GlobalMembersEval.fill_gpval_integer("GPVAL_TERM_XMIN", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_lower / GlobalMembersTerm.term.tscale);
		GlobalMembersEval.fill_gpval_integer("GPVAL_TERM_XMAX", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].term_upper / GlobalMembersTerm.term.tscale);
		GlobalMembersEval.fill_gpval_integer("GPVAL_TERM_YMIN", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_lower / GlobalMembersTerm.term.tscale);
		GlobalMembersEval.fill_gpval_integer("GPVAL_TERM_YMAX", GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].term_upper / GlobalMembersTerm.term.tscale);
	}
	public static void fill_gpval_axis(AXIS_INDEX axis)
	{
		String prefix = "GPVAL";
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define A axis_array[axis]
		double a = (GlobalMembersAxis.axis_array[axis.getValue()].log ? Math.exp((GlobalMembersAxis.axis_array[axis.getValue()].min) * GlobalMembersAxis.axis_array[axis.getValue()].log_base): (GlobalMembersAxis.axis_array[axis.getValue()].min));
		double b = (GlobalMembersAxis.axis_array[axis.getValue()].log ? Math.exp((GlobalMembersAxis.axis_array[axis.getValue()].max) * GlobalMembersAxis.axis_array[axis.getValue()].log_base): (GlobalMembersAxis.axis_array[axis.getValue()].max));
		GlobalMembersEval.set_gpval_axis_sth_double(prefix, axis, "MIN", ((a < b) ? a : b), 0);
		GlobalMembersEval.set_gpval_axis_sth_double(prefix, axis, "MAX", ((a < b) ? b : a), 0);
		GlobalMembersEval.set_gpval_axis_sth_double(prefix, axis, "REVERSE", (GlobalMembersAxis.axis_array[axis.getValue()].range_flags & DefineConstants.RANGE_REVERSE), 1);
		GlobalMembersEval.set_gpval_axis_sth_double(prefix, axis, "LOG", GlobalMembersAxis.axis_array[axis.getValue()].base, 0);

		if (axis < AXIS_INDEX.R_AXIS)
		{
		if (axis == AXIS_INDEX.T_AXIS) // T axis is never drawn; colorbar is.
			axis = AXIS_INDEX.COLOR_AXIS;
		GlobalMembersEval.set_gpval_axis_sth_double("GPVAL_DATA", axis, "MIN", (GlobalMembersAxis.axis_array[axis.getValue()].log ? Math.exp((GlobalMembersAxis.axis_array[axis.getValue()].data_min) * GlobalMembersAxis.axis_array[axis.getValue()].log_base): (GlobalMembersAxis.axis_array[axis.getValue()].data_min)), 0);
		GlobalMembersEval.set_gpval_axis_sth_double("GPVAL_DATA", axis, "MAX", (GlobalMembersAxis.axis_array[axis.getValue()].log ? Math.exp((GlobalMembersAxis.axis_array[axis.getValue()].data_max) * GlobalMembersAxis.axis_array[axis.getValue()].log_base): (GlobalMembersAxis.axis_array[axis.getValue()].data_max)), 0);
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef A
	}
	public static void set_gpval_axis_sth_double(String prefix, AXIS_INDEX axis, String suffix, double value, int is_int)
	{
		udvt_entry v;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * cc;
		String s = new String(new char[24]);
		String.format(s, "%s_%s_%s", prefix, GlobalMembersAxis.axis_defaults[axis.getValue()].name, suffix);
		for (cc = s; * cc; cc++) // make the name uppercase
			*cc = Character.toUpperCase(*cc);
		v = GlobalMembersEval.add_udv_by_name(s);
		if (v == null) // should not happen
			return;
		v.udv_undef = false;
		if (is_int != 0)
		GlobalMembersEval.Ginteger(v.udv_value, (int)(value + 0.5));
		else
		GlobalMembersEval.Gcomplex(v.udv_value, value, 0);
	}
}