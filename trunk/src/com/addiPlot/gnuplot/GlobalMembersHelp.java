package com.addiPlot.gnuplot;

public class GlobalMembersHelp
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: help.c,v 1.24 2008/03/30 03:27:54 sfeam Exp $");
	}

/* help:
 * print a help message
 * also print available subtopics, if subtopics is TRUE
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String help_oldpath = "";
	///#endif

	/* GNUPLOT - help.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * $Id: help.h,v 1.8 2004/04/13 17:23:56 broeker Exp $
	 */

	/* GNUPLOT - help.h */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/



	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif

	/* Exit status returned by help() */
	///#define H_FOUND 0
	///#define H_NOTFOUND 1
	///#define H_ERROR (-1)

	/* Prototypes from file "help.c" */

	public static int help(String keyword, String path, boolean subtopics)
					/* (out) - are there subtopics? */
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte oldpath[BUFSIZ] = ""; // previous help file
		int status; // result of LoadHelp
		key_s key; // key that matches keyword

		/*
		 ** Load the help file if necessary (say, first time we enter this routine,
		 ** or if the help file changes from the last time we were called).
		 ** Also may occur if in-memory copy was freed.
		 ** Calling routine may access errno to determine cause of H_ERROR.
		 */
		errno = 0;
		if (strncmp(help_oldpath, path, BUFSIZ) != 0)
		GlobalMembersBf_test.FreeHelp();
		if (keys == DefineConstants.NULL)
		{
		status = GlobalMembersHelp.LoadHelp(path);
		if (status == DefineConstants.H_ERROR)
			return (status);

		/* save the new path in oldpath */
		GlobalMembersStdfn.safe_strncpy(help_oldpath, path, BUFSIZ);
		}
		/* look for the keyword in the help file */
		key = GlobalMembersHelp.FindHelp(keyword);
		if (key != DefineConstants.NULL)
		{
		/* found the keyword: if help exists, print and return */
		if (key.text != null)
			GlobalMembersHelp.PrintHelp(key, subtopics);
		status = DefineConstants.H_FOUND;
		}
		else
		{
		status = DefineConstants.H_NOTFOUND;
		}

		return (status);
	}

/* Free the help file from memory. */
/* May be called externally if space is needed */
	public static void FreeHelp()
	{
		int i; // index into keys[]
		line_s t;
		line_s next;

		if (keys == DefineConstants.NULL)
		return;

		for (i = 0; i < keycount; i++)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) keys[i].key);
		if (keys[i].primary) // only try to release text once!
			for (t = keys[i].text; t != DefineConstants.NULL; t = next)
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free((String) t.line);
			next = t.next;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free((String) t);
			}
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) keys);
		keys = DefineConstants.NULL;
		keycount = 0;
	///#ifdef DOS16
	//    (void) fclose(helpfp);
	///#endif
	}

/* StartOutput:
 * Open a file pointer to a pipe to user's $PAGER, if there is one,
 * otherwise use our own pager.
 */
	public static void StartOutput()
	{
		String line_count = DefineConstants.NULL;

	///#if defined(PIPES)
		byte pager_name = getenv("PAGER");

		if (pager_name != DefineConstants.NULL && pager_name != DefineConstants.NUL)
		if ((outfile = GlobalMembersAmiga.popen(pager_name, "w")) != (FILE) DefineConstants.NULL)
			return; // success
		outfile = stderr;
		/* fall through to built-in pager */
	///#endif

		/* buit-in dumb pager: use the line count provided by the terminal */
		line_count = getenv("LINES");

		if (!line_count.equals(DefineConstants.NULL))
		screensize = (int) strtol(line_count, DefineConstants.NULL, 0);
		if (line_count.equals(DefineConstants.NULL) || screensize < 3)
		screensize = DefineConstants.SCREENSIZE;

		/* built-in pager */
		pagelines = 0;
	}

/* write a line of help output  */
/* line should contain only one \n, at the end */
	public static void OutLine(String line)
	{
		int c; // dummy input char
	///#if defined(PIPES)
		if (outfile != stderr)
		{
		fputs(line, outfile);
		return;
		}
	///#endif

		/* built-in dumb pager */
		/* leave room for prompt line */
		if (pagelines >= screensize - 2)
		{
		fputs("Press return for more: ", stderr);
		do
			c = System.in.read();
		while (c != EOF && c != '\n');
		pagelines = 0;
		}
		fputs(line, stderr);
		pagelines++;
	}
	public static void EndOutput()
	{
	///#if defined(PIPES)
		if (outfile != stderr)
		() GlobalMembersAmiga.pclose(outfile);
	///#endif
	}
	public static linkey_s keylist = DefineConstants.NULL; // linked list of keys
	public static key_s keys = DefineConstants.NULL; // array of keys
	public static int keycount = 0; // number of keys
	public static FILE helpfp = DefineConstants.NULL;
	public static key_s empty_key = new key_s(DefineConstants.NULL, 0, DefineConstants.NULL, 0);

/* we only read the file once, into memory
 * except for DOS16 when we don't read all the file -
 * just the keys and location of the text
 */

	public static int LoadHelp(String path)
	{
		linkey_s key = 0; // this key
		int pos = 0; // ftell location within help file
		String buf = new String(new char[BUFSIZ]); // line from help file
		line_s head; // head of text list
		line_s firsthead = DefineConstants.NULL;
		boolean primary; // first ? line of a set is primary
		boolean flag;

		if ((helpfp = fopen(path, "r")) == DefineConstants.NULL)
		{
		/* can't open help file, so error exit */
		return (DefineConstants.H_ERROR);
		}
		/*
		 ** The help file is open.  Look in there for the keyword.
		 */
		if (!fgets(buf, BUFSIZ - 1, helpfp) || !buf.equals(DefineConstants.KEYFLAG))
		return (DefineConstants.H_ERROR); // it is probably not the .gih file

		while (!feof(helpfp))
		{
		/*
		 ** Make an entry for each synonym keyword
		 */
		primary = true;
		while (buf.charAt(0) == DefineConstants.KEYFLAG)
		{
			key = GlobalMembersHelp.storekey(buf + 1); // store this key
			key.primary = primary;
			key.text = DefineConstants.NULL; // fill in with real value later
			key.pos = 0; // fill in with real value later
			primary = false;
			pos = ftell(helpfp);
			if (fgets(buf, BUFSIZ - 1, helpfp) == (String) DefineConstants.NULL)
			break;
		}
		/*
		 ** Now store the text for this entry.
		 ** buf already contains the first line of text.
		 */
	///#ifndef DOS16
		firsthead = GlobalMembersHelp.storeline(buf);
		head = firsthead;
	///#endif
		while ((fgets(buf, BUFSIZ - 1, helpfp) != (String) DefineConstants.NULL) && (buf.charAt(0) != DefineConstants.KEYFLAG))
		{
	///#ifndef DOS16
			/* save text line */
			head.next = GlobalMembersHelp.storeline(buf);
			head = head.next;
	///#endif
		}
		/* make each synonym key point to the same text */
		do
		{
			key.pos = pos;
			key.text = firsthead;
			flag = key.primary;
			key = key.next;
		} while (flag != true && key != DefineConstants.NULL);
		}
	///#ifndef DOS16
		() fclose(helpfp);
	///#endif

		/* we sort the keys so we can use binary search later */
		GlobalMembersHelp.sortkeys();
		return (DefineConstants.H_FOUND); // ok
	}

/* we sort the keys so we can use binary search later */
/* We have a linked list of keys and the number.
 * to sort them we need an array, so we reform them into an array,
 * and then throw away the list.
 */
	public static void sortkeys()
	{
		linkey_s p; // pointers to linked list
		linkey_s n;
		int i; // index into key array

		/* allocate the array */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		keys = (GlobalMembersMouse.struct key_s *) GlobalMembersAlloc.gp_alloc((keycount + 1) * sizeof(GlobalMembersMouse.struct key_s), "key array");

		/* copy info from list to array, freeing list */
		for (p = keylist, i = 0; p != DefineConstants.NULL; p = n, i++)
		{
		keys[i].key = p.key;
		keys[i].pos = p.pos;
		keys[i].text = p.text;
		keys[i].primary = p.primary;
		n = p.next;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) p);
		}

		/* a null entry to terminate subtopic searches */
		keys[keycount].key = DefineConstants.NULL;
		keys[keycount].pos = 0;
		keys[keycount].text = DefineConstants.NULL;

		/* sort the array */
		/* note that it only moves objects of size (two pointers + long + int) */
		/* it moves no strings */
		/* HBB 20010720: removed superfluous, potentially dangerous casts */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(keys, keycount, sizeof(GlobalMembersMouse.struct key_s), GlobalMembersHelp.keycomp);
	}

/* HBB 20010720: changed to make this match the prototype qsort()
 * really expects. Casting function pointers, as we did before, is
 * illegal! */
/* HBB 20010720: removed 'static' to avoid HP-sUX gcc bug */
	public static int keycomp(Object arg1, Object arg2)
	{
		final key_s a = arg1;
		final key_s b = arg2;

		return (strcmp(a.key, b.key));
	}

/* make a new line buffer and save this string there */
	public static line_s storeline(String text)
	{
		line_s new_Renamed;

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		new() = (GlobalMembersMouse.struct line_s *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct line_s), "new line buffer");
		if (text != null)
		new_Renamed.line = GlobalMembersUtil.gp_strdup(text);
		else
		new_Renamed.line = DefineConstants.NULL;

		new_Renamed.next = DefineConstants.NULL;

		return (new_Renamed);
	}

/* Add this keyword to the keys list, with the given text */
	public static linkey_s storekey(String key)
	{
		linkey_s new_Renamed;

		key = tangible.StringFunctions.changeCharacter(key, key.length() - 1, DefineConstants.NUL); // cut off \n

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		new() = (GlobalMembersMouse.struct linkey_s *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct linkey_s), "new key list");
		if (key != null)
		new_Renamed.key = GlobalMembersUtil.gp_strdup(key);

		/* add to front of list */
		new_Renamed.next = keylist;
		keylist = new_Renamed;
		keycount++;
		return (new_Renamed);
	}

/* FindHelp:
 *  Find the key that matches the keyword.
 *  The keys[] array is sorted by key.
 *  We could use a binary search, but a linear search will aid our
 *  attempt to allow abbreviations. We search for the first thing that
 *  matches all the text we're given. If not an exact match, then
 *  it is an abbreviated match, and there must be no other abbreviated
 *  matches -- for if there are, the abbreviation is ambiguous.
 *  We print the ambiguous matches in that case, and return not found.
 */
	public static key_s FindHelp(String keyword)
	{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		key_s * key = new key_s();
		int len = strcspn(keyword, " ");

		for (key = keys; !key.key.equals(DefineConstants.NULL); key++)
		{
		if (!strncmp(keyword, key.key, len)) // we have a match!
		{
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: if (!Ambiguous(key, len))
			if (!GlobalMembersHelp.Ambiguous(new key_s(key), len))
			{
			int key_len = key.key.length();
			int keyword_len = keyword.length();

			if (key_len != len)
			{
				/* Expand front portion of keyword */
				int i;
				int shift = key_len - len;

				for (i = keyword_len + shift; i >= len; i--)
				keyword = tangible.StringFunctions.changeCharacter(keyword, i, keyword.charAt(i - shift));
				keyword = key.key.substring(0, key_len); // give back the full spelling
				len = key_len;
				keyword_len += shift;
			}
			/* Check for another subword */
			if (keyword.charAt(len) == ' ')
			{
				len = len + 1 + strcspn(keyword + len + 1, " ");
				key--; // start with current key
			}
			else
				return (key); // found!!  non-ambiguous abbreviation
			}
			else
			return (empty_key);
		}
		}

		/* not found */
		return (DefineConstants.NULL);
	}

/* Ambiguous:
 * Check the key for ambiguity up to the given length.
 * It is ambiguous if it is not a complete string and there are other
 * keys following it with the same leading substring.
 */
	public static boolean Ambiguous(key_s[] key, int len)
	{
		String first;
		String prev;
		boolean status = false; // assume not ambiguous
		int compare;
		int sublen;

		if (key.key.charAt(len) == DefineConstants.NUL)
		return (false);

		for (prev = first = key.key, compare = 0, key++; !key.key.equals(DefineConstants.NULL) && compare == 0; key++)
		{
		compare = strncmp(first, key.key, len);
		if (compare == 0)
		{
			/* So this key matches the first one, up to len.
			 * But is it different enough from the previous one
			 * to bother printing it as a separate choice?
			 */
			sublen = strcspn(prev + len, " ");
			if (strncmp(key.key, prev, len + sublen) != 0)
			{
			/* yup, this is different up to the next space */
			if (!status)
			{
				/* first one we have printed is special */
				fprintf(stderr, "Ambiguous request '%.*s'; possible matches:\n", (int)len, first);
				fprintf(stderr, "\t%s\n", prev);
				status = true;
			}
			fprintf(stderr, "\t%s\n", key.key);
			prev = key.key;
			}
		}
		}

		return (status);
	}

/* PrintHelp:
 * print the text for key
 */

	/* Help output */
	public static void PrintHelp(key_s key, boolean subtopics)
					/* (out) - are there subtopics? */
	{
		line_s t;
	///#ifdef DOS16
	//    char buf[BUFSIZ];		// line from help file
	///#endif

		GlobalMembersHelp.StartOutput();

		if (subtopics == DefineConstants.NULL || !subtopics)
		{
	///#ifdef DOS16
	//	fseek(helpfp, key->pos, 0);
	//	while ((fgets(buf, BUFSIZ - 1, helpfp) != (char *) NULL)
	//	       && (buf[0] != KEYFLAG)) {
	//	    OutLine(buf);
	//	}
	///#else
		for (t = key.text; t != DefineConstants.NULL; t = t.next)
			GlobalMembersHelp.OutLine(t.line); // print text line
	///#endif
		}
		GlobalMembersHelp.ShowSubtopics(key, subtopics);
		GlobalMembersHelp.OutLine_InternalPager("\n");

		GlobalMembersHelp.EndOutput();
	}
	public static void ShowSubtopics(key_s key, boolean subtopics)
	{
		int subt = 0; // printed any subtopics yet?
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		key_s * subkey = new key_s(); // subtopic key
		int len; // length of key name
		String line = new String(new char[BUFSIZ]); // subtopic output line
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * start; // position of subname in key name
		int sublen; // length of subname
		String prev = DefineConstants.NULL; // the last thing we put on the list

	///#define MAXSTARTS 256
		int stopics = 0; // count of (and index to next) subtopic name
		String[] starts = new String[DefineConstants.MAXSTARTS]; // saved positions of subnames

		line = DefineConstants.NUL;
		len = key.key.length();

		for (subkey = key + 1; !subkey.key.equals(DefineConstants.NULL); subkey++)
		{
		if (strncmp(subkey.key, key.key, len) == 0)
		{
			/* find this subtopic name */
			start = subkey.key + len;
			if (len > 0)
			{
			if (*start == ' ')
				start++; // skip space
			else
				break; // not the same topic after all
			}
			else
			{
			/* here we are looking for main topics */
			if (!subkey.primary)
				continue; // not a main topic
			}
			sublen = strcspn(start, " ");
			if (prev.equals(DefineConstants.NULL) || strncmp(start, prev, sublen) != 0)
			{
			if (subt == 0)
			{
				subt++;
				if (len != 0)
				{
				line = "\nSubtopics available for ";
				strncat(line, key.key, BUFSIZ - 25 - 2 - 1);
				line += ":\n";
				}
				else
				line = "\nHelp topics available:\n";
				GlobalMembersHelp.OutLine_InternalPager(line);
				line = DefineConstants.NUL;
			}
			starts[stopics++] = start;
			prev = start;
			}
		}
		else
		{
			/* new topic */
			break;
		}
		}

	/* The number of the first column for subtopic entries */
	///#define FIRSTCOL 4
	/* Length of a subtopic entry; if COLLENGTH is exceeded,
	 * the next column is skipped */
	///#define COLLENGTH 18

	///#ifndef COLUMN_HELP
		{
		/* sort subtopics by row - default */
		int subtopic;
		int spacelen = 0;
		int ispacelen;
		int pos = 0;

		for (subtopic = 0; subtopic < stopics; subtopic++)
		{
			start = starts[subtopic];
			sublen = strcspn(start, " ");
			if (pos == 0)
			spacelen = DefineConstants.FIRSTCOL;
			/* adapted by DvdSchaaf */
			for (ispacelen = 0; ispacelen < spacelen; ispacelen++)
			() strcat(line, " ");
			() strncat(line, start, sublen);

			spacelen = DefineConstants.COLLENGTH - sublen;
			while (spacelen <= 0)
			{
			spacelen += DefineConstants.COLLENGTH;
			pos++;
			}

			pos++;
			if (pos >= DefineConstants.PER_LINE)
			{
			() strcat(line, "\n");
			GlobalMembersHelp.OutLine_InternalPager(line);
			line = DefineConstants.NUL;
			pos = 0;
			}
		}

		/* put out the last line */
		if (subt > 0 && pos > 0)
		{
			() strcat(line, "\n");
			GlobalMembersHelp.OutLine_InternalPager(line);
		}
		}
	///#else // COLUMN_HELP
	//    {
	// /* sort subtopics by column */
	//	int subtopic, sublen;
	//	int spacelen = 0, ispacelen;
	//	int row, col;
	//	int rows = (int) (stopics / PER_LINE) + 1;
	//
	//	for (row = 0; row < rows; row++) {
	//	    *line = NUL;
	//	    for (ispacelen = 0; ispacelen < FIRSTCOL; ispacelen++)
	//		(void) strcat(line, " ");
	//
	//	    for (col = 0; col < PER_LINE; col++) {
	//		subtopic = row + rows * col;
	//		if (subtopic >= stopics) {
	//		    break;
	//		} else {
	//		    start = starts[subtopic];
	//		    sublen = strcspn(start, " ");
	//		    (void) strncat(line, start, sublen);
	//		    spacelen = COLLENGTH - sublen;
	//		    if (spacelen <= 0)
	//			spacelen = 1;
	//		    for (ispacelen = 0; ispacelen < spacelen; ispacelen++)
	//			(void) strcat(line, " ");
	//		}
	//	    }
	//	    (void) strcat(line, "\n");
	//	    OutLine_InternalPager(line);
	//	}
	//    }
	///#endif // COLUMN_HELP

		if (subtopics)
		subtopics = (subt != 0);
	}

/* Same as Outline, but does not go through the external pager.
 * Used for the list of available subtopics because if it would be passed to
 * 'less' (for example), the list would not be displayed anymore after 'less'
 * has exited and the user is asked for a subtopic */
	public static void OutLine_InternalPager(String line)
	{
		int c; // dummy input char

	///#if defined(PIPES)
		if (outfile != stderr)
		{
		/* do not go through external pager */
		fputs(line, stderr);
		return;
		}
	///#endif // PIPES

		/* built-in dumb pager */
		/* leave room for prompt line */
		if (pagelines >= screensize - 2)
		{
		fputs("Press return for more: ", stderr);
		do
			c = System.in.read();
		while (c != EOF && c != '\n');
		pagelines = 0;
		}
		fputs(line, stderr);
		pagelines++;
	}

	///#if defined(PIPES)
	public static FILE outfile; // for unix pager, if any
	///#endif
	public static int pagelines; // count for builtin pager
	public static int screensize; // lines on screen (got with env var)
}