package com.addiPlot.gnuplot;

public class GlobalMembersGadgets
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("gadgets.c,v 1.1.3.1 2000/05/03 21:47:15 hbb Exp");
	}
	///#endif

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern legend_key keyT;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern color_box_struct color_box;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern color_box_struct default_color_box;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern BoundingBox plot_bounds; // Plot Boundary
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern BoundingBox canvas; // Writable area on terminal
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern BoundingBox *clip_area; // Current clipping box

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float xsize; // x scale factor for size
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float ysize; // y scale factor for size
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float zsize; // z scale factor for size
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float xoffset; // x origin setting
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float yoffset; // y origin setting
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern float aspect_ratio; // 1.0 for square
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int aspect_ratio_3D; // 2 for equal scaling of x and y; 3 for z also

	/* plot border autosizing overrides, in characters (-1: autosize) */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern position lmargin, bmargin, rmargin, tmargin;
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern FILE *table_outfile;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean table_mode;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct arrow_def *first_arrow;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct text_label *first_label;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct linestyle_def *first_linestyle;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct arrowstyle_def *first_arrowstyle;

	///#ifdef EAM_OBJECTS
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct object *first_object;
	///#endif

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern text_label title;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern text_label timelabel;
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	/* asctime() format */
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int timelabel_rotate;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int timelabel_bottom;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean polar;

	///#define ZERO 1e-8
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern double zero; // zero threshold, not 0!

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern double pointsize;

	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int draw_border;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int user_border;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int border_layer;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct lp_style_type border_lp;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern const struct lp_style_type default_border_lp;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean clip_lines1;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean clip_lines2;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean clip_points;

	///#define SAMPLES 100
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int samples_1;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int samples_2;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern double ang2rad; // 1 or pi/180

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern enum PLOT_STYLE data_style;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern enum PLOT_STYLE func_style;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean parametric;

	/* If last plot was a 3d one. */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean is_3d_plot;

	/* A macro to check whether 2D functionality is allowed in the last plot:
	   either the plot is a 2D plot, or it is a suitably oriented 3D plot (e.g. map).
	*/
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )

	///#ifdef VOLATILE_REFRESH
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int refresh_ok; // 0 = no;  2 = 2D ok;  3 = 3D ok
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int refresh_nplots;
	///#else
	///#define refresh_ok FALSE
	///#endif
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean volatile_data;

	/* WINDOWID to be filled by terminals running on X11 (x11, wxt, qt, ...) */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern int current_x11_windowid;

/* Clip the given line to drawing coords defined by BoundingBox.
 *   This routine uses the cohen & sutherland bit mapping for fast clipping -
 * see "Principles of Interactive Computer Graphics" Newman & Sproull page 65.
 */

	/* Plot layer definitions are collected here. */
	/* Someday they might actually be used.       */
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99

	/* Functions exported by gadgets.c */

	/* moved here from util3d: */
	public static void draw_clip_line(int x1, int y1, int x2, int y2)
	{
		TERMENTRY t = GlobalMembersTerm.term;

		/* HBB 20000522: I've made this routine use the clippling in
		 * clip_line(), in a movement to reduce code duplication. There
		 * was one very small difference between these two routines. See
		 * clip_line() for a comment about it, at the relevant place. */
		if (GlobalMembersGadgets.clip_line(x1, y1, x2, y2) == 0)
		/* clip_line() returns zero --> segment completely outside
		 * bounding box */
		return;

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x1, y1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x2, y2);
	}
	public static void draw_clip_arrow(int sx, int sy, int ex, int ey, int head)
	{
		TERMENTRY t = GlobalMembersTerm.term;

		/* Don't draw head if the arrow itself is clipped */
		if (GlobalMembersGadgets.clip_point(sx, sy) != 0)
		head &= ~e_arrow_head.BACKHEAD;
		if (GlobalMembersGadgets.clip_point(ex, ey) != 0)
		head &= ~e_arrow_head.END_HEAD;
		GlobalMembersGadgets.clip_line(sx, sy, ex, ey);

		/* Call terminal routine to draw the clipped arrow */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)((int)sx, (int)sy, (int)ex, (int)ey, head);
	}

/* Clip the given line to drawing coords defined by BoundingBox.
 *   This routine uses the cohen & sutherland bit mapping for fast clipping -
 * see "Principles of Interactive Computer Graphics" Newman & Sproull page 65.
 * Return 0: entire line segment is outside bounding box
 *        1: entire line segment is inside bounding box
 *       -1: line segment has been clipped to bounding box
 */
	public static int clip_line(int x1, int y1, int x2, int y2)
	{
		int x;
		int y;
		int dx;
		int dy;
		int[] x_intr = new int[4];
		int[] y_intr = new int[4];
		int count;
		int pos1;
		int pos2;
		int x_max;
		int x_min;
		int y_max;
		int y_min;
		pos1 = GlobalMembersGadgets.clip_point(x1, y1);
		pos2 = GlobalMembersGadgets.clip_point(x2, y2);
		if (pos1 == 0 && pos2 == 0)
		return 1; // segment is totally in
		if (pos1 & pos2 != 0)
		return 0; // segment is totally out.
		/* Here part of the segment MAY be inside. test the intersection
		 * of this segment with the 4 boundaries for hopefully 2 intersections
		 * in. If none are found segment is totaly out.
		 * Under rare circumstances there may be up to 4 intersections (e.g.
		 * when the line passes directly through at least one corner). In
		 * this case it is sufficient to take any 2 intersections (e.g. the
		 * first two found).
		 */
		count = 0;
		dx = x2 - x1;
		dy = y2 - y1;
		/* Find intersections with the x parallel bbox lines: */
		if (dy != 0)
		{
		x = (clip_area.ybot - y2) * dx / dy + x2; // Test for clip_area->ybot boundary.
		if (x >= clip_area.xleft && x <= clip_area.xright)
		{
			x_intr[count] = x;
			y_intr[count++] = clip_area.ybot;
		}
		x = (clip_area.ytop - y2) * dx / dy + x2; // Test for clip_area->ytop boundary.
		if (x >= clip_area.xleft && x <= clip_area.xright)
		{
			x_intr[count] = x;
			y_intr[count++] = clip_area.ytop;
		}
		}
		/* Find intersections with the y parallel bbox lines: */
		if (dx != 0)
		{
		y = (clip_area.xleft - x2) * dy / dx + y2; // Test for clip_area->xleft boundary.
		if (y >= clip_area.ybot && y <= clip_area.ytop)
		{
			x_intr[count] = clip_area.xleft;
			y_intr[count++] = y;
		}
		y = (clip_area.xright - x2) * dy / dx + y2; // Test for clip_area->xright boundary.
		if (y >= clip_area.ybot && y <= clip_area.ytop)
		{
			x_intr[count] = clip_area.xright;
			y_intr[count++] = y;
		}
		}
		if (count < 2)
		return 0;

		if (x1 < x2)
		{
		x_min = x1;
		x_max = x2;
		}
		else
		{
		x_min = x2;
		x_max = x1;
		}
		if (y1 < y2)
		{
		y_min = y1;
		y_max = y2;
		}
		else
		{
		y_min = y2;
		y_max = y1;
		}

		if (pos1 != 0 && pos2 != 0) // Both were out - update both
		{
		/* EAM Sep 2008 - preserve direction of line segment */
		if ((dx * (x_intr[1] - x_intr[0]) < 0) || (dy * (y_intr[1] - y_intr[0]) < 0))
		{
			x1 = x_intr[1];
			y1 = y_intr[1];
			x2 = x_intr[0];
			y2 = y_intr[0];
		}
		else
		{
			x1 = x_intr[0];
			y1 = y_intr[0];
			x2 = x_intr[1];
			y2 = y_intr[1];
		}
		} // Only x1/y1 was out - update only it
		else if (pos1 != 0)
		{
		/* This is about the only real difference between this and
		 * draw_clip_line(): it compares for '>0', here */
		if (dx * (x2 - x_intr[0]) + dy * (y2 - y_intr[0]) >= 0)
		{
			x1 = x_intr[0];
			y1 = y_intr[0];
		}
		else
		{
			x1 = x_intr[1];
			y1 = y_intr[1];
		}
		} // Only x2/y2 was out - update only it
		else
		{
		/* Same difference here, again */
		if (dx * (x_intr[0] - x1) + dy * (y_intr[0] - y1) >= 0)
		{
			x2 = x_intr[0];
			y2 = y_intr[0];
		}
		else
		{
			x2 = x_intr[1];
			y2 = y_intr[1];
		}
		}

		if (x1 < x_min || x1 > x_max || x2 < x_min || x2 > x_max || y1 < y_min || y1 > y_max || y2 < y_min || y2 > y_max)
		return 0;

		return -1;
	}

/*****************************************************************/
/* Routines that deal with global objects defined in this module */
/*****************************************************************/

/* Clipping to the bounding box: */

/* Test a single point to be within the BoundingBox.
 * Sets the returned integers 4 l.s.b. as follows:
 * bit 0 if to the left of xleft.
 * bit 1 if to the right of xright.
 * bit 2 if below of ybot.
 * bit 3 if above of ytop.
 * 0 is returned if inside.
 */
	public static int clip_point(int x, int y)
	{
		int ret_val = 0;

		if (clip_area == null)
		return 0;
		if ((int)x < clip_area.xleft)
		ret_val |= 0x01;
		if ((int)x > clip_area.xright)
		ret_val |= 0x02;
		if ((int)y < clip_area.ybot)
		ret_val |= 0x04;
		if ((int)y > clip_area.ytop)
		ret_val |= 0x08;

		return ret_val;
	}
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void clip_put_text(int NamelessParameter1, int NamelessParameter2, String NamelessParameter3);

	/* moved here from graph3d: */
	public static void clip_move(int x, int y)
	{
		move_pos_x = x;
		move_pos_y = y;
	}
	public static void clip_vector(int x, int y)
	{
		GlobalMembersGadgets.draw_clip_line(move_pos_x, move_pos_y, x, y);
		move_pos_x = x;
		move_pos_y = y;
	}

/* Common routines for setting text or line color from t_colorspec */


	/* Common routines for setting line or text color from t_colorspec */
	public static void apply_pm3dcolor(t_colorspec tc, TERMENTRY t)
	{

		/* Replace colorspec with that of the requested line style */
		lp_style_type style = new lp_style_type();
		if (tc.type == DefineConstants.TC_LINESTYLE)
		{
		GlobalMembersTerm.lp_use_properties(style, tc.lt);
		tc = style.pm3d_color;
		}

		if (tc.type == DefineConstants.TC_DEFAULT)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
		return;
		}
		if (tc.type == DefineConstants.TC_LT)
		{
		if (t.set_color)
			t.set_color(tc);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.linetype)(tc.lt);
		return;
		}
		if (tc.type == DefineConstants.TC_RGB && t.set_color)
		{
		t.set_color(tc);
		return;
		}
		if (!GlobalMembersPm3d.is_plot_with_palette() || !t.set_color)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
		return;
		}
		switch (tc.type)
		{
		case DefineConstants.TC_Z:
			GlobalMembersColor.set_color(GlobalMembersPm3d.cb2gray(GlobalMembersPm3d.z2cb(tc.value)));
			break;
		case DefineConstants.TC_CB:
			GlobalMembersColor.set_color(GlobalMembersPm3d.cb2gray(tc.value));
			break;
		case DefineConstants.TC_FRAC:
			GlobalMembersColor.set_color(GlobalMembersColor.sm_palette.positive == DefineConstants.SMPAL_POSITIVE ? tc.value : 1 - tc.value);
				  break;
		}
	}
	public static void reset_textcolor(t_colorspec tc, TERMENTRY t)
	{
		if (tc.type != DefineConstants.TC_DEFAULT)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
	}

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern fill_style_type default_fillstyle;

	///#ifdef EAM_OBJECTS
	/*       Warning: C89 does not like the union initializers     */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct object default_rectangle;
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct object default_circle;
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }

	///#endif

	/* filledcurves style options set by 'set style [data|func] filledcurves opts' */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern filledcurves_opts filledcurves_opts_data;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern filledcurves_opts filledcurves_opts_func;

	/* Prefer line styles over plain line types */
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean prefer_line_styles;

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern histogram_style histogram_opts;

	public static void default_arrow_style(arrow_style_type arrow)
	{
		final GlobalMembersMouse.struct lp_style_type tmp_lp_style = new struct(0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0});

		arrow.layer = 0;
		arrow.lp_properties = tmp_lp_style;
		arrow.head = 1;
		arrow.head_length = 0.0;
		arrow.head_lengthunit = position_type.first_axes.getValue();
		arrow.head_angle = 15.0;
		arrow.head_backangle = 90.0;
		arrow.head_filled = 0;
	}

	public static void free_labels(text_label label)
	{
	text_label temp;
	String master_font = label.font;

		/* Labels generated by 'plot with labels' all use the same font */
		if (master_font != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(master_font);

		while (label != null)
		{
		if (label.text != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(label.text);
		if (label.font != null && !label.font.equals(master_font))
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(label.font);
		temp = label.next;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(label);
		label = temp;
		}

	}

	public static void get_offsets(text_label this_label, TERMENTRY t, int htic, int vtic)
	{
		if (this_label.lp_properties.pointflag != 0)
		{
		htic = (pointsize * t.h_tic * 0.5);
		vtic = (pointsize * t.v_tic * 0.5);
		}
		else
		{
		htic = 0;
		vtic = 0;
		}
		if (is_3d_plot)
		{
		int htic2;
		int vtic2;
		GlobalMembersGraph3d.map3d_position_r((this_label.offset), htic2, vtic2, "get_offsets");
		htic += htic2;
		vtic += vtic2;
		}
		else
		{
		double htic2;
		double vtic2;
		GlobalMembersGraphics.map_position_r((this_label.offset), htic2, vtic2, "get_offsets");
		htic += (int)htic2;
		vtic += (int)vtic2;
		}
	}

/*
 * Write one label, with all the trimmings.
 * This routine is used for both 2D and 3D plots.
 */
	public static void write_label(int x, int y, text_label this_label)
	{
		int htic;
		int vtic;
		int justify = VERT_JUSTIFY.JUST_TOP.getValue(); // This was the 2D default; 3D had CENTRE

		GlobalMembersGadgets.apply_pm3dcolor((this_label.textcolor), GlobalMembersTerm.term);
		GlobalMembersTerm.ignore_enhanced(this_label.noenhanced);

		GlobalMembersGadgets.get_offsets(this_label, GlobalMembersTerm.term, htic, vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if (this_label.rotate != 0 && (*GlobalMembersTerm.term.text_angle)(this_label.rotate))
		{
			GlobalMembersTerm.write_multiline(x + htic, y + vtic, this_label.text, this_label.pos, justify, this_label.rotate, this_label.font);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.text_angle)(0);
		}
		else
		{
			GlobalMembersTerm.write_multiline(x + htic, y + vtic, this_label.text, this_label.pos, justify, 0, this_label.font);
		}
		/* write_multiline() clips text to on_page; do the same for any point */
		if (this_label.lp_properties.pointflag != 0 && GlobalMembersTerm.on_page(x, y))
		{
			GlobalMembersTerm.term_apply_lp_properties(this_label.lp_properties);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*GlobalMembersTerm.term.point)(x, y, this_label.lp_properties.p_type);
			/* the default label color is that of border */
			GlobalMembersTerm.term_apply_lp_properties(border_lp);
		}

		GlobalMembersTerm.ignore_enhanced(false);
	}


	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif

	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifndef TERM_HELP
	///#define PM3D_AT_BASE 'b'
	///#define PM3D_AT_TOP 't'
	///#define PM3D_AT_SURFACE 's'
	///#define PM3D_FLUSH_BEGIN 'b'
	///#define PM3D_FLUSH_END 'r'
	///#define PM3D_FLUSH_CENTER 'c'
	///#define PM3D_SCANS_AUTOMATIC 'a'
	///#define PM3D_SCANS_FORWARD 'f'
	///#define PM3D_SCANS_BACKWARD 'b'
	///#define PM3D_DEPTH 'd'
	///#define PM3D_CLIP_1IN '1'
	///#define PM3D_CLIP_4IN '4'
	///#endif // TERM_HELP 

	/* This file contains mainly a collection of global variables that
	 * used to be in 'set.c', where they didn't really belong. They
	 * describe the status of several parts of the gnuplot plotting engine
	 * that are used by both 2D and 3D plots, and thus belong neither to
	 * graphics.c nor graph3d.c, alone. This is not a very clean solution,
	 * but better than mixing internal status and the user interface as we
	 * used to have it, in set.c and setshow.h */

	public static legend_key keyT = new legend_key(true, en_key_region.GPKEY_AUTO_INTERIOR_LRTBC, en_key_ext_region.GPKEY_RMARGIN, {position_type.graph, position_type.graph, position_type.graph, 0.9, 0.9, 0.}, VERT_JUSTIFY.JUST_TOP, JUSTIFY.RIGHT, en_key_sample_positioning.GPKEY_RIGHT, en_key_stack_direction.GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, keytitle_type.FILENAME_KEYTITLES, false, false, true, {0, DefineConstants.LT_NODRAW, 0, 1.0, 1.0, 0}, "", DefineConstants.NULL, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0});

	/* Description of the color box associated with CB_AXIS */
	public static color_box_struct color_box = new color_box_struct(); // initialized in init_color()
	public static color_box_struct default_color_box = new color_box_struct(DefineConstants.SMCOLOR_BOX_DEFAULT, 'v', 1, DefineConstants.LT_BLACK, DefineConstants.LAYER_FRONT, 0, {position_type.screen, position_type.screen, position_type.screen, 0.90, 0.2, 0.0}, {position_type.screen, position_type.screen, position_type.screen, 0.05, 0.6, 0.0});

	/* The graph box, in terminal coordinates, as calculated by boundary()
	 * or boundary3d(): */
	public static BoundingBox plot_bounds = new BoundingBox();

	/* The bounding box for the entire drawable area  of current terminal */
	public static BoundingBox canvas = new BoundingBox();

	/* The bounding box against which clipping is to be done */
	public static BoundingBox clip_area = plot_bounds;

	/* 'set size', 'set origin' setttings */
	public static float xsize = 1.0F; // scale factor for size
	public static float ysize = 1.0F; // scale factor for size
	public static float zsize = 1.0F; // scale factor for size
	public static float xoffset = 0.0F; // x origin
	public static float yoffset = 0.0F; // y origin
	public static float aspect_ratio = 0.0F; // don't attempt to force it
	public static int aspect_ratio_3D = 0; // 2 will put x and y on same scale, 3 for z also

	/* EAM Augest 2006 - 
	   redefine margin as t_position so that absolute placement is possible */
	/* space between left edge and plot_bounds.xleft in chars (-1: computed) */
	public static position lmargin = new position(position_type.character, position_type.character, position_type.character, -1, -1, -1);
	/* space between bottom and plot_bounds.ybot in chars (-1: computed) */
	public static position bmargin = new position(position_type.character, position_type.character, position_type.character, -1, -1, -1);
	/* space between right egde and plot_bounds.xright in chars (-1: computed) */
	public static position rmargin = new position(position_type.character, position_type.character, position_type.character, -1, -1, -1);
	/* space between top egde and plot_bounds.ytop in chars (-1: computed) */
	public static position tmargin = new position(position_type.character, position_type.character, position_type.character, -1, -1, -1);

	/* File descriptor for output during 'set table' mode */
	public static FILE table_outfile = DefineConstants.NULL;
	public static boolean table_mode = false;

	/* Pointer to the start of the linked list of 'set label' definitions */
	public static text_label first_label = DefineConstants.NULL;

	/* Pointer to first 'set linestyle' definition in linked list */
	public static linestyle_def first_linestyle = DefineConstants.NULL;

	/* Pointer to first 'set style arrow' definition in linked list */
	public static arrowstyle_def first_arrowstyle = DefineConstants.NULL;

	/* set arrow */
	public static arrow_def first_arrow = DefineConstants.NULL;

	///#ifdef EAM_OBJECTS
	/* Pointer to first object instance in linked list */
	public static object first_object = DefineConstants.NULL;
	///#endif

	/* 'set title' status */
	public static text_label title = new text_label(DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false);

	/* 'set timelabel' status */
	public static text_label timelabel = new text_label(DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false);
	public static int timelabel_rotate = false;
	public static int timelabel_bottom = true;

	/* flag for polar mode */
	public static boolean polar = false;

	/* zero threshold, may _not_ be 0! */
	public static double zero = DefineConstants.ZERO;

	/* Status of 'set pointsize' command */
	public static double pointsize = 1.0;

	/* set border */
	public static int draw_border = 31; // The current settings
	public static int user_border = 31; // What the user last set explicitly
	public static int border_layer = 1;
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_BORDER_LP { 0, -2, 0, 1.0, 1.0, 0 }
	public static lp_style_type border_lp = new lp_style_type(0, -2, 0, 1.0, 1.0, 0);
	public static final lp_style_type default_border_lp = new lp_style_type(0, -2, 0, 1.0, 1.0, 0);

	/* set clip */
	public static boolean clip_lines1 = true;
	public static boolean clip_lines2 = false;
	/* FIXME HBB 20000521: clip_points is only used by 2D plots. This may
	 * well constitute a yet unknown bug... */
	public static boolean clip_points = false;

	/* set samples */
	public static int samples_1 = DefineConstants.SAMPLES;
	public static int samples_2 = DefineConstants.SAMPLES;

	/* set angles */
	public static double ang2rad = 1.0; // 1 or pi/180, tracking angles_format

	public static PLOT_STYLE data_style = PLOT_STYLE.POINTSTYLE;
	public static PLOT_STYLE func_style = PLOT_STYLE.LINES;

	public static boolean parametric = false;

	/* If last plot was a 3d one. */
	public static boolean is_3d_plot = false;

	///#ifdef VOLATILE_REFRESH
	/* Flag to signal that the existing data is valid for a quick refresh */
	public static int refresh_ok = 0; // 0 = no;  2 = 2D ok;  3 = 3D ok
	/* FIXME: do_plot should be able to figure this out on its own! */
	public static int refresh_nplots = 0;
	///#endif
	/* Flag to show that volatile input data is present */
	public static boolean volatile_data = false;

	public static fill_style_type default_fillstyle = new fill_style_type(t_fillstyle.FS_EMPTY, 100, 0, {DefineConstants.TC_DEFAULT, 0, 0.0});

	///#ifdef EAM_OBJECTS
	/* Default rectangle style - background fill, black border */
	public static object default_rectangle = new object(DefineConstants.NULL, -1, 0, DefineConstants.OBJ_RECTANGLE, {t_fillstyle.FS_SOLID, 100, 0, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0}}, {1, DefineConstants.LT_BACKGROUND, 0, 0, 1.0, 0.0, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}});
	///#endif

	/* filledcurves style options */
	public static filledcurves_opts filledcurves_opts_data = new filledcurves_opts(0, 0, 0.0, 0.0, 0);
	public static filledcurves_opts filledcurves_opts_func = new filledcurves_opts(0, 0, 0.0, 0.0, 0);

	/* Prefer line styles over plain line types */
	public static boolean prefer_line_styles = false;

	public static histogram_style histogram_opts = new histogram_style(histogram_type.HT_NONE, 2, 1, 0.0, 0.0, DefineConstants.LT_UNDEFINED, DefineConstants.LT_UNDEFINED, 0, DefineConstants.NULL, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false});

	/* WINDOWID to be filled by terminals running on X11 (x11, wxt, qt, ...) */
	public static int current_x11_windowid = 0;


	/* Two routines to emulate move/vector sequence using line drawing routine. */
	public static int move_pos_x;
	public static int move_pos_y;
}