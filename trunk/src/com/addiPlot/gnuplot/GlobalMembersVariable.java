package com.addiPlot.gnuplot;

public class GlobalMembersVariable
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: variable.c,v 1.34.2.1 2010/02/07 23:17:34 sfeam Exp $");
	}

/*
 * char *loadpath_handler (int, char *)
 *
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String loadpath_handler_loadpath;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String loadpath_handler_p;
String last;
String envptr;
String limit;
	///#endif

	/* GNUPLOT - variable.c */

	/*[
	 * Copyright 1999, 2004   Lars Hecking
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/* The Death of Global Variables - part one. */


	/*
	 * $Id: variable.h,v 1.17 2008/03/18 00:16:33 sfeam Exp $
	 */

	/* GNUPLOT - variable.h */

	/*[
	 * Copyright 1999, 2004   Lars Hecking
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/* The death of global variables - part one. */


	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 

	/* Generic defines */

	///#ifdef ACTION_NULL
	///#undef ACTION_NULL
	///#endif

	///#ifdef ACTION_INIT
	///#undef ACTION_INIT
	///#endif

	///#ifdef ACTION_SHOW
	///#undef ACTION_SHOW
	///#endif

	///#ifdef ACTION_SET
	///#undef ACTION_SET
	///#endif

	///#ifdef ACTION_GET
	///#undef ACTION_GET
	///#endif

	///#ifndef ACTION_SAVE
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef ACTION_SAVE
	///#endif

	///#ifdef ACTION_CLEAR
	///#undef ACTION_CLEAR
	///#endif

	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)

	/* Loadpath related */

	public static String loadpath_handler(int action, String path)
	{
		/* loadpath variable
		 * the path elements are '\0' separated (!)
		 * this way, reading out loadpath is very
		 * easy to implement */
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte *loadpath;
		/* index pointer, end of loadpath,
		 * env section of loadpath, current limit, in that order */
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte *p, *last, *envptr, *limit;
		String appdir;

		switch (action)
		{
		case 1 << 5:
		/* Clear loadpath, fall through to init */
		GlobalMembersFit.a((stderr, "Clear loadpath\n"));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(loadpath_handler_loadpath);
		loadpath_handler_loadpath = loadpath_handler_p = last = DefineConstants.NULL;
		/* HBB 20000726: 'limit' has to be initialized to NULL, too! */
		limit = DefineConstants.NULL;
		case 1 << 0:
		/* Init loadpath from environment */
		GlobalMembersFit.a((stderr, "Init loadpath from environment\n"));
		assert loadpath_handler_loadpath.equals(DefineConstants.NULL);
		if (loadpath_handler_loadpath == null)
		{
			byte envlib = getenv("GNUPLOT_LIB");
			if (envlib != 0)
			{
			int len = envlib.length();
			loadpath_handler_loadpath = GlobalMembersUtil.gp_strdup(envlib);
			/* point to end of loadpath */
			last = loadpath_handler_loadpath + len;
			/* convert all PATHSEPs to \0 */
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = loadpath_handler_loadpath;
				while ((s = tangible.StringFunctions.strChr(s, DefineConstants.PATHSEP)) != DefineConstants.NULL)
					*s++= DefineConstants.NUL;
			} while (0);
			} // else: NULL = empty
		} // else: already initialised; int_warn (?)
		/* point to env portion of loadpath */
		envptr = loadpath_handler_loadpath;
		break;
		case 1 << 2:
		/* set the loadpath */
		GlobalMembersFit.a((stderr, "Set loadpath\n"));
		if (path != null && !path.equals(DefineConstants.NUL))
		{
			/* length of env portion */
			int elen = last - envptr;
			int plen = path.length();
			if (loadpath_handler_loadpath != null && envptr != null)
			{
			/* we are prepending a path name; because
			 * realloc() preserves only the contents up
			 * to the minimum of old and new size, we move
			 * the part to be preserved to the beginning
			 * of the string; use memmove() because strings
			 * may overlap */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in Java:
			memmove(loadpath_handler_loadpath, envptr, elen + 1);
			}
			loadpath_handler_loadpath = GlobalMembersAlloc.gp_realloc(loadpath_handler_loadpath, elen + 1 + plen + 1, "expand loadpath");
			/* now move env part back to the end to make space for
			 * the new path */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in Java:
			memmove(loadpath_handler_loadpath + plen + 1, loadpath_handler_loadpath, elen + 1);
			loadpath_handler_loadpath = path;
			/* separate new path(s) and env path(s) */
			loadpath_handler_loadpath = tangible.StringFunctions.changeCharacter(loadpath_handler_loadpath, plen, DefineConstants.PATHSEP);
			/* adjust pointer to env part and last */
			envptr = loadpath_handler_loadpath.charAt(plen + 1);
			last = envptr + elen;
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = loadpath_handler_loadpath;
				while ((s = tangible.StringFunctions.strChr(s, DefineConstants.PATHSEP)) != DefineConstants.NULL)
					*s++= DefineConstants.NUL;
			} while (0);
		} // else: NULL = empty
		break;
		case 1 << 1:
		/* print the current, full loadpath */
		GlobalMembersFit.a((stderr, "Show loadpath\n"));
		if (loadpath_handler_loadpath != null)
		{
			fputs("\tloadpath is ", stderr);
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = loadpath_handler_loadpath;
				while (s < envptr)
				{
					fprintf(stderr, "\"%s\" ", s);
					s += s.length() + 1;
				}
				fputc('\n',stderr);
			} while (0);
			if (envptr != null)
			{
			/* env part */
			fputs("\tsystem loadpath is ", stderr);
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = envptr;
				while (s < last)
				{
					fprintf(stderr, "\"%s\" ", s);
					s += s.length() + 1;
				}
				fputc('\n',stderr);
			} while (0);
			}
		}
		else
			fputs("\tloadpath is empty\n", stderr);
	///#ifdef X11
		if ((appdir = getenv("XAPPLRESDIR")))
		{
			fprintf(stderr,"\tenvironmental path for X11 application defaults: \"%s\"\n", appdir);
		}
	///#ifdef XAPPLRESDIR
		else
		{
			fprintf(stderr,"\tno XAPPLRESDIR found in the environment,\n");
			fprintf(stderr,"\t    falling back to \"%s\"\n", DefineConstants.XAPPLRESDIR);
		}
	///#endif
	///#endif
		break;
		case 1 << 4:
		/* we don't save the load path taken from the
		 * environment, so don't go beyond envptr when
		 * extracting the path elements
		 */
		limit = envptr;
		case 1 << 3:
		/* subsequent calls to get_loadpath() return all
		 * elements of the loadpath until exhausted
		 */
		GlobalMembersFit.a((stderr, "Get loadpath\n"));
		if (loadpath_handler_loadpath == null)
			return DefineConstants.NULL;
		if (loadpath_handler_p == null)
		{
			/* init section */
			loadpath_handler_p = loadpath_handler_loadpath;
			if (limit == null)
			limit = last;
		}
		else
		{
			/* skip over '\0' */
			loadpath_handler_p += loadpath_handler_p.length() + 1;
		}
		if (loadpath_handler_p.compareTo(limit) >= 0)
			limit = loadpath_handler_p = DefineConstants.NULL;
		return loadpath_handler_p;
		break;
		case DefineConstants.ACTION_NULL:
		/* just return */
		default:
		break;
		}

		/* should always be ignored - points to the
		 * first path in the list */
		return loadpath_handler_loadpath;

	}

/*
 * char *fontpath_handler (int, char *)
 *
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String fontpath_handler_fontpath;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String fontpath_handler_p;
String last;
String envptr;
String limit;

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)

	/* Fontpath related */

	public static String fontpath_handler(int action, String path)
	{
		/* fontpath variable
		 * the path elements are '\0' separated (!)
		 * this way, reading out fontpath is very
		 * easy to implement */
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte *fontpath;
		/* index pointer, end of fontpath,
		 * env section of fontpath, current limit, in that order */
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte *p, *last, *envptr, *limit;

		if (!fontpath_init_done)
		{
		fontpath_init_done = true;
		() GlobalMembersVariable.fontpath_handler(1 << 0, DefineConstants.NULL)();
		}

		switch (action)
		{
		case 1 << 5:
		/* Clear fontpath, fall through to init */
		GlobalMembersFit.a((stderr, "Clear fontpath\n"));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(fontpath_handler_fontpath);
		fontpath_handler_fontpath = fontpath_handler_p = last = DefineConstants.NULL;
		/* HBB 20000726: 'limit' has to be initialized to NULL, too! */
		limit = DefineConstants.NULL;
		case 1 << 0:
		/* Init fontpath from environment */
		GlobalMembersFit.a((stderr, "Init fontpath from environment\n"));
		assert fontpath_handler_fontpath.equals(DefineConstants.NULL);
		if (fontpath_handler_fontpath == null)
		{
			byte envlib = getenv("GNUPLOT_FONTPATH");
			if (envlib != 0)
			{
			/* get paths from environment */
			int len = envlib.length();
			fontpath_handler_fontpath = GlobalMembersUtil.gp_strdup(envlib);
			/* point to end of fontpath */
			last = fontpath_handler_fontpath + len;
			/* convert all PATHSEPs to \0 */
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = fontpath_handler_fontpath;
				while ((s = tangible.StringFunctions.strChr(s, DefineConstants.PATHSEP)) != DefineConstants.NULL)
					*s++= DefineConstants.NUL;
			} while (0);
			}
	///#if defined(HAVE_DIRENT_H) || defined(_Windows)
			else
			{
			/* set hardcoded paths */
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			final path_table * curr_fontpath = fontpath_tbl;

			while (curr_fontpath.dir != null)
			{
				String currdir = DefineConstants.NULL;
				String envbeg = DefineConstants.NULL;
	///#if defined(PIPES)
				String cmdbeg = DefineConstants.NULL;
	///#endif
				boolean subdirs = false;

				currdir = GlobalMembersUtil.gp_strdup(curr_fontpath.dir);

	///#if defined(PIPES)
				while ((envbeg = tangible.StringFunctions.strStr(currdir, "$(")) || (cmdbeg = tangible.StringFunctions.strStr(currdir, "$`")))
	///#else
	//            while ( (envbeg=strstr(currdir, "$("))
	///#endif
				{
				/* Read environment variables */
				if (envbeg != null)
				{
					String tmpdir = DefineConstants.NULL;
					String envend = DefineConstants.NULL;
					String envval = DefineConstants.NULL;
					int envlen;
					envend = tangible.StringFunctions.strChr(envbeg + 2,')');
					envend = tangible.StringFunctions.changeCharacter(envend, 0, '\0');
					envval = getenv(envbeg + 2);
					envend = tangible.StringFunctions.changeCharacter(envend, 0, ')');
					envlen = envval != null ? envval.length() : 0;
					tmpdir = GlobalMembersAlloc.gp_alloc(currdir.length() + envlen + envbeg - envend + 1, "expand fontpath");
					tmpdir = currdir.substring(0, envbeg - currdir);
					if (envval != null)
					tmpdir + (envbeg - currdir) = envval;
					tmpdir + (envbeg - currdir + envlen) = envend + 1;

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(currdir);
					currdir = tmpdir;
				}
	///#if defined(PIPES)
				/* Read environment variables */
				else if (cmdbeg != null)
				{
					String tmpdir = DefineConstants.NULL;
					String envend = DefineConstants.NULL;
					String envval = new String(new char[256]);
					int envlen;
					FILE fcmd;
					envend = tangible.StringFunctions.strChr(cmdbeg + 2,'`');
					envend = tangible.StringFunctions.changeCharacter(envend, 0, '\0');
					fcmd = GlobalMembersAmiga.popen(cmdbeg + 2, "r");
					if (fcmd != null)
					{
					fgets(envval,255,fcmd);
					if (envval.charAt(envval.length() - 1) == '\n')
						envval.charAt(envval.length() - 1) = '\0';
					GlobalMembersAmiga.pclose(fcmd);
					}
					envend = tangible.StringFunctions.changeCharacter(envend, 0, '`');
					envlen = envval.length();
					tmpdir = GlobalMembersAlloc.gp_alloc(currdir.length() + envlen + cmdbeg - envend + 1, "expand fontpath");
					tmpdir = currdir.substring(0, cmdbeg - currdir);
					if (envval != null)
					tmpdir + (cmdbeg - currdir) = envval;
					tmpdir + (cmdbeg - currdir + envlen) = envend + 1;

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(currdir);
					currdir = tmpdir;
				}
	///#endif
				}

				if (currdir.charAt(currdir.length() - 1) == '!')
				{
				/* search subdirectories */
				/* delete ! from directory name */
				currdir = tangible.StringFunctions.changeCharacter(currdir, currdir.length() - 1, '\0');
				subdirs = true;
				}

				if (GlobalMembersUtil.existdir(currdir))
				{
				int plen;
				if (subdirs)
					/* add ! to directory name again */
					currdir = tangible.StringFunctions.changeCharacter(currdir, currdir.length(), '!');
				plen = currdir.length();
				if (fontpath_handler_fontpath != null)
				{
					int elen = fontpath_handler_fontpath.length();
					fontpath_handler_fontpath = GlobalMembersAlloc.gp_realloc(fontpath_handler_fontpath, elen + 1 + plen + 1, "expand fontpath");
					last = fontpath_handler_fontpath + elen;
					last = DefineConstants.PATHSEP;
					++last;
					last = '\0';
				}
				else
				{
					fontpath_handler_fontpath = GlobalMembersAlloc.gp_alloc(plen + 1, "expand fontpath");
					last = fontpath_handler_fontpath;
				}

				last = currdir;
				last += plen;
				}
				curr_fontpath++;
				if (currdir != null)
				{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(currdir);
				currdir = DefineConstants.NULL;
				}
			}
			/* convert all PATHSEPs to \0 */
			if (fontpath_handler_fontpath != null)
				do
				{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
					byte * s = fontpath_handler_fontpath;
					while ((s = tangible.StringFunctions.strChr(s, DefineConstants.PATHSEP)) != DefineConstants.NULL)
						*s++= DefineConstants.NUL;
				} while (0);
			}
	///#endif // HAVE_DIRENT_H

		} // else: already initialised; int_warn (?)
		/* point to env portion of fontpath */
		envptr = fontpath_handler_fontpath;
		break;
		case 1 << 2:
		/* set the fontpath */
		GlobalMembersFit.a((stderr, "Set fontpath\n"));
		if (path != null && !path.equals(DefineConstants.NUL))
		{
			/* length of env portion */
			int elen = last - envptr;
			int plen = path.length();
			if (fontpath_handler_fontpath != null && envptr != null)
			{
			/* we are prepending a path name; because
			 * realloc() preserves only the contents up
			 * to the minimum of old and new size, we move
			 * the part to be preserved to the beginning
			 * of the string; use memmove() because strings
			 * may overlap */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in Java:
			memmove(fontpath_handler_fontpath, envptr, elen + 1);
			}
			fontpath_handler_fontpath = GlobalMembersAlloc.gp_realloc(fontpath_handler_fontpath, elen + 1 + plen + 1, "expand fontpath");
			/* now move env part back to the end to make space for
			 * the new path */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in Java:
			memmove(fontpath_handler_fontpath + plen + 1, fontpath_handler_fontpath, elen + 1);
			fontpath_handler_fontpath = path;
			/* separate new path(s) and env path(s) */
			fontpath_handler_fontpath = tangible.StringFunctions.changeCharacter(fontpath_handler_fontpath, plen, DefineConstants.PATHSEP);
			/* adjust pointer to env part and last */
			envptr = fontpath_handler_fontpath.charAt(plen + 1);
			last = envptr + elen;
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = fontpath_handler_fontpath;
				while ((s = tangible.StringFunctions.strChr(s, DefineConstants.PATHSEP)) != DefineConstants.NULL)
					*s++= DefineConstants.NUL;
			} while (0);
		} // else: NULL = empty
		break;
		case 1 << 1:
		/* print the current, full fontpath */
		GlobalMembersFit.a((stderr, "Show fontpath\n"));
		if (fontpath_handler_fontpath != null)
		{
			fputs("\tfontpath is ", stderr);
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = fontpath_handler_fontpath;
				while (s < envptr)
				{
					fprintf(stderr, "\"%s\" ", s);
					s += s.length() + 1;
				}
				fputc('\n',stderr);
			} while (0);
			if (envptr != null)
			{
			/* env part */
			fputs("\tsystem fontpath is ", stderr);
			do
			{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
				byte * s = envptr;
				while (s < last)
				{
					fprintf(stderr, "\"%s\" ", s);
					s += s.length() + 1;
				}
				fputc('\n',stderr);
			} while (0);
			}
		}
		else
			fputs("\tfontpath is empty\n", stderr);
		break;
		case 1 << 4:
		/* we don't save the font path taken from the
		 * environment, so don't go beyond envptr when
		 * extracting the path elements
		 */
		limit = envptr;
		case 1 << 3:
		/* subsequent calls to get_fontpath() return all
		 * elements of the fontpath until exhausted
		 */
		GlobalMembersFit.a((stderr, "Get fontpath\n"));
		if (fontpath_handler_fontpath == null)
			return DefineConstants.NULL;
		if (fontpath_handler_p == null)
		{
			/* init section */
			fontpath_handler_p = fontpath_handler_fontpath;
			if (limit == null)
			limit = last;
		}
		else
		{
			/* skip over '\0' */
			fontpath_handler_p += fontpath_handler_p.length() + 1;
		}
		if (fontpath_handler_p.compareTo(limit) >= 0)
			limit = fontpath_handler_p = DefineConstants.NULL;
		return fontpath_handler_p;
		case DefineConstants.ACTION_NULL:
		/* just return */
		default:
		break;
		}

		/* should always be ignored - points to the
		 * first path in the list */
		return fontpath_handler_fontpath;

	}

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)

	/* Locale related */

	public static String locale_handler(int action, String newlocale)
	{
		tm tm = new tm();
		int i;

		switch (action)
		{
		case 1 << 5:
		case 1 << 0:
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(GlobalMembersUtil.current_locale);
	///#ifdef HAVE_LOCALE_H
		setlocale(LC_TIME, "");
		GlobalMembersUtil.current_locale = GlobalMembersUtil.gp_strdup(setlocale(LC_TIME,DefineConstants.NULL));
	///#else
	//	current_locale = gp_strdup(INITIAL_LOCALE);
	///#endif
		break;

		case 1 << 2:
	///#ifdef HAVE_LOCALE_H
		if (setlocale(LC_TIME, newlocale))
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersUtil.current_locale);
			GlobalMembersUtil.current_locale = GlobalMembersUtil.gp_strdup(setlocale(LC_TIME,DefineConstants.NULL));
		}
		else
		{
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Locale not available");
		}

		/* we can do a *lot* better than this ; eg use system functions
		 * where available; create values on first use, etc
		 */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memset(tm, 0, sizeof(GlobalMembersMouse.struct tm));
		for (i = 0; i < 7; ++i)
		{
			tm.tm_wday = i; // hope this enough
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersStrftime.strftime(full_day_names[i], sizeof(full_day_names[i]), "%A", tm);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersStrftime.strftime(abbrev_day_names[i], sizeof(abbrev_day_names[i]), "%a", tm);
		}
		for (i = 0; i < 12; ++i)
		{
			tm.tm_mon = i; // hope this enough
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersStrftime.strftime(full_month_names[i], sizeof(full_month_names[i]), "%B", tm);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersStrftime.strftime(abbrev_month_names[i], sizeof(abbrev_month_names[i]), "%b", tm);
		}
	///#else
	//	current_locale = gp_realloc(current_locale, strlen(newlocale) + 1, "locale");
	//	strcpy(current_locale, newlocale);
	///#endif // HAVE_LOCALE_H
		break;

		case 1 << 1:
	///#ifdef HAVE_LOCALE_H
		fprintf(stderr, "\tgnuplot LC_CTYPE   %s\n", setlocale(LC_CTYPE,DefineConstants.NULL));
		fprintf(stderr, "\tgnuplot encoding   %s\n", GlobalMembersTerm.encoding_names[GlobalMembersGplt_x11.encoding.getValue()]);
		fprintf(stderr, "\tgnuplot LC_TIME    %s\n", setlocale(LC_TIME,DefineConstants.NULL));
		fprintf(stderr, "\tgnuplot LC_NUMERIC %s\n", GlobalMembersUtil.numeric_locale != null ? GlobalMembersUtil.numeric_locale : "C");
	///#else
	//	fprintf(stderr, "\tlocale is \"%s\"\n", current_locale);
	///#endif
		break;

		case 1 << 3:
		default:
		break;
		}

		return GlobalMembersUtil.current_locale;
	}

	///#define INITIAL_LOCALE ("C")

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)

	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte full_month_names[12][32];
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte abbrev_month_names[12][8];
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte full_day_names[7][32];
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern sbyte abbrev_day_names[7][8];

	/* Yet, no special font paths for these operating systems:
	 * MSDOS, AMIGA, NeXT, ultrix, VMS, _IBMR2, alliant
	 *
	 * Environmental variables are written as $(name).
	 * Commands are written as $`command`.
	 */

	///#if defined(OS2) && !defined(FONTPATHSET)
	///#define FONTPATHSET
	//static const struct path_table fontpath_tbl[] =
	//{
	//    { "$(BOOTDIR)/PSFONTS" },
	// /* X11 */
	//    { "$(X11ROOT)/X11R6/lib/X11/fonts/Type1" },
	//    { NULL }
	//};
	///#endif

	///#if defined(_Windows) && !defined(FONTPATHSET)
	///#define FONTPATHSET
	//static const struct path_table fontpath_tbl[] =
	//{
	//    { "$(windir)\\fonts" },
	// /* Ghostscript */
	//    { "c:\\gs\\fonts" },
	// /* X11 */
	//    { "$(CYGWIN_ROOT)\\usr\\X11R6\\lib\\X11\\fonts\\Type1" },
	///#ifdef HAVE_KPSEXPAND
	// /* fpTeX */
	//    { "$`kpsewhich -expand-path=$HOMETEXMF`\\fonts\\type1!" },
	//    { "$`kpsewhich -expand-path=$TEXMFLOCAL`\\fonts\\type1!" },
	//    { "$`kpsewhich -expand-path=$TEXMFMAIN`\\fonts\\type1!" },
	//    { "$`kpsewhich -expand-path=$TEXMFDIST`\\fonts\\type1!" },
	///#endif
	//    { NULL }
	//};
	///#endif

	///#if defined(_Macintosh) && !defined(FONTPATHSET)
	///#define FONTPATHSET
	//static const struct path_table fontpath_tbl[] =
	//{
	//    { "/System/Library/Fonts!" },
	//    { "/Library/Fonts!" },
	//    { "$(HOME)/Library/Fonts!" },
	//    { NULL }
	//};
	///#endif

	///#if defined(VMS) && !defined(FONTPATHSET)
	///#define FONTPATHSET
	//static const struct path_table fontpath_tbl[] =
	//{
	//    { "SYS$COMMON:[SYSFONT]!" },
	//    { NULL }
	//};
	///#endif

	/* Fallback: Should work for unix */
	///#ifndef FONTPATHSET
	///#ifdef HAVE_KPSEXPAND
	///#endif
	public static final struct[] path_table fontpath_tbl = {{"$`kpsexpand '$HOMETEXMF'`/fonts/type1!"}, {"$`kpsexpand '$TEXMFLOCAL'`/fonts/type1!"}, {"$`kpsexpand '$TEXMFMAIN'`/fonts/type1!"}, {"$`kpsexpand '$TEXMFDIST'`/fonts/type1!"}, {"/usr/X11R6/lib/X11/fonts/Type1"}, {"/usr/X11R6/lib/X11/fonts/truetype"}, {"/usr/lib/X11/fonts!"}, {"/usr/share/ghostscript/fonts"}, {"/usr/local/share/ghostscript/fonts"}, {DefineConstants.NULL}};
		/* teTeX or TeXLive */
		/* Linux paths */
		/* HP-UX */
		/* Ghostscript */
	///#endif

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef FONTPATHSET

	public static boolean fontpath_init_done = false;

	/* not set or shown directly, but controlled by 'set locale'
	 * defined in national.h
	 */

	public static byte[][] full_month_names = {{DefineConstants.FMON01, DefineConstants.FMON02, DefineConstants.FMON03, DefineConstants.FMON04, DefineConstants.FMON05, DefineConstants.FMON06, DefineConstants.FMON07, DefineConstants.FMON08, DefineConstants.FMON09, DefineConstants.FMON10, DefineConstants.FMON11, DefineConstants.FMON12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
	public static byte[][] abbrev_month_names = {{DefineConstants.AMON01, DefineConstants.AMON02, DefineConstants.AMON03, DefineConstants.AMON04, DefineConstants.AMON05, DefineConstants.AMON06, DefineConstants.AMON07, DefineConstants.AMON08}, {DefineConstants.AMON09, DefineConstants.AMON10, DefineConstants.AMON11, DefineConstants.AMON12, 0, 0, 0, 0}};

	public static byte[][] full_day_names = {{DefineConstants.FDAY0, DefineConstants.FDAY1, DefineConstants.FDAY2, DefineConstants.FDAY3, DefineConstants.FDAY4, DefineConstants.FDAY5, DefineConstants.FDAY6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
	public static byte[][] abbrev_day_names = {{DefineConstants.ADAY0, DefineConstants.ADAY1, DefineConstants.ADAY2, DefineConstants.ADAY3, DefineConstants.ADAY4, DefineConstants.ADAY5, DefineConstants.ADAY6, 0}};
}