package com.addiPlot.gnuplot;

public class GlobalMembersSet
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	//public static String RCSid()
	//{
	//	return GlobalMembersAlloc.RCSid("$Id: set.c,v 1.299.2.7 2010/02/13 06:35:21 sfeam Exp $");
	//}
	///#endif

	/* GNUPLOT - set.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/*
	 * 19 September 1992  Lawrence Crowl  (crowl@cs.orst.edu)
	 * Added user-specified bases for log scaling.
	 */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	///#define PROGRAM "G N U P L O T"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_NUM_OR_TIME(fp, x, axis) do{ if (axis_array[axis].is_timedata) { char s[80]; putc('"', fp); gstrftime(s,80,axis_array[axis].timefmt,(double)(x)); fputs(conv_text(s), fp); putc('"', fp); } else { fprintf(fp,"%#g",x); } } while(0)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#define DEFAULT_CONTOUR_LEVELS 5
	///#define DEFAULT_NUM_APPROX_PTS 5
	///#define DEFAULT_CONTOUR_ORDER 4
	///#define MAX_BSPLINE_ORDER 10
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define contour_levels_list ((double *)dyn_contour_levels_list.v)
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#define DF_EOF (-1)
	///#define DF_UNDEFINED (-2)
	///#define DF_FIRST_BLANK (-3)
	///#define DF_SECOND_BLANK (-4)
	///#define DF_MISSING (-5)
	///#define DF_FOUND_KEY_TITLE (-6)
	///#define DF_KEY_TITLE_MISSING (-7)
	///#define DF_STRINGDATA (-8)
	///#ifndef MAXINT // should there be one already defined ?
	///#ifdef INT_MAX // in limits.h ?
	///#define MAXINT INT_MAX
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define MAXINT ((~0)>>1)
	///#endif
	///#endif
	///#define MAXDATACOLS 7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DF_DEFAULT_TYPE DF_FLOAT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SIGNED_TEST(val) ((val)==sizeof(long) ? DF_LONG : ((val)==sizeof(long long) ? DF_LONGLONG : ((val)==sizeof(int) ? DF_INT : ((val)==sizeof(short) ? DF_SHORT : ((val)==sizeof(char) ? DF_CHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define UNSIGNED_TEST(val) ((val)==sizeof(unsigned long) ? DF_ULONG : ((val)==sizeof(unsigned long long) ? DF_ULONGLONG : ((val)==sizeof(unsigned int) ? DF_UINT : ((val)==sizeof(unsigned short) ? DF_USHORT : ((val)==sizeof(unsigned char) ? DF_UCHAR : DF_BAD_TYPE)))))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLOAT_TEST(val) ((val)==sizeof(float) ? DF_FLOAT : ((val)==sizeof(double) ? DF_DOUBLE : DF_BAD_TYPE))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define df_set_skip_after(col,bytes) df_set_skip_before(col+1,bytes)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STANDARD stderr
	///#define BACKUP_SUFFIX ".old"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex(a) {sprintf (fitbuf+9, (a)); error_ex ();}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex2(a,b) {sprintf (fitbuf+9, (a),(b)); error_ex ();}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Eex3(a,b,c) {sprintf (fitbuf+9, (a),(b),(c)); error_ex ();}
	///#ifdef GP_FIT_ERRVARS
	///#endif // GP_FIT_ERRVARS 
	///#ifdef GNUPLOT_HISTORY
	///#endif
	///#ifdef HAVE_LIBREADLINE
	///#endif
	///#if defined(HAVE_LIBEDITLINE)
	///#include <editline/readline.h>
	///#endif
	///#if defined(READLINE) && !defined(HAVE_LIBREADLINE) && !defined(HAVE_LIBEDITLINE)
	///#elif defined(HAVE_LIBREADLINE) || defined(HAVE_LIBEDITLINE)
	///#endif // READLINE && !HAVE_LIBREADLINE 
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#ifdef HIDDEN3D_VAR_PTSIZE // Needed for variable pointsize, but takes space
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLAG_VERTEX_AS_UNDEFINED(v) do { (v).z = -2.0; } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VERTEX_IS_UNDEFINED(v) ((v).z == -2.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define V_EQUAL(a,b) ( GE(0.0, fabs((a)->x - (b)->x) + fabs((a)->y - (b)->y) + fabs((a)->z - (b)->z)) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOORD(v,xvar,yvar) { xvar = ((int)((v)->x * xscaler)) + xmiddle; yvar = ((int)((v)->y * yscaler)) + ymiddle; }
	///#ifndef LITE
	///#endif
	/* #include "parse.h" */
	///#ifdef USE_MOUSE
	///#ifdef _MOUSE_C
	///#endif // _MOUSE_C 
	///#if 0
	///#endif
	///#if defined(_MOUSE_C)
	///#else
	///#endif
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef LINUXVGA
	///#endif // LINUXVGA 
	///#ifdef OS2
	///#endif
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifndef TERM_HELP
	///#define PM3D_AT_BASE 'b'
	///#define PM3D_AT_TOP 't'
	///#define PM3D_AT_SURFACE 's'
	///#define PM3D_FLUSH_BEGIN 'b'
	///#define PM3D_FLUSH_END 'r'
	///#define PM3D_FLUSH_CENTER 'c'
	///#define PM3D_SCANS_AUTOMATIC 'a'
	///#define PM3D_SCANS_FORWARD 'f'
	///#define PM3D_SCANS_BACKWARD 'b'
	///#define PM3D_DEPTH 'd'
	///#define PM3D_CLIP_1IN '1'
	///#define PM3D_CLIP_4IN '4'
	///#endif // TERM_HELP 

	public static palette_color_mode pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_NONE;

	/* process 'set angles' command */

	public static void set_angles()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* assuming same as defaults */
			GlobalMembersGadgets.ang2rad = 1;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "r$adians") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersGadgets.ang2rad = 1;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "d$egrees") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersGadgets.ang2rad = DefineConstants.M_PI / 180.0;
		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'radians' or 'degrees'");

		if (GlobalMembersGadgets.polar && ((int)GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_autoscale) != 0)
		{
			/* set trange if in polar mode and no explicit range */
			GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_min = 0;
			GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_max = 2 * DefineConstants.M_PI / GlobalMembersGadgets.ang2rad;
		}
	}

	/* process a 'set arrow' command */
	/* set arrow {tag} {from x,y} {to x,y} {{no}head} ... */
	/* allow any order of options - pm 25.11.2001 */
	public static void set_arrow()
	{
		arrow_def this_arrow = DefineConstants.NULL;
		arrow_def new_arrow = DefineConstants.NULL;
		arrow_def prev_arrow = DefineConstants.NULL;
		boolean duplication = false;
		boolean set_start = false;
		boolean set_end = false;
		int save_token;
		int tag;

		GlobalMembersCommand.c_token++;

		/* get tag */
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "back$head") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "from") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "size") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "rto") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "filled") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "empty") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "as") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "arrowstyle") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "head$s") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "nohead") != 0)
		{
			tag = GlobalMembersSet.assign_arrow_tag();

		}
		else
			tag = GlobalMembersParse.int_expression();

		if (tag <= 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be > 0");

		/* OK! add arrow */
		if (GlobalMembersGadgets.first_arrow != null) // skip to last arrow
		{
			for (this_arrow = GlobalMembersGadgets.first_arrow; this_arrow != null; prev_arrow = this_arrow, this_arrow = this_arrow.next)
				/* is this the arrow we want? */
				if (tag <= this_arrow.tag)
					break;
		}
		if (this_arrow == null || tag != this_arrow.tag)
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			new_arrow = GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct arrow_def), "arrow");
			if (prev_arrow == null)
				GlobalMembersGadgets.first_arrow = new_arrow;
			else
				prev_arrow.next = new_arrow;
			new_arrow.tag = tag;
			new_arrow.next = this_arrow;
			this_arrow = new_arrow;

			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_arrow->start = default_position;
			this_arrow.start.copyFrom(default_position);
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_arrow->end = default_position;
			this_arrow.end.copyFrom(default_position);

			GlobalMembersGadgets.default_arrow_style((new_arrow.arrow_properties));
		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{

			/* get start position */
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "from") != 0)
			{
				if (set_start)
				{
					duplication = true;
					break;
				}
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "start coordinates expected");
				/* get coordinates */
				GlobalMembersAxis.get_position(this_arrow.start);
				set_start = true;
				continue;
			}

			/* get end or relative end position */
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "rto") != 0)
			{
				if (set_end)
				{
					duplication = true;
					break;
				}
				this_arrow.relative = (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "rto")) ? true : false;
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "end coordinates expected");
				/* get coordinates */
				GlobalMembersAxis.get_position(this_arrow.end);
				set_end = true;
				continue;
			}

			/* Allow interspersed style commands */
			save_token = GlobalMembersCommand.c_token;
			GlobalMembersMisc.arrow_parse(this_arrow.arrow_properties, true);
			if (save_token != GlobalMembersCommand.c_token)
				continue;

			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "wrong argument in set arrow");

		} // while (!END_OF_COMMAND)

		if (duplication)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "duplicate or contradictory arguments");

	}

	/* assign a new arrow tag
	 * arrows are kept sorted by tag number, so this is easy
	 * returns the lowest unassigned tag number
	 */
	public static int assign_arrow_tag()
	{
		arrow_def this_arrow;
		int last = 0; // previous tag value

		for (this_arrow = GlobalMembersGadgets.first_arrow; this_arrow != null; this_arrow = this_arrow.next)
			if (this_arrow.tag == last + 1)
				last++;
			else
				break;

		return (last + 1);
	}

	/* process 'set autoscale' command */
	public static void set_autoscale()
	{
		String min_string = new String(new char[20]);
		String max_string = new String(new char[20]);

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			do
			{
				int tmp;
				for (tmp = 0; tmp < DefineConstants.AXIS_ARRAY_SIZE; tmp++)
					GlobalMembersAxis.axis_array[tmp].field = (e_autoscale.AUTOSCALE_BOTH);
			} while (0);
			return;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "xy") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "yx") != 0)
		{
			GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].set_autoscale = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].set_autoscale = e_autoscale.AUTOSCALE_BOTH;
			GlobalMembersCommand.c_token++;
			return;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "fix") != 0)
		{
			int a = 0;
			while (a < DefineConstants.AXIS_ARRAY_SIZE)
			{
				GlobalMembersAxis.axis_array[a].set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				a++;
			}
			GlobalMembersCommand.c_token++;
			return;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ke$epfix") != 0)
		{
			int a = 0;
			while (a < DefineConstants.AXIS_ARRAY_SIZE)
				GlobalMembersAxis.axis_array[a++].set_autoscale |= e_autoscale.AUTOSCALE_BOTH;
			GlobalMembersCommand.c_token++;
			return;
		}

		/* save on replication with a macro */
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define PROCESS_AUTO_LETTER(axis) do { axis *this = axis_array + axis; if (equals(c_token, axis_defaults[axis].name)) { this->set_autoscale = AUTOSCALE_BOTH; ++c_token; return; } sprintf(min_string, "%smi$n", axis_defaults[axis].name); if (almost_equals(c_token, min_string)) { this->set_autoscale |= AUTOSCALE_MIN; ++c_token; return; } sprintf(max_string, "%sma$x", axis_defaults[axis].name); if (almost_equals(c_token, max_string)) { this->set_autoscale |= AUTOSCALE_MAX; ++c_token; return; } sprintf(min_string, "%sfix", axis_defaults[axis].name); if (equals(c_token, min_string)) { this->set_autoscale |= AUTOSCALE_FIXMIN | AUTOSCALE_FIXMAX; ++c_token; return; } sprintf(min_string, "%sfixmi$n", axis_defaults[axis].name); if (almost_equals(c_token, min_string)) { this->set_autoscale |= AUTOSCALE_FIXMIN; ++c_token; return; } sprintf(max_string, "%sfixma$x", axis_defaults[axis].name); if (almost_equals(c_token, max_string)) { this->set_autoscale |= AUTOSCALE_FIXMAX; ++c_token; return; } } while(0)

		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.R_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.R_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.T_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.T_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.U_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.U_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.V_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.V_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.FIRST_X_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.FIRST_Y_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.FIRST_Z_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.FIRST_Z_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.SECOND_X_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_X_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.SECOND_Y_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.SECOND_Y_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		do
		{
			axis this_Renamed = GlobalMembersAxis.axis_array + AXIS_INDEX.COLOR_AXIS;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name) != 0)
			{
				this_Renamed.set_autoscale = e_autoscale.AUTOSCALE_BOTH;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%smi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_MAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfix", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN | e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(min_string, "%sfixmi$n", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, min_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMIN;
				++GlobalMembersCommand.c_token;
				return;
			}
			String.format(max_string, "%sfixma$x", GlobalMembersAxis.axis_defaults[AXIS_INDEX.COLOR_AXIS.getValue()].name);
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, max_string) != 0)
			{
				this_Renamed.set_autoscale |= e_autoscale.AUTOSCALE_FIXMAX;
				++GlobalMembersCommand.c_token;
				return;
			}
		} while (0);
		/* came here only if nothing found: */
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Invalid range");
	}

	/* process 'set bars' command */
	public static void set_bars()
	{

		int save_token = ++GlobalMembersCommand.c_token;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "s$mall") != 0)
			{
				GlobalMembersGraphics.bar_size = 0.0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "l$arge") != 0)
			{
				GlobalMembersGraphics.bar_size = 1.0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "full$width") != 0)
			{
				GlobalMembersGraphics.bar_size = -1.0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
				GlobalMembersGraphics.bar_layer = DefineConstants.LAYER_FRONT;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
				GlobalMembersGraphics.bar_layer = DefineConstants.LAYER_BACK;
				++GlobalMembersCommand.c_token;
			}
			else
			{
				GlobalMembersGraphics.bar_size = GlobalMembersParse.real_expression();
			}
		}

		if (save_token == GlobalMembersCommand.c_token)
			GlobalMembersGraphics.bar_size = 1.0;

	}

	/* process 'set border' command */
	public static void set_border()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersGadgets.draw_border = 31;
			GlobalMembersGadgets.border_layer = 1;
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: border_lp = default_border_lp;
			GlobalMembersGadgets.border_lp.copyFrom(GlobalMembersGadgets.default_border_lp);
		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
				GlobalMembersGadgets.border_layer = 1;
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
				GlobalMembersGadgets.border_layer = 0;
				GlobalMembersCommand.c_token++;
			}
			else
			{
				int save_token = GlobalMembersCommand.c_token;
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: lp_parse(&border_lp, true, false);
				GlobalMembersMisc.lp_parse(new lp_style_type(GlobalMembersGadgets.border_lp), true, false);
				if (save_token != GlobalMembersCommand.c_token)
					continue;
				GlobalMembersGadgets.draw_border = GlobalMembersParse.int_expression();
			}
		}

		/* This is the only place the user can change the border	*/
		/* so remember what he set.  If draw_border is later changed*/
		/* internally, we can still recover the user's preference.	*/
		GlobalMembersGadgets.user_border = GlobalMembersGadgets.draw_border;
	}

	/* process 'set boxwidth' command */
	public static void set_boxwidth()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersPlot2d.boxwidth = -1.0;
			GlobalMembersPlot2d.boxwidth_is_absolute = true;
		}
		else
		{
			GlobalMembersPlot2d.boxwidth = GlobalMembersParse.real_expression();
		}
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			return;
		else
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "a$bsolute") != 0)
				GlobalMembersPlot2d.boxwidth_is_absolute = true;
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "r$elative") != 0)
				GlobalMembersPlot2d.boxwidth_is_absolute = false;
			else
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'absolute' or 'relative' ");
		}
		GlobalMembersCommand.c_token++;
	}

	/* process 'set clabel' command */
	public static void set_clabel()
	{
		String new_format;

		GlobalMembersCommand.c_token++;
		GlobalMembersGraph3d.label_contours = true;
		if ((new_format = GlobalMembersUtil.try_to_get_string()))
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			GlobalMembersContour.contour_format = new_format.substring(0, sizeof(GlobalMembersContour.contour_format));
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(new_format);
		}
	}

	/* process 'set clip' command */
	public static void set_clip()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			/* assuming same as points */
			GlobalMembersGadgets.clip_points = true;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "p$oints") != 0)
			GlobalMembersGadgets.clip_points = true;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "o$ne") != 0)
			GlobalMembersGadgets.clip_lines1 = true;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "t$wo") != 0)
			GlobalMembersGadgets.clip_lines2 = true;
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'points', 'one', or 'two'");
		GlobalMembersCommand.c_token++;
	}

	/* process 'set cntrparam' command */
	public static void set_cntrparam()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* assuming same as defaults */
			GlobalMembersContour.contour_pts = DefineConstants.DEFAULT_NUM_APPROX_PTS;
			GlobalMembersContour.contour_kind = en_contour_kind.CONTOUR_KIND_LINEAR;
			GlobalMembersContour.contour_order = DefineConstants.DEFAULT_CONTOUR_ORDER;
			GlobalMembersContour.contour_levels = DefineConstants.DEFAULT_CONTOUR_LEVELS;
			GlobalMembersContour.contour_levels_kind = en_contour_levels_kind.LEVELS_AUTO;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "p$oints") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersContour.contour_pts = GlobalMembersParse.int_expression();
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "li$near") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersContour.contour_kind = en_contour_kind.CONTOUR_KIND_LINEAR;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "c$ubicspline") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersContour.contour_kind = en_contour_kind.CONTOUR_KIND_CUBIC_SPL;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "b$spline") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersContour.contour_kind = en_contour_kind.CONTOUR_KIND_BSPLINE;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "le$vels") != 0)
		{
			GlobalMembersCommand.c_token++;

			if (GlobalMembersParse.iteration == 0)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: free_dynarray(&dyn_contour_levels_list);
				GlobalMembersDynarray.free_dynarray(new dynarray(GlobalMembersContour.dyn_contour_levels_list));
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: init_dynarray(&dyn_contour_levels_list, sizeof(double), 5, 10);
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersDynarray.init_dynarray(new dynarray(GlobalMembersContour.dyn_contour_levels_list), sizeof(double), 5, 10);
			}

			/*  RKC: I have modified the next two:
			 *   to use commas to separate list elements as in xtics
			 *   so that incremental lists start,incr[,end]as in "
			 */
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "di$screte") != 0)
			{
				GlobalMembersContour.contour_levels_kind = en_contour_levels_kind.LEVELS_DISCRETE;
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting discrete level");
				else
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: *(double *)nextfrom_dynarray(&dyn_contour_levels_list) = real_expression();
					(Double)GlobalMembersDynarray.nextfrom_dynarray(new dynarray(GlobalMembersContour.dyn_contour_levels_list)) = GlobalMembersParse.real_expression();

				while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting comma to separate discrete levels");
					GlobalMembersCommand.c_token++;
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: *(double *)nextfrom_dynarray(&dyn_contour_levels_list) = real_expression();
					(Double)GlobalMembersDynarray.nextfrom_dynarray(new dynarray(GlobalMembersContour.dyn_contour_levels_list)) = GlobalMembersParse.real_expression();
				}
				GlobalMembersContour.contour_levels = GlobalMembersContour.dyn_contour_levels_list.end;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "in$cremental") != 0)
			{
				int i = 0; // local counter

				GlobalMembersContour.contour_levels_kind = en_contour_levels_kind.LEVELS_INCREMENTAL;
				GlobalMembersCommand.c_token++;
				(double)GlobalMembersContour.dyn_contour_levels_list.v[i++] = GlobalMembersParse.real_expression();
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting comma to separate start,incr levels");
				GlobalMembersCommand.c_token++;
				if (((double)GlobalMembersContour.dyn_contour_levels_list.v[i++] = GlobalMembersParse.real_expression()) == 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "increment cannot be 0");
				if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting comma to separate incr,stop levels");
					GlobalMembersCommand.c_token++;
					/* need to round up, since 10,10,50 is 5 levels, not four,
					 * but 10,10,49 is four
					 */
					GlobalMembersContour.dyn_contour_levels_list.end = i;
					GlobalMembersContour.contour_levels = (int)((GlobalMembersParse.real_expression() - (double)GlobalMembersContour.dyn_contour_levels_list.v[0]) / (double)GlobalMembersContour.dyn_contour_levels_list.v[1] + 1.0);
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "au$to") != 0)
			{
				GlobalMembersContour.contour_levels_kind = en_contour_levels_kind.LEVELS_AUTO;
				GlobalMembersCommand.c_token++;
				if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersContour.contour_levels = GlobalMembersParse.int_expression();
			}
			else
			{
				if (GlobalMembersContour.contour_levels_kind == en_contour_levels_kind.LEVELS_DISCRETE)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Levels type is discrete, ignoring new number of contour levels");
				GlobalMembersContour.contour_levels = GlobalMembersParse.int_expression();
			}
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "o$rder") != 0)
		{
			int order;
			GlobalMembersCommand.c_token++;
			order = GlobalMembersParse.int_expression();
			if (order < 2 || order > DefineConstants.MAX_BSPLINE_ORDER)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "bspline order must be in [2..10] range.");
			GlobalMembersContour.contour_order = order;
		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'linear', 'cubicspline', 'bspline', 'points', 'levels' or 'order'");
	}

	/* process 'set contour' command */
	public static void set_contour()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			/* assuming same as points */
			GlobalMembersGraph3d.draw_contour = en_contour_placement.CONTOUR_BASE;
		else
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ba$se") != 0)
				GlobalMembersGraph3d.draw_contour = en_contour_placement.CONTOUR_BASE;
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "s$urface") != 0)
				GlobalMembersGraph3d.draw_contour = en_contour_placement.CONTOUR_SRF;
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bo$th") != 0)
				GlobalMembersGraph3d.draw_contour = en_contour_placement.CONTOUR_BOTH;
			else
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'base', 'surface', or 'both'");
			GlobalMembersCommand.c_token++;
		}
	}

	/* process 'set dgrid3d' command */
	public static void set_dgrid3d()
	{
		int token_cnt = 0; // Number of comma-separated values read in

		int gridx = GlobalMembersPlot3d.dgrid3d_row_fineness;
		int gridy = GlobalMembersPlot3d.dgrid3d_col_fineness;
		int normval = GlobalMembersPlot3d.dgrid3d_norm_value;
		double scalex = GlobalMembersPlot3d.dgrid3d_x_scale;
		double scaley = GlobalMembersPlot3d.dgrid3d_y_scale;

		/* dgrid3d has two different syntax alternatives: classic and new.
		   If there is a "mode" keyword, the syntax is new, otherwise it is classic.*/
		GlobalMembersPlot3d.dgrid3d_mode = en_dgrid3d_mode.DGRID3D_DEFAULT.getValue();

		GlobalMembersCommand.c_token++;
		while (!(GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0))
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: int tmp_mode = lookup_table(&dgrid3d_mode_tbl[0],c_token);
			int tmp_mode = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.dgrid3d_mode_tbl[0]), GlobalMembersCommand.c_token);
			if (tmp_mode != en_dgrid3d_mode.DGRID3D_OTHER.getValue())
			{
				GlobalMembersPlot3d.dgrid3d_mode = tmp_mode;
				GlobalMembersCommand.c_token++;
			}

			switch (tmp_mode)
			{
			case DGRID3D_QNORM:
				if (!(GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0))
					normval = GlobalMembersParse.int_expression();
				break;
			case DGRID3D_SPLINES:
				break;
			case DGRID3D_GAUSS:
			case DGRID3D_CAUCHY:
			case DGRID3D_EXP:
			case DGRID3D_BOX:
			case DGRID3D_HANN:
				if (!(GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0))
				{
					scalex = GlobalMembersParse.real_expression();
					scaley = scalex;
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
					{
						GlobalMembersCommand.c_token++;
						scaley = GlobalMembersParse.real_expression();
					}
				}
				break;

			default: // {rows}{,cols{,norm}}}

				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
				{
					GlobalMembersCommand.c_token++;
					token_cnt++;
				}
				else if (token_cnt == 0)
				{
					gridx = GlobalMembersParse.int_expression();
					gridy = gridx; // gridy defaults to gridx, unless overridden below
				}
				else if (token_cnt == 1)
				{
					gridy = GlobalMembersParse.int_expression();
				}
				else if (token_cnt == 2)
				{
					normval = GlobalMembersParse.int_expression();
				}
				else
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognize keyword or unexpected value");
				break;
			}

		}

		/* we could warn here about floating point values being truncated... */
		if (gridx < 2 || gridx > 1000 || gridy < 2 || gridy > 1000)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Number of grid points must be in [2:1000] - not changed!");

		/* no mode token found: classic format */
		if (GlobalMembersPlot3d.dgrid3d_mode == en_dgrid3d_mode.DGRID3D_DEFAULT.getValue())
			GlobalMembersPlot3d.dgrid3d_mode = en_dgrid3d_mode.DGRID3D_QNORM.getValue();

		if (scalex < 0.0 || scaley < 0.0)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Scale factors must be greater than zero - not changed!");

		GlobalMembersPlot3d.dgrid3d_row_fineness = gridx;
		GlobalMembersPlot3d.dgrid3d_col_fineness = gridy;
		GlobalMembersPlot3d.dgrid3d_norm_value = normval;
		GlobalMembersPlot3d.dgrid3d_x_scale = scalex;
		GlobalMembersPlot3d.dgrid3d_y_scale = scaley;
		GlobalMembersPlot3d.dgrid3d = true;
	}

	/* process 'set decimalsign' command */
	public static void set_decimalsign()
	{
		GlobalMembersCommand.c_token++;

		/* Clear current setting */
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(GlobalMembersUtil.decimalsign);
		GlobalMembersUtil.decimalsign = DefineConstants.NULL;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			() do {if (GlobalMembersUtil.numeric_locale != null && strcmp(GlobalMembersUtil.numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)();
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersUtil.numeric_locale);
			GlobalMembersUtil.numeric_locale = DefineConstants.NULL;
			///#ifdef HAVE_LOCALE_H
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "locale") != 0)
		{
			String newlocale = DefineConstants.NULL;
			GlobalMembersCommand.c_token++;
			newlocale = GlobalMembersUtil.try_to_get_string();
			if (newlocale == null)
				newlocale = GlobalMembersUtil.gp_strdup(getenv("LC_ALL"));
			if (newlocale == null)
				newlocale = GlobalMembersUtil.gp_strdup(getenv("LC_NUMERIC"));
			if (newlocale == null)
				newlocale = GlobalMembersUtil.gp_strdup(getenv("LANG"));
			if (!setlocale(LC_NUMERIC, newlocale != null ? newlocale : ""))
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Could not find requested locale");
			GlobalMembersUtil.decimalsign = GlobalMembersUtil.gp_strdup(()(localeconv().decimal_point)());
			fprintf(stderr,"decimal_sign in locale is %s\n", GlobalMembersUtil.decimalsign);
			/* Save this locale for later use, but return to "C" for now */
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersUtil.numeric_locale);
			GlobalMembersUtil.numeric_locale = newlocale;
			setlocale(LC_NUMERIC,"C");
			///#endif
		}
		else if (!(GlobalMembersUtil.decimalsign = GlobalMembersUtil.try_to_get_string()))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting string");
	}

	/* process 'set dummy' command */
	public static void set_dummy()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting dummy variable name");
		else
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
				GlobalMembersUtil.copy_str(GlobalMembersParse.set_dummy_var[0], GlobalMembersCommand.c_token++, DefineConstants.MAX_ID_LEN);
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting second dummy variable name");
				GlobalMembersUtil.copy_str(GlobalMembersParse.set_dummy_var[1], GlobalMembersCommand.c_token++, DefineConstants.MAX_ID_LEN);
			}
		}
	}

	/* process 'set encoding' command */
	public static void set_encoding()
	{
		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersGplt_x11.encoding = set_encoding_id.S_ENC_DEFAULT;
			///#ifdef HAVE_LOCALE_H
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "locale") != 0)
		{
			byte l = setlocale(LC_CTYPE,"");
			if (l != 0 && (tangible.StringFunctions.strStr(l,"utf") || tangible.StringFunctions.strStr(l,"UTF")))
				GlobalMembersGplt_x11.encoding = set_encoding_id.S_ENC_UTF8;
			GlobalMembersCommand.c_token++;
			///#endif
		}
		else
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: int temp = lookup_table(&set_encoding_tbl[0],c_token);
			int temp = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTerm.set_encoding_tbl[0]), GlobalMembersCommand.c_token);

			if (temp == set_encoding_id.S_ENC_INVALID.getValue())
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unrecognized encoding specification; see 'help encoding'.");
			GlobalMembersGplt_x11.encoding = temp;
			GlobalMembersCommand.c_token++;
		}
	}

	/* process 'set fit' command */
	public static void set_fit()
	{
		GlobalMembersCommand.c_token++;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "log$file") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					if (!GlobalMembersFit.fitlogfile.equals(DefineConstants.NULL))
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(GlobalMembersFit.fitlogfile);
					GlobalMembersFit.fitlogfile = DefineConstants.NULL;
				}
				else if (!(GlobalMembersFit.fitlogfile = GlobalMembersUtil.try_to_get_string()))
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting string");
				///#if GP_FIT_ERRVARS
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "err$orvariables") != 0)
			{
				GlobalMembersFit.fit_errorvariables = true;
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noerr$orvariables") != 0)
			{
				GlobalMembersFit.fit_errorvariables = false;
				GlobalMembersCommand.c_token++;
				///#endif // GP_FIT_ERRVARS
			}
			else
			{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unknown --- expected 'logfile' or [no]errorvariables");
			}
		} // while (!end)
	}

	/* process 'set format' command */
	public static void set_format()
	{
		boolean[] set_for_axis = {false, false, false, false, false, false, false, false, false, false, false};
		int axis;

		GlobalMembersCommand.c_token++;
		//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
		//ORIGINAL LINE: if ((axis = lookup_table(axisname_tbl, c_token)) >= 0)
		if ((axis = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersAxis.axisname_tbl), GlobalMembersCommand.c_token)) >= 0)
		{
			set_for_axis[axis] = true;
			GlobalMembersCommand.c_token++;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "xy") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "yx") != 0)
		{
			set_for_axis[AXIS_INDEX.FIRST_X_AXIS.getValue()] = set_for_axis[AXIS_INDEX.FIRST_Y_AXIS.getValue()] = true;
			GlobalMembersCommand.c_token++;
		}
		else
		{
			/* Assume he wants all */
			for (axis = 0; axis < DefineConstants.AXIS_ARRAY_SIZE; axis++)
				set_for_axis[axis] = true;
		}

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (set_for_axis[AXIS_INDEX.FIRST_X_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].format_is_numeric = true;
			};
			if (set_for_axis[AXIS_INDEX.FIRST_Y_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].format_is_numeric = true;
			};
			if (set_for_axis[AXIS_INDEX.FIRST_Z_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].format_is_numeric = true;
			};
			if (set_for_axis[AXIS_INDEX.SECOND_X_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].format_is_numeric = true;
			};
			if (set_for_axis[AXIS_INDEX.SECOND_Y_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].format_is_numeric = true;
			};
			if (set_for_axis[AXIS_INDEX.COLOR_AXIS.getValue()])
			{
				() strcpy(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].formatstring,DefineConstants.DEF_FORMAT);
				GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].format_is_numeric = true;
			};
		}
		else
		{
			byte format = GlobalMembersUtil.try_to_get_string();
			if (format == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting format string");

			//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
			///#define SET_FORMATSTRING(axis) if (set_for_axis[axis]) { strncpy(axis_array[axis].formatstring, format, MAX_ID_LEN); axis_array[axis].format_is_numeric = looks_like_numeric(format); }
			if (set_for_axis[AXIS_INDEX.FIRST_X_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			if (set_for_axis[AXIS_INDEX.FIRST_Y_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			if (set_for_axis[AXIS_INDEX.FIRST_Z_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			if (set_for_axis[AXIS_INDEX.SECOND_X_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			if (set_for_axis[AXIS_INDEX.SECOND_Y_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			if (set_for_axis[AXIS_INDEX.COLOR_AXIS.getValue()])
			{
				GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].formatstring = format.substring(0, DefineConstants.MAX_ID_LEN);
				GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(format);
			};
			//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
			///#undef SET_FORMATSTRING

			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(format);
		}
	}

	/* process 'set grid' command */

	public static void set_grid()
	{
		boolean explicit_change = false;
		GlobalMembersCommand.c_token++;
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define GRID_MATCH(axis, string) if (almost_equals(c_token, string+2)) { if (string[2] == 'm') axis_array[axis].gridminor = TRUE; else axis_array[axis].gridmajor = TRUE; explicit_change = TRUE; ++c_token; } else if (almost_equals(c_token, string)) { if (string[2] == 'm') axis_array[axis].gridminor = FALSE; else axis_array[axis].gridmajor = FALSE; explicit_change = TRUE; ++c_token; }
		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nox$tics" + 2) != 0)
			{
				if ("nox$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nox$tics") != 0)
			{
				if ("nox$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noy$tics" + 2) != 0)
			{
				if ("noy$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noy$tics") != 0)
			{
				if ("noy$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noz$tics" + 2) != 0)
			{
				if ("noz$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noz$tics") != 0)
			{
				if ("noz$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nox2$tics" + 2) != 0)
			{
				if ("nox2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nox2$tics") != 0)
			{
				if ("nox2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noy2$tics" + 2) != 0)
			{
				if ("noy2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noy2$tics") != 0)
			{
				if ("noy2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomx$tics" + 2) != 0)
			{
				if ("nomx$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomx$tics") != 0)
			{
				if ("nomx$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomy$tics" + 2) != 0)
			{
				if ("nomy$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomy$tics") != 0)
			{
				if ("nomy$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomz$tics" + 2) != 0)
			{
				if ("nomz$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomz$tics") != 0)
			{
				if ("nomz$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomx2$tics" + 2) != 0)
			{
				if ("nomx2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomx2$tics") != 0)
			{
				if ("nomx2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomy2$tics" + 2) != 0)
			{
				if ("nomy2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomy2$tics") != 0)
			{
				if ("nomy2$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nocb$tics" + 2) != 0)
			{
				if ("nocb$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nocb$tics") != 0)
			{
				if ("nocb$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomcb$tics" + 2) != 0)
			{
				if ("nomcb$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridminor = true;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridmajor = true;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomcb$tics") != 0)
			{
				if ("nomcb$tics"[2] == 'm')
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridminor = false;
				else
					GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].gridmajor = false;
				explicit_change = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "po$lar") != 0)
			{
				if (!GlobalMembersAxis.some_grid_selected())
				{
					/* grid_selection = GRID_X; */
					GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = true;
				}
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					GlobalMembersAxis.polar_grid_angle = 30 * DefineConstants.M_PI / 180.0;
				}
				else
				{
					/* get radial interval */
					GlobalMembersAxis.polar_grid_angle = GlobalMembersGadgets.ang2rad * GlobalMembersParse.real_expression();
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nopo$lar") != 0)
			{
				GlobalMembersAxis.polar_grid_angle = 0; // not polar grid
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
				GlobalMembersAxis.grid_layer = 0;
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
				GlobalMembersAxis.grid_layer = 1;
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "layerd$efault") != 0)
			{
				GlobalMembersAxis.grid_layer = -1;
				GlobalMembersCommand.c_token++;
			}
			else
				break; // might be a linetype
		}

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			int old_token = GlobalMembersCommand.c_token;

			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: lp_parse(&grid_lp, true, false);
			GlobalMembersMisc.lp_parse(new lp_style_type(GlobalMembersAxis.grid_lp), true, false);
			if (GlobalMembersCommand.c_token == old_token) // nothing parseable found...
			{
				GlobalMembersAxis.grid_lp.l_type = GlobalMembersParse.int_expression() - 1;
			}

			/* probably just  set grid <linetype> */

			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				memcpy(GlobalMembersAxis.mgrid_lp,GlobalMembersAxis.grid_lp,sizeof(GlobalMembersMouse.struct lp_style_type));
			}
			else
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
					GlobalMembersCommand.c_token++;
				old_token = GlobalMembersCommand.c_token;
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: lp_parse(&mgrid_lp, true, false);
				GlobalMembersMisc.lp_parse(new lp_style_type(GlobalMembersAxis.mgrid_lp), true, false);
				if (GlobalMembersCommand.c_token == old_token)
				{
					GlobalMembersAxis.mgrid_lp.l_type = GlobalMembersParse.int_expression() - 1;
				}
			}
		}

		if (!explicit_change && !GlobalMembersAxis.some_grid_selected())
		{
			/* no axis specified, thus select default grid */
			GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].gridmajor = true;
			GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].gridmajor = true;
		}
	}

	/* process 'set hidden3d' command */
	public static void set_hidden3d()
	{
		GlobalMembersCommand.c_token++;
		///#ifdef LITE
		//    printf(" Hidden Line Removal Not Supported in LITE version\n");
		///#else
		/* HBB 970618: new parsing engine for hidden3d options */
		GlobalMembersHidden3d.set_hidden3doptions();
		GlobalMembersGraph3d.hidden3d = true;
		///#endif
	}

	///#ifdef GNUPLOT_HISTORY
	/* process 'set historysize' command */
	///#ifdef GNUPLOT_HISTORY
	public static void set_historysize()
	{
		GlobalMembersCommand.c_token++;

		GlobalMembersHistory.gnuplot_history_size = GlobalMembersParse.int_expression();
		if (GlobalMembersHistory.gnuplot_history_size < 0)
		{
			GlobalMembersHistory.gnuplot_history_size = 0;
		}
	}
	///#endif


	/* process 'set isosamples' command */
	///#endif
	public static void set_isosamples()
	{
		int tsamp1;
		int tsamp2;

		GlobalMembersCommand.c_token++;
		tsamp1 = Math.abs(GlobalMembersParse.int_expression());
		tsamp2 = tsamp1;
		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "',' expected");
			GlobalMembersCommand.c_token++;
			tsamp2 = Math.abs(GlobalMembersParse.int_expression());
		}
		if (tsamp1 < 2 || tsamp2 < 2)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "sampling rate must be > 1; sampling unchanged");
		else
		{
			curve_points f_p = GlobalMembersPlot2d.first_plot;
			surface_points f_3dp = GlobalMembersPlot3d.first_3dplot;

			GlobalMembersPlot2d.first_plot = DefineConstants.NULL;
			GlobalMembersPlot3d.first_3dplot = DefineConstants.NULL;
			GlobalMembersPlot2d.cp_free(f_p);
			GlobalMembersPlot3d.sp_free(f_3dp);

			GlobalMembersGraph3d.iso_samples_1 = tsamp1;
			GlobalMembersGraph3d.iso_samples_2 = tsamp2;
		}
	}

	/* process 'set key' command */
	public static void set_key()
	{
		boolean vpos_set = false;
		boolean hpos_set = false;
		boolean reg_set = false;
		boolean sdir_set = false;
		String vpos_warn = "Multiple vertical position settings";
		String hpos_warn = "Multiple horizontal position settings";
		String reg_warn = "Multiple location region settings";
		String sdir_warn = "Multiple stack direction settings";
		legend_key key = GlobalMembersGadgets.keyT;

		GlobalMembersCommand.c_token++;
		key.visible = true;

		///#ifdef BACKWARDS_COMPATIBLE
		//    if (END_OF_COMMAND) {
		//	free(key->font);
		//	reset_key();
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"set key default\"");
		//    }
		///#endif

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: switch(lookup_table(&set_key_tbl[0],c_token))
			switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_key_tbl[0]), GlobalMembersCommand.c_token))
			{
			case S_KEY_ON:
				key.visible = true;
				break;
			case S_KEY_OFF:
				key.visible = false;
				break;
			case S_KEY_DEFAULT:
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(key.font);
				GlobalMembersUnset.reset_key();
				break;
			case S_KEY_TOP:
				if (vpos_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, vpos_warn);
				key.vpos = VERT_JUSTIFY.JUST_TOP;
				vpos_set = true;
				break;
			case S_KEY_BOTTOM:
				if (vpos_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, vpos_warn);
				key.vpos = VERT_JUSTIFY.JUST_BOT;
				vpos_set = true;
				break;
			case S_KEY_LEFT:
				if (hpos_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, hpos_warn);
				key.hpos = JUSTIFY.LEFT;
				hpos_set = true;
				break;
			case S_KEY_RIGHT:
				if (hpos_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, hpos_warn);
				key.hpos = JUSTIFY.RIGHT;
				hpos_set = true;
				break;
			case S_KEY_CENTER:
				if (!vpos_set)
					key.vpos = VERT_JUSTIFY.JUST_CENTRE;
				if (!hpos_set)
					key.hpos = JUSTIFY.CENTRE;
				if (vpos_set || hpos_set)
					vpos_set = hpos_set = true;
				break;
			case S_KEY_VERTICAL:
				if (sdir_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, sdir_warn);
				key.stack_dir = en_key_stack_direction.GPKEY_VERTICAL;
				sdir_set = true;
				break;
			case S_KEY_HORIZONTAL:
				if (sdir_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, sdir_warn);
				key.stack_dir = en_key_stack_direction.GPKEY_HORIZONTAL;
				sdir_set = true;
				break;
			case S_KEY_OVER:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				/* Fall through */
			case S_KEY_ABOVE:
				if (!hpos_set)
					key.hpos = JUSTIFY.CENTRE;
				if (!sdir_set)
					key.stack_dir = en_key_stack_direction.GPKEY_HORIZONTAL;
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_TMARGIN;
				reg_set = true;
				break;
			case S_KEY_UNDER:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				/* Fall through */
			case S_KEY_BELOW:
				if (!hpos_set)
					key.hpos = JUSTIFY.CENTRE;
				if (!sdir_set)
					key.stack_dir = en_key_stack_direction.GPKEY_HORIZONTAL;
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_BMARGIN;
				reg_set = true;
				break;
			case S_KEY_INSIDE:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_INTERIOR_LRTBC;
				reg_set = true;
				break;
			case S_KEY_OUTSIDE:
				///#ifdef BACKWARDS_COMPATIBLE
				//	    if (!hpos_set)
				//		key->hpos = RIGHT;
				//	    if (!sdir_set)
				//		key->stack_dir = GPKEY_VERTICAL;
				///#endif
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_LRTBC;
				reg_set = true;
				break;
			case S_KEY_TMARGIN:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_TMARGIN;
				reg_set = true;
				break;
			case S_KEY_BMARGIN:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_BMARGIN;
				reg_set = true;
				break;
			case S_KEY_LMARGIN:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_LMARGIN;
				reg_set = true;
				break;
			case S_KEY_RMARGIN:
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				key.region = en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN;
				key.margin = en_key_ext_region.GPKEY_RMARGIN;
				reg_set = true;
				break;
			case S_KEY_LLEFT:
				key.just = en_key_sample_positioning.GPKEY_LEFT;
				break;
			case S_KEY_RRIGHT:
				key.just = en_key_sample_positioning.GPKEY_RIGHT;
				break;
			case S_KEY_REVERSE:
				key.reverse = true;
				break;
			case S_KEY_NOREVERSE:
				key.reverse = false;
				break;
			case S_KEY_INVERT:
				key.invert = true;
				break;
			case S_KEY_NOINVERT:
				key.invert = false;
				break;
			case S_KEY_ENHANCED:
				key.enhanced = true;
				break;
			case S_KEY_NOENHANCED:
				key.enhanced = false;
				break;
			case S_KEY_BOX:
				GlobalMembersCommand.c_token++;
				key.box.l_type = DefineConstants.LT_BLACK;
				if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					int old_token = GlobalMembersCommand.c_token;
					GlobalMembersMisc.lp_parse(key.box, true, false);
					if (old_token == GlobalMembersCommand.c_token && GlobalMembersUtil.isanumber(GlobalMembersCommand.c_token) != 0)
					{
						key.box.l_type = GlobalMembersParse.int_expression() - 1;
						GlobalMembersCommand.c_token++;
					}
				}
				GlobalMembersCommand.c_token--; // is incremented after loop
				break;
			case S_KEY_NOBOX:
				key.box.l_type = DefineConstants.LT_NODRAW;
				break;
			case S_KEY_SAMPLEN:
				GlobalMembersCommand.c_token++;
				key.swidth = GlobalMembersParse.real_expression();
				GlobalMembersCommand.c_token--; // it is incremented after loop
				break;
			case S_KEY_SPACING:
				GlobalMembersCommand.c_token++;
				key.vert_factor = GlobalMembersParse.real_expression();
				if (key.vert_factor < 0.0)
					key.vert_factor = 0.0;
				GlobalMembersCommand.c_token--; // it is incremented after loop
				break;
			case S_KEY_WIDTH:
				GlobalMembersCommand.c_token++;
				key.width_fix = GlobalMembersParse.real_expression();
				GlobalMembersCommand.c_token--; // it is incremented after loop
				break;
			case S_KEY_HEIGHT:
				GlobalMembersCommand.c_token++;
				key.height_fix = GlobalMembersParse.real_expression();
				GlobalMembersCommand.c_token--; // it is incremented after loop
				break;
			case S_KEY_AUTOTITLES:
				if (GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "col$umnheader") != 0)
					key.auto_titles = keytitle_type.COLUMNHEAD_KEYTITLES;
				else
				{
					key.auto_titles = keytitle_type.FILENAME_KEYTITLES;
					GlobalMembersCommand.c_token--;
				}
				break;
			case S_KEY_NOAUTOTITLES:
				key.auto_titles = keytitle_type.NOAUTO_KEYTITLES;
				break;
			case S_KEY_TITLE:
			{
				String s;
				GlobalMembersCommand.c_token++;
				if ((s = GlobalMembersUtil.try_to_get_string()))
				{
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					key.title = s.substring(0, sizeof(key.title));
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(s);
				}
				else
					key.title = tangible.StringFunctions.changeCharacter(key.title, 0, '\0');
				GlobalMembersCommand.c_token--;
			}
			break;
			case S_KEY_NOTITLE:
				key.title = tangible.StringFunctions.changeCharacter(key.title, 0, '\0');
				break;
			case S_KEY_FONT:
				GlobalMembersCommand.c_token++;
				/* Make sure they've specified a font */
				if (!(GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected font");
				else
				{
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(key.font);
					key.font = GlobalMembersUtil.try_to_get_string();
					GlobalMembersCommand.c_token--;
				}
				break;
			case S_KEY_TEXTCOLOR:
			{
				t_colorspec lcolor = new t_colorspec(DefineConstants.TC_DEFAULT, 0, 0.0);
				GlobalMembersMisc.parse_colorspec(lcolor, DefineConstants.TC_FRAC);
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
				//ORIGINAL LINE: key->textcolor = lcolor;
				key.textcolor.copyFrom(lcolor);
			}
			GlobalMembersCommand.c_token--;
			break;

			case S_KEY_MANUAL:
				GlobalMembersCommand.c_token++;
				///#ifdef BACKWARDS_COMPATIBLE
				//	case S_KEY_INVALID:
				//	default:
				///#endif
				if (reg_set)
					GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, reg_warn);
				GlobalMembersAxis.get_position(key.user_pos);
				key.region = en_key_region.GPKEY_USER_PLACEMENT;
				reg_set = true;
				GlobalMembersCommand.c_token--; // will be incremented again soon
				break;
				///#ifndef BACKWARDS_COMPATIBLE
			case S_KEY_INVALID:
			default:
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unknown key option");
				break;
				///#endif
			}
			GlobalMembersCommand.c_token++;
		}

		if (key.region == en_key_region.GPKEY_AUTO_EXTERIOR_LRTBC)
			GlobalMembersSet.set_key_position_from_stack_direction(key);
		else if (key.region == en_key_region.GPKEY_AUTO_EXTERIOR_MARGIN)
		{
			if (vpos_set && (key.margin == en_key_ext_region.GPKEY_TMARGIN || key.margin == en_key_ext_region.GPKEY_BMARGIN))
				GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "ignoring top/center/bottom; incompatible with tmargin/bmargin.");
			else if (hpos_set && (key.margin == en_key_ext_region.GPKEY_LMARGIN || key.margin == en_key_ext_region.GPKEY_RMARGIN))
				GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "ignoring left/center/right; incompatible with lmargin/tmargin.");
		}
	}

	/* process 'set keytitle' command */
	public static void set_keytitle()
	{
		legend_key key = GlobalMembersGadgets.keyT;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // set to default
		{
			key.title = tangible.StringFunctions.changeCharacter(key.title, 0, DefineConstants.NUL);
		}
		else
		{
			String s;
			if ((s = GlobalMembersUtil.try_to_get_string()))
			{
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				key.title = s.substring(0, sizeof(key.title));
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(s);
			}
		}
	}

	/* process 'set label' command */
	/* set label {tag} {"label_text"{,<value>{,...}}} {<label options>} */
	/* EAM Mar 2003 - option parsing broken out into separate routine */
	public static void set_label()
	{
		text_label this_label = DefineConstants.NULL;
		text_label new_label = DefineConstants.NULL;
		text_label prev_label = DefineConstants.NULL;
		value a = new value();
		int tag;

		GlobalMembersCommand.c_token++;

		/* get tag */
		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && !(GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING) && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "left") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "center") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "centre") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "right") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rot$ate") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "norot$ate") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lt") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linet$ype") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pt") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "pointt$ype") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "tc") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "text$color") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "font") == 0)
			/* FIXME - Are these tests really still needed? */
		{

			/* must be an expression, but is it a tag or is it the label itself? */
			int save_token = GlobalMembersCommand.c_token;
			GlobalMembersParse.const_express(a);
			if (a.type == DATA_TYPES.STRING)
			{
				GlobalMembersCommand.c_token = save_token;
				tag = GlobalMembersSet.assign_label_tag();
				GlobalMembersEval.gpfree_string(a);
			}
			else
				tag = (int) GlobalMembersEval.real(a);

		}
		else
			tag = GlobalMembersSet.assign_label_tag(); // default next tag

		if (tag <= 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be > zero");

		if (GlobalMembersGadgets.first_label != DefineConstants.NULL) // skip to last label
		{
			for (this_label = GlobalMembersGadgets.first_label; this_label != DefineConstants.NULL; prev_label = this_label, this_label = this_label.next)
				/* is this the label we want? */
				if (tag <= this_label.tag)
					break;
		}
		/* Insert this label into the list if it is a new one */
		if (this_label == DefineConstants.NULL || tag != this_label.tag)
		{
			position default_offset = new position(position_type.character, position_type.character, position_type.character, 0., 0., 0.);
			new_label = GlobalMembersSet.new_text_label(tag);
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: new_label->offset = default_offset;
			new_label.offset.copyFrom(default_offset);
			if (prev_label == DefineConstants.NULL)
				GlobalMembersGadgets.first_label = new_label;
			else
				prev_label.next = new_label;
			new_label.next = this_label;
			this_label = new_label;
		}

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			String text;
			GlobalMembersSet.parse_label_options(this_label);
			text = GlobalMembersUtil.try_to_get_string();
			if (text != null)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(this_label.text);
				this_label.text = text;
			}

			/* HBB 20001021: new functionality. If next token is a ','
			 * treat it as a numeric expression whose value is to be
			 * sprintf()ed into the label string (which contains an
			 * appropriate %f format string) */
			/* EAM Oct 2004 - this is superseded by general string variable
			 * handling, but left in for backward compatibility */
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
				this_label.text = GlobalMembersSet.fill_numbers_into_string(this_label.text);
		}

		/* Now parse the label format and style options */
		GlobalMembersSet.parse_label_options(this_label);
	}

	/* assign a new label tag
	 * labels are kept sorted by tag number, so this is easy
	 * returns the lowest unassigned tag number
	 */
	public static int assign_label_tag()
	{
		text_label this_label;
		int last = 0; // previous tag value

		for (this_label = GlobalMembersGadgets.first_label; this_label != DefineConstants.NULL; this_label = this_label.next)
			if (this_label.tag == last + 1)
				last++;
			else
				break;

		return (last + 1);
	}

	/* process 'set loadpath' command */
	public static void set_loadpath()
	{
		/* We pick up all loadpath elements here before passing
		 * them on to set_var_loadpath()
		 */
		String collect = DefineConstants.NULL;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			() GlobalMembersVariable.loadpath_handler(1 << 5, DefineConstants.NULL)();
		}
		else
			while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
				{
					int len;
					byte ss = GlobalMembersAlloc.gp_alloc(GlobalMembersUtil.token_len(GlobalMembersCommand.c_token), "tmp storage");
					len = (collect != null? collect.length() : 0);
					GlobalMembersUtil.quote_str(ss, GlobalMembersCommand.c_token, GlobalMembersUtil.token_len(GlobalMembersCommand.c_token));
					collect = GlobalMembersAlloc.gp_realloc(collect, len + 1 + ss.length() + 1, "tmp loadpath");
					if (len != 0)
					{
						collect + len + 1 = ss;
						*(collect + len) = DefineConstants.PATHSEP;
					}
					else
						collect = ss;
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
					++GlobalMembersCommand.c_token;
				}
				else
				{
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected string");
				}
			}
		if (collect != null)
		{
			GlobalMembersVariable.loadpath_handler(1 << 2, (collect));
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(collect);
		}
	}

	/* process 'set fontpath' command */
	public static void set_fontpath()
	{
		/* We pick up all fontpath elements here before passing
		 * them on to set_var_fontpath()
		 */
		String collect = DefineConstants.NULL;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			() GlobalMembersVariable.fontpath_handler(1 << 5, DefineConstants.NULL)();
		}
		else
			while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
				{
					int len;
					byte ss = GlobalMembersAlloc.gp_alloc(GlobalMembersUtil.token_len(GlobalMembersCommand.c_token), "tmp storage");
					len = (collect != null? collect.length() : 0);
					GlobalMembersUtil.quote_str(ss, GlobalMembersCommand.c_token, GlobalMembersUtil.token_len(GlobalMembersCommand.c_token));
					collect = GlobalMembersAlloc.gp_realloc(collect, len + 1 + ss.length() + 1, "tmp fontpath");
					if (len != 0)
					{
						collect + len + 1 = ss;
						*(collect + len) = DefineConstants.PATHSEP;
					}
					else
						collect = ss;
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
					++GlobalMembersCommand.c_token;
				}
				else
				{
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected string");
				}
			}
		if (collect != null)
		{
			GlobalMembersVariable.fontpath_handler(1 << 2, (collect));
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(collect);
		}
	}

	/* process 'set locale' command */
	public static void set_locale()
	{
		String s;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			() GlobalMembersVariable.locale_handler(1 << 0, DefineConstants.NULL)();
		}
		else if ((s = GlobalMembersUtil.try_to_get_string()))
		{
			GlobalMembersVariable.locale_handler(1 << 2, (s));
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(s);
		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected string");
	}

	/* process 'set logscale' command */
	public static void set_logscale()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			do
			{
				int tmp;
				for (tmp = 0; tmp < DefineConstants.AXIS_ARRAY_SIZE; tmp++)
					GlobalMembersAxis.axis_array[tmp].field = (true);
			} while (0);
			do
			{
				int tmp;
				for (tmp = 0; tmp < DefineConstants.AXIS_ARRAY_SIZE; tmp++)
					GlobalMembersAxis.axis_array[tmp].field = (10.0);
			} while (0);
		}
		else
		{
			boolean[] set_for_axis = {false, false, false, false, false, false, false, false, false, false, false};
			int axis;
			double newbase = 10;

			/* do reverse search because of "x", "x1", "x2" sequence in axisname_tbl */
			int i = 0;
			while (i < GlobalMembersCommand.token[GlobalMembersCommand.c_token].length)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: axis = lookup_table_nth_reverse(axisname_tbl, DefineConstants.AXIS_ARRAY_SIZE, gp_input_line + token[c_token].start_index + i);
				axis = GlobalMembersTables.lookup_table_nth_reverse(new gen_table(GlobalMembersAxis.axisname_tbl), DefineConstants.AXIS_ARRAY_SIZE, GlobalMembersCommand.gp_input_line + GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index + i);
				if (axis < 0)
				{
					GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index += i;
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unknown axis");
				}
				set_for_axis[GlobalMembersAxis.axisname_tbl[axis].value] = true;
				i += String.valueOf(GlobalMembersAxis.axisname_tbl[axis].key).length();
			}
			GlobalMembersCommand.c_token++;

			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				newbase = Math.abs(GlobalMembersParse.real_expression());
				if (newbase < 1.1)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "log base must be >= 1.1; logscale unchanged");
			}

			for (axis = 0; axis < DefineConstants.AXIS_ARRAY_SIZE; axis++)
				if (set_for_axis[axis])
				{
					GlobalMembersAxis.axis_array[axis].log = true;
					GlobalMembersAxis.axis_array[axis].base = newbase;
				}
		}

		///#ifdef VOLATILE_REFRESH
		/* Because the log scaling is applied during data input, a quick refresh */
		/* using existing stored data will not work if the log setting changes.  */
		GlobalMembersGadgets.refresh_ok = 0;
		///#endif
	}

	///#ifdef GP_MACROS
	///#ifdef GP_MACROS
	public static void set_macros()
	{
		GlobalMembersCommand.c_token++;
		GlobalMembersCommand.expand_macros = true;
	}
	///#endif

	/* process 'set mapping3d' command */
	///#endif
	public static void set_mapping()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			/* assuming same as points */
			GlobalMembersPlot3d.mapping3d = en_data_mapping.MAP3D_CARTESIAN;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ca$rtesian") != 0)
			GlobalMembersPlot3d.mapping3d = en_data_mapping.MAP3D_CARTESIAN;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "s$pherical") != 0)
			GlobalMembersPlot3d.mapping3d = en_data_mapping.MAP3D_SPHERICAL;
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cy$lindrical") != 0)
			GlobalMembersPlot3d.mapping3d = en_data_mapping.MAP3D_CYLINDRICAL;
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'cartesian', 'spherical', or 'cylindrical'");
		GlobalMembersCommand.c_token++;
	}

	/* process 'set {blrt}margin' command */
	public static void set_margin(position margin)
	{
		margin.scalex = position_type.character;
		margin.x = -1;
		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			return;

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") != 0 && GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "sc$reen") == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'screen <fraction>'");
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sc$reen") != 0)
		{
			margin.scalex = position_type.screen;
			GlobalMembersCommand.c_token++;
		}

		margin.x = GlobalMembersParse.real_expression();
		if (margin.x < 0)
			margin.x = -1;

		if (margin.scalex == position_type.screen)
		{
			if (margin.x < 0)
				margin.x = 0;
			if (margin.x > 1)
				margin.x = 1;
		}

	}

	/* process 'set missing' command */
	public static void set_missing()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersDatafile.missing_val);
			GlobalMembersDatafile.missing_val = DefineConstants.NULL;
		}
		else if (!(GlobalMembersDatafile.missing_val = GlobalMembersUtil.try_to_get_string()))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected missing-value string");
	}
	public static void set_separator()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersDatafile.df_separator = (byte)'\0';
			return;
		}
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "white$space") != 0)
			GlobalMembersDatafile.df_separator = (byte)'\0';
		else if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected \"<separator_char>\"");
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "\"\\t\"") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "\'\\t\'") != 0)
			GlobalMembersDatafile.df_separator = (byte)'\t';
		else if (GlobalMembersCommand.gp_input_line.charAt(GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index) != GlobalMembersCommand.gp_input_line.charAt(GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index + 2))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "extra chars after <separation_char>");
		else
			GlobalMembersDatafile.df_separator = GlobalMembersCommand.gp_input_line.charAt(GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index + 1);
		GlobalMembersCommand.c_token++;
	}
	public static void set_datafile_commentschars()
	{
		String s;

		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersDatafile.df_commentschars);
			GlobalMembersDatafile.df_commentschars = GlobalMembersUtil.gp_strdup(DefineConstants.DEFAULT_COMMENTS_CHARS);
		}
		else if ((s = GlobalMembersUtil.try_to_get_string()))
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersDatafile.df_commentschars);
			GlobalMembersDatafile.df_commentschars = s;
		} // Leave it the way it was
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected string with comments chars");
	}

	///#ifdef USE_MOUSE
	///#ifdef USE_MOUSE
	public static void set_mouse()
	{
		GlobalMembersCommand.c_token++;
		mouse_setting.on = 1;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "do$ubleclick") != 0)
			{
				++GlobalMembersCommand.c_token;
				mouse_setting.doubleclick = GlobalMembersParse.real_expression();
				if (mouse_setting.doubleclick < 0)
					mouse_setting.doubleclick = 0;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nodo$ubleclick") != 0)
			{
				mouse_setting.doubleclick = 0; // double click off
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "zoomco$ordinates") != 0)
			{
				mouse_setting.annotate_zoom_box = 1;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nozoomco$ordinates") != 0)
			{
				mouse_setting.annotate_zoom_box = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "po$lardistancedeg") != 0)
			{
				mouse_setting.polardistance = 1;
				GlobalMembersMouse.UpdateStatusline();
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "polardistancet$an") != 0)
			{
				mouse_setting.polardistance = 2;
				GlobalMembersMouse.UpdateStatusline();
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nopo$lardistance") != 0)
			{
				mouse_setting.polardistance = 0;
				GlobalMembersMouse.UpdateStatusline();
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "label$s") != 0)
			{
				mouse_setting.label = 1;
				++GlobalMembersCommand.c_token;
				/* check if the optional argument "<label options>" is present */
				if ((GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
				{
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(mouse_setting.labelopts);
					mouse_setting.labelopts = GlobalMembersUtil.try_to_get_string();
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nola$bels") != 0)
			{
				mouse_setting.label = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ve$rbose") != 0)
			{
				mouse_setting.verbose = 1;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nove$rbose") != 0)
			{
				mouse_setting.verbose = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "zoomju$mp") != 0)
			{
				mouse_setting.warp_pointer = 1;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nozoomju$mp") != 0)
			{
				mouse_setting.warp_pointer = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fo$rmat") != 0)
			{
				++GlobalMembersCommand.c_token;
				if ((GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
				{
					if (!GlobalMembersMouse.mouse_fmt_default.equals(mouse_setting.fmt))
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(mouse_setting.fmt);
					mouse_setting.fmt = GlobalMembersUtil.try_to_get_string();
				}
				else
					mouse_setting.fmt = GlobalMembersMouse.mouse_fmt_default;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cl$ipboardformat") != 0)
			{
				++GlobalMembersCommand.c_token;
				if ((GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
				{
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(GlobalMembersMouse.clipboard_alt_string);
					GlobalMembersMouse.clipboard_alt_string = GlobalMembersUtil.try_to_get_string();
					if (!GlobalMembersMouse.clipboard_alt_string.length())
					{
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(GlobalMembersMouse.clipboard_alt_string);
						GlobalMembersMouse.clipboard_alt_string = DefineConstants.NULL;
						if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == GlobalMembersMouse.mouse_mode)
							GlobalMembersMouse.mouse_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
					}
					else
					{
						GlobalMembersMouse.clipboard_mode = AnonymousEnum.MOUSE_COORDINATES_ALT.getValue();
					}
				}
				else
				{
					int itmp = GlobalMembersParse.int_expression();
					if (itmp >= AnonymousEnum.MOUSE_COORDINATES_REAL && itmp <= AnonymousEnum.MOUSE_COORDINATES_XDATETIME)
					{
						if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == itmp && GlobalMembersMouse.clipboard_alt_string == null)
						{
							fprintf(stderr, "please 'set mouse clipboard <fmt>' first.\n");
						}
						else
						{
							GlobalMembersMouse.clipboard_mode = itmp;
						}
					}
					else
					{
						fprintf(stderr, "should be: %d <= clipboardformat <= %d\n", AnonymousEnum.MOUSE_COORDINATES_REAL, AnonymousEnum.MOUSE_COORDINATES_XDATETIME);
					}
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "mo$useformat") != 0)
			{
				++GlobalMembersCommand.c_token;
				if ((GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
				{
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(GlobalMembersMouse.mouse_alt_string);
					GlobalMembersMouse.mouse_alt_string = GlobalMembersUtil.try_to_get_string();
					if (!GlobalMembersMouse.mouse_alt_string.length())
					{
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(GlobalMembersMouse.mouse_alt_string);
						GlobalMembersMouse.mouse_alt_string = DefineConstants.NULL;
						if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == GlobalMembersMouse.mouse_mode)
							GlobalMembersMouse.mouse_mode = AnonymousEnum.MOUSE_COORDINATES_REAL.getValue();
					}
					else
					{
						GlobalMembersMouse.mouse_mode = AnonymousEnum.MOUSE_COORDINATES_ALT.getValue();
					}
					GlobalMembersCommand.c_token++;
				}
				else
				{
					int itmp = GlobalMembersParse.int_expression();
					if (itmp >= AnonymousEnum.MOUSE_COORDINATES_REAL && itmp <= AnonymousEnum.MOUSE_COORDINATES_XDATETIME)
					{
						if (AnonymousEnum.MOUSE_COORDINATES_ALT.getValue() == itmp && GlobalMembersMouse.mouse_alt_string == null)
						{
							fprintf(stderr, "please 'set mouse mouseformat <fmt>' first.\n");
						}
						else
						{
							GlobalMembersMouse.mouse_mode = itmp;
						}
					}
					else
					{
						fprintf(stderr, "should be: %d <= mouseformat <= %d\n", AnonymousEnum.MOUSE_COORDINATES_REAL, AnonymousEnum.MOUSE_COORDINATES_XDATETIME);
					}
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noru$ler") != 0)
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersMouse.set_ruler(false, -1, -1);
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ru$ler") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") == 0)
				{
					GlobalMembersMouse.set_ruler(true, -1, -1);
				} // set mouse ruler at ...
				else
				{
					position where = new position();
					int x;
					int y;
					GlobalMembersCommand.c_token++;
					if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting ruler coordinates");
					GlobalMembersAxis.get_position(where);
					GlobalMembersGraphics.map_position(where, x, y, "ruler at");
					GlobalMembersMouse.set_ruler(true, (int)x, (int)y);
				}
			}
			else
			{
				if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "wrong option");
				break;
			}
		}
		///#ifdef OS2
		//    PM_update_menu_items();
		///#endif
	}
	///#endif

	/* process 'set offsets' command */
	///#endif
	public static void set_offsets()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersGraphics.loff.x = GlobalMembersGraphics.roff.x = GlobalMembersGraphics.toff.y = GlobalMembersGraphics.boff.y = 0.0;
			return;
		}

		GlobalMembersGraphics.loff.scalex = position_type.first_axes;
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "gr$aph") != 0)
		{
			GlobalMembersGraphics.loff.scalex = position_type.graph;
			GlobalMembersCommand.c_token++;
		}
		GlobalMembersGraphics.loff.x = GlobalMembersParse.real_expression();
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			return;

		GlobalMembersGraphics.roff.scalex = position_type.first_axes;
		if (GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "gr$aph") != 0)
		{
			GlobalMembersGraphics.roff.scalex = position_type.graph;
			GlobalMembersCommand.c_token++;
		}
		GlobalMembersGraphics.roff.x = GlobalMembersParse.real_expression();
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			return;

		GlobalMembersGraphics.toff.scaley = position_type.first_axes;
		if (GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "gr$aph") != 0)
		{
			GlobalMembersGraphics.toff.scaley = position_type.graph;
			GlobalMembersCommand.c_token++;
		}
		GlobalMembersGraphics.toff.y = GlobalMembersParse.real_expression();
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			return;

		GlobalMembersGraphics.boff.scaley = position_type.first_axes;
		if (GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "gr$aph") != 0)
		{
			GlobalMembersGraphics.boff.scaley = position_type.graph;
			GlobalMembersCommand.c_token++;
		}
		GlobalMembersGraphics.boff.y = GlobalMembersParse.real_expression();
	}

	/* process 'set origin' command */
	public static void set_origin()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersGadgets.xoffset = 0.0F;
			GlobalMembersGadgets.yoffset = 0.0F;
		}
		else
		{
			GlobalMembersGadgets.xoffset = GlobalMembersParse.real_expression();
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "',' expected");
			GlobalMembersCommand.c_token++;
			GlobalMembersGadgets.yoffset = GlobalMembersParse.real_expression();
		}
	}

	/* process 'set output' command */
	public static void set_output()
	{
		String testfile;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersTerm.multiplot)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "you can't change the output in multiplot mode");

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // no file specified
		{
			GlobalMembersTerm.term_set_output(DefineConstants.NULL);
			if (GlobalMembersTerm.outstr != null)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(GlobalMembersTerm.outstr);
				GlobalMembersTerm.outstr = DefineConstants.NULL; // means STDOUT
			}
		}
		else if ((testfile = GlobalMembersUtil.try_to_get_string()))
		{
			tangible.RefObject<String[]> tempRef_testfile = new tangible.RefObject<String[]>(testfile);
			GlobalMembersPlot.gp_expand_tilde(tempRef_testfile);
			testfile = tempRef_testfile.argvalue;
			GlobalMembersTerm.term_set_output(testfile);
			if (!GlobalMembersTerm.outstr.equals(testfile))
			{
				if (testfile != null)
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(testfile);
				testfile = GlobalMembersTerm.outstr;
			}
			/* if we get here then it worked, and outstr now = testfile */
		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting filename");

		/* Invalidate previous palette */
		GlobalMembersColor.invalidate_palette();

	}

	/* process 'set parametric' command */
	public static void set_parametric()
	{
		GlobalMembersCommand.c_token++;

		if (!GlobalMembersGadgets.parametric)
		{
			GlobalMembersGadgets.parametric = true;
			if (!GlobalMembersGadgets.polar) // already done for polar
			{
				GlobalMembersParse.set_dummy_var[0] = "t";
				GlobalMembersParse.set_dummy_var[1] = "y";
				if (GlobalMembersPlot.interactive)
					() fprintf(stderr,"\n\tdummy variable is t for curves, u/v for surfaces\n");
			}
		}
	}

	/* process 'set pm3d' command */
	public static void set_pm3d()
	{
		int c_token0 = ++GlobalMembersCommand.c_token;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // assume default settings
		{
			GlobalMembersPm3d.pm3d_reset(); // sets pm3d.implicit to PM3D_IMPLICIT and pm3d.where to "s"
			GlobalMembersPm3d.pm3d.implicit = PM3D_IMPL_MODE.PM3D_IMPLICIT; // for historical reasons
		}
		else // go through all options of 'set pm3d'
		{
			for (; !GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0; GlobalMembersCommand.c_token++)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: switch (lookup_table(&set_pm3d_tbl[0],c_token))
				switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_pm3d_tbl[0]), GlobalMembersCommand.c_token))
				{
				/* where to plot */
				case S_PM3D_AT: // "at"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersPm3d.get_pm3d_at_option(GlobalMembersPm3d.pm3d.where.charAt(0)) != 0)
						return; // error
					GlobalMembersCommand.c_token--;
					///#if 1
					if (GlobalMembersCommand.c_token == c_token0 + 1)
						/* for historical reasons: if "at" is the first option of pm3d,
						 * like "set pm3d at X other_opts;", then implicit is switched on */
						GlobalMembersPm3d.pm3d.implicit = PM3D_IMPL_MODE.PM3D_IMPLICIT;
					///#endif
					continue;
				case S_PM3D_INTERPOLATE: // "interpolate"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					{
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting step values i,j");
					}
					else
					{
						GlobalMembersPm3d.pm3d.interp_i = GlobalMembersParse.int_expression();
						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "',' expected");
						GlobalMembersCommand.c_token++;
						GlobalMembersPm3d.pm3d.interp_j = GlobalMembersParse.int_expression();
						GlobalMembersCommand.c_token--;
					}
					continue;
					/* forward and backward drawing direction */
				case S_PM3D_SCANSFORWARD: // "scansfor$ward"
					GlobalMembersPm3d.pm3d.direction = DefineConstants.PM3D_SCANS_FORWARD;
					continue;
				case S_PM3D_SCANSBACKWARD: // "scansback$ward"
					GlobalMembersPm3d.pm3d.direction = DefineConstants.PM3D_SCANS_BACKWARD;
					continue;
				case S_PM3D_SCANS_AUTOMATIC: // "scansauto$matic"
					GlobalMembersPm3d.pm3d.direction = DefineConstants.PM3D_SCANS_AUTOMATIC;
					continue;
				case S_PM3D_DEPTH: // "dep$thorder"
					GlobalMembersPm3d.pm3d.direction = DefineConstants.PM3D_DEPTH;
					continue;
					/* flush scans: left, right or center */
				case S_PM3D_FLUSH: // "fl$ush"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "b$egin") != 0)
						GlobalMembersPm3d.pm3d.flush = DefineConstants.PM3D_FLUSH_BEGIN;
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "c$enter") != 0)
						GlobalMembersPm3d.pm3d.flush = DefineConstants.PM3D_FLUSH_CENTER;
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "e$nd") != 0)
						GlobalMembersPm3d.pm3d.flush = DefineConstants.PM3D_FLUSH_END;
					else
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting flush 'begin', 'center' or 'end'");
					continue;
					/* clipping method */
				case S_PM3D_CLIP_1IN: // "clip1$in"
					GlobalMembersPm3d.pm3d.clip = DefineConstants.PM3D_CLIP_1IN;
					continue;
				case S_PM3D_CLIP_4IN: // "clip4$in"
					GlobalMembersPm3d.pm3d.clip = DefineConstants.PM3D_CLIP_4IN;
					continue;
					/* setup everything for plotting a map */
				case S_PM3D_MAP: // "map"
					GlobalMembersPm3d.pm3d.where = tangible.StringFunctions.changeCharacter(GlobalMembersPm3d.pm3d.where, 0, 'b'); // set pm3d at b
					GlobalMembersPm3d.pm3d.where = GlobalMembersPm3d.pm3d.where.substring(0, 1);
					GlobalMembersGadgets.data_style = PLOT_STYLE.PM3DSURFACE;
					GlobalMembersGadgets.func_style = PLOT_STYLE.PM3DSURFACE;
					GlobalMembersGraph3d.splot_map = true;
					continue;
					/* flushing triangles */
				case S_PM3D_FTRIANGLES: // "ftr$iangles"
					GlobalMembersPm3d.pm3d.ftriangles = 1;
					continue;
				case S_PM3D_NOFTRIANGLES: // "noftr$iangles"
					GlobalMembersPm3d.pm3d.ftriangles = 0;
					continue;
					/* pm3d-specific hidden line overwrite */
				case S_PM3D_HIDDEN: // "hi$dden3d"
				{
					GlobalMembersCommand.c_token++;
					GlobalMembersPm3d.pm3d.hidden3d_tag = GlobalMembersParse.int_expression();
					--GlobalMembersCommand.c_token;
					if (GlobalMembersPm3d.pm3d.hidden3d_tag <= 0)
					{
						GlobalMembersPm3d.pm3d.hidden3d_tag = 0;
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be strictly positive (see `help set style line')");
					}
				}
				continue;
				case S_PM3D_NOHIDDEN: // "nohi$dden3d"
					GlobalMembersPm3d.pm3d.hidden3d_tag = 0;
					continue;
				case S_PM3D_SOLID: // "so$lid"
				case S_PM3D_NOTRANSPARENT: // "notr$ansparent"
				case S_PM3D_NOSOLID: // "noso$lid"
				case S_PM3D_TRANSPARENT: // "tr$ansparent"
					if (GlobalMembersPlot.interactive)
						GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "Deprecated syntax --- ignored");
				case S_PM3D_IMPLICIT: // "i$mplicit"
				case S_PM3D_NOEXPLICIT: // "noe$xplicit"
					GlobalMembersPm3d.pm3d.implicit = PM3D_IMPL_MODE.PM3D_IMPLICIT;
					continue;
				case S_PM3D_NOIMPLICIT: // "noi$mplicit"
				case S_PM3D_EXPLICIT: // "e$xplicit"
					GlobalMembersPm3d.pm3d.implicit = PM3D_IMPL_MODE.PM3D_EXPLICIT;
					continue;
				case S_PM3D_WHICH_CORNER: // "corners2color"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "mean") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MEAN;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "geomean") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_GEOMEAN;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "median") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MEDIAN;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "min") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MIN;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "max") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MAX;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "c1") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_C1;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "c2") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_C2;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "c3") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_C3;
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "c4") != 0)
						GlobalMembersPm3d.pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_C4;
					else
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'mean', 'geomean', 'median', 'c1', 'c2', 'c3' or 'c4'");
					continue;
				} // switch over pm3d lookup table
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "invalid pm3d option");
			} // end of while !end of command over pm3d options
			if (DefineConstants.PM3D_SCANS_AUTOMATIC == GlobalMembersPm3d.pm3d.direction && DefineConstants.PM3D_FLUSH_BEGIN != GlobalMembersPm3d.pm3d.flush)
			{
				GlobalMembersPm3d.pm3d.direction = DefineConstants.PM3D_SCANS_FORWARD;
				///#if 0
				//// /* be silent, don't print this warning */
				//// /* Rather FIXME that this combination is supported? Shouldn't be
				////    so big problem, I guess, just it is not implemented. */
				////	    fprintf(stderr, "pm3d: `scansautomatic' and `flush %s' are incompatible\n",
				////		PM3D_FLUSH_END == pm3d.flush ? "end": "center");
				////	    fputs("   => setting `scansforward'\n", stderr);
				///#endif
			}
		}
	}

	/* Process 'set palette' command */
	public static void set_palette()
	{
		int transform_defined;
		int named_color;
		transform_defined = named_color = 0;
		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // reset to default settings
			GlobalMembersSet.reset_palette();
		else // go through all options of 'set palette'
		{
			for (; !GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0; GlobalMembersCommand.c_token++)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: switch (lookup_table(&set_palette_tbl[0],c_token))
				switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_palette_tbl[0]), GlobalMembersCommand.c_token))
				{
				/* positive and negative picture */
				case S_PALETTE_POSITIVE: // "pos$itive"
					GlobalMembersColor.sm_palette.positive = DefineConstants.SMPAL_POSITIVE;
					continue;
				case S_PALETTE_NEGATIVE: // "neg$ative"
					GlobalMembersColor.sm_palette.positive = DefineConstants.SMPAL_NEGATIVE;
					continue;
					/* Now the options that determine the palette of smooth colours */
					/* gray or rgb-coloured */
				case S_PALETTE_GRAY: // "gray"
					GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_GRAY;
					continue;
				case S_PALETTE_GAMMA: // "gamma"
				++GlobalMembersCommand.c_token;
				GlobalMembersColor.sm_palette.gamma = GlobalMembersParse.real_expression();
				--GlobalMembersCommand.c_token;
				continue;
				case S_PALETTE_COLOR: // "col$or"
					if (pm3d_last_set_palette_mode != palette_color_mode.SMPAL_COLOR_MODE_NONE)
					{
						GlobalMembersColor.sm_palette.colorMode = pm3d_last_set_palette_mode;
					}
					else
					{
						GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_RGB;
					}
					continue;
					/* rgb color mapping formulae: rgb$formulae r,g,b (3 integers) */
				case S_PALETTE_RGBFORMULAE: // "rgb$formulae"
				{
					int i;

					do {if (transform_defined) GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Use either `rgbformulae`, `defined`, `file` or `formulae`."); transform_defined = 1;} while (0);
					do
					{
						GlobalMembersCommand.c_token++;
						i = GlobalMembersParse.int_expression();
						if (Math.abs(i) >= GlobalMembersColor.sm_palette.colorFormulae)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "color formula out of range (use `show palette rgbformulae' to display the range)");
						GlobalMembersColor.sm_palette.formulaR = i;
					} while (0);
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
					{
						GlobalMembersCommand.c_token--;
						continue;
					}
					do
					{
						GlobalMembersCommand.c_token++;
						i = GlobalMembersParse.int_expression();
						if (Math.abs(i) >= GlobalMembersColor.sm_palette.colorFormulae)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "color formula out of range (use `show palette rgbformulae' to display the range)");
						GlobalMembersColor.sm_palette.formulaG = i;
					} while (0);
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
					{
						GlobalMembersCommand.c_token--;
						continue;
					}
					do
					{
						GlobalMembersCommand.c_token++;
						i = GlobalMembersParse.int_expression();
						if (Math.abs(i) >= GlobalMembersColor.sm_palette.colorFormulae)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "color formula out of range (use `show palette rgbformulae' to display the range)");
						GlobalMembersColor.sm_palette.formulaB = i;
					} while (0);
					GlobalMembersCommand.c_token--;
					GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_RGB;
					pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_RGB;
					continue;
				} // rgbformulae
				case S_PALETTE_DEFINED: // "def$ine"
				{
					do {if (transform_defined) GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Use either `rgbformulae`, `defined`, `file` or `formulae`."); transform_defined = 1;} while (0);
					++GlobalMembersCommand.c_token;
					named_color = GlobalMembersSet.set_palette_defined();
					GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_GRADIENT;
					pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_GRADIENT;
					continue;
				}
				case S_PALETTE_FILE: // "file"
				{
					do {if (transform_defined) GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Use either `rgbformulae`, `defined`, `file` or `formulae`."); transform_defined = 1;} while (0);
					GlobalMembersSet.set_palette_file();
					GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_GRADIENT;
					pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_GRADIENT;
					--GlobalMembersCommand.c_token;
					continue;
				}
				case S_PALETTE_FUNCTIONS: // "func$tions"
				{
					do {if (transform_defined) GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Use either `rgbformulae`, `defined`, `file` or `formulae`."); transform_defined = 1;} while (0);
					GlobalMembersSet.set_palette_function();
					GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_FUNCTIONS;
					pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_FUNCTIONS;
					--GlobalMembersCommand.c_token;
					continue;
				}
				case S_PALETTE_MODEL: // "mo$del"
				{
					int model;

					++GlobalMembersCommand.c_token;
					if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected color model.");
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: model = lookup_table(&color_model_tbl[0],c_token);
					model = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.color_model_tbl[0]), GlobalMembersCommand.c_token);
					if (model == -1)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unknown color model.");
					GlobalMembersColor.sm_palette.cmodel = model;
					continue;
				}
				/* ps_allcF: write all rgb formulae into PS file? */
				case S_PALETTE_NOPS_ALLCF: // "nops_allcF"
					GlobalMembersColor.sm_palette.ps_allcF = 0;
					continue;
				case S_PALETTE_PS_ALLCF: // "ps_allcF"
					GlobalMembersColor.sm_palette.ps_allcF = 1;
					continue;
					/* max colors used */
				case S_PALETTE_MAXCOLORS: // "maxc$olors"
				{
					int i;

					GlobalMembersCommand.c_token++;
					i = GlobalMembersParse.int_expression();
					if (i < 0)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "non-negative number required");
					GlobalMembersColor.sm_palette.use_maxcolors = i;
					--GlobalMembersCommand.c_token;
					continue;
				}
				} // switch over palette lookup table
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "invalid palette option");
			} // end of while !end of command over palette options
		} // else(arguments found)

		if (named_color != 0 && GlobalMembersColor.sm_palette.cmodel != color_models_id.C_MODEL_RGB.getValue() && GlobalMembersPlot.interactive)
			GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "Named colors will produce strange results if not in color mode RGB.");

		/* Invalidate previous palette */
		GlobalMembersColor.invalidate_palette();
	}

	/* process 'set colorbox' command */
	public static void set_colorbox()
	{
		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // reset to default position
			GlobalMembersGadgets.color_box.where = DefineConstants.SMCOLOR_BOX_DEFAULT;
		else // go through all options of 'set colorbox'
		{
			for (; !GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0; GlobalMembersCommand.c_token++)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: switch (lookup_table(&set_colorbox_tbl[0],c_token))
				switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_colorbox_tbl[0]), GlobalMembersCommand.c_token))
				{
				/* vertical or horizontal color gradient */
				case S_COLORBOX_VERTICAL: // "v$ertical"
					GlobalMembersGadgets.color_box.rotation = (byte)'v';
					continue;
				case S_COLORBOX_HORIZONTAL: // "h$orizontal"
					GlobalMembersGadgets.color_box.rotation = (byte)'h';
					continue;
					/* color box where: default position */
				case S_COLORBOX_DEFAULT: // "def$ault"
					GlobalMembersGadgets.color_box.where = DefineConstants.SMCOLOR_BOX_DEFAULT;
					continue;
					/* color box where: position by user */
				case S_COLORBOX_USER: // "u$ser"
					GlobalMembersGadgets.color_box.where = DefineConstants.SMCOLOR_BOX_USER;
					continue;
					/* color box layer: front or back */
				case S_COLORBOX_FRONT: // "fr$ont"
					GlobalMembersGadgets.color_box.layer = DefineConstants.LAYER_FRONT;
					continue;
				case S_COLORBOX_BACK: // "ba$ck"
					GlobalMembersGadgets.color_box.layer = DefineConstants.LAYER_BACK;
					continue;
					/* border of the color box */
				case S_COLORBOX_BORDER: // "bo$rder"

					GlobalMembersGadgets.color_box.border = 1;
					GlobalMembersCommand.c_token++;

					if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					{
						/* expecting a border line type */
						GlobalMembersGadgets.color_box.border_lt_tag = GlobalMembersParse.int_expression();
						if (GlobalMembersGadgets.color_box.border_lt_tag <= 0)
						{
							GlobalMembersGadgets.color_box.border_lt_tag = 0;
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be strictly positive (see `help set style line')");
						}
						--GlobalMembersCommand.c_token;
					}
					continue;
				case S_COLORBOX_BDEFAULT: // "bd$efault"
					GlobalMembersGadgets.color_box.border_lt_tag = -1; // use default border
					continue;
				case S_COLORBOX_NOBORDER: // "nobo$rder"
					GlobalMembersGadgets.color_box.border = 0;
					continue;
					/* colorbox origin */
				case S_COLORBOX_ORIGIN: // "o$rigin"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					{
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting screen value [0 - 1]");
					}
					else
					{
						//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
						//ORIGINAL LINE: get_position_default(&color_box.origin, screen);
						GlobalMembersAxis.get_position_default(new position(GlobalMembersGadgets.color_box.origin), position_type.screen);
					}
					GlobalMembersCommand.c_token--;
					continue;
					/* colorbox size */
				case S_COLORBOX_SIZE: // "s$ize"
					GlobalMembersCommand.c_token++;
					if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					{
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting screen value [0 - 1]");
					}
					else
					{
						//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
						//ORIGINAL LINE: get_position_default(&color_box.size, screen);
						GlobalMembersAxis.get_position_default(new position(GlobalMembersGadgets.color_box.size), position_type.screen);
					}
					GlobalMembersCommand.c_token--;
					continue;
				} // switch over colorbox lookup table
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "invalid colorbox option");
			} // end of while !end of command over colorbox options
			if (GlobalMembersGadgets.color_box.where == DefineConstants.SMCOLOR_BOX_NO) // default: draw at default position
				GlobalMembersGadgets.color_box.where = DefineConstants.SMCOLOR_BOX_DEFAULT;
		}
	}

	/* process 'set pointsize' command */
	public static void set_pointsize()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersGadgets.pointsize = 1.0;
		else
			GlobalMembersGadgets.pointsize = GlobalMembersParse.real_expression();
		if (GlobalMembersGadgets.pointsize <= 0)
			GlobalMembersGadgets.pointsize = 1;
	}

	/* process 'set polar' command */
	public static void set_polar()
	{
		GlobalMembersCommand.c_token++;

		if (!GlobalMembersGadgets.polar)
		{
			if (!GlobalMembersGadgets.parametric)
			{
				if (GlobalMembersPlot.interactive)
					fprintf(stderr,"\n\tdummy variable is t for curves\n");
				GlobalMembersParse.set_dummy_var[0] = "t";
			}
			GlobalMembersGadgets.polar = true;
			if (((int)GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_autoscale) != 0)
			{
				/* only if user has not set a range manually */
				GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_min = 0.0;
				/* 360 if degrees, 2pi if radians */
				GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].set_max = 2 * DefineConstants.M_PI / GlobalMembersGadgets.ang2rad;
			}
		}
	}

	/* process 'set print' command */
	public static void set_print()
	{
		boolean append_p = false;
		String testfile = DefineConstants.NULL;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // no file specified
		{
			GlobalMembersCommand.print_set_output(DefineConstants.NULL, append_p);
		}
		else if ((testfile = GlobalMembersUtil.try_to_get_string()))
		{
			tangible.RefObject<String[]> tempRef_testfile = new tangible.RefObject<String[]>(testfile);
			GlobalMembersPlot.gp_expand_tilde(tempRef_testfile);
			testfile = tempRef_testfile.argvalue;
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "append") != 0)
				{
					append_p = true;
					GlobalMembersCommand.c_token++;
				}
				else
				{
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting keyword \'append\'");
				}
			}
			GlobalMembersCommand.print_set_output(testfile, append_p);
		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting filename");
	}

	///#ifdef EAM_OBJECTS
	/* 
	 * Process command     'set object <tag> {rectangle|ellipse|circle|polygon}'
	 * set object {tag} rectangle {from <bottom_left> {to|rto} <top_right>}
	 *                     {{at|center} <xcen>,<ycen> size <w>,<h>}
	 *                     {fc|fillcolor <colorspec>} {lw|linewidth <lw>}
	 *                     {fs <fillstyle>} {front|back|behind}
	 *                     {default}
	 * EAM Jan 2005
	 */

	///#ifdef EAM_OBJECTS
	public static void set_object()
	{
		int tag;

		/* The next token must either be a tag or the object type */
		GlobalMembersCommand.c_token++;
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rect$angle") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "ellipse") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "circle") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "poly$gon") != 0)
			tag = -1; // We'll figure out what it really is later
		else
		{
			tag = GlobalMembersParse.int_expression();
			if (tag <= 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be > zero");
		}

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rect$angle") != 0)
		{
			GlobalMembersSet.set_obj(tag, DefineConstants.OBJ_RECTANGLE);

		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "ellipse") != 0)
		{
			GlobalMembersSet.set_obj(tag, DefineConstants.OBJ_ELLIPSE);

		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "circle") != 0)
		{
			GlobalMembersSet.set_obj(tag, DefineConstants.OBJ_CIRCLE);

		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "poly$gon") != 0)
		{
			GlobalMembersSet.set_obj(tag, DefineConstants.OBJ_POLYGON);

		}
		else if (tag > 0)
		{
			/* Look for existing object with this tag */
			object this_object = GlobalMembersGadgets.first_object;
			for (; this_object != DefineConstants.NULL; this_object = this_object.next)
				if (tag == this_object.tag)
					break;
			if (this_object != null && tag == this_object.tag)
			{
				GlobalMembersCommand.c_token--;
				GlobalMembersSet.set_obj(tag, this_object.object_type);
			}
			else
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unknown object");

		}
		else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unrecognized object type");

	}
	public static void set_obj(int tag, int obj_type)
	{
		rectangle this_rect = DefineConstants.NULL;
		ellipse this_ellipse = DefineConstants.NULL;
		circle this_circle = DefineConstants.NULL;
		polygon this_polygon = DefineConstants.NULL;
		object this_object = DefineConstants.NULL;
		object new_obj = DefineConstants.NULL;
		object prev_object = DefineConstants.NULL;
		boolean got_fill = false;
		boolean got_lt = false;
		boolean got_lw = false;
		boolean got_corners = false;
		boolean got_center = false;
		boolean got_origin = false;
		double lw = 1.0;

		GlobalMembersCommand.c_token++;

		/* We are setting the default, not any particular rectangle */
		if (tag < -1)
		{
			GlobalMembersCommand.c_token--;
			if (obj_type == DefineConstants.OBJ_RECTANGLE)
			{
				this_object = GlobalMembersGadgets.default_rectangle;
				this_rect = this_object.o.rectangle;
			}
			else
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unknown object type");

		}
		else
		{
			/* Look for existing object with this tag */
			for (this_object = GlobalMembersGadgets.first_object; this_object != DefineConstants.NULL; prev_object = this_object, this_object = this_object.next)
				/* is this the one we want? */
				if (0 < tag && tag <= this_object.tag)
					break;

			/* Insert this rect into the list if it is a new one */
			if (this_object == DefineConstants.NULL || tag != this_object.tag)
			{
				if (tag == -1)
					tag = (prev_object) ? prev_object.tag + 1 : 1;
				new_obj = GlobalMembersSet.new_object(tag, obj_type, DefineConstants.NULL);
				if (prev_object == DefineConstants.NULL)
					GlobalMembersGadgets.first_object = new_obj;
				else
					prev_object.next = new_obj;
				new_obj.next = this_object;
				this_object = new_obj;
			}

			/* Over-write old object if the type has changed */
			else if (this_object.object_type != obj_type)
			{
				object save_link = this_object.next;
				new_obj = GlobalMembersSet.new_object(tag, obj_type, this_object);
				this_object.next = save_link;
			}

			this_rect = this_object.o.rectangle;
			this_ellipse = this_object.o.ellipse;
			this_circle = this_object.o.circle;
			this_polygon = this_object.o.polygon;

		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			int save_token = GlobalMembersCommand.c_token;

			switch (obj_type)
			{
			case DefineConstants.OBJ_RECTANGLE:
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "from") != 0)
				{
					/* Read in the bottom left and upper right corners */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_rect.bl);
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") != 0)
					{
						GlobalMembersCommand.c_token++;
						GlobalMembersAxis.get_position(this_rect.tr);
					}
					else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "rto") != 0)
					{
						GlobalMembersCommand.c_token++;
						GlobalMembersAxis.get_position_default(this_rect.tr, this_rect.bl.scalex);
						if (this_rect.bl.scalex != this_rect.tr.scalex || this_rect.bl.scaley != this_rect.tr.scaley)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "relative coordinates must match in type");
						this_rect.tr.x += this_rect.bl.x;
						this_rect.tr.y += this_rect.bl.y;
					}
					else
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expecting to or rto");
					got_corners = true;
					this_rect.type = 0;
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cen$ter") != 0)
				{
					/* Read in the center position */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_rect.center);
					got_center = true;
					this_rect.type = 1;
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "size") != 0)
				{
					/* Read in the width and height */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_rect.extent);
					got_center = true;
					this_rect.type = 1;
					continue;
				}
				break;

			case DefineConstants.OBJ_CIRCLE:
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cen$ter") != 0)
				{
					/* Read in the center position */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_circle.center);
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "size") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "radius") != 0)
				{
					/* Read in the radius */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_circle.extent);
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "arc") != 0)
				{
					/* Start and end angle for arc */
					if (GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, "[") != 0)
					{
						double arc;
						GlobalMembersCommand.c_token++;
						arc = GlobalMembersParse.real_expression();
						if (Math.abs(arc) > 1000.)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Angle out of range");
						else
							this_circle.arc_begin = arc;
						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token++, ":") != 0)
						{
							arc = GlobalMembersParse.real_expression();
							if (Math.abs(arc) > 1000.)
								GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Angle out of range");
							else
								this_circle.arc_end = arc;
							if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token++, "]") != 0)
								continue;
						}
					}
					GlobalMembersBf_test.int_error(--GlobalMembersCommand.c_token, "Expecting arc [<begin>:<end>]");
				}
				break;

			case DefineConstants.OBJ_ELLIPSE:
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "cen$ter") != 0)
				{
					/* Read in the center position */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_ellipse.center);
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "size") != 0)
				{
					/* Read in the width and height */
					GlobalMembersCommand.c_token++;
					GlobalMembersAxis.get_position(this_ellipse.extent);
					continue;

				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "angle") != 0)
				{
					GlobalMembersCommand.c_token++;
					this_ellipse.orientation = GlobalMembersParse.real_expression();
					continue;
				}
				break;

			case DefineConstants.OBJ_POLYGON:
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "from") != 0)
				{
					GlobalMembersCommand.c_token++;
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					this_polygon.vertex = GlobalMembersAlloc.gp_realloc(this_polygon.vertex, sizeof(GlobalMembersMouse.struct position), "polygon vertex");
					GlobalMembersAxis.get_position(this_polygon.vertex[0]);
					this_polygon.type = 1;
					got_origin = true;
				}
				while (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "to") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "rto") != 0)
				{
					if (!got_origin)
						//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
						goto polygon_error;
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					this_polygon.vertex = GlobalMembersAlloc.gp_realloc(this_polygon.vertex, (this_polygon.type + 1) * sizeof(GlobalMembersMouse.struct position), "polygon vertex");
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token++, "to") != 0)
					{
						GlobalMembersAxis.get_position(this_polygon.vertex[this_polygon.type]);
					} // "rto"
					else
					{
						int v = this_polygon.type;
						GlobalMembersAxis.get_position_default(this_polygon.vertex[v], this_polygon.vertex.scalex);
						if (this_polygon.vertex[v].scalex != this_polygon.vertex[v - 1].scalex || this_polygon.vertex[v].scaley != this_polygon.vertex[v - 1].scaley)
							GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "relative coordinates must match in type");
						this_polygon.vertex[v].x += this_polygon.vertex[v - 1].x;
						this_polygon.vertex[v].y += this_polygon.vertex[v - 1].y;
					}
					this_polygon.type++;
					got_corners = true;
				}
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in Java:
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				if (got_corners && memcmp(this_polygon.vertex[this_polygon.type-1], this_polygon.vertex[0], sizeof(GlobalMembersMouse.struct position)))
				{
					fprintf(stderr,"Polygon is not closed - adding extra vertex\n");
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					this_polygon.vertex = GlobalMembersAlloc.gp_realloc(this_polygon.vertex, (this_polygon.type + 1) * sizeof(GlobalMembersMouse.struct position), "polygon vertex");
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					memcpy(this_polygon.vertex[this_polygon.type], this_polygon.vertex[0], sizeof(GlobalMembersMouse.struct position));
					this_polygon.type++;
				}
				break;
				//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
				polygon_error:
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(this_polygon.vertex);
				this_polygon.vertex = DefineConstants.NULL;
				this_polygon.type = 0;
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognized polygon syntax");

			default:
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecoginized object type");
			} // End of object-specific options

			/* The rest of the options apply to any type of object */

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
				this_object.layer = 1;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
				this_object.layer = 0;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "behind") != 0)
			{
				this_object.layer = -1;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
			{
				if (tag < 0)
				{
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Invalid command - did you mean 'unset style rectangle'?");
				}
				else
				{
					this_object.lp_properties.l_type = DefineConstants.LT_DEFAULT;
					this_object.fillstyle.fillstyle = t_fillstyle.FS_DEFAULT.getValue();
				}
				got_fill = got_lt = true;
				GlobalMembersCommand.c_token++;
				continue;
			}

			/* Now parse the style options; default to whatever the global style is  */
			if (!got_fill)
			{
				fill_style_type default_style;
				if (this_object.object_type == DefineConstants.OBJ_RECTANGLE)
					default_style = GlobalMembersGadgets.default_rectangle.fillstyle;
				else
					default_style = GlobalMembersGadgets.default_fillstyle;

				if (new_obj != null)
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: parse_fillstyle(&this_object->fillstyle, default_style->fillstyle, default_style->filldensity, default_style->fillpattern, default_style->border_color);
					GlobalMembersMisc.parse_fillstyle(this_object.fillstyle, default_style.fillstyle, default_style.filldensity, default_style.fillpattern, new t_colorspec(default_style.border_color));
				else
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: parse_fillstyle(&this_object->fillstyle, this_object->fillstyle.fillstyle, this_object->fillstyle.filldensity, this_object->fillstyle.fillpattern, this_object->fillstyle.border_color);
					GlobalMembersMisc.parse_fillstyle(this_object.fillstyle, this_object.fillstyle.fillstyle, this_object.fillstyle.filldensity, this_object.fillstyle.fillpattern, new t_colorspec(this_object.fillstyle.border_color));
				if (GlobalMembersCommand.c_token != save_token)
				{
					got_fill = true;
					continue;
				}
			}

			/* Parse the colorspec */
			if (!got_lt)
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "fc") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fillc$olor") != 0)
				{
					this_object.lp_properties.use_palette = true;
					this_object.lp_properties.l_type = DefineConstants.LT_BLACK; // Anything but LT_DEFAULT
					GlobalMembersMisc.parse_colorspec(this_object.lp_properties.pm3d_color, DefineConstants.TC_FRAC);
					if (this_object.lp_properties.pm3d_color.type == DefineConstants.TC_DEFAULT)
						this_object.lp_properties.l_type = DefineConstants.LT_DEFAULT;
				}

				if (GlobalMembersCommand.c_token != save_token)
				{
					got_lt = true;
					continue;
				}
			}

			/* And linewidth */
			if (!got_lw)
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lw") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linew$idth") != 0)
				{
					GlobalMembersCommand.c_token++;
					lw = GlobalMembersParse.real_expression();
				}
				if (GlobalMembersCommand.c_token != save_token)
				{
					got_lw = true;
					continue;
				}
			}

			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognized or duplicate option");
		}

		if (got_lw)
			this_object.lp_properties.l_width = lw;

		if (got_center && got_corners)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Inconsistent options");

	}
	///#endif

	/* process 'set samples' command */
	///#endif
	public static void set_samples()
	{
		int tsamp1;
		int tsamp2;

		GlobalMembersCommand.c_token++;
		tsamp1 = Math.abs(GlobalMembersParse.int_expression());
		tsamp2 = tsamp1;
		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "',' expected");
			GlobalMembersCommand.c_token++;
			tsamp2 = Math.abs(GlobalMembersParse.int_expression());
		}
		if (tsamp1 < 2 || tsamp2 < 2)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "sampling rate must be > 1; sampling unchanged");
		else
		{
			surface_points f_3dp = GlobalMembersPlot3d.first_3dplot;

			GlobalMembersPlot3d.first_3dplot = DefineConstants.NULL;
			GlobalMembersPlot3d.sp_free(f_3dp);

			GlobalMembersGadgets.samples_1 = tsamp1;
			GlobalMembersGadgets.samples_2 = tsamp2;
		}
	}

	/* process 'set size' command */
	public static void set_size()
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersGadgets.xsize = 1.0F;
			GlobalMembersGadgets.ysize = 1.0F;
		}
		else
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sq$uare") != 0)
			{
				GlobalMembersGadgets.aspect_ratio = 1.0F;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ra$tio") != 0)
			{
				++GlobalMembersCommand.c_token;
				GlobalMembersGadgets.aspect_ratio = GlobalMembersParse.real_expression();
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nora$tio") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nosq$uare") != 0)
			{
				GlobalMembersGadgets.aspect_ratio = 0.0F;
				++GlobalMembersCommand.c_token;
			}

			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				GlobalMembersGadgets.xsize = GlobalMembersParse.real_expression();
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
				{
					GlobalMembersCommand.c_token++;
					GlobalMembersGadgets.ysize = GlobalMembersParse.real_expression();
				}
				else
				{
					GlobalMembersGadgets.ysize = GlobalMembersGadgets.xsize;
				}
			}
		}
		if (GlobalMembersGadgets.xsize <= 0 || GlobalMembersGadgets.ysize <= 0)
		{
			GlobalMembersGadgets.xsize = GlobalMembersGadgets.ysize = 1.0F;
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Illegal value for size");
		}
	}

	/* process 'set style' command */
	public static void set_style()
	{
		GlobalMembersCommand.c_token++;

		//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
		//ORIGINAL LINE: switch(lookup_table(&show_style_tbl[0],c_token))
		switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.show_style_tbl[0]), GlobalMembersCommand.c_token))
		{
		case SHOW_STYLE_DATA:
			GlobalMembersGadgets.data_style = GlobalMembersMisc.get_style();
			if (GlobalMembersGadgets.data_style == PLOT_STYLE.FILLEDCURVES)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: get_filledcurves_style_options(&filledcurves_opts_data);
				GlobalMembersMisc.get_filledcurves_style_options(new filledcurves_opts(GlobalMembersGadgets.filledcurves_opts_data));
				if (GlobalMembersGadgets.filledcurves_opts_data.opt_given == 0) // default value
					GlobalMembersGadgets.filledcurves_opts_data.closeto = filledcurves_opts_id.FILLEDCURVES_CLOSED.getValue();
			}
			break;
		case SHOW_STYLE_FUNCTION:
		{
			PLOT_STYLE temp_style = GlobalMembersMisc.get_style();

			if ((temp_style & e_PLOT_STYLE_FLAGS.PLOT_STYLE_HAS_ERRORBAR) || (temp_style == PLOT_STYLE.LABELPOINTS) || (temp_style == PLOT_STYLE.HISTOGRAMS))
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "style not usable for function plots, left unchanged");
			else
				GlobalMembersGadgets.func_style = temp_style;
			if (GlobalMembersGadgets.func_style == PLOT_STYLE.FILLEDCURVES)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: get_filledcurves_style_options(&filledcurves_opts_func);
				GlobalMembersMisc.get_filledcurves_style_options(new filledcurves_opts(GlobalMembersGadgets.filledcurves_opts_func));
				if (GlobalMembersGadgets.filledcurves_opts_func.opt_given == 0) // default value
					GlobalMembersGadgets.filledcurves_opts_func.closeto = filledcurves_opts_id.FILLEDCURVES_CLOSED.getValue();
			}
			break;
		}
		case SHOW_STYLE_LINE:
			GlobalMembersSet.set_linestyle();
			break;
		case SHOW_STYLE_FILLING:
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: parse_fillstyle(&default_fillstyle, default_fillstyle.fillstyle, default_fillstyle.filldensity, default_fillstyle.fillpattern, default_fillstyle.border_color);
			GlobalMembersMisc.parse_fillstyle(GlobalMembersGadgets.default_fillstyle, GlobalMembersGadgets.default_fillstyle.fillstyle, GlobalMembersGadgets.default_fillstyle.filldensity, GlobalMembersGadgets.default_fillstyle.fillpattern, new t_colorspec(GlobalMembersGadgets.default_fillstyle.border_color));
			break;
		case SHOW_STYLE_ARROW:
			GlobalMembersSet.set_arrowstyle();
			break;
			///#ifdef EAM_OBJECTS
		case SHOW_STYLE_RECTANGLE:
			GlobalMembersCommand.c_token++;
			GlobalMembersSet.set_obj(-2, DefineConstants.OBJ_RECTANGLE);
			break;
			///#endif
		case SHOW_STYLE_HISTOGRAM:
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: parse_histogramstyle(&histogram_opts,HT_CLUSTERED,histogram_opts.gap);
			GlobalMembersSet.parse_histogramstyle(new histogram_style(GlobalMembersGadgets.histogram_opts), histogram_type.HT_CLUSTERED, GlobalMembersGadgets.histogram_opts.gap);
			break;
		case SHOW_STYLE_INCREMENT:
			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
				GlobalMembersGadgets.prefer_line_styles = false;
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "u$serstyles") != 0)
				GlobalMembersGadgets.prefer_line_styles = true;
			GlobalMembersCommand.c_token++;
			break;
		default:
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting 'data', 'function', 'line', 'fill', 'rectangle', or 'arrow'");
		}
	}

	/* process 'set surface' command */
	public static void set_surface()
	{
		GlobalMembersCommand.c_token++;
		GlobalMembersGraph3d.draw_surface = true;
	}

	/* process 'set table' command */
	public static void set_table()
	{
		String tablefile;

		GlobalMembersCommand.c_token++;

		if (GlobalMembersGadgets.table_outfile != null)
		{
			fclose(GlobalMembersGadgets.table_outfile);
			GlobalMembersGadgets.table_outfile = DefineConstants.NULL;
		}

		if ((tablefile = GlobalMembersUtil.try_to_get_string()))
		{
			/* 'set table "foo"' creates a new output file */
			if (!(GlobalMembersGadgets.table_outfile = fopen(tablefile, "w")))
				GlobalMembersUtil.os_error(GlobalMembersCommand.c_token, "cannot open table output file");
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(tablefile);
		}

		GlobalMembersGadgets.table_mode = true;

	}

	/* process 'set terminal' comamnd */
	public static void set_terminal()
	{
		GlobalMembersCommand.c_token++;

		if (GlobalMembersTerm.multiplot)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "You can't change the terminal in multiplot mode");

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersTerm.list_terms();
			GlobalMembersUtil.screen_ok = false;
			return;
		}

		///#ifdef BACKWARDS_COMPATIBLE
		//    if (equals(c_token,"table")) {
		//	set_table();
		//	if (interactive)
		//	    int_warn(NO_CARET,"The command 'set term table' is deprecated.\n\t Please use 'set table \"outfile\"' instead.\n");
		//	return;
		//    } else
		//	table_mode = FALSE;
		///#endif

		/* `set term push' */
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "push") != 0)
		{
			GlobalMembersMisc.push_terminal(GlobalMembersPlot.interactive);
			GlobalMembersCommand.c_token++;
			return;
		} // set term push

		///#ifdef EXTENDED_COLOR_SPECS
		// /* each terminal is supposed to turn this on, probably
		//  * somewhere when the graphics is initialized */
		//    supply_extended_color_specs = 0;
		///#endif
		///#ifdef USE_MOUSE
		GlobalMembersMouse.event_reset((Object)1); // cancel zoombox etc.
		///#endif
		GlobalMembersTerm.term_reset();

		/* `set term pop' */
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "pop") != 0)
		{
			GlobalMembersMisc.pop_terminal();
			GlobalMembersCommand.c_token++;
			return;
		} // set term pop

		/* `set term <normal terminal>' */
		GlobalMembersTerm.term = 0; // in case set_term() fails
		GlobalMembersTerm.term = GlobalMembersTerm.set_term();
		/* get optional mode parameters
		 * not all drivers reset the option string before
		 * strcat-ing to it, so we reset it for them
		 */
		GlobalMembersTerm.term_options = 0;
		if (GlobalMembersTerm.term != null)
			//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
			//	(*GlobalMembersTerm.term.options)();
			if (GlobalMembersPlot.interactive && GlobalMembersTerm.term_options != null)
				fprintf(stderr,"Options are '%s'\n",GlobalMembersTerm.term_options);
	}

	/* 
	 * Accept a single terminal option to apply to the current terminal if possible.
	 * If the current terminal cannot support this option, we silently ignore it.
	 * Only reasonably common terminal options are supported.
	 *
	 * If necessary, the code in term->options() can detect that it was called
	 * from here because in this case (c_token == 2), whereas when called from 
	 * 'set term foo ...' it will see (c_token == 3).
	 */

	public static void set_termoptions()
	{
		boolean ok_to_call_terminal = false;
		int save_end_of_line = GlobalMembersCommand.num_tokens;
		GlobalMembersCommand.c_token++;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersTerm.term == null)
			return;

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "enh$anced") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noenh$anced") != 0)
		{
			GlobalMembersCommand.num_tokens = ((GlobalMembersCommand.num_tokens) < (GlobalMembersCommand.c_token + 1) ? (GlobalMembersCommand.num_tokens) : (GlobalMembersCommand.c_token + 1));
			if (GlobalMembersTerm.term.enhanced_open)
				ok_to_call_terminal = true;
			else
				GlobalMembersCommand.c_token++;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "font") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "fname") != 0)
		{
			GlobalMembersCommand.num_tokens = ((GlobalMembersCommand.num_tokens) < (GlobalMembersCommand.c_token + 2) ? (GlobalMembersCommand.num_tokens) : (GlobalMembersCommand.c_token + 2));
			if (GlobalMembersTerm.term.set_font)
				ok_to_call_terminal = true;
			else
				GlobalMembersCommand.c_token += 2;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lw") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linew$idth") != 0)
		{
			if (GlobalMembersTerm.term.flags & DefineConstants.TERM_LINEWIDTH != 0)
				ok_to_call_terminal = true;
			else
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersParse.real_expression(); // Silently ignore the request
			}
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "dash$ed") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "solid") != 0)
		{
			if (GlobalMembersTerm.term.flags & DefineConstants.TERM_CAN_DASH != 0)
				ok_to_call_terminal = true;
			else
				GlobalMembersCommand.c_token++;
		}
		else if (!strcmp(GlobalMembersTerm.term.name,"gif") && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "delay") != 0 && GlobalMembersCommand.num_tokens == 4)
		{
			ok_to_call_terminal = true;
		}
		else
		{
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "This option cannot be changed using 'set termoption'");
		}
		if (ok_to_call_terminal)
		{
			GlobalMembersTerm.term_options = 0;
			(GlobalMembersTerm.term.options)();
		}
		GlobalMembersCommand.num_tokens = save_end_of_line;
	}

	/* process 'set tics' command */
	public static void set_tics()
	{
		int i = 0;
		boolean axisset = false;
		boolean mirror_opt = false; // set to true if (no)mirror option specified)

		++GlobalMembersCommand.c_token;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
				GlobalMembersAxis.axis_array[i].tic_in = true;
		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ax$is") != 0)
			{
				axisset = true;
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
				{
					GlobalMembersAxis.axis_array[i].ticmode &= ~DefineConstants.TICS_ON_BORDER;
					GlobalMembersAxis.axis_array[i].ticmode |= DefineConstants.TICS_ON_AXIS;
				}
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bo$rder") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
				{
					GlobalMembersAxis.axis_array[i].ticmode &= ~DefineConstants.TICS_ON_AXIS;
					GlobalMembersAxis.axis_array[i].ticmode |= DefineConstants.TICS_ON_BORDER;
				}
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "mi$rror") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					GlobalMembersAxis.axis_array[i].ticmode |= DefineConstants.TICS_MIRROR;
				mirror_opt = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomi$rror") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					GlobalMembersAxis.axis_array[i].ticmode &= ~DefineConstants.TICS_MIRROR;
				mirror_opt = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "in$wards") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					GlobalMembersAxis.axis_array[i].tic_in = true;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "out$wards") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					GlobalMembersAxis.axis_array[i].tic_in = false;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sc$ale") != 0)
			{
				++GlobalMembersCommand.c_token;
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
				{
					for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					{
						GlobalMembersAxis.axis_array[i].ticscale = 1.0;
						GlobalMembersAxis.axis_array[i].miniticscale = 0.5;
					}
					++GlobalMembersCommand.c_token;
				}
				else
				{
					double lticscale;
					double lminiticscale;
					lticscale = GlobalMembersParse.real_expression();
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
					{
						++GlobalMembersCommand.c_token;
						lminiticscale = GlobalMembersParse.real_expression();
					}
					else
						lminiticscale = 0.5 * lticscale;
					for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					{
						GlobalMembersAxis.axis_array[i].ticscale = lticscale;
						GlobalMembersAxis.axis_array[i].miniticscale = lminiticscale;
					}
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ro$tate") != 0)
			{
				GlobalMembersAxis.axis_array[i].tic_rotate = DefineConstants.TEXT_VERTICAL;
				++GlobalMembersCommand.c_token;
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "by") != 0)
				{
					int langle;
					++GlobalMembersCommand.c_token;
					langle = GlobalMembersParse.int_expression();
					for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
						GlobalMembersAxis.axis_array[i].tic_rotate = langle;
				}
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noro$tate") != 0)
			{
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					GlobalMembersAxis.axis_array[i].tic_rotate = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "off$set") != 0)
			{
				position lpos = new position();
				++GlobalMembersCommand.c_token;
				GlobalMembersAxis.get_position_default(lpos, position_type.character);
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
					//ORIGINAL LINE: axis_array[i].ticdef.offset = lpos;
					GlobalMembersAxis.axis_array[i].ticdef.offset.copyFrom(lpos);
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nooff$set") != 0)
			{
				position tics_nooffset = new position(position_type.character, position_type.character, position_type.character, 0., 0., 0.);
				++GlobalMembersCommand.c_token;
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
					//ORIGINAL LINE: axis_array[i].ticdef.offset = tics_nooffset;
					GlobalMembersAxis.axis_array[i].ticdef.offset.copyFrom(tics_nooffset);
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "format") != 0)
			{
				GlobalMembersSet.set_format();
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "f$ont") != 0)
			{
				++GlobalMembersCommand.c_token;
				/* Make sure they've specified a font */
				if (!(GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected font");
				else
				{
					byte lfont = GlobalMembersUtil.try_to_get_string();
					for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					{
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(GlobalMembersAxis.axis_array[i].ticdef.font);
						GlobalMembersAxis.axis_array[i].ticdef.font = GlobalMembersUtil.gp_strdup(lfont);
					}
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(lfont);
				}
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "tc") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "text$color") != 0)
			{
				t_colorspec lcolor = new t_colorspec();
				GlobalMembersMisc.parse_colorspec(lcolor, DefineConstants.TC_FRAC);
				for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
					//ORIGINAL LINE: axis_array[i].ticdef.textcolor = lcolor;
					GlobalMembersAxis.axis_array[i].ticdef.textcolor.copyFrom(lcolor);
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
			{
				GlobalMembersAxis.grid_layer = 1;
				++GlobalMembersCommand.c_token;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
			{
				GlobalMembersAxis.grid_layer = 0;
				++GlobalMembersCommand.c_token;
			}
			else if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "extraneous arguments in set tics");
			}
		}

		/* if tics are off and not set by axis, reset to default (border) */
		for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
		{
			if (((GlobalMembersAxis.axis_array[i].ticmode & DefineConstants.TICS_MASK) == DefineConstants.NO_TICS) && (!axisset))
			{
				if ((i == AXIS_INDEX.SECOND_X_AXIS.getValue()) || (i == AXIS_INDEX.SECOND_Y_AXIS.getValue()))
					continue; // don't switch on secondary axes by default
				GlobalMembersAxis.axis_array[i].ticmode = DefineConstants.TICS_ON_BORDER;
				if ((mirror_opt == false) && ((i == AXIS_INDEX.FIRST_X_AXIS.getValue()) || (i == AXIS_INDEX.FIRST_Y_AXIS.getValue()) || (i == AXIS_INDEX.COLOR_AXIS.getValue())))
				{
					GlobalMembersAxis.axis_array[i].ticmode |= DefineConstants.TICS_MIRROR;
				}
			}
		}
	}

	/* process 'set ticscale' command */
	public static void set_ticscale()
	{
		double lticscale;
		double lminiticscale;
		int i;

		GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "Deprecated syntax - please use 'set tics scale' keyword");

		++GlobalMembersCommand.c_token;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			lticscale = 1.0;
			lminiticscale = 0.5;
		}
		else
		{
			lticscale = GlobalMembersParse.real_expression();
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				lminiticscale = lticscale * 0.5;
			}
			else
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
					++GlobalMembersCommand.c_token;
				lminiticscale = GlobalMembersParse.real_expression();
			}
		}
		for (i = 0; i < DefineConstants.AXIS_ARRAY_SIZE; ++i)
		{
			GlobalMembersAxis.axis_array[i].ticscale = lticscale;
			GlobalMembersAxis.axis_array[i].miniticscale = lminiticscale;
		}
	}

	/* Process 'set timefmt' command */
	/* HBB 20000507: changed this to a per-axis setting. I.e. you can now
	 * have separate timefmt parse strings, different axes */
	public static void set_timefmt()
	{
		int axis;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* set all axes to default */
			for (axis = 0; axis < DefineConstants.AXIS_ARRAY_SIZE; axis++)
				GlobalMembersAxis.axis_array[axis].timefmt = DefineConstants.TIMEFMT;
		}
		else
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: if ((axis = lookup_table(axisname_tbl, c_token)) >= 0)
			if ((axis = GlobalMembersTables.lookup_table(new gen_table(GlobalMembersAxis.axisname_tbl), GlobalMembersCommand.c_token)) >= 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
				{
					GlobalMembersUtil.quote_str(GlobalMembersAxis.axis_array[axis].timefmt, GlobalMembersCommand.c_token, DefineConstants.MAX_ID_LEN);
					GlobalMembersCommand.c_token++;
				}
				else
				{
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "time format string expected");
				}
			}
			else if (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
			{
				/* set the given parse string for all current timedata axes: */
				for (axis = 0; axis < DefineConstants.AXIS_ARRAY_SIZE; axis++)
					GlobalMembersUtil.quote_str(GlobalMembersAxis.axis_array[axis].timefmt, GlobalMembersCommand.c_token, DefineConstants.MAX_ID_LEN);
				GlobalMembersCommand.c_token++;
			}
			else
			{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "time format string expected");
			}
		}
	}

	/* process 'set timestamp' command */
	public static void set_timestamp()
	{
		boolean got_format = false;
		String new_Renamed;

		GlobalMembersCommand.c_token++;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "t$op") != 0)
			{
				GlobalMembersGadgets.timelabel_bottom = false;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "b$ottom") != 0)
			{
				GlobalMembersGadgets.timelabel_bottom = true;
				GlobalMembersCommand.c_token++;
				continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "r$otate") != 0)
			{
				GlobalMembersGadgets.timelabel_rotate = true;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "n$orotate") != 0)
			{
				GlobalMembersGadgets.timelabel_rotate = false;
				GlobalMembersCommand.c_token++;
				continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "off$set") != 0)
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersAxis.get_position_default((GlobalMembersGadgets.timelabel.offset), position_type.character);
				continue;
			}

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "font") != 0)
			{
				GlobalMembersCommand.c_token++;
				new() = GlobalMembersUtil.try_to_get_string();
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(GlobalMembersGadgets.timelabel.font);
				GlobalMembersGadgets.timelabel.font = new_Renamed;
				continue;
			}

			if (!got_format && ((new() = GlobalMembersUtil.try_to_get_string())))
			{
				/* we have a format string */
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(GlobalMembersGadgets.timelabel.text);
				GlobalMembersGadgets.timelabel.text = new_Renamed;
				got_format = true;
				continue;
			}

			///#ifdef BACKWARDS_COMPATIBLE
			// /* The "font" keyword is new (v4.1), for backward compatibility we don't enforce it */
			//	if (!END_OF_COMMAND && ((new = try_to_get_string()))) {
			//	    free(timelabel.font);
			//	    timelabel.font = new;
			//	    continue;
			//	}
			// /* The "offset" keyword is new (v4.1); for backward compatibility we don't enforce it */
			//	get_position_default(&(timelabel.offset),character);
			///#else
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "unrecognized option");
			///#endif

		}

		if (!(GlobalMembersGadgets.timelabel.text))
			GlobalMembersGadgets.timelabel.text = GlobalMembersUtil.gp_strdup(DefineConstants.DEFAULT_TIMESTAMP_FORMAT);

	}

	/* process 'set view' command */
	public static void set_view()
	{
		int i;
		boolean was_comma = true;
		final String errmsg1 = "rot_%c must be in [0:%d] degrees range; view unchanged";
		final String errmsg2 = "%sscale must be > 0; view unchanged";
		double[] local_vals = new double[4];

		GlobalMembersCommand.c_token++;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "map") != 0)
		{
			GlobalMembersGraph3d.splot_map = true;
			GlobalMembersCommand.c_token++;
			return;
		};

		if (GlobalMembersGraph3d.splot_map == true)
		{
			GlobalMembersCommand.splot_map_deactivate();
			GlobalMembersGraph3d.splot_map = false; // default is no map
		}

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "equal$_axes") != 0)
		{
			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "xy") != 0)
			{
				GlobalMembersGadgets.aspect_ratio_3D = 2;
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "xyz") != 0)
			{
				GlobalMembersGadgets.aspect_ratio_3D = 3;
				GlobalMembersCommand.c_token++;
			}
			return;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noequal$_axes") != 0)
		{
			GlobalMembersGadgets.aspect_ratio_3D = 0;
			GlobalMembersCommand.c_token++;
			return;
		}

		local_vals[0] = GlobalMembersGraph3d.surface_rot_x;
		local_vals[1] = GlobalMembersGraph3d.surface_rot_z;
		local_vals[2] = GlobalMembersGraph3d.surface_scale;
		local_vals[3] = GlobalMembersGraph3d.surface_zscale;
		for (i = 0; i < 4 && !(GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0);)
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
			{
				if (was_comma)
					i++;
				was_comma = true;
				GlobalMembersCommand.c_token++;
			}
			else
			{
				if (!was_comma)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "',' expected");
				local_vals[i] = GlobalMembersParse.real_expression();
				i++;
				was_comma = false;
			}
		}

		if (local_vals[0] < 0 || local_vals[0] > 180)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, errmsg1, 'x', 180);
		if (local_vals[1] < 0 || local_vals[1] > 360)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, errmsg1, 'z', 360);
		if (local_vals[2] < 1e-6)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, errmsg2, "");
		if (local_vals[3] < 1e-6)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, errmsg2, "z");

		GlobalMembersGraph3d.surface_rot_x = local_vals[0];
		GlobalMembersGraph3d.surface_rot_z = local_vals[1];
		GlobalMembersGraph3d.surface_scale = local_vals[2];
		GlobalMembersGraph3d.surface_zscale = local_vals[3];

	}

	/* process 'set zero' command */
	public static void set_zero()
	{
		value a = new value();
		GlobalMembersCommand.c_token++;
		GlobalMembersGadgets.zero = GlobalMembersEval.magnitude(GlobalMembersParse.const_express(a));
	}

	/* process 'set {x|y|z|x2|y2}data' command */
	public static void set_timedata(AXIS_INDEX axis)
	{
		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			GlobalMembersAxis.axis_array[axis.getValue()].is_timedata = false;
		}
		else
		{
			if ((GlobalMembersAxis.axis_array[axis.getValue()].is_timedata = GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "t$ime")))
				GlobalMembersCommand.c_token++;
		}
	}
	public static void set_range(AXIS_INDEX axis)
	{
		GlobalMembersCommand.c_token++;

		if (GlobalMembersGraph3d.splot_map != 0)
			GlobalMembersCommand.splot_map_deactivate();

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "re$store") != 0) // ULIG
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersAxis.axis_array[axis.getValue()].set_min = GlobalMembersAxis.get_writeback_min(axis);
			GlobalMembersAxis.axis_array[axis.getValue()].set_max = GlobalMembersAxis.get_writeback_max(axis);
			GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale = e_autoscale.AUTOSCALE_NONE;
		}
		else
		{
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "[") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting '[' or 'restore'");
			GlobalMembersCommand.c_token++;
			GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale = GlobalMembersAxis.load_range(axis, GlobalMembersAxis.axis_array[axis.getValue()].set_min, GlobalMembersAxis.axis_array[axis.getValue()].set_max, GlobalMembersAxis.axis_array[axis.getValue()].set_autoscale);
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "]") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting ']'");
			GlobalMembersCommand.c_token++;
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rev$erse") != 0)
			{
				++GlobalMembersCommand.c_token;
				GlobalMembersAxis.axis_array[axis.getValue()].range_flags |= DefineConstants.RANGE_REVERSE;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "norev$erse") != 0)
			{
				++GlobalMembersCommand.c_token;
				GlobalMembersAxis.axis_array[axis.getValue()].range_flags &= ~DefineConstants.RANGE_REVERSE;
			}
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "wr$iteback") != 0)
			{
				++GlobalMembersCommand.c_token;
				GlobalMembersAxis.axis_array[axis.getValue()].range_flags |= DefineConstants.RANGE_WRITEBACK;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nowri$teback") != 0)
			{
				++GlobalMembersCommand.c_token;
				GlobalMembersAxis.axis_array[axis.getValue()].range_flags &= ~DefineConstants.RANGE_WRITEBACK;
			}
		}
		if (GlobalMembersGraph3d.splot_map != 0)
			GlobalMembersCommand.splot_map_activate();
	}

	/* process 'set xyplane' command */
	/* is datatype 'time' relevant here ? */
	public static void set_xyplane()
	{
		if (GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, "at") != 0)
		{
			GlobalMembersCommand.c_token++;
			GlobalMembersGraph3d.xyplane.z = GlobalMembersParse.real_expression();
			GlobalMembersGraph3d.xyplane.absolute = true;
			return;
		}
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rel$ative") == 0)
		{
			GlobalMembersCommand.c_token--;
			/* int_warn(NO_CARET, "deprecated syntax"); */
		}
		GlobalMembersSet.set_ticslevel();
	}

	/* process 'set ticslevel' command */
	/* is datatype 'time' relevant here ? */
	public static void set_ticslevel()
	{
		GlobalMembersCommand.c_token++;
		GlobalMembersGraph3d.xyplane.z = GlobalMembersParse.real_expression();
		GlobalMembersGraph3d.xyplane.absolute = false;
	}

	/* process 'set {xyz}zeroaxis' command */
	public static void set_zeroaxis(AXIS_INDEX axis)
	{

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersAxis.axis_array[axis.getValue()].zeroaxis.l_type = -1;
		else
		{
			int old_token = GlobalMembersCommand.c_token;
			GlobalMembersAxis.axis_array[axis.getValue()].zeroaxis.l_type = DefineConstants.LT_AXIS;
			GlobalMembersMisc.lp_parse(GlobalMembersAxis.axis_array[axis.getValue()].zeroaxis, true, false);
			if (old_token == GlobalMembersCommand.c_token)
				GlobalMembersAxis.axis_array[axis.getValue()].zeroaxis.l_type = GlobalMembersParse.int_expression() - 1;
		}

	}

	/* process 'set zeroaxis' command */
	public static void set_allzeroaxis()
	{
		GlobalMembersSet.set_zeroaxis(AXIS_INDEX.FIRST_X_AXIS);
		GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].zeroaxis = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].zeroaxis;
		///#ifndef BACKWARDS_COMPATIBLE
		GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].zeroaxis = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].zeroaxis;
		///#endif
	}

	/* process a 'set {x/y/z}label command */
	/* set {x/y/z}label {label_text} {offset {x}{,y}} {<fontspec>} {<textcolor>} */


	/******** Local functions ********/

	public static void set_xyzlabel(text_label label)
	{
		String text = DefineConstants.NULL;

		GlobalMembersCommand.c_token++;
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0) // no label specified
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(label.text);
			label.text = DefineConstants.NULL;
			return;
		}

		GlobalMembersSet.parse_label_options(label);

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			text = GlobalMembersUtil.try_to_get_string();
			if (text != null)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(label.text);
				label.text = text;
			}
			///#ifdef BACKWARDS_COMPATIBLE
			//	if (isanumber(c_token) || equals(c_token, "-")) {
			// /* Parse offset with missing keyword "set xlabel 'foo' 1,2 "*/
			//	    get_position_default(&(label->offset),character);
			//	}
			///#endif
		}

		GlobalMembersSet.parse_label_options(label);

	}

	/* For set [xy]tics... command */
	public static void load_tics(AXIS_INDEX axis)
	{
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "(") != 0) // set : TIC_USER
		{
			if (GlobalMembersUtil.equals(++GlobalMembersCommand.c_token, ")") != 0)
				GlobalMembersCommand.c_token++;
			else
				GlobalMembersSet.load_tic_user(axis);
		} // series : TIC_SERIES
		else
		{
			GlobalMembersSet.load_tic_series(axis);
		}
	}

	/* load TIC_USER definition */
	/* (tic[,tic]...)
	 * where tic is ["string"] value [level]
	 * Left paren is already scanned off before entry.
	 */
	public static void load_tic_user(AXIS_INDEX axis)
	{
		String ticlabel;
		double ticposition;

		/* Free any old tic labels */
		if (!GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix && GlobalMembersParse.iteration == 0)
		{
			GlobalMembersSet.free_marklist(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user);
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user = DefineConstants.NULL;
		}

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			int ticlevel = 0;
			int save_token;
			/* syntax is  (  {'format'} value {level} {, ...} )
			 * but for timedata, the value itself is a string, which
			 * complicates things somewhat
			 */

			/* has a string with it? */
			save_token = GlobalMembersCommand.c_token;
			ticlabel = GlobalMembersUtil.try_to_get_string();
			if (ticlabel != null && GlobalMembersAxis.axis_array[axis.getValue()].is_timedata && (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ")") != 0))
			{
				GlobalMembersCommand.c_token = save_token;
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(ticlabel);
				ticlabel = DefineConstants.NULL;
			}

			/* in any case get the value */
			do
			{
				(ticposition) = 0;
				do
				{
					if (((DefineConstants.FIRST_AXES) >= 0) && (GlobalMembersAxis.axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					{
						tm tm = new tm();
						byte ss = GlobalMembersUtil.try_to_get_string();
						if (GlobalMembersTime.gstrptime(ss, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, tm) != null)
							(ticposition) = (double) GlobalMembersTime.gtimegm(tm);
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(ss);
					}
					else
					{
						(ticposition) = GlobalMembersParse.real_expression();
					}
				} while (0);
			} while (0);

			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ")") == 0)
			{
				ticlevel = GlobalMembersParse.int_expression(); // tic level
			}

			/* add to list */
			GlobalMembersAxis.add_tic_user(axis, ticlabel, ticposition, ticlevel);
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(ticlabel);

			/* expect "," or ")" here */
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
				GlobalMembersCommand.c_token++; // loop again
			else
				break; // hopefully ")"
		}

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ")") == 0)
		{
			GlobalMembersSet.free_marklist(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user);
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user = DefineConstants.NULL;
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting right parenthesis )");
		}
		GlobalMembersCommand.c_token++;
	}

	/* load TIC_SERIES definition */
	/* [start,]incr[,end] */
	public static void load_tic_series(AXIS_INDEX axis)
	{
		double start;
		double incr;
		double end;
		int incr_token;

		ticdef tdef = GlobalMembersAxis.axis_array[axis.getValue()].ticdef;

		do
		{
			(start) = 0;
			do
			{
				if (((DefineConstants.FIRST_AXES) >= 0) && (GlobalMembersAxis.axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
				{
					tm tm = new tm();
					byte ss = GlobalMembersUtil.try_to_get_string();
					if (GlobalMembersTime.gstrptime(ss, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, tm) != null)
						(start) = (double) GlobalMembersTime.gtimegm(tm);
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(ss);
				}
				else
				{
					(start) = GlobalMembersParse.real_expression();
				}
			} while (0);
		} while (0);

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
		{
			/* only step specified */
			incr = start;
			start = -DefineConstants.VERYLARGE;
			end = DefineConstants.VERYLARGE;
		}
		else
		{
			GlobalMembersCommand.c_token++;
			incr_token = GlobalMembersCommand.c_token;
			do
			{
				(incr) = 0;
				do
				{
					if (((DefineConstants.FIRST_AXES) >= 0) && (GlobalMembersAxis.axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
					{
						tm tm = new tm();
						byte ss = GlobalMembersUtil.try_to_get_string();
						if (GlobalMembersTime.gstrptime(ss, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, tm) != null)
							(incr) = (double) GlobalMembersTime.gtimegm(tm);
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(ss);
					}
					else
					{
						(incr) = GlobalMembersParse.real_expression();
					}
				} while (0);
			} while (0);

			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			{
				/* only step and increment specified */
				end = DefineConstants.VERYLARGE;
			}
			else
			{
				GlobalMembersCommand.c_token++;
				do
				{
					(end) = 0;
					do
					{
						if (((DefineConstants.FIRST_AXES) >= 0) && (GlobalMembersAxis.axis_array[(DefineConstants.FIRST_AXES) + (axis)].is_timedata) && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
						{
							tm tm = new tm();
							byte ss = GlobalMembersUtil.try_to_get_string();
							if (GlobalMembersTime.gstrptime(ss, GlobalMembersAxis.axis_array[axis.getValue()].timefmt, tm) != null)
								(end) = (double) GlobalMembersTime.gtimegm(tm);
							//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
							free(ss);
						}
						else
						{
							(end) = GlobalMembersParse.real_expression();
						}
					} while (0);
				} while (0);
			}

			if (start < end && incr <= 0)
				GlobalMembersBf_test.int_error(incr_token, "increment must be positive");
			if (start > end && incr >= 0)
				GlobalMembersBf_test.int_error(incr_token, "increment must be negative");
			if (start > end)
			{
				/* put in order */
				double numtics = Math.floor((end * (1 + DefineConstants.SIGNIF) - start) / incr);

				end = start;
				start = end + numtics * incr;
				incr = -incr;
			}
		}

		if (!tdef.def.mix) // remove old list
		{
			GlobalMembersSet.free_marklist(tdef.def.user);
			tdef.def.user = DefineConstants.NULL;
		}
		tdef.type = en_ticseries_type.TIC_SERIES;
		tdef.def.series.start = start;
		tdef.def.series.incr = incr;
		tdef.def.series.end = end;
	}

	/* 'set style line' command */
	/* set style line {tag} {linetype n} {linewidth x} {pointtype n} {pointsize x} */

	public static void set_linestyle()
	{
		linestyle_def this_linestyle = DefineConstants.NULL;
		linestyle_def new_linestyle = DefineConstants.NULL;
		linestyle_def prev_linestyle = DefineConstants.NULL;
		lp_style_type loc_lp = new lp_style_type(0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0});
		int tag;

		GlobalMembersCommand.c_token++;

		/* get tag */
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || ((tag = GlobalMembersParse.int_expression()) <= 0))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be > zero");

		/* Default style is based on linetype with the same tag id */
		loc_lp.l_type = tag - 1;
		loc_lp.p_type = tag - 1;

		/* Check if linestyle is already defined */
		if (GlobalMembersGadgets.first_linestyle != DefineConstants.NULL) // skip to last linestyle
		{
			for (this_linestyle = GlobalMembersGadgets.first_linestyle; this_linestyle != DefineConstants.NULL; prev_linestyle = this_linestyle, this_linestyle = this_linestyle.next)
				/* is this the linestyle we want? */
				if (tag <= this_linestyle.tag)
					break;
		}

		if (this_linestyle == DefineConstants.NULL || tag != this_linestyle.tag)
		{
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			new_linestyle = GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct linestyle_def), "linestyle");
			if (prev_linestyle != DefineConstants.NULL)
				prev_linestyle.next = new_linestyle; // add it to end of list
			else
				GlobalMembersGadgets.first_linestyle = new_linestyle; // make it start of list
			new_linestyle.tag = tag;
			new_linestyle.next = this_linestyle;
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: new_linestyle->lp_properties = loc_lp;
			new_linestyle.lp_properties.copyFrom(loc_lp);
			this_linestyle = new_linestyle;
		}

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
		{
			GlobalMembersSet.delete_linestyle(GlobalMembersGadgets.first_linestyle, prev_linestyle, this_linestyle);
			GlobalMembersCommand.c_token++;
		}
		else
			/* pick up a line spec; dont allow ls, do allow point type */
			GlobalMembersMisc.lp_parse(this_linestyle.lp_properties, false, true);

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Extraneous arguments to set style line");

	}

	/* ======================================================== */
	/* process a 'set arrowstyle' command */
	/* set style arrow {tag} {nohead|head|backhead|heads} {size l,a{,b}} {{no}filled} {linestyle...} {layer n}*/
	public static void set_arrowstyle()
	{
		arrowstyle_def this_arrowstyle = DefineConstants.NULL;
		arrowstyle_def new_arrowstyle = DefineConstants.NULL;
		arrowstyle_def prev_arrowstyle = DefineConstants.NULL;
		arrow_style_type loc_arrow = new arrow_style_type();
		int tag;

		GlobalMembersGadgets.default_arrow_style(loc_arrow);

		GlobalMembersCommand.c_token++;

		/* get tag */
		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* must be a tag expression! */
			tag = GlobalMembersParse.int_expression();
			if (tag <= 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "tag must be > zero");
		}
		else
			tag = GlobalMembersSet.assign_arrowstyle_tag(); // default next tag

		/* search for arrowstyle */
		if (GlobalMembersGadgets.first_arrowstyle != DefineConstants.NULL) // skip to last arrowstyle
		{
			for (this_arrowstyle = GlobalMembersGadgets.first_arrowstyle; this_arrowstyle != DefineConstants.NULL; prev_arrowstyle = this_arrowstyle, this_arrowstyle = this_arrowstyle.next)
				/* is this the arrowstyle we want? */
				if (tag <= this_arrowstyle.tag)
					break;
		}

		if (this_arrowstyle == DefineConstants.NULL || tag != this_arrowstyle.tag)
		{
			/* adding the arrowstyle */
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			new_arrowstyle = (GlobalMembersMouse.struct arrowstyle_def *) GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct arrowstyle_def), "arrowstyle");
			GlobalMembersGadgets.default_arrow_style((new_arrowstyle.arrow_properties));
			if (prev_arrowstyle != DefineConstants.NULL)
				prev_arrowstyle.next = new_arrowstyle; // add it to end of list
			else
				GlobalMembersGadgets.first_arrowstyle = new_arrowstyle; // make it start of list
			new_arrowstyle.tag = tag;
			new_arrowstyle.next = this_arrowstyle;
			this_arrowstyle = new_arrowstyle;
		}

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_arrowstyle->arrow_properties = loc_arrow;
			this_arrowstyle.arrow_properties.copyFrom(loc_arrow);
		else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_arrowstyle->arrow_properties = loc_arrow;
			this_arrowstyle.arrow_properties.copyFrom(loc_arrow);
			GlobalMembersCommand.c_token++;
		}
		else
			/* pick up a arrow spec : dont allow arrowstyle */
			GlobalMembersMisc.arrow_parse(this_arrowstyle.arrow_properties, false);

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "extraneous or out-of-order arguments in set arrowstyle");

	}

	/* assign a new arrowstyle tag
	 * arrowstyles are kept sorted by tag number, so this is easy
	 * returns the lowest unassigned tag number
	 */
	public static int assign_arrowstyle_tag()
	{
		arrowstyle_def this_Renamed;
		int last = 0; // previous tag value

		for (this_Renamed = GlobalMembersGadgets.first_arrowstyle; this_Renamed != DefineConstants.NULL; this_Renamed = this_Renamed.next)
			if (this_Renamed.tag == last + 1)
				last++;
			else
				break;

		return (last + 1);
	}

	/* return 1 if format looks like a numeric format
	 * ie more than one %{efg}, or %something-else
	 */
	/* FIXME HBB 20000430: as coded, this will only check the *first*
	 * format string, not all of them. */
	public static int looks_like_numeric(String format)
	{
		if (!(format = tangible.StringFunctions.strChr(format, '%')))
			return 0;

		while (++format && (format.equals(' ') || format.equals('-') || format.equals('+') || format.equals('#')))
			; // do nothing

		while (Character.isDigit((byte) format) || format.equals('.'))
			++format;

		return (format.equals('f') || format.equals('g') || format.equals('e'));
	}

	/*********** Support functions for set_command ***********/

	/*
	 * The set.c PROCESS_TIC_PROP macro has the following characteristics:
	 *   (a) options must in the correct order
	 *   (b) 'set xtics' (no option) resets only the interval (FREQ)
	 *       {it will also negate NO_TICS, see (d)}
	 *   (c) changing any property also resets the interval to automatic
	 *   (d) set no[xy]tics; set [xy]tics changes border to nomirror, rather
	 *       than to the default, mirror.
	 *   (e) effect of 'set no[]tics; set []tics border ...' is compiler
	 *       dependent;  if '!(TICS)' is evaluated first, 'border' is an
	 *       undefined variable :-(
	 *
	 * This function replaces the macro, and introduces a new option
	 * 'au$tofreq' to give somewhat different behaviour:
	 *   (a) no change
	 *   (b) 'set xtics' (no option) only affects NO_TICS;  'autofreq' resets
	 *       the interval calulation to automatic
	 *   (c) the interval mode is not affected by changing some other option
	 *   (d) if NO_TICS, set []tics will restore defaults (borders, mirror
	 *       where appropriate)
	 *   (e) if (NO_TICS), border option is processed.
	 *
	 *  A 'default' option could easily be added to reset all options to
	 *  the initial values - mostly book-keeping.
	 *
	 *  To retain tic properties after setting no[]tics may also be
	 *  straightforward (save value as negative), but requires changes
	 *  in other code ( e.g. for  'if (xtics)', use 'if (xtics > 0)'
	 */

	/*    generates PROCESS_TIC_PROP strings from tic_side, e.g. "x2"
	 *  STRING, NOSTRING, MONTH, NOMONTH, DAY, NODAY, MINISTRING, NOMINI
	 *  "nox2t$ics"     "nox2m$tics"  "nox2d$tics"    "nomx2t$ics"
	 */

	public static int set_tic_prop(AXIS_INDEX axis)
	{
		int match = 0; // flag, set by matching a tic command
		String nocmd = new String(new char[12]); // fill w/ "no"+axis_name+suffix
		String cmdptr;
		String sfxptr;

		() strcpy(nocmd, "no");
		cmdptr = nocmd.charAt(2);
		() strcpy(cmdptr, GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		sfxptr = nocmd.charAt(nocmd.length());
		() strcpy(sfxptr, "t$ics"); // STRING

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, cmdptr) != 0)
		{
			boolean axisset = false;
			boolean mirror_opt = false; // set to true if (no)mirror option specified)
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix = false;
			match = 1;
			++GlobalMembersCommand.c_token;
			do
			{
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ax$is") != 0)
				{
					axisset = true;
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode &= ~DefineConstants.TICS_ON_BORDER;
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode |= DefineConstants.TICS_ON_AXIS;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bo$rder") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode &= ~DefineConstants.TICS_ON_AXIS;
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode |= DefineConstants.TICS_ON_BORDER;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "mi$rror") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode |= DefineConstants.TICS_MIRROR;
					mirror_opt = true;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nomi$rror") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode &= ~DefineConstants.TICS_MIRROR;
					mirror_opt = true;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "in$wards") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].tic_in = true;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "out$wards") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].tic_in = false;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sc$ale") != 0)
				{
					++GlobalMembersCommand.c_token;
					if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
					{
						GlobalMembersAxis.axis_array[axis.getValue()].ticscale = 1.0;
						GlobalMembersAxis.axis_array[axis.getValue()].miniticscale = 0.5;
						++GlobalMembersCommand.c_token;
					}
					else
					{
						GlobalMembersAxis.axis_array[axis.getValue()].ticscale = GlobalMembersParse.real_expression();
						if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
						{
							++GlobalMembersCommand.c_token;
							GlobalMembersAxis.axis_array[axis.getValue()].miniticscale = GlobalMembersParse.real_expression();
						}
						else
							GlobalMembersAxis.axis_array[axis.getValue()].miniticscale = 0.5 * GlobalMembersAxis.axis_array[axis.getValue()].ticscale;
					}
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ro$tate") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate = DefineConstants.TEXT_VERTICAL;
					++GlobalMembersCommand.c_token;
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "by") != 0)
					{
						GlobalMembersCommand.c_token++;
						GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate = GlobalMembersParse.int_expression();
					}
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noro$tate") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].tic_rotate = 0;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "off$set") != 0)
				{
					++GlobalMembersCommand.c_token;
					GlobalMembersAxis.get_position_default(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.offset, position_type.character);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nooff$set") != 0)
				{
					position tics_nooffset = new position(position_type.character, position_type.character, position_type.character, 0., 0., 0.);
					++GlobalMembersCommand.c_token;
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
					//ORIGINAL LINE: axis_array[axis].ticdef.offset = tics_nooffset;
					GlobalMembersAxis.axis_array[axis.getValue()].ticdef.offset.copyFrom(tics_nooffset);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "range$limited") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticdef.rangelimited = true;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "norange$limited") != 0)
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticdef.rangelimited = false;
					++GlobalMembersCommand.c_token;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "f$ont") != 0)
				{
					++GlobalMembersCommand.c_token;
					/* Make sure they've specified a font */
					if (!(GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected font");
					else
					{
						//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
						free(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font);
						GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font = DefineConstants.NULL;
						GlobalMembersAxis.axis_array[axis.getValue()].ticdef.font = GlobalMembersUtil.try_to_get_string();
					}
				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "format") != 0)
				{
					String format;
					++GlobalMembersCommand.c_token;
					if (!((format = GlobalMembersUtil.try_to_get_string())))
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected format");
					//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					GlobalMembersAxis.axis_array[axis.getValue()].formatstring = format.substring(0, sizeof(GlobalMembersAxis.axis_array[axis.getValue()].formatstring));
					//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
					free(format);
					GlobalMembersAxis.axis_array[axis.getValue()].format_is_numeric = GlobalMembersSet.looks_like_numeric(GlobalMembersAxis.axis_array[axis.getValue()].formatstring);
				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "tc") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "text$color") != 0)
				{
					GlobalMembersMisc.parse_colorspec(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.textcolor, axis == (AXIS_INDEX.FIRST_Z_AXIS.getValue()) != 0 ? DefineConstants.TC_Z : DefineConstants.TC_FRAC);
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "au$tofreq") != 0)
				{
					/* auto tic interval */
					++GlobalMembersCommand.c_token;
					if (!GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix)
					{
						GlobalMembersSet.free_marklist(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user);
						GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user = DefineConstants.NULL;
					}
					GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_COMPUTED;
				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "add") != 0)
				{
					++GlobalMembersCommand.c_token;
					GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix = true;
				}
				else if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
					GlobalMembersSet.load_tics(axis);
				}
			} while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0);

			/* if tics are off and not set by axis, reset to default (border) */
			if (((GlobalMembersAxis.axis_array[axis.getValue()].ticmode & DefineConstants.TICS_MASK) == DefineConstants.NO_TICS) && (!axisset))
			{
				GlobalMembersAxis.axis_array[axis.getValue()].ticmode |= DefineConstants.TICS_ON_BORDER;
				if ((mirror_opt == false) && ((axis == AXIS_INDEX.FIRST_X_AXIS) || (axis == AXIS_INDEX.FIRST_Y_AXIS) || (axis == AXIS_INDEX.COLOR_AXIS)))
				{
					GlobalMembersAxis.axis_array[axis.getValue()].ticmode |= DefineConstants.TICS_MIRROR;
				}
			}

		}

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, nocmd) != 0) // NOSTRING
		{
			GlobalMembersAxis.axis_array[axis.getValue()].ticmode &= ~DefineConstants.TICS_MASK;
			GlobalMembersCommand.c_token++;
			match = 1;
		}
		/* other options */

		() strcpy(sfxptr, "m$tics"); // MONTH
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, cmdptr) != 0)
		{
			if (!GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix)
			{
				GlobalMembersSet.free_marklist(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user);
				GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user = DefineConstants.NULL;
			}
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_MONTH;
			++GlobalMembersCommand.c_token;
			match = 1;
		}
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, nocmd) != 0) // NOMONTH
		{
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_COMPUTED;
			++GlobalMembersCommand.c_token;
			match = 1;
		}
		() strcpy(sfxptr, "d$tics"); // DAYS
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, cmdptr) != 0)
		{
			match = 1;
			if (!GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.mix)
			{
				GlobalMembersSet.free_marklist(GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user);
				GlobalMembersAxis.axis_array[axis.getValue()].ticdef.def.user = DefineConstants.NULL;
			}
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_DAY;
			++GlobalMembersCommand.c_token;
		}
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, nocmd) != 0) // NODAYS
		{
			GlobalMembersAxis.axis_array[axis.getValue()].ticdef.type = en_ticseries_type.TIC_COMPUTED;
			++GlobalMembersCommand.c_token;
			match = 1;
		}
		cmdptr = 'm';
		() strcpy(cmdptr + 1, GlobalMembersAxis.axis_defaults[axis.getValue()].name);
		() strcat(cmdptr, "t$ics"); // MINISTRING

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, cmdptr) != 0)
		{
			GlobalMembersCommand.c_token++;
			match = 1;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
				GlobalMembersAxis.axis_array[axis.getValue()].minitics = en_minitics_status.MINI_AUTO.getValue();
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "def$ault") != 0)
			{
				GlobalMembersAxis.axis_array[axis.getValue()].minitics = en_minitics_status.MINI_DEFAULT.getValue();
				++GlobalMembersCommand.c_token;
			}
			else
			{
				GlobalMembersAxis.axis_array[axis.getValue()].mtic_freq = Math.floor(GlobalMembersParse.real_expression());
				GlobalMembersAxis.axis_array[axis.getValue()].minitics = en_minitics_status.MINI_USER.getValue();
			}
		}
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, nocmd) != 0) // NOMINI
		{
			GlobalMembersAxis.axis_array[axis.getValue()].minitics = false;
			GlobalMembersCommand.c_token++;
			match = 1;
		}
		return (match);
	}

	///#ifdef BACKWARDS_COMPATIBLE
	// /*
	//  * Backwards compatibility ...
	//  */
	//static void set_nolinestyle()
	//{
	//    struct linestyle_def *this, *prev;
	//    int tag;
	//
	//    if (END_OF_COMMAND) {
	// /* delete all linestyles */
	//	while (first_linestyle != NULL)
	//	    delete_linestyle(&first_linestyle, NULL, first_linestyle);
	//    } else {
	// /* get tag */
	//	tag = int_expression();
	//	if (!END_OF_COMMAND)
	//	    int_error(c_token, "extraneous arguments to set nolinestyle");
	//	for (this = first_linestyle, prev = NULL;
	//	     this != NULL;
	//	     prev = this, this = this->next) {
	//	    if (this->tag == tag) {
	//		delete_linestyle(&first_linestyle, prev, this);
	//		return;         // exit, our job is done 
	//	    }
	//	}
	//	int_error(c_token, "linestyle not found");
	//    }
	//}
	///#endif


	/* HBB 20001021: new function: make label texts decoratable with numbers */
	public static String fill_numbers_into_string(String pattern)
	{
		int pattern_length = pattern.length() + 1;
		int newlen = pattern_length;
		byte output = GlobalMembersAlloc.gp_alloc(newlen, "fill_numbers output buffer");
		int output_end = 0;

		do // loop over string/value pairs
		{
			double value;

			if (GlobalMembersUtil.isstring(++GlobalMembersCommand.c_token) != 0)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(output);
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(pattern);
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "constant expression expected");
			}

			/* assume it's a numeric expression, concatenate it to output
			 * string: parse value, enlarge output buffer, and gprintf()
			 * it. */
			value = GlobalMembersParse.real_expression();
			newlen += pattern_length + 30;
			output = GlobalMembersAlloc.gp_realloc(output, newlen, "fill_numbers next number");
			GlobalMembersUtil.gprintf(output + output_end, newlen - output_end, pattern, 1.0, value);
			output_end += String.valueOf(output + output_end).length();

			/* allow a string to follow, after another comma: */
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			{
				/* no comma followed the number --> we're done. Jump out
				 * directly, as falling out of the while loop means
				 * something slightly different. */
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(pattern);
				return output;
			}
			GlobalMembersCommand.c_token++;

			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0)
			{
				int length = GlobalMembersUtil.token_len(GlobalMembersCommand.c_token);

				if (length >= pattern_length)
					pattern = GlobalMembersAlloc.gp_realloc(pattern, pattern_length = length, "fill_numbers resize pattern");
				GlobalMembersUtil.quote_str(pattern, GlobalMembersCommand.c_token, length);
				GlobalMembersCommand.c_token++;
			}
			else
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(pattern);
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(output);
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "string expected");
			} // if (string after comma)
		} while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0);

		/* came out here --> the last element was a string, not a number.
		 * that means that there is a string in pattern which was not yet
		 * copied to 'output' */
		output = GlobalMembersAlloc.gp_realloc(output, newlen += pattern_length, "fill_numbers closing");
		output + output_end = pattern;
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(pattern);
		return output;
	}

	/*
	 *  Normalize gray scale of gradient to fill [0,1] and
	 *  complain if gray values are not strictly increasing.
	 *  Maybe automatic sorting of the gray values could be a
	 *  feature.
	 */

	public static void check_palette_grayscale()
	{
		int i;
		double off;
		double f;

		/* check if gray values are sorted */
		for (i = 0; i < GlobalMembersColor.sm_palette.gradient_num - 1; ++i)
		{
			if (GlobalMembersColor.sm_palette.gradient[i].pos > GlobalMembersColor.sm_palette.gradient[i + 1].pos)
			{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Gray scale not sorted in gradient.");
			}
		}

		/* fit gray axis into [0:1]:  subtract offset and rescale */
		off = GlobalMembersColor.sm_palette.gradient[0].pos;
		f = 1.0 / (GlobalMembersColor.sm_palette.gradient[GlobalMembersColor.sm_palette.gradient_num - 1].pos - off);
		for (i = 1; i < GlobalMembersColor.sm_palette.gradient_num - 1; ++i)
		{
			GlobalMembersColor.sm_palette.gradient[i].pos = f * (GlobalMembersColor.sm_palette.gradient[i].pos - off);
		}

		/* paranoia on the first and last entries */
		GlobalMembersColor.sm_palette.gradient[0].pos = 0.0;
		GlobalMembersColor.sm_palette.gradient[GlobalMembersColor.sm_palette.gradient_num - 1].pos = 1.0;
	}

	/* Process 'set palette defined' gradient specification */
	/* Syntax
	 *   set palette defined   -->  use default palette
	 *   set palette defined ( <pos1> <colorspec1>, ... , <posN> <colorspecN> )
	 *     <posX>  gray value, automatically rescaled to [0, 1]
	 *     <colorspecX>   :=  { "<color_name>" | "<X-style-color>" |  <r> <g> <b> }
	 *        <color_name>     predefined colors (see below)
	 *        <X-style-color>  "#rrggbb" with 2char hex values for red, green, blue
	 *        <r> <g> <b>      three values in [0, 1] for red, green and blue
	 *   return 1 if named colors where used, 0 otherwise
	 */
	public static int set_palette_defined()
	{
		double p = 0;
		double r = 0;
		double g = 0;
		double b = 0;
		int num;
		int named_colors = 0;
		int actual_size = 8;

		/* Invalidate previous gradient */
		GlobalMembersColor.invalidate_palette();

		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(GlobalMembersColor.sm_palette.gradient);
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersColor.sm_palette.gradient = GlobalMembersAlloc.gp_alloc(actual_size * sizeof(gradient_struct), "pm3d gradient");

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* lets use some default gradient */
			double[][] pal = {{0.0, 0.05, 0.05, 0.2}, {0.1, 0, 0, 1}, {0.25, 0.7, 0.85, 0.9}, {0.4, 0, 0.75, 0}, {0.5, 1, 1, 0}, {0.7, 1, 0, 0}, {0.9, 0.6, 0.6, 0.6}, {1.0, 0.95, 0.95, 0.95}};
			int i;
			for (i = 0; i < 8; ++i)
			{
				GlobalMembersColor.sm_palette.gradient[i].pos = pal[i][0];
				GlobalMembersColor.sm_palette.gradient[i].col.r = pal[i][1];
				GlobalMembersColor.sm_palette.gradient[i].col.g = pal[i][2];
				GlobalMembersColor.sm_palette.gradient[i].col.b = pal[i][3];
			}
			GlobalMembersColor.sm_palette.gradient_num = 8;
			GlobalMembersColor.sm_palette.cmodel = color_models_id.C_MODEL_RGB.getValue();
			return 0;
		}

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "(") == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected ( to start gradient definition.");

		++GlobalMembersCommand.c_token;
		num = -1;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			String col_str;
			p = GlobalMembersParse.real_expression();
			col_str = GlobalMembersUtil.try_to_get_string();
			if (col_str != null)
			{
				/* either color name or X-style rgb value "#rrggbb" */
				if (col_str.charAt(0) == '#')
				{
					/* X-style specifier */
					int rr;
					int gg;
					int bb;
					if (sscanf(col_str, "#%2x%2x%2x", rr, gg, bb) != 3)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Unknown color specifier. Use '#rrggbb'.");
					r = (double)(rr) / 255.;
					g = (double)(gg) / 255.;
					b = (double)(bb) / 255.;
				}
				else // some predefined names
				{
					/* Maybe we could scan the X11 rgb.txt file to look up color
					 * names?  Or at least move these definitions to some file
					 * which is included somehow during compilation instead
					 * hardcoding them. */
					/* Can't use lookupt_table() as it works for tokens only,
			   so we'll do it manually */
					//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
					final GlobalMembersBreaders.gen_table * tbl = GlobalMembersTables.pm3d_color_names_tbl;
					while (tbl.key != null)
					{
						if (!strcmp(col_str, tbl.key))
						{
							r = (double)((tbl.value >> 16) & 255) / 255.;
							g = (double)((tbl.value >> 8) & 255) / 255.;
							b = (double)(tbl.value & 255) / 255.;
							break;
						}
						tbl++;
					}
					if (tbl.key == null)
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Unknown color name.");
					named_colors = 1;
				}
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(col_str);
			}
			else
			{
				/* numerical rgb, hsv, xyz, ... values  [0,1] */
				r = GlobalMembersParse.real_expression();
				if (r<0 || r>1)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Value out of range [0,1].");
				g = GlobalMembersParse.real_expression();
				if (g<0 || g>1)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Value out of range [0,1].");
				b = GlobalMembersParse.real_expression();
				if (b<0 || b>1)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "Value out of range [0,1].");
			}
			++num;

			if (num >= actual_size)
			{
				/* get more space for the gradient */
				actual_size += 10;
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersColor.sm_palette.gradient = GlobalMembersAlloc.gp_realloc(GlobalMembersColor.sm_palette.gradient, actual_size * sizeof(gradient_struct), "pm3d gradient");
			}
			GlobalMembersColor.sm_palette.gradient[num].pos = p;
			GlobalMembersColor.sm_palette.gradient[num].col.r = r;
			GlobalMembersColor.sm_palette.gradient[num].col.g = g;
			GlobalMembersColor.sm_palette.gradient[num].col.b = b;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ")") != 0)
				break;
			if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected comma.");
			++GlobalMembersCommand.c_token;

		}

		GlobalMembersColor.sm_palette.gradient_num = num + 1;
		GlobalMembersSet.check_palette_grayscale();

		return named_colors;
	}

	/*  process 'set palette file' command
	 *  load a palette from file, honor datafile modifiers
	 */
	public static void set_palette_file()
	{
		int specs;
		double[] v = new double[4];
		int i;
		int j;
		int actual_size;
		String file_name;

		++GlobalMembersCommand.c_token;

		/* get filename */
		if (!(file_name = GlobalMembersUtil.try_to_get_string()))
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "missing filename");

		GlobalMembersDatafile.df_set_plot_mode(MODE_PLOT_TYPE.MODE_QUERY); // Needed only for binary datafiles
		specs = GlobalMembersDatafile.df_open(file_name, 4, DefineConstants.NULL);
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(file_name);

		if (specs > 0 && specs < 3)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Less than 3 using specs for palette");

		if (GlobalMembersColor.sm_palette.gradient != null)
		{
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(GlobalMembersColor.sm_palette.gradient);
			GlobalMembersColor.sm_palette.gradient = 0;
		}
		actual_size = 10;
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersColor.sm_palette.gradient = GlobalMembersAlloc.gp_alloc(actual_size * sizeof(gradient_struct), "gradient");

		i = 0;

		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define VCONSTRAIN(x) ( (x)<0 ? 0 : ( (x)>1 ? 1: (x) ) )
		/* values are simply clipped to [0,1] without notice */
		while ((j = GlobalMembersDatafile.df_readline(v, 4)) != DefineConstants.DF_EOF)
		{
			if (i >= actual_size)
			{
				actual_size += 10;
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersColor.sm_palette.gradient = (gradient_struct) GlobalMembersAlloc.gp_realloc(GlobalMembersColor.sm_palette.gradient, actual_size * sizeof(gradient_struct), "pm3d gradient");
			}
			switch (j)
			{
			case 3:
				GlobalMembersColor.sm_palette.gradient[i].col.r = ((v[0])<0 ? 0 : ((v[0])>1 ? 1: (v[0])));
				GlobalMembersColor.sm_palette.gradient[i].col.g = ((v[1])<0 ? 0 : ((v[1])>1 ? 1: (v[1])));
				GlobalMembersColor.sm_palette.gradient[i].col.b = ((v[2])<0 ? 0 : ((v[2])>1 ? 1: (v[2])));
				GlobalMembersColor.sm_palette.gradient[i].pos = i;
				break;
			case 4:
				GlobalMembersColor.sm_palette.gradient[i].col.r = ((v[1])<0 ? 0 : ((v[1])>1 ? 1: (v[1])));
				GlobalMembersColor.sm_palette.gradient[i].col.g = ((v[2])<0 ? 0 : ((v[2])>1 ? 1: (v[2])));
				GlobalMembersColor.sm_palette.gradient[i].col.b = ((v[3])<0 ? 0 : ((v[3])>1 ? 1: (v[3])));
				GlobalMembersColor.sm_palette.gradient[i].pos = v[0];
				break;
			default:
				GlobalMembersDatafile.df_close();
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Bad data on line %d", GlobalMembersDatafile.df_line_number);
				break;
			}
			++i;
		}
		//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
		///#undef VCONSTRAIN
		GlobalMembersDatafile.df_close();
		if (i == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "No valid palette found");

		GlobalMembersColor.sm_palette.gradient_num = i;
		GlobalMembersSet.check_palette_grayscale();

	}

	/* Process a 'set palette function' command.
	 *  Three functions with fixed dummy variable gray are registered which
	 *  map gray to the different color components.
	 *  If ALLOW_DUMMY_VAR_FOR_GRAY is set:
	 *    A different dummy variable may proceed the formulae in quotes.
	 *    This syntax is different from the usual '[u=<start>:<end>]', but
	 *    as <start> and <end> are fixed to 0 and 1 you would have to type
	 *    always '[u=]' which looks strange, especially as just '[u]'
	 *    wouldn't work.
	 *  If unset:  dummy variable is fixed to 'gray'.
	 */
	public static void set_palette_function()
	{
		int start_token;
		String saved_dummy_var = new String(new char[DefineConstants.MAX_ID_LEN + 1]);

		++GlobalMembersCommand.c_token;
		saved_dummy_var = String.valueOf(GlobalMembersParse.c_dummy_var[0]).substring(0, DefineConstants.MAX_ID_LEN);

		/* set dummy variable */
		///#ifdef ALLOW_DUMMY_VAR_FOR_GRAY
		//    if (isstring(c_token)) {
		//	quote_str( c_dummy_var[0], c_token, MAX_ID_LEN );
		//	++c_token;
		//    }
		//    else
		///#endif // ALLOW_DUMMY_VAR_FOR_GRAY
		GlobalMembersParse.c_dummy_var[0] = "gray".substring(0, DefineConstants.MAX_ID_LEN);


		/* Afunc */
		start_token = GlobalMembersCommand.c_token;
		if (GlobalMembersColor.sm_palette.Afunc.at != null)
		{
			GlobalMembersEval.free_at(GlobalMembersColor.sm_palette.Afunc.at);
			GlobalMembersColor.sm_palette.Afunc.at = DefineConstants.NULL;
		}
		GlobalMembersCommand.dummy_func = GlobalMembersColor.sm_palette.Afunc;
		GlobalMembersColor.sm_palette.Afunc.at = GlobalMembersParse.perm_at();
		if (GlobalMembersColor.sm_palette.Afunc.at == null)
			GlobalMembersBf_test.int_error(start_token, "not enough memory for function");
		GlobalMembersUtil.m_capture((GlobalMembersColor.sm_palette.Afunc.definition), start_token, GlobalMembersCommand.c_token - 1);
		GlobalMembersCommand.dummy_func = DefineConstants.NULL;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected comma");
		++GlobalMembersCommand.c_token;

		/* Bfunc */
		start_token = GlobalMembersCommand.c_token;
		if (GlobalMembersColor.sm_palette.Bfunc.at != null)
		{
			GlobalMembersEval.free_at(GlobalMembersColor.sm_palette.Bfunc.at);
			GlobalMembersColor.sm_palette.Bfunc.at = DefineConstants.NULL;
		}
		GlobalMembersCommand.dummy_func = GlobalMembersColor.sm_palette.Bfunc;
		GlobalMembersColor.sm_palette.Bfunc.at = GlobalMembersParse.perm_at();
		if (GlobalMembersColor.sm_palette.Bfunc.at == null)
			GlobalMembersBf_test.int_error(start_token, "not enough memory for function");
		GlobalMembersUtil.m_capture((GlobalMembersColor.sm_palette.Bfunc.definition), start_token, GlobalMembersCommand.c_token - 1);
		GlobalMembersCommand.dummy_func = DefineConstants.NULL;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Expected comma");
		++GlobalMembersCommand.c_token;

		/* Cfunc */
		start_token = GlobalMembersCommand.c_token;
		if (GlobalMembersColor.sm_palette.Cfunc.at != null)
		{
			GlobalMembersEval.free_at(GlobalMembersColor.sm_palette.Cfunc.at);
			GlobalMembersColor.sm_palette.Cfunc.at = DefineConstants.NULL;
		}
		GlobalMembersCommand.dummy_func = GlobalMembersColor.sm_palette.Cfunc;
		GlobalMembersColor.sm_palette.Cfunc.at = GlobalMembersParse.perm_at();
		if (GlobalMembersColor.sm_palette.Cfunc.at == null)
			GlobalMembersBf_test.int_error(start_token, "not enough memory for function");
		GlobalMembersUtil.m_capture((GlobalMembersColor.sm_palette.Cfunc.definition), start_token, GlobalMembersCommand.c_token - 1);
		GlobalMembersCommand.dummy_func = DefineConstants.NULL;

		GlobalMembersParse.c_dummy_var[0] = saved_dummy_var.substring(0, DefineConstants.MAX_ID_LEN);
	}

	/* <histogramstyle> = {clustered {gap <n>} | rowstacked | columnstacked */
	/*                     errorbars {gap <n>} {linewidth <lw>}}            */
	/*                    {title <title_options>}                           */
	public static void parse_histogramstyle(histogram_style hs, histogram_type def_type, int def_gap)
	{
		text_label title_specs = new text_label(DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false);

		/* Set defaults */
		hs.type = (int)def_type;
		hs.gap = def_gap;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			return;
		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "hs") == 0 && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "hist$ogram") == 0)
			return;
		GlobalMembersCommand.c_token++;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "clust$ered") != 0)
			{
				hs.type = histogram_type.HT_CLUSTERED.getValue();
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "error$bars") != 0)
			{
				hs.type = histogram_type.HT_ERRORBARS.getValue();
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rows$tacked") != 0)
			{
				hs.type = histogram_type.HT_STACKED_IN_LAYERS.getValue();
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "columns$tacked") != 0)
			{
				hs.type = histogram_type.HT_STACKED_IN_TOWERS.getValue();
				GlobalMembersCommand.c_token++;
			}
			else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "gap") != 0)
			{
				if (GlobalMembersUtil.isanumber(++GlobalMembersCommand.c_token) != 0)
					hs.gap = GlobalMembersParse.int_expression();
				else
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expected gap value");
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ti$tle") != 0)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
				//ORIGINAL LINE: title_specs.offset = hs->title.offset;
				title_specs.offset.copyFrom(hs.title.offset);
				GlobalMembersSet.set_xyzlabel(title_specs);
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
				//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				memcpy(hs.title.textcolor, title_specs.textcolor, sizeof(t_colorspec));
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
				//ORIGINAL LINE: hs->title.offset = title_specs.offset;
				hs.title.offset.copyFrom(title_specs.offset);
				/* EAM FIXME - could allocate space and copy parsed font instead */
				hs.title.font = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.font;
			}
			else if ((GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "lw") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "linew$idth") != 0) && (hs.type == histogram_type.HT_ERRORBARS.getValue()))
			{
				GlobalMembersCommand.c_token++;
				hs.bar_lw = GlobalMembersParse.real_expression();
				if (hs.bar_lw <= 0)
					hs.bar_lw = 1;
			}
			else
				/* We hit something unexpected */
				break;
		}
	}

	public static position default_position = new position(position_type.first_axes, position_type.first_axes, position_type.first_axes, 0., 0., 0.);

	///#ifdef BACKWARDS_COMPATIBLE
	//static void set_nolinestyle __PROTO((void));
	///#endif

	/******** The 'set' command ********/
	public static void set_command()
	{
		GlobalMembersCommand.c_token++;

		///#ifdef BACKWARDS_COMPATIBLE
		//
		// /* retain backwards compatibility to the old syntax for now
		//  * Oh, such ugliness ...
		//  */
		//
		//    if (almost_equals(c_token,"da$ta")) {
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"set style data\"");
		//	if (!almost_equals(++c_token,"s$tyle"))
		//	    int_error(c_token,"expecting keyword 'style'");
		//	else
		//	    data_style = get_style();
		//    } else if (almost_equals(c_token,"fu$nction")) {
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"set style function\"");
		//	if (!almost_equals(++c_token,"s$tyle"))
		//	    int_error(c_token,"expecting keyword 'style'");
		//	else {
		//	    enum PLOT_STYLE temp_style = get_style();
		//
		//	    if (temp_style & PLOT_STYLE_HAS_ERRORBAR)
		//		int_error(c_token, "style not usable for function plots, left unchanged");
		//	    else if (temp_style == HISTOGRAMS)
		//		int_error(c_token, "style not usable for function plots, left unchanged");
		//	    else
		//		func_style = temp_style;
		//	}
		//    } else if (almost_equals(c_token,"li$nestyle") || equals(c_token, "ls" )) {
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"set style line\"");
		//	c_token++;
		//	set_linestyle();
		//    } else if (almost_equals(c_token,"noli$nestyle") || equals(c_token, "nols" )) {
		//	c_token++;
		//	set_nolinestyle();
		//    } else if (gp_input_line[token[c_token].start_index] == 'n' &&
		//	       gp_input_line[token[c_token].start_index+1] == 'o') {
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"unset\"");
		//	token[c_token].start_index += 2;
		//	token[c_token].length -= 2;
		//	c_token--;
		//	unset_command();
		//    } else if (almost_equals(c_token,"miss$ing")) {
		//	if (interactive)
		//	    int_warn(c_token, "deprecated syntax, use \"set datafile missing\"");
		//	set_missing();
		//    } else {
		//
		///#else	// Milder form of backwards compatibility 
		/* Allow "set no{foo}" rather than "unset foo" */ 
		if (GlobalMembersCommand.gp_input_line.charAt(GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index) == 'n' && GlobalMembersCommand.gp_input_line.charAt(GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index + 1) == 'o')
		{
			if (GlobalMembersPlot.interactive)
				GlobalMembersUtil.int_warn(GlobalMembersCommand.c_token, "deprecated syntax, use \"unset\"");
			GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index += 2;
			GlobalMembersCommand.token[GlobalMembersCommand.c_token].length -= 2;
			GlobalMembersCommand.c_token--;
			GlobalMembersUnset.unset_command();
		}
		else
		{

			///#endif // BACKWARDS_COMPATIBLE 

			int save_token;
			GlobalMembersParse.check_for_iteration();
			save_token = GlobalMembersCommand.c_token;
			//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
			ITERATE:

				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: switch(lookup_table(&set_tbl[0],c_token))
				switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_tbl[0]), GlobalMembersCommand.c_token))
				{
				case S_ANGLES:
					GlobalMembersSet.set_angles();
					break;
				case S_ARROW:
					GlobalMembersSet.set_arrow();
					break;
				case S_AUTOSCALE:
					GlobalMembersSet.set_autoscale();
					break;
				case S_BARS:
					GlobalMembersSet.set_bars();
					break;
				case S_BORDER:
					GlobalMembersSet.set_border();
					break;
				case S_BOXWIDTH:
					GlobalMembersSet.set_boxwidth();
					break;
				case S_CLABEL:
					GlobalMembersSet.set_clabel();
					break;
				case S_CLIP:
					GlobalMembersSet.set_clip();
					break;
				case S_CNTRPARAM:
					GlobalMembersSet.set_cntrparam();
					break;
				case S_CONTOUR:
					GlobalMembersSet.set_contour();
					break;
				case S_DGRID3D:
					GlobalMembersSet.set_dgrid3d();
					break;
				case S_DECIMALSIGN:
					GlobalMembersSet.set_decimalsign();
					break;
				case S_DUMMY:
					GlobalMembersSet.set_dummy();
					break;
				case S_ENCODING:
					GlobalMembersSet.set_encoding();
					break;
				case S_FIT:
					GlobalMembersSet.set_fit();
					break;
				case S_FONTPATH:
					GlobalMembersSet.set_fontpath();
					break;
				case S_FORMAT:
					GlobalMembersSet.set_format();
					break;
				case S_GRID:
					GlobalMembersSet.set_grid();
					break;
				case S_HIDDEN3D:
					GlobalMembersSet.set_hidden3d();
					break;
				case S_HISTORYSIZE:
					///#ifdef GNUPLOT_HISTORY
					GlobalMembersSet.set_historysize();
					///#else
					//	    int_error(c_token, "Command 'set historysize' requires history support.");
					///#endif
					break;
				case S_ISOSAMPLES:
					GlobalMembersSet.set_isosamples();
					break;
				case S_KEY:
					GlobalMembersSet.set_key();
					break;
				case S_KEYTITLE:
					GlobalMembersSet.set_keytitle();
					break;
				case S_LABEL:
					GlobalMembersSet.set_label();
					break;
				case S_LOADPATH:
					GlobalMembersSet.set_loadpath();
					break;
				case S_LOCALE:
					GlobalMembersSet.set_locale();
					break;
				case S_LOGSCALE:
					GlobalMembersSet.set_logscale();
					break;
					///#ifdef GP_MACROS
				case S_MACROS:
					GlobalMembersSet.set_macros();
					break;
					///#endif
				case S_MAPPING:
					GlobalMembersSet.set_mapping();
					break;
				case S_BMARGIN:
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: set_margin(&bmargin);
					GlobalMembersSet.set_margin(new position(GlobalMembersGadgets.bmargin));
					break;
				case S_LMARGIN:
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: set_margin(&lmargin);
					GlobalMembersSet.set_margin(new position(GlobalMembersGadgets.lmargin));
					break;
				case S_RMARGIN:
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: set_margin(&rmargin);
					GlobalMembersSet.set_margin(new position(GlobalMembersGadgets.rmargin));
					break;
				case S_TMARGIN:
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
					//ORIGINAL LINE: set_margin(&tmargin);
					GlobalMembersSet.set_margin(new position(GlobalMembersGadgets.tmargin));
					break;
				case S_DATAFILE:
					if (GlobalMembersUtil.almost_equals(++GlobalMembersCommand.c_token, "miss$ing") != 0)
						GlobalMembersSet.set_missing();
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "sep$arator") != 0)
						GlobalMembersSet.set_separator();
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "com$mentschars") != 0)
						GlobalMembersSet.set_datafile_commentschars();
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "bin$ary") != 0)
						GlobalMembersDatafile.df_set_datafile_binary();
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fort$ran") != 0)
					{
						GlobalMembersDatafile.df_fortran_constants = true;
						GlobalMembersCommand.c_token++;
					}
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nofort$ran") != 0)
					{
						GlobalMembersDatafile.df_fortran_constants = false;
						GlobalMembersCommand.c_token++;
					}
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "fpe_trap") != 0)
					{
						GlobalMembersDatafile.df_nofpe_trap = false;
						GlobalMembersCommand.c_token++;
					}
					else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nofpe_trap") != 0)
					{
						GlobalMembersDatafile.df_nofpe_trap = true;
						GlobalMembersCommand.c_token++;
					}
					else
						GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting datafile modifier");
					break;
					///#ifdef USE_MOUSE
				case S_MOUSE:
					GlobalMembersSet.set_mouse();
					break;
					///#endif
				case S_MULTIPLOT:
					GlobalMembersTerm.term_start_multiplot();
					break;
				case S_OFFSETS:
					GlobalMembersSet.set_offsets();
					break;
				case S_ORIGIN:
					GlobalMembersSet.set_origin();
					break;
				case SET_OUTPUT:
					GlobalMembersSet.set_output();
					break;
				case S_PARAMETRIC:
					GlobalMembersSet.set_parametric();
					break;
				case S_PM3D:
					GlobalMembersSet.set_pm3d();
					break;
				case S_PALETTE:
					GlobalMembersSet.set_palette();
					break;
				case S_COLORBOX:
					GlobalMembersSet.set_colorbox();
					break;
				case S_POINTSIZE:
					GlobalMembersSet.set_pointsize();
					break;
				case S_POLAR:
					GlobalMembersSet.set_polar();
					break;
				case S_PRINT:
					GlobalMembersSet.set_print();
					break;
					///#ifdef EAM_OBJECTS
				case S_OBJECT:
					GlobalMembersSet.set_object();
					break;
					///#endif
				case S_SAMPLES:
					GlobalMembersSet.set_samples();
					break;
				case S_SIZE:
					GlobalMembersSet.set_size();
					break;
				case S_STYLE:
					GlobalMembersSet.set_style();
					break;
				case S_SURFACE:
					GlobalMembersSet.set_surface();
					break;
				case S_TABLE:
					GlobalMembersSet.set_table();
					break;
				case S_TERMINAL:
					GlobalMembersSet.set_terminal();
					break;
				case S_TERMOPTIONS:
					GlobalMembersSet.set_termoptions();
					break;
				case S_TICS:
					GlobalMembersSet.set_tics();
					break;
				case S_TICSCALE:
					GlobalMembersSet.set_ticscale();
					break;
				case S_TIMEFMT:
					GlobalMembersSet.set_timefmt();
					break;
				case S_TIMESTAMP:
					GlobalMembersSet.set_timestamp();
					break;
				case S_TITLE:
					GlobalMembersSet.set_xyzlabel(GlobalMembersGadgets.title);
					break;
				case S_VIEW:
					GlobalMembersSet.set_view();
					break;
				case S_ZERO:
					GlobalMembersSet.set_zero();
					break;

				case S_MXTICS:
				case S_NOMXTICS:
				case S_XTICS:
				case S_NOXTICS:
				case S_XDTICS:
				case S_NOXDTICS:
				case S_XMTICS:
				case S_NOXMTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.FIRST_X_AXIS);
					break;
				case S_MYTICS:
				case S_NOMYTICS:
				case S_YTICS:
				case S_NOYTICS:
				case S_YDTICS:
				case S_NOYDTICS:
				case S_YMTICS:
				case S_NOYMTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.FIRST_Y_AXIS);
					break;
				case S_MX2TICS:
				case S_NOMX2TICS:
				case S_X2TICS:
				case S_NOX2TICS:
				case S_X2DTICS:
				case S_NOX2DTICS:
				case S_X2MTICS:
				case S_NOX2MTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.SECOND_X_AXIS);
					break;
				case S_MY2TICS:
				case S_NOMY2TICS:
				case S_Y2TICS:
				case S_NOY2TICS:
				case S_Y2DTICS:
				case S_NOY2DTICS:
				case S_Y2MTICS:
				case S_NOY2MTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.SECOND_Y_AXIS);
					break;
				case S_MZTICS:
				case S_NOMZTICS:
				case S_ZTICS:
				case S_NOZTICS:
				case S_ZDTICS:
				case S_NOZDTICS:
				case S_ZMTICS:
				case S_NOZMTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.FIRST_Z_AXIS);
					break;
				case S_MCBTICS:
				case S_NOMCBTICS:
				case S_CBTICS:
				case S_NOCBTICS:
				case S_CBDTICS:
				case S_NOCBDTICS:
				case S_CBMTICS:
				case S_NOCBMTICS:
					GlobalMembersSet.set_tic_prop(AXIS_INDEX.COLOR_AXIS);
					break;
				case S_XDATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.FIRST_X_AXIS);
					/* HBB 20000506: the old cod this this, too, although it
					 * serves no useful purpose, AFAICS */
					/* HBB 20010201: Changed implementation to fix bug
					 * (c_token advanced too far) */
					GlobalMembersAxis.axis_array[AXIS_INDEX.T_AXIS.getValue()].is_timedata = GlobalMembersAxis.axis_array[AXIS_INDEX.U_AXIS.getValue()].is_timedata = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].is_timedata;
					break;
				case S_YDATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.FIRST_Y_AXIS);
					/* dito */
					GlobalMembersAxis.axis_array[AXIS_INDEX.V_AXIS.getValue()].is_timedata = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].is_timedata;
					break;
				case S_ZDATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.FIRST_Z_AXIS);
					break;
				case S_CBDATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.COLOR_AXIS);
					break;
				case S_X2DATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.SECOND_X_AXIS);
					break;
				case S_Y2DATA:
					GlobalMembersSet.set_timedata(AXIS_INDEX.SECOND_Y_AXIS);
					break;
				case S_XLABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label);
					break;
				case S_YLABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label);
					break;
				case S_ZLABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label);
					break;
				case S_CBLABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label);
					break;
				case S_X2LABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label);
					break;
				case S_Y2LABEL:
					GlobalMembersSet.set_xyzlabel(GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label);
					break;
				case S_XRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.FIRST_X_AXIS);
					break;
				case S_X2RANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.SECOND_X_AXIS);
					break;
				case S_YRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.FIRST_Y_AXIS);
					break;
				case S_Y2RANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.SECOND_Y_AXIS);
					break;
				case S_ZRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.FIRST_Z_AXIS);
					break;
				case S_CBRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.COLOR_AXIS);
					break;
				case S_RRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.R_AXIS);
					break;
				case S_TRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.T_AXIS);
					break;
				case S_URANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.U_AXIS);
					break;
				case S_VRANGE:
					GlobalMembersSet.set_range(AXIS_INDEX.V_AXIS);
					break;
				case S_XZEROAXIS:
					GlobalMembersSet.set_zeroaxis(AXIS_INDEX.FIRST_X_AXIS);
					break;
				case S_YZEROAXIS:
					GlobalMembersSet.set_zeroaxis(AXIS_INDEX.FIRST_Y_AXIS);
					break;
				case S_ZZEROAXIS:
					GlobalMembersSet.set_zeroaxis(AXIS_INDEX.FIRST_Z_AXIS);
					break;
				case S_X2ZEROAXIS:
					GlobalMembersSet.set_zeroaxis(AXIS_INDEX.SECOND_X_AXIS);
					break;
				case S_Y2ZEROAXIS:
					GlobalMembersSet.set_zeroaxis(AXIS_INDEX.SECOND_Y_AXIS);
					break;
				case S_ZEROAXIS:
					GlobalMembersSet.set_allzeroaxis();
					break;
				case S_XYPLANE:
					GlobalMembersSet.set_xyplane();
					break;
				case S_TICSLEVEL:
					GlobalMembersSet.set_ticslevel();
					break;
				default:
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "Unrecognized option.  See 'help set'.");
					break;
				}

			if (GlobalMembersParse.next_iteration())
			{
				GlobalMembersCommand.c_token = save_token;
				//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
				goto ITERATE;
			}

		}

		/* FIXME - Should this be inside the iteration loop? */
		GlobalMembersEval.update_gpval_variables(0);

	}


	/* When plotting an external key, the margin and l/r/t/b/c are
	   used to determine one of twelve possible positions.  They must
	   be defined appropriately in the case where stack direction
	   determines exact position. */
	public static void set_key_position_from_stack_direction(legend_key key)
	{
		if (key.stack_dir == en_key_stack_direction.GPKEY_VERTICAL)
		{
			switch (key.hpos)
			{
			case LEFT:
				key.margin = en_key_ext_region.GPKEY_LMARGIN;
				break;
			case CENTRE:
				if (key.vpos == VERT_JUSTIFY.JUST_TOP)
					key.margin = en_key_ext_region.GPKEY_TMARGIN;
				else
					key.margin = en_key_ext_region.GPKEY_BMARGIN;
				break;
			case RIGHT:
				key.margin = en_key_ext_region.GPKEY_RMARGIN;
				break;
			}
		}
		else
		{
			switch (key.vpos)
			{
			case JUST_TOP:
				key.margin = en_key_ext_region.GPKEY_TMARGIN;
				break;
			case JUST_CENTRE:
				if (key.hpos == JUSTIFY.LEFT)
					key.margin = en_key_ext_region.GPKEY_LMARGIN;
				else
					key.margin = en_key_ext_region.GPKEY_RMARGIN;
				break;
			case JUST_BOT:
				key.margin = en_key_ext_region.GPKEY_BMARGIN;
				break;
			}
		}
	}


	/* is resetting palette enabled?
	 * note: reset_palette() is disabled within 'test palette'
	 */
	public static int enable_reset_palette = 1;

	/* default settings for palette */
	public static void reset_palette()
	{
		if (enable_reset_palette == 0)
			return;
		GlobalMembersColor.sm_palette.colorMode = palette_color_mode.SMPAL_COLOR_MODE_RGB;
		GlobalMembersColor.sm_palette.formulaR = 7;
		GlobalMembersColor.sm_palette.formulaG = 5;
		GlobalMembersColor.sm_palette.formulaB = 15;
		GlobalMembersColor.sm_palette.positive = DefineConstants.SMPAL_POSITIVE;
		GlobalMembersColor.sm_palette.ps_allcF = 0;
		GlobalMembersColor.sm_palette.use_maxcolors = 0;
		GlobalMembersColor.sm_palette.gradient_num = 0;
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(GlobalMembersColor.sm_palette.gradient);
		GlobalMembersColor.sm_palette.gradient = DefineConstants.NULL;
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(GlobalMembersColor.sm_palette.color);
		GlobalMembersColor.sm_palette.color = DefineConstants.NULL;
		GlobalMembersColor.sm_palette.cmodel = color_models_id.C_MODEL_RGB.getValue();
		GlobalMembersColor.sm_palette.gamma = 1.5;
		pm3d_last_set_palette_mode = palette_color_mode.SMPAL_COLOR_MODE_NONE;
	}


	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SCAN_RGBFORMULA(formula) do { c_token++; i = int_expression(); if (abs(i) >= sm_palette.colorFormulae) int_error(c_token, "color formula out of range (use `show palette rgbformulae' to display the range)"); formula = i; } while(0)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_TRANSFORM do { if (transform_defined) int_error(c_token, "Use either `rgbformulae`, `defined`, `file` or `formulae`." ); transform_defined = 1; } while(0)

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef CHECK_TRANSFORM
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef SCAN_RGBFORMULA

	public static object new_object(int tag, int object_type, object new_Renamed)
	{
		object def_rect = new object(DefineConstants.NULL, -1, 0, DefineConstants.OBJ_RECTANGLE, {t_fillstyle.FS_SOLID, 100, 0, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0}}, {1, DefineConstants.LT_BACKGROUND, 0, 0, 1.0, 0.0, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}});
		object def_ellipse = new object(DefineConstants.NULL, -1, 0, DefineConstants.OBJ_CIRCLE, {t_fillstyle.FS_SOLID, 100, 0, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0}}, {1, DefineConstants.LT_BACKGROUND, 0, 0, 1.0, 0.0, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0.}});
		object def_circle = new object(DefineConstants.NULL, -1, 0, DefineConstants.OBJ_CIRCLE, {t_fillstyle.FS_SOLID, 100, 0, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0}}, {1, DefineConstants.LT_BACKGROUND, 0, 0, 1.0, 0.0, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360.}});
		object def_polygon = new object(DefineConstants.NULL, -1, 0, DefineConstants.OBJ_POLYGON, {t_fillstyle.FS_SOLID, 100, 0, {DefineConstants.TC_LT, DefineConstants.LT_BLACK, 0.0}}, {1, DefineConstants.LT_BLACK, 0, 0, 1.0, 0.0, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {.polygon = {0, DefineConstants.NULL}});

		if (new_Renamed == null)
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			new() = GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct object), "object");
		else if (new_Renamed.object_type == DefineConstants.OBJ_POLYGON)
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(new_Renamed.o.polygon.vertex);

		if (object_type == DefineConstants.OBJ_RECTANGLE)
		{
			*new() = def_rect;
			new_Renamed.lp_properties.l_type = DefineConstants.LT_DEFAULT; // Use default rectangle color
			new_Renamed.fillstyle.fillstyle = t_fillstyle.FS_DEFAULT.getValue(); // and default fill style
		}
		else if (object_type == DefineConstants.OBJ_ELLIPSE)
			*new() = def_ellipse;
		else if (object_type == DefineConstants.OBJ_CIRCLE)
			*new() = def_circle;
		else if (object_type == DefineConstants.OBJ_POLYGON)
			*new() = def_polygon;
		else
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "object initialization failure");

		new_Renamed.tag = tag;
		new_Renamed.object_type = object_type;

		return new_Renamed;
	}

	/*
	 * Delete linestyle from linked list.
	 * Called with pointers to the head of the list,
	 * to the previous linestyle (not strictly necessary),
	 * and to the linestyle to delete.
	 */
	public static void delete_linestyle(linestyle_def[] head, linestyle_def prev, linestyle_def this_Renamed)
	{
		if (this_Renamed != null) // there really is something to delete
		{
			if (this_Renamed == head)
				head = this_Renamed.next;
			else
				prev.next = this_Renamed.next;
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(this_Renamed);
		}
	}

	public static void free_marklist(ticmark list)
	{
		while (list != null)
		{
			ticmark freeable = list;
			list = list.next;
			if (!freeable.label.equals(DefineConstants.NULL))
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(freeable.label);
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(freeable);
		}
	}

	/* Remove tic labels that were read from a datafile during a previous plot
	 * via the 'using xtics(n)' mechanism.  These have tick level < 0.
	 */
	public static ticmark prune_dataticks(ticmark list)
	{
		ticmark a = new ticmark(0.0,DefineConstants.NULL,0,DefineConstants.NULL);
		ticmark b = a;
		ticmark tmp;

		while (list != null)
		{
			if (list.level < 0)
			{
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(list.label);
				tmp = list.next;
				//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(list);
				list = tmp;
			}
			else
			{
				b.next = list;
				b = list;
				list = list.next;
			}
		}
		b.next = DefineConstants.NULL;
		return a.next;
	}

	/*
	 * new_text_label() allocates and initializes a text_label structure.
	 * This routine is also used by the plot and splot with labels commands.
	 */
	public static text_label new_text_label(int tag)
	{
		text_label new_Renamed;
		position default_offset = new position(position_type.character, position_type.character, position_type.character, 0., 0., 0.);

		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		new() = GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct text_label), "text_label");
		new_Renamed.next = DefineConstants.NULL;
		new_Renamed.tag = tag;
		//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
		//ORIGINAL LINE: new->place = default_position;
		new_Renamed.place.copyFrom(default_position);
		new_Renamed.pos = JUSTIFY.LEFT;
		new_Renamed.rotate = 0;
		new_Renamed.layer = 0;
		new_Renamed.text = (String)DefineConstants.NULL;
		new_Renamed.font = (String)DefineConstants.NULL;
		new_Renamed.textcolor.type = DefineConstants.TC_DEFAULT;
		new_Renamed.lp_properties.pointflag = 0;
		new_Renamed.lp_properties.p_type = 1;
		//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
		//ORIGINAL LINE: new->offset = default_offset;
		new_Renamed.offset.copyFrom(default_offset);
		new_Renamed.noenhanced = false;

		return (new_Renamed);
	}

	/*
	 * Parse the sub-options for label style and placement.
	 * This is called from set_label, and from plot2d and plot3d 
	 * to handle options for 'plot with labels'
	 */
	public static void parse_label_options(text_label this_label)
	{
		position pos = new position();
		String font = DefineConstants.NULL;
		JUSTIFY just = JUSTIFY.LEFT;
		int rotate = 0;
		boolean set_position = false;
		boolean set_just = false;
		boolean set_rot = false;
		boolean set_font = false;
		boolean set_offset = false;
		boolean set_layer = false;
		boolean set_textcolor = false;
		int layer = 0;
		boolean axis_label = (this_label.tag == -2);
		position offset = new position(position_type.character, position_type.character, position_type.character, 0., 0., 0.);
		t_colorspec textcolor = new t_colorspec(DefineConstants.TC_DEFAULT,0,0.0);
		lp_style_type loc_lp = new lp_style_type(0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0});
		loc_lp.pointflag = -2;

		/* Now parse the label format and style options */
		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			/* get position */
			if (!set_position && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "at") != 0 && !axis_label)
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersAxis.get_position(pos);
				set_position = true;
				continue;
			}

			/* get justification */
			if (!set_just)
			{
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "l$eft") != 0)
				{
					just = JUSTIFY.LEFT;
					GlobalMembersCommand.c_token++;
					set_just = true;
					continue;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "c$entre") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "c$enter") != 0)
				{
					just = JUSTIFY.CENTRE;
					GlobalMembersCommand.c_token++;
					set_just = true;
					continue;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "r$ight") != 0)
				{
					just = JUSTIFY.RIGHT;
					GlobalMembersCommand.c_token++;
					set_just = true;
					continue;
				}
			}

			/* get rotation (added by RCC) */
			if (!set_rot)
			{
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "rot$ate") != 0)
				{
					rotate = DefineConstants.TEXT_VERTICAL;
					GlobalMembersCommand.c_token++;
					set_rot = true;
					if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "by") != 0)
					{
						GlobalMembersCommand.c_token++;
						rotate = GlobalMembersParse.int_expression();
					}
					continue;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "norot$ate") != 0)
				{
					rotate = 0;
					GlobalMembersCommand.c_token++;
					set_rot = true;
					continue;
				}
			}

			/* get font (added by DJL) */
			if (!set_font && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "font") != 0)
			{
				GlobalMembersCommand.c_token++;
				if ((font = GlobalMembersUtil.try_to_get_string()))
				{
					set_font = true;
					continue;
				}
				else
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "'fontname,fontsize' expected");
			}

			/* get front/back (added by JDP) */
			if (!set_layer && !axis_label)
			{
				if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "back") != 0)
				{
					layer = 0;
					GlobalMembersCommand.c_token++;
					set_layer = true;
					continue;
				}
				else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "front") != 0)
				{
					layer = 1;
					GlobalMembersCommand.c_token++;
					set_layer = true;
					continue;
				}
			}

			if (loc_lp.pointflag == -2 && !axis_label)
			{
				if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "po$int") != 0)
				{
					int stored_token = ++GlobalMembersCommand.c_token;
					lp_style_type tmp_lp = new lp_style_type();
					loc_lp.pointflag = 1;
					//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
					//ORIGINAL LINE: tmp_lp = loc_lp;
					tmp_lp.copyFrom(loc_lp);
					GlobalMembersMisc.lp_parse(tmp_lp, true, true);
					if (stored_token != GlobalMembersCommand.c_token)
						//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
						//ORIGINAL LINE: loc_lp = tmp_lp;
						loc_lp.copyFrom(tmp_lp);
					continue;
				}
				else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "nopo$int") != 0)
				{
					loc_lp.pointflag = 0;
					GlobalMembersCommand.c_token++;
					continue;
				}
			}

			if (!set_offset && GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "of$fset") != 0)
			{
				GlobalMembersCommand.c_token++;
				GlobalMembersAxis.get_position_default(offset, position_type.character);
				set_offset = true;
				continue;
			}

			if ((GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "tc") != 0 || GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "text$color") != 0) && !set_textcolor)
			{
				GlobalMembersMisc.parse_colorspec(textcolor, DefineConstants.TC_Z);
				set_textcolor = true;
				continue;
			}

			if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "noenh$anced") != 0)
			{
				this_label.noenhanced = true;
				GlobalMembersCommand.c_token++;
				continue;
			}
			else if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "enh$anced") != 0)
			{
				this_label.noenhanced = false;
				GlobalMembersCommand.c_token++;
				continue;
			}

			/* Coming here means that none of the previous 'if's struck
			 * its "continue" statement, i.e.  whatever is in the command
			 * line is forbidden by the 'set label' command syntax.
			 * On the other hand, 'plot with labels' may have additional stuff coming up.
			 */
			break;

		} // while(!END_OF_COMMAND)

		/* HBB 20011120: this chunk moved here, behind the while()
		 * loop. Only after all options have been parsed it's safe to
		 * overwrite the position if none has been specified. */
		if (!set_position)
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: pos = default_position;
			pos.copyFrom(default_position);

		/* OK! copy the requested options into the label */
		if (set_position)
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_label->place = pos;
			this_label.place.copyFrom(pos);
		if (set_just)
			this_label.pos = just;
		if (set_rot)
			this_label.rotate = rotate;
		if (set_layer)
			this_label.layer = layer;
		if (set_font)
			this_label.font = font;
		if (set_textcolor)
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memcpy((this_label.textcolor), textcolor, sizeof(t_colorspec));
		if (loc_lp.pointflag >= 0)
			//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memcpy((this_label.lp_properties), loc_lp, sizeof(loc_lp));
		if (set_offset)
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
			//ORIGINAL LINE: this_label->offset = offset;
			this_label.offset.copyFrom(offset);

		/* Make sure the z coord and the z-coloring agree */
		if (this_label.textcolor.type == DefineConstants.TC_Z)
			this_label.textcolor.value = this_label.place.z;
	}
}