package com.addiPlot.gnuplot;

public class GlobalMembersHidden3d
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	//public static String RCSid()
	//{
	//	return GlobalMembersAlloc.RCSid("$Id: hidden3d.c,v 1.69 2008/09/24 03:19:06 sfeam Exp $");
	//}
	///#endif

	/* GNUPLOT - hidden3d.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/*
	 * 1999 Hans-Bernhard Broeker (Broeker@physik.rwth-aachen.de)
	 *
	 * Major rewrite, affecting just about everything
	 *
	 */

	/*
	 * $Id: hidden3d.h,v 1.10 2008/06/02 19:18:32 sfeam Exp $
	 */

	/* GNUPLOT - hidden3d.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef HIDDEN3D_VAR_PTSIZE // Needed for variable pointsize, but takes space
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLAG_VERTEX_AS_UNDEFINED(v) do { (v).z = -2.0; } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VERTEX_IS_UNDEFINED(v) ((v).z == -2.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define V_EQUAL(a,b) ( GE(0.0, fabs((a)->x - (b)->x) + fabs((a)->y - (b)->y) + fabs((a)->z - (b)->z)) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOORD(v,xvar,yvar) { xvar = ((int)((v)->x * xscaler)) + xmiddle; yvar = ((int)((v)->y * yscaler)) + ymiddle; }

	/* Type definitions */

	/* Variables of hidden3d.c needed by other modules: */

	//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern boolean disable_mouse_z;

	/* Set the options for hidden3d. To be called from set.c, when the
	 * user has begun a command with 'set hidden3d', to parse the rest of
	 * that command */

	/* Prototypes of functions exported by hidden3d.c */

	public static void set_hidden3doptions()
	{
		int tmp;

		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
			//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
			//ORIGINAL LINE: switch (lookup_table(&set_hidden3d_tbl[0], c_token))
			switch (GlobalMembersTables.lookup_table(new gen_table(GlobalMembersTables.set_hidden3d_tbl[0]), GlobalMembersCommand.c_token))
			{
			case S_HI_DEFAULTS:
				/* reset all parameters to defaults */
				GlobalMembersHidden3d.reset_hidden3doptions();
				GlobalMembersCommand.c_token++;
				if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
					GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "No further options allowed after 'defaults'");
				return;
				break;
			case S_HI_OFFSET:
				GlobalMembersCommand.c_token++;
				hiddenBacksideLinetypeOffset = GlobalMembersParse.int_expression();
				GlobalMembersCommand.c_token--;
				break;
			case S_HI_NOOFFSET:
				hiddenBacksideLinetypeOffset = 0;
				break;
			case S_HI_TRIANGLEPATTERN:
				GlobalMembersCommand.c_token++;
				hiddenTriangleLinesdrawnPattern = GlobalMembersParse.int_expression();
				GlobalMembersCommand.c_token--;
				break;
			case S_HI_UNDEFINED:
				GlobalMembersCommand.c_token++;
				tmp = GlobalMembersParse.int_expression();
				if (tmp <= 0 || tmp > coord_type.UNDEFINED + 1)
					tmp = coord_type.UNDEFINED.getValue() + 1;
				hiddenHandleUndefinedPoints = tmp;
				GlobalMembersCommand.c_token--;
				break;
			case S_HI_NOUNDEFINED:
				hiddenHandleUndefinedPoints = coord_type.UNDEFINED.getValue() + 1;
				break;
			case S_HI_ALTDIAGONAL:
				hiddenShowAlternativeDiagonal = 1;
				break;
			case S_HI_NOALTDIAGONAL:
				hiddenShowAlternativeDiagonal = 0;
				break;
			case S_HI_BENTOVER:
				hiddenHandleBentoverQuadrangles = 1;
				break;
			case S_HI_NOBENTOVER:
				hiddenHandleBentoverQuadrangles = 0;
				break;
			case S_HI_BACK:
				GlobalMembersGraph3d.hidden3d_layer = DefineConstants.LAYER_BACK;
				break;
			case S_HI_FRONT:
				GlobalMembersGraph3d.hidden3d_layer = DefineConstants.LAYER_FRONT;
				break;
			case S_HI_INVALID:
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "No such option to hidden3d (or wrong order)");
			default:
				break;
			}
			GlobalMembersCommand.c_token++;
		}
	}
	public static void show_hidden3doptions()
	{
		fprintf(stderr,"\t  Hidden3d elements will be drawn in %s of non-hidden3d elements\n", GlobalMembersGraph3d.hidden3d_layer == DefineConstants.LAYER_BACK ? "back" : "front");
		fprintf(stderr,"\t  Back side of surfaces has linestyle offset of %d\n\t  Bit-Mask of Lines to draw in each triangle is %ld\n\t  %d: ", hiddenBacksideLinetypeOffset, hiddenTriangleLinesdrawnPattern, hiddenHandleUndefinedPoints);

		switch (hiddenHandleUndefinedPoints)
		{
		case OUTRANGE:
			fputs("Outranged and undefined datapoints are omitted from the surface.\n", stderr);
			break;
		case UNDEFINED:
			fputs("Only undefined datapoints are omitted from the surface.\n", stderr);
			break;
		case UNDEFINED + 1:
			fputs("Will not check for undefined datapoints (may cause crashes).\n", stderr);
		break;
		default:
			fputs("Value stored for undefined datapoint handling is illegal!!!\n", stderr);
			break;
		}

		fprintf(stderr,"\t  Will %suse other diagonal if it gives a less jaggy outline\n\t  Will %sdraw diagonal visibly if quadrangle is 'bent over'\n", hiddenShowAlternativeDiagonal != 0 ? "" : "not ", hiddenHandleBentoverQuadrangles != 0 ? "" : "not ");
	}
	public static void reset_hidden3doptions()
	{
		hiddenBacksideLinetypeOffset = DefineConstants.BACKSIDE_LINETYPE_OFFSET;
		hiddenTriangleLinesdrawnPattern = DefineConstants.TRIANGLE_LINESDRAWN_PATTERN;
		hiddenHandleUndefinedPoints = DefineConstants.HANDLE_UNDEFINED_POINTS;
		hiddenShowAlternativeDiagonal = DefineConstants.SHOW_ALTERNATIVE_DIAGONAL;
		hiddenHandleBentoverQuadrangles = DefineConstants.HANDLE_BENTOVER_QUADRANGLES;
		GlobalMembersGraph3d.hidden3d_layer = DefineConstants.LAYER_BACK;
	}

	/* Implements proper 'save'ing of the new hidden3d options... */
	public static void save_hidden3doptions(FILE fp)
	{
		if (!GlobalMembersGraph3d.hidden3d)
		{
			fputs("unset hidden3d\n", fp);
			return;
		}
		fprintf(fp, "set hidden3d %s offset %d trianglepattern %ld undefined %d %saltdiagonal %sbentover\n", GlobalMembersGraph3d.hidden3d_layer == DefineConstants.LAYER_BACK ? "back" : "front", hiddenBacksideLinetypeOffset, hiddenTriangleLinesdrawnPattern, hiddenHandleUndefinedPoints, hiddenShowAlternativeDiagonal != 0 ? "" : "no", hiddenHandleBentoverQuadrangles != 0 ? "" : "no");
	}

	/* Initialize the necessary steps for hidden line removal and
   initialize global variables. */
	///#ifndef LITE
	public static void init_hidden_line_removal()
	{
		/* Check for some necessary conditions to be set elsewhere: */
		/* HandleUndefinedPoints mechanism depends on these: */
		assert coord_type.OUTRANGE == 1;
		assert coord_type.UNDEFINED == 2;

		/* Re-mapping of this value makes the test easier in the critical
		 * section */
		if (hiddenHandleUndefinedPoints < coord_type.OUTRANGE)
			hiddenHandleUndefinedPoints = coord_type.UNDEFINED.getValue() + 1;

		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersDynarray.init_dynarray(vertices, sizeof(vertex), 100, 100);
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersDynarray.init_dynarray(edges, sizeof(edge), 100, 100);
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersDynarray.init_dynarray(polygons, sizeof(mesh_triangle), 100, 100);
		///#if HIDDEN3D_QUADTREE
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersDynarray.init_dynarray(qtree, sizeof(qtreelist), 100, 100);
		///#endif

	}

	/* Reset the hidden line data to a fresh start. */
	public static void reset_hidden_line_removal()
	{
		vertices.end = 0;
		edges.end = 0;
		polygons.end = 0;
		///#if HIDDEN3D_QUADTREE
		qtree.end = 0;
		///#endif
	}

	/* Terminates the hidden line removal process.                  */
	/* Free any memory allocated by init_hidden_line_removal above. */
	public static void term_hidden_line_removal()
	{
		GlobalMembersDynarray.free_dynarray(polygons);
		GlobalMembersDynarray.free_dynarray(edges);
		GlobalMembersDynarray.free_dynarray(vertices);
		///#if HIDDEN3D_QUADTREE
		GlobalMembersDynarray.free_dynarray(qtree);
		///#endif
	}

	/***********************************************************************
	 * and, finally, the 'mother function' that uses all these lots of tools
	 ***********************************************************************/
	public static void plot3d_hidden(surface_points plots, int pcount)
	{
		/* make vertices, edges and polygons out of all the plots */
		GlobalMembersHidden3d.build_networks(plots, pcount);

		if (edges.end == 0)
		{
			/* No drawable edges found. Free all storage and bail out. */
			GlobalMembersHidden3d.term_hidden_line_removal();
			GlobalMembersUtil.graph_error("*All* edges undefined or out of range, thus no plot.");
		}

		if (polygons.end == 0)
		{
			/* No polygons anything could be hidden behind... */

			GlobalMembersHidden3d.sort_edges_by_z();
			while (efirst >= 0)
			{
				GlobalMembersHidden3d.draw_edge((edge) edges.v + efirst, (vertex GPHUGE *) vertices.v + (edge) edges.v[efirst].v1, (vertex GPHUGE *) vertices.v + (edge) edges.v[efirst].v2);
				efirst = (edge) edges.v[efirst].next;
			}
		}
		else
		{
			int temporary_pfirst;

			/* Presort edges in z order */
			GlobalMembersHidden3d.sort_edges_by_z();
			/* Presort polygons in z order */
			GlobalMembersHidden3d.sort_polys_by_z();

			temporary_pfirst = pfirst;

			while (efirst >= 0)
			{
				if ((edge) edges.v[efirst].style >= -2) // skip invisible edges
					GlobalMembersHidden3d.in_front(efirst, (edge) edges.v[efirst].v1, (edge) edges.v[efirst].v2, temporary_pfirst);
				efirst = (edge) edges.v[efirst].next;
			}
		}

		/* Free memory */
		/* FIXME: anything to free? */
	}
	//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void draw_line_hidden(vertex GPHUGE, vertex GPHUGE, lp_style_type NamelessParameter3);
	///#endif



	///#ifdef HAVE_CONFIG_H
	///#endif
	///#ifndef TERM_HELP
	///#define PM3D_AT_BASE 'b'
	///#define PM3D_AT_TOP 't'
	///#define PM3D_AT_SURFACE 's'
	///#define PM3D_FLUSH_BEGIN 'b'
	///#define PM3D_FLUSH_END 'r'
	///#define PM3D_FLUSH_CENTER 'c'
	///#define PM3D_SCANS_AUTOMATIC 'a'
	///#define PM3D_SCANS_FORWARD 'f'
	///#define PM3D_SCANS_BACKWARD 'b'
	///#define PM3D_DEPTH 'd'
	///#define PM3D_CLIP_1IN '1'
	///#define PM3D_CLIP_4IN '4'
	///#endif // TERM_HELP 
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif


	/*************************/
	/* Configuration section */
	/*************************/

	/* If this module is compiled with HIDDEN3D_GRIDBOX = 1 defined, it
	 * will store the information about {x|y}{min|max} in an other
	 * (additional!) form: a bit mask, with each bit representing one
	 * horizontal or vertical strip of the screen. The bits for strips a
	 * polygon spans are set to one. This allows to test for xy overlap
	 * of an edge with a polygon simply by comparing bit patterns.  */
	///#ifndef HIDDEN3D_GRIDBOX
	///#define HIDDEN3D_GRIDBOX 0
	///#endif

	/* HBB 19991204: new code started to finally implement a spatially
	 * ordered data structure to store the polygons in. This is meant to
	 * speed up the HLR process. Before, the hot spot of hidden3d was the
	 * loop in in_front, where by far most of the polygons are rejected by
	 * the first test, already. The idea is to _not_ to loop over all
	 * those polygons far away from the edge under consideration, in the
	 * first place. Instead, store the polygons in an xy grid of lists,
	 * so we can select a sample of these lists to test a given edge
	 * against. */
	///#ifndef HIDDEN3D_QUADTREE
	///#define HIDDEN3D_QUADTREE 0
	///#endif
	///#if HIDDEN3D_QUADTREE && HIDDEN3D_GRIDBOX
	///#warning HIDDEN3D_QUADTREE & HIDDEN3D_GRIDBOX do not work together, sensibly!
	///#endif

	/* If you don't want the color-distinction between the
	 * 'top' and 'bottom' sides of the surface, like I do, then just compile
	 * with -DBACKSIDE_LINETYPE_OFFSET = 0. */
	///#ifndef BACKSIDE_LINETYPE_OFFSET
	///#define BACKSIDE_LINETYPE_OFFSET 1
	///#endif

	/* This #define lets you choose if the diagonals that
	 * divide each original quadrangle in two triangles will be drawn
	 * visible or not: do draw them, define it to be 7L, otherwise let be
	 * 3L */
	///#ifndef TRIANGLE_LINESDRAWN_PATTERN
	///#define TRIANGLE_LINESDRAWN_PATTERN 3L
	///#endif

	/* Handle out-of-range or undefined points. Compares the maximum
	 * marking (0=inrange, 1=outrange, 2=undefined) of the coordinates of
	 * a vertex to the value #defined here. If not less, the vertex is
	 * rejected, and all edges that hit it, as well. NB: if this is set to
	 * anything above 1, gnuplot may crash with a floating point exception
	 * in hidden3d. You get what you asked for ... */
	///#ifndef HANDLE_UNDEFINED_POINTS
	///#define HANDLE_UNDEFINED_POINTS 1
	///#endif
	/* Symbolic value for 'do not handle Undefined Points specially' */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define UNHANDLED (UNDEFINED+1)

	/* If both subtriangles of a quad were cancelled, try if using the
	 * other diagonal is better. This only makes a difference if exactly
	 * one vertex of the quad is unusable, and that one is on the 'usual'
	 * tried diagonal. In such a case, the border of the hole in the
	 * surface will be less rough than with the previous method, as the
	 * border follows the undefined region as close as it can. */
	///#ifndef SHOW_ALTERNATIVE_DIAGONAL
	///#define SHOW_ALTERNATIVE_DIAGONAL 1
	///#endif

	/* If the two triangles in a quad are both drawn, and they show
	 * different sides to the user (the quad is 'bent over'), then it's
	 * preferrable to force the diagonal being visible to avoid other
	 * parts of the scene being obscured by a line the user can't
	 * see. This avoids unnecessary user surprises. */
	///#ifndef HANDLE_BENTOVER_QUADRANGLES
	///#define HANDLE_BENTOVER_QUADRANGLES 1
	///#endif

	/* The actual configuration is stored in these variables, modifiable
	 * at runtime through 'set hidden3d' options */
	public static int hiddenBacksideLinetypeOffset = DefineConstants.BACKSIDE_LINETYPE_OFFSET;
	public static int hiddenTriangleLinesdrawnPattern = DefineConstants.TRIANGLE_LINESDRAWN_PATTERN;
	public static int hiddenHandleUndefinedPoints = DefineConstants.HANDLE_UNDEFINED_POINTS;
	public static int hiddenShowAlternativeDiagonal = DefineConstants.SHOW_ALTERNATIVE_DIAGONAL;
	public static int hiddenHandleBentoverQuadrangles = DefineConstants.HANDLE_BENTOVER_QUADRANGLES;


	/**************************************************************/
	/**************************************************************
	 * The 'real' code begins, here.                              *
	 *                                                            *
	 * first: types and global variables                          *
	 **************************************************************/
	/**************************************************************/

	/* precision of calculations in normalized space. Coordinates closer to
	 * each other than an absolute difference of EPSILON are considered
	 * equal, by some of the routines in this module. */
	///#define EPSILON 1e-5

	/* The code used to die messily if the scale parameters got over-large.
	 * Prevent this from happening due to mousing by locking out the mouse
	 * response. */
	public static boolean disable_mouse_z = false;

	/* Three dynamical arrays that describe what we have to plot: */
	public static dynarray vertices = new dynarray();
	public static dynarray edges = new dynarray();
	public static dynarray polygons = new dynarray();

	/* convenience #defines to make the generic vector useable as typed arrays */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define vlist ((p_vertex) vertices.v)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define plist ((p_polygon) polygons.v)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define elist ((p_edge) edges.v)

	public static int pfirst; // first polygon in zsorted chain
	public static int efirst; // first edges in zsorted chain

	/* the number of cells in x and y direction: */
	///#ifndef QUADTREE_GRANULARITY
	///#define QUADTREE_GRANULARITY 10
	///#endif
	/* indices of the heads of all the cells' chains: */
	public static int[][] quadtree = new int[DefineConstants.QUADTREE_GRANULARITY][DefineConstants.QUADTREE_GRANULARITY];

	/* and a routine to calculate the cells' position in that array: */
	public static int coord_to_treecell(double x)
	{
		int index;
		index = (int) (((((x) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0) * DefineConstants.QUADTREE_GRANULARITY);
		if (index >= DefineConstants.QUADTREE_GRANULARITY)
			index = DefineConstants.QUADTREE_GRANULARITY - 1;
		else if (index < 0)
			index = 0;

		return index;
	}

	/* the dynarray to actually store all that stuff in: */
	public static dynarray qtree = new dynarray();

	///#if 0 // UNUSED !
	//// /* Do we see the top or bottom of the polygon, or is it 'on edge'? */
	////#define GET_SIDE(vlst,csign)						do {									    double ctmp =								vlist[vlst[0]].x * (vlist[vlst[1]].y - vlist[vlst[2]].y) +		vlist[vlst[1]].x * (vlist[vlst[2]].y - vlist[vlst[0]].y) +		vlist[vlst[2]].x * (vlist[vlst[0]].y - vlist[vlst[1]].y);	    csign = SIGN (ctmp);						} while (0)
	////ignore
	////ignore
	////ignore
	////ignore
	////ignore
	////ignore
	////ignore
	///#endif // UNUSED 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define qlist ((p_qtreelist) qtree.v)

	/* Prototypes for internal functions of this module. */
	public static int store_vertex(coordinate point, lp_style_type lp_style, boolean color_from_column)
	{
		vertex GPHUGE * thisvert = GlobalMembersDynarray.nextfrom_dynarray(vertices);

		thisvert.lp_style = lp_style;
		if ((int) point.type >= hiddenHandleUndefinedPoints)
		{
			do
			{
				thisvert.z = -2.0;
			} while (0);
			return (-1);
		}
		GlobalMembersUtil3d.map3d_xyz(point.x, point.y, point.z, thisvert);
		if (color_from_column)
		{
			thisvert.real_z = point.ylow;
			thisvert.lp_style.pm3d_color.lt = DefineConstants.LT_COLORFROMCOLUMN;
		}
		else
			thisvert.real_z = point.z;

		///#ifdef HIDDEN3D_VAR_PTSIZE
		/* Store pointer back to original point */
		/* Needed to support variable pointsize */
		thisvert.original = point;
		///#endif

		return (thisvert - (vertex GPHUGE *) vertices.v);
	}

	/* A part of store_edge that does the actual storing. Used by
	 * in_front(), as well, so I separated it out. */
	public static int make_edge(int vnum1, int vnum2, lp_style_type lp, int style, int next)
	{
		edge GPHUGE * thisedge = GlobalMembersDynarray.nextfrom_dynarray(edges);
		vertex GPHUGE * v1 = (vertex GPHUGE *) vertices.v + vnum1;
		vertex GPHUGE * v2 = (vertex GPHUGE *) vertices.v + vnum2;

		/* ensure z ordering inside each edge */
		if (v1.z >= v2.z)
		{
			thisedge.v1 = vnum1;
			thisedge.v2 = vnum2;
		}
		else
		{
			thisedge.v1 = vnum2;
			thisedge.v2 = vnum1;
		}

		thisedge.style = style;
		thisedge.lp = lp;
		thisedge.next = next;

		return thisedge - (edge) edges.v;
	}

	/* store the edge from vnum1 to vnum2 into the edge list. Ensure that
	 * the vertex with higher z is stored in v1, to ease sorting by zmax */
	public static int store_edge(int vnum1, edge_direction direction, int crvlen, lp_style_type lp, int style)
	{
		vertex GPHUGE * v1 = (vertex GPHUGE *) vertices.v + vnum1;
		vertex GPHUGE * v2 = DefineConstants.NULL; // just in case: initialize...
		int vnum2;
		int drawbits = (0x1 << direction);

		switch (direction)
		{
		case edir_vector:
			v2 = v1 + 1;
			drawbits = 0;
			break;
		case edir_west:
			v2 = v1 - 1;
			break;
		case edir_north:
			v2 = v1 - crvlen;
			break;
		case edir_NW:
			v2 = v1 - crvlen - 1;
			break;
		case edir_NE:
			v2 = v1 - crvlen;
			v1 -= 1;
			drawbits >>= 1; // altDiag is handled like normal NW one
		break;
		case edir_impulse:
			v2 = v1 - 1;
			drawbits = 0; // don't care about the triangle pattern
			break;
		case edir_point:
			v2 = v1;
			drawbits = 0; // nothing to draw, but disable check
			break;
		}

		vnum2 = v2 - (vertex GPHUGE *) vertices.v;

		if ((v1.z == -2.0) || (v2.z == -2.0))
		{
			return -2;
		}

		if (drawbits != 0 && !(hiddenTriangleLinesdrawnPattern & drawbits)) // no bits set: 'blind' edge --> no test!
			style = -3;

		return GlobalMembersHidden3d.make_edge(vnum1, vnum2, lp, style, -1);
	}

	/* Evaluate the plane equation represented a four-vector for the given
	 * vector. For points in the plane, this should result in values ==0.
	 * < 0 is 'away' from the polygon, > 0 is infront of it */
	public static double eval_plane_equation(double[] p, vertex v)
	{
		return (p[0] * v.x + p[1] * v.y + p[2] * v.z + p[3]);
	}

	/* Find the intersection of a line and plane in 3d space in
	 * terms of parameterization u where v = v1 + u * (v2 - v1) */
	public static double intersect_line_plane(vertex v1, vertex v2, double[] p)
	{
		double numerator = GlobalMembersHidden3d.eval_plane_equation(p, v1);
		if (numerator == 0)
			return 0;
		else
		{
			double denominator = p[0] * (v1.x - v2.x) + p[1] * (v1.y - v2.y) + p[2] * (v1.z - v2.z);
			return numerator / denominator;
		}
	}

	/* Find the intersection of two lines in 2d space in terms
	 * of parameterization u where v = v1 + u * (v2 - v1) */
	public static double intersect_line_line(vertex v1, vertex v2, vertex w1, vertex w2)
	{
		double numerator = (w2.x - w1.x) * (v1.y - w1.y) - (w2.y - w1.y) * (v1.x - w1.x);
		if (numerator == 0)
			return 0;
		else
		{
			double denominator = (w2.y - w1.y) * (v2.x - v1.x) - (w2.x - w1.x) * (v2.y - v1.y);
			return numerator / denominator;
		}
	}

	/* Check whether the point is covered by the plane in 3d space
	 *
	 * 0 - point not covered
	 * 1 - point covered and does not lie in plane
	 * 2 - point covered and lies in plane
	 */
	public static int cover_point_poly(vertex v1, vertex v2, double u, mesh_triangle poly)
	{
		/* Using EQ() test seemed to have no effect on results */
		if (poly.plane[2] == 0)
		{
			/* The element is "vertical" so treat as infitesimally small for now.
			 * An alternative would be to interpolate the edge closest to the
			 * viewer plane.  However, there may be tests previous to this that
			 * rule out this case. */
			return 0;
		}
		else
		{
			vertex GPHUGE * w1 = (vertex GPHUGE *) vertices.v + poly.vertex[0];
			vertex GPHUGE * w2 = (vertex GPHUGE *) vertices.v + poly.vertex[1];
			vertex GPHUGE * w3 = (vertex GPHUGE *) vertices.v + poly.vertex[2];
			double[] p_side = new double[3]; // Signed areas
			vertex p = new vertex();
			p.x = v1.x + u * (v2.x - v1.x);
			p.y = v1.y + u * (v2.y - v1.y);
			p.z = v1.z + u * (v2.z - v1.z);
			/* Check if point is inside triangular element */
			p_side[0] = GlobalMembersHidden3d.area2D(w1, w2, p);
			p_side[1] = GlobalMembersHidden3d.area2D(w2, w3, p);
			p_side[2] = GlobalMembersHidden3d.area2D(w3, w1, p);
			if (0 || (((p_side[0]) >= (0) - DefineConstants.EPSILON) && ((p_side[1]) >= (0) - DefineConstants.EPSILON) && ((p_side[2]) >= (0) - DefineConstants.EPSILON)) || (((0) >= (p_side[0]) - DefineConstants.EPSILON) && ((0) >= (p_side[1]) - DefineConstants.EPSILON) && ((0) >= (p_side[2]) - DefineConstants.EPSILON)))
			{
				/* Point inside closed triangle, now check z value */
				double z_plane = -(poly.plane[0] * p.x + poly.plane[1] * p.y + poly.plane[3]) / poly.plane[2];
				if (((z_plane) >= (p.z) - DefineConstants.EPSILON))
				{
					/* Covered, but is it on the plane? */
					if (((p.z) >= (z_plane) - DefineConstants.EPSILON))
						return 2;
					else
						return 1;
				}
				else
					return 0;
			}
			else
				return 0;
		}
	}

	/* Build the data structure for this polygon. The return value is the
	 * index of the newly generated polygon. This is memorized for access
	 * to polygons in the previous isoline, from the next-following
	 * one. */
	public static int store_polygon(int vnum1, polygon_direction direction, int crvlen)
	{
		int[] v = new int[DefineConstants.POLY_NVERT];
		vertex GPHUGE * v1, *v2, *v3;
		mesh_triangle GPHUGE * GlobalMembersAnsi2knr.p;

		switch (direction)
		{
		case pdir_NE:
			v[0] = vnum1;
			v[2] = vnum1 - crvlen;
			v[1] = v[2] - 1;
			break;
		case pdir_SW:
			/* triangle points southwest, here */
			v[0] = vnum1;
			v[1] = vnum1 - 1;
			v[2] = v[1] - crvlen;
			break;
		case pdir_SE:
			/* alt-diagonal, case 1: southeast triangle: */
			v[0] = vnum1;
			v[2] = vnum1 - crvlen;
			v[1] = vnum1 - 1;
			break;
		case pdir_NW:
			v[2] = vnum1 - crvlen;
			v[0] = vnum1 - 1;
			v[1] = v[0] - crvlen;
			break;
		}

		v1 = (vertex GPHUGE *) vertices.v + v[0];
		v2 = (vertex GPHUGE *) vertices.v + v[1];
		v3 = (vertex GPHUGE *) vertices.v + v[2];

		if ((v1.z == -2.0) || (v2.z == -2.0) || (v3.z == -2.0))
			return (-2);

		/* Check if polygon is degenerate */
		if ((((0.0) >= (Math.abs((v1).x - (v2).x) + Math.abs((v1).y - (v2).y) + Math.abs((v1).z - (v2).z)) - DefineConstants.EPSILON)) || (((0.0) >= (Math.abs((v2).x - (v3).x) + Math.abs((v2).y - (v3).y) + Math.abs((v2).z - (v3).z)) - DefineConstants.EPSILON)) || (((0.0) >= (Math.abs((v3).x - (v1).x) + Math.abs((v3).y - (v1).y) + Math.abs((v3).z - (v1).z)) - DefineConstants.EPSILON)))
			return (-2);

		/* All else OK, fill in the polygon: */

		GlobalMembersAnsi2knr.p = GlobalMembersDynarray.nextfrom_dynarray(polygons);

		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memcpy(GlobalMembersAnsi2knr.p.vertex, v, sizeof(v));
		///#if ! HIDDEN3D_QUADTREE
		//    p->next = -1;
		///#endif

		/* Some helper macros for repeated code blocks: */

		/* Gets Minimum 'var' value of polygon 'poly' into variable
		 * 'min. C is one of x, y, or z: */
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define GET_MIN(poly, var, min) do { int i; long *v = poly->vertex; min = vlist[*v++].var; for (i = 1; i< POLY_NVERT; i++, v++) if (vlist[*v].var < min) min = vlist[*v].var; if (min < -surface_scale) disable_mouse_z = TRUE; } while (0)

		/* Gets Maximum 'var' value of polygon 'poly', as with GET_MIN */
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define GET_MAX(poly, var, max) do { int i; long *v = poly->vertex; max = vlist[*v++].var; for (i = 1; i< POLY_NVERT; i++, v++) if (vlist[*v].var > max) max = vlist[*v].var; if (max > surface_scale) disable_mouse_z = TRUE; } while (0)

		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.xmin = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var < GlobalMembersAnsi2knr.p.xmin)
					GlobalMembersAnsi2knr.p.xmin = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.xmin < -GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.ymin = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var < GlobalMembersAnsi2knr.p.ymin)
					GlobalMembersAnsi2knr.p.ymin = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.ymin < -GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.zmin = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var < GlobalMembersAnsi2knr.p.zmin)
					GlobalMembersAnsi2knr.p.zmin = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.zmin < -GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.xmax = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var > GlobalMembersAnsi2knr.p.xmax)
					GlobalMembersAnsi2knr.p.xmax = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.xmax > GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.ymax = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var > GlobalMembersAnsi2knr.p.ymax)
					GlobalMembersAnsi2knr.p.ymax = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.ymax > GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		do
		{
			int i;
			int[] v = GlobalMembersAnsi2knr.p.vertex;
			GlobalMembersAnsi2knr.p.zmax = (vertex GPHUGE *) vertices.v[*v++].var;
			for (i = 1; i < DefineConstants.POLY_NVERT; i++, v++)
				if ((vertex GPHUGE *) vertices.v[*v].var > GlobalMembersAnsi2knr.p.zmax)
					GlobalMembersAnsi2knr.p.zmax = (vertex GPHUGE *) vertices.v[*v].var;
			if (GlobalMembersAnsi2knr.p.zmax > GlobalMembersGraph3d.surface_scale)
				disable_mouse_z = true;
		} while (0);
		//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
		///#undef GET_MIN
		//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
		///#undef GET_MAX

		///#if HIDDEN3D_GRIDBOX
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersAnsi2knr.p.xbits = ((~(~0 << (int)(((((GlobalMembersAnsi2knr.p.xmax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((GlobalMembersAnsi2knr.p.xmin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		GlobalMembersAnsi2knr.p.ybits = ((~(~0 << (int)(((((GlobalMembersAnsi2knr.p.ymax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((GlobalMembersAnsi2knr.p.ymin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
		///#endif

		GlobalMembersAnsi2knr.p.frontfacing = GlobalMembersHidden3d.get_plane(GlobalMembersAnsi2knr.p, GlobalMembersAnsi2knr.p.plane);

		return (GlobalMembersAnsi2knr.p - (mesh_triangle) polygons.v);
	}

	/* color edges, based on the orientation of polygon(s). One of the two
	 * edges passed in is a new one, meaning there is no other polygon
	 * sharing it, yet. The other, 'old' edge is common to the new polygon
	 * and another one, which was created earlier on. If these two polygon
	 * differ in their orientation (one front-, the other backsided to the
	 * viewer), this routine has to resolve that conflict.  Edge colours
	 * are changed only if the edge wasn't invisible, before */
	public static void color_edges(int new_edge, int old_edge, int new_poly, int old_poly, int above, int below)
	{
		int casenumber;

		if (new_poly > -2)
		{
			/* new polygon was built successfully */
			if (old_poly <= -2)
				/* old polygon doesn't exist. Use new_polygon for both: */
				old_poly = new_poly;

			casenumber = ((mesh_triangle) polygons.v[new_poly].frontfacing ? 1 : 0) + 2 * ((mesh_triangle) polygons.v[old_poly].frontfacing ? 1 : 0);
			switch (casenumber)
			{
			case 0:
				/* both backfacing */
				if ((edge) edges.v[new_edge].style >= -2)
					(edge) edges.v[new_edge].style = below;
				if ((edge) edges.v[old_edge].style >= -2)
					(edge) edges.v[old_edge].style = below;
				break;
			case 2:
				if ((edge) edges.v[new_edge].style >= -2)
					(edge) edges.v[new_edge].style = below;
				/* FALLTHROUGH */
			case 1:
				/* new front-, old one backfacing, or */
				/* new back-, old one frontfacing */
				if (((new_edge == old_edge) && hiddenHandleBentoverQuadrangles != 0) || ((edge) edges.v[old_edge].style >= -2)) // a diagonal edge!
				{
					/* conflict has occured: two polygons meet here, with opposige
					 * sides being shown. What's to do?
					 * 1) find a vertex of one polygon outside this common
					 * edge
					 * 2) check wether it's in front of or behind the
					 * other polygon's plane
					 * 3) if in front, color the edge accoring to the
					 * vertex' polygon, otherwise, color like the other
					 * polygon */
					int vnum1 = (edge) edges.v[old_edge].v1;
					int vnum2 = (edge) edges.v[old_edge].v2;
					mesh_triangle GPHUGE * GlobalMembersAnsi2knr.p = (mesh_triangle) polygons.v + new_poly;
					int pvert = -1;
					double point_to_plane;

					if (GlobalMembersAnsi2knr.p.vertex[0] == vnum1)
					{
						if (GlobalMembersAnsi2knr.p.vertex[1] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[2];
						}
						else if (GlobalMembersAnsi2knr.p.vertex[2] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[1];
						}
					}
					else if (GlobalMembersAnsi2knr.p.vertex[1] == vnum1)
					{
						if (GlobalMembersAnsi2knr.p.vertex[0] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[2];
						}
						else if (GlobalMembersAnsi2knr.p.vertex[2] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[0];
						}
					}
					else if (GlobalMembersAnsi2knr.p.vertex[2] == vnum1)
					{
						if (GlobalMembersAnsi2knr.p.vertex[0] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[1];
						}
						else if (GlobalMembersAnsi2knr.p.vertex[1] == vnum2)
						{
							pvert = GlobalMembersAnsi2knr.p.vertex[0];
						}
					}
					assert pvert >= 0;

					point_to_plane = GlobalMembersHidden3d.eval_plane_equation((mesh_triangle) polygons.v[old_poly].plane, (vertex GPHUGE *) vertices.v + pvert);

					if (point_to_plane > 0)
					{
						/* point in new_poly is in front of old_poly plane */
						(edge) edges.v[old_edge].style = GlobalMembersAnsi2knr.p.frontfacing ? above : below;
					}
					else
					{
						(edge) edges.v[old_edge].style = (mesh_triangle) polygons.v[old_poly].frontfacing ? above : below;
					}
				}
				break;
			case 3:
				/* both frontfacing: nothing to do */
				break;
			} // switch
		}
		else
		{
			/* Ooops? build_networks() must have guessed incorrectly that
			 * this polygon should exist. */
			return;
		}
	}

	/* This somewhat monstrous routine fills the vlist, elist and plist
	 * dynamic arrays with values from all those plots. It strives to
	 * respect all the topological linkage between vertices, edges and
	 * polygons. E.g., it has to find the correct color for each edge,
	 * based on the orientation of the two polygons sharing it, WRT both
	 * the observer and each other. */
	/* NEW FEATURE HBB 20000715: allow non-grid datasets too, by storing
	 * only vertices and 'direct' edges, but no polygons or 'cross' edges
	 * */
	public static void build_networks(surface_points plots, int pcount)
	{
		int i;
		surface_points this_plot;
		int surface; // count the surfaces (i.e. sub-plots)
		int crv; // count isolines
		int ncrvs;
		int nverts; // count vertices
		int max_crvlen; // maximal length of isoline in any plot
		int nv; // local poly/edge/vertex counts
		int ne;
		int np;
		int north_polygons; // stores polygons of isoline above
		int these_polygons; // same, being built for use by next turn
		int north_edges; // stores edges of polyline above
		int these_edges; // same, being built for use by next turn
		iso_curve icrvs;
		int above = -3; // line type for edges of front/back side
		int below;
		lp_style_type lp; // pointer to line and point properties

		/* Count out the initial sizes needed for the polygon and vertex
		 * lists. */
		nv = ne = np = 0;
		max_crvlen = -1;

		for (this_plot = plots, surface = 0; surface < pcount; this_plot = this_plot.next_sp, surface++)
		{
			int crvlen;

			/* Quietly skip empty plots */
			if (this_plot.plot_type == PLOT_TYPE.NODATA)
				continue;

			crvlen = this_plot.iso_crvs.p_count;

			/* Allow individual plots to opt out of hidden3d calculations */
			if (this_plot.opt_out_of_hidden3d)
				continue;

			/* register maximal isocurve length. Only necessary for
			 * grid-topology plots that will create polygons, so I can do
			 * it here, already. */
			if (crvlen > max_crvlen)
				max_crvlen = crvlen;

			/* count 'curves' (i.e. isolines) and vertices in this plot */
			nverts = 0;
			if (this_plot.plot_type == PLOT_TYPE.FUNC3D)
			{
				ncrvs = 0;
				for (icrvs = this_plot.iso_crvs; icrvs; icrvs = icrvs.next)
				{
					ncrvs++;
				}
				nverts += ncrvs * crvlen;
			}
			else if (this_plot.plot_type == PLOT_TYPE.DATA3D)
			{
				ncrvs = this_plot.num_iso_read;
				if (this_plot.has_grid_topology != 0)
					nverts += ncrvs * crvlen;
				else if (this_plot.plot_style == PLOT_STYLE.VECTOR)
					nverts += this_plot.iso_crvs.p_count;
				else
				{
					/* have to check each isoline separately: */
					for (icrvs = this_plot.iso_crvs; icrvs; icrvs = icrvs.next)
						nverts += icrvs.p_count;
				}
			}
			else
			{
				GlobalMembersUtil.graph_error("Plot type is neither function nor data");
				return;
			}

			/* To avoid possibly suprising error messages, several 2d-only
			 * plot styles are mapped to others, that are genuinely
			 * available in 3d. */
			switch (this_plot.plot_style)
			{
			case LINESPOINTS:
			case STEPS:
			case FSTEPS:
			case HISTEPS:
			case LINES:
				nv += nverts;
				ne += nverts - ncrvs;
				if (this_plot.has_grid_topology != 0)
				{
					ne += 2 * nverts - ncrvs - 2 * crvlen + 1;
					np += 2 * (ncrvs - 1) * (crvlen - 1);
				}
				break;
			case BOXES:
			case FILLEDCURVES:
			case IMPULSES:
			case VECTOR:
				nv += 2 * nverts;
				ne += nverts;
				break;
			case POINTSTYLE:
			default:
				/* treat all remaining ones like 'points' */
				nv += nverts;
				ne += nverts; // a 'phantom edge' per isolated point
				break;
			} // switch
		} // for (plots)

		/* Check for no data at all */
		if (max_crvlen <= 0)
			return;

		/* allocate all the lists to the size we need: */
		GlobalMembersDynarray.resize_dynarray(vertices, nv);
		GlobalMembersDynarray.resize_dynarray(edges, ne);
		GlobalMembersDynarray.resize_dynarray(polygons, np);

		/* allocate the storage for polygons and edges of the isoline just
		 * above the current one, to allow easy access to them from the
		 * current isoline */
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		north_polygons = GlobalMembersAlloc.gp_alloc(2 * max_crvlen * sizeof(int), "hidden north_polys");
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		these_polygons = GlobalMembersAlloc.gp_alloc(2 * max_crvlen * sizeof(int), "hidden these_polys");
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		north_edges = GlobalMembersAlloc.gp_alloc(3 * max_crvlen * sizeof(int), "hidden north_edges");
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		these_edges = GlobalMembersAlloc.gp_alloc(3 * max_crvlen * sizeof(int), "hidden these_edges");

		/* initialize the lists, all in one large loop. This is different
		 * from the previous approach, which went over the vertices,
		 * first, and only then, in new loop, built polygons */
		for (this_plot = plots, surface = 0; surface < pcount; this_plot = this_plot.next_sp, surface++)
		{
			lp_style_type lp_style = DefineConstants.NULL;
			boolean color_from_column = this_plot.pm3d_color_from_column;
			int crvlen;

			/* Quietly skip empty plots */
			if (this_plot.plot_type == PLOT_TYPE.NODATA)
				continue;

			crvlen = this_plot.iso_crvs.p_count;

			/* Allow individual plots to opt out of hidden3d calculations */
			if (this_plot.opt_out_of_hidden3d)
				continue;

			lp = (this_plot.lp_properties);
			above = this_plot.lp_properties.l_type;
			below = this_plot.lp_properties.l_type + hiddenBacksideLinetypeOffset;

			/* calculate the point symbol type: */
			/* Assumes that upstream functions have made sure this is
			 * initialized sensibly --- thou hast been warned */
			lp_style = (this_plot.lp_properties);

			/* HBB 20000715: new initialization code block for non-grid
			 * structured datasets. Sufficiently different from the rest
			 * to warrant separate code, I think. */
			if (this_plot.has_grid_topology == 0)
			{
				for (crv = 0, icrvs = this_plot.iso_crvs; icrvs; crv++, icrvs = icrvs.next)
				{
					coordinate points = icrvs.points;
					int previousvertex = -1;

					/* To handle labels we must look inside a separate list */
					/* rather than just walking through the points arrays.  */
					if (this_plot.plot_style == PLOT_STYLE.LABELPOINTS)
					{
						text_label label;
						int thisvertex;
						coordinate labelpoint = new coordinate();

						lp.pointflag = 1; // Labels can use the code for hidden points
						for (label = this_plot.labels.next; label != DefineConstants.NULL; label = label.next)
						{
							labelpoint.x = label.place.x;
							labelpoint.y = label.place.y;
							labelpoint.z = label.place.z;
							thisvertex = GlobalMembersHidden3d.store_vertex(labelpoint, (this_plot.lp_properties), color_from_column);
							if (thisvertex < 0)
								continue;
							((vertex GPHUGE *) vertices.v + thisvertex).label = label;
							GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_point, crvlen, lp, above);
						}

					}
					else
						for (i = 0; i < icrvs.p_count; i++)
						{
							int thisvertex;
							int basevertex;

							thisvertex = GlobalMembersHidden3d.store_vertex(points + i, lp_style, color_from_column);

							if (this_plot.plot_style == PLOT_STYLE.VECTOR)
							{
								GlobalMembersHidden3d.store_vertex(icrvs.next.points + i, 0, 0);
							}

							if (thisvertex < 0)
							{
								previousvertex = thisvertex;
								continue;
							}

							switch (this_plot.plot_style)
							{
							case LINESPOINTS:
							case STEPS:
							case FSTEPS:
							case HISTEPS:
							case LINES:
								if (previousvertex >= 0)
									GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_west, 0, lp, above);
								break;
							case VECTOR:
								GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_vector, 0, lp, above);
								break;
							case BOXES:
							case FILLEDCURVES:
							case IMPULSES:
								/* set second vertex to the low end of zrange */
							{
								double remember_z = points[i].z;

								points[i].z = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].min;
								basevertex = GlobalMembersHidden3d.store_vertex(points + i, lp_style, color_from_column);
								points[i].z = remember_z;
							}
							if (basevertex > 0)
								GlobalMembersHidden3d.store_edge(basevertex, edge_direction.edir_impulse, 0, lp, above);
							break;

							case POINTSTYLE:
							default: // treat all the others like 'points'
								GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_point, crvlen, lp, above);
								break;
							} // switch(plot_style)

							previousvertex = thisvertex;
						} // for(vertex)
				} // for(crv)

				continue; // done with this plot!
			}

			/* initialize stored indices of north-of-this-isoline polygons and
			 * edges properly */
			for (i = 0; i < this_plot.iso_crvs.p_count; i++)
			{
				north_polygons[2 * i] = north_polygons[2 * i + 1] = north_edges[3 * i] = north_edges[3 * i + 1] = north_edges[3 * i + 2] = -3;
			}

			for (crv = 0, icrvs = this_plot.iso_crvs; icrvs; crv++, icrvs = icrvs.next)
			{
				//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
				//ORIGINAL LINE: struct coordinate  *points = icrvs->points;
				coordinate[] points = new coordinate(icrvs.points);

				for (i = 0; i < icrvs.p_count; i++)
				{
					int thisvertex;
					int basevertex;
					int e1;
					int e2;
					int e3;
					int pnum;

					thisvertex = GlobalMembersHidden3d.store_vertex(points + i, lp_style, color_from_column);

					/* Preset the pointers to the polygons and edges
					 * belonging to this isoline */
					these_polygons[2 * i] = these_polygons[2 * i + 1] = these_edges[3 * i] = these_edges[3 * i + 1] = these_edges[3 * i + 2] = -3;

					switch (this_plot.plot_style)
					{
					case LINESPOINTS:
					case STEPS:
					case FSTEPS:
					case HISTEPS:
					case LINES:
						if (i > 0)
						{
							/* not first point, so we might want to set up
							 * the edge(s) to the left of this vertex */
							if (thisvertex < 0)
							{
								if ((crv > 0) && (hiddenShowAlternativeDiagonal))
								{
									/* this vertex is invalid, but the
									 * other three might still form a
									 * valid triangle, facing northwest to
									 * do that, we'll need the 'wrong'
									 * diagonal, which goes from SW to NE:
									 * */
									these_edges[i * 3 + 2] = e3 = GlobalMembersHidden3d.store_edge(vertices.end - 1, edge_direction.edir_NE, crvlen, lp, above);
									if (e3 > -2)
									{
										/* don't store this polygon for
										 * later: it doesn't share edges
										 * with any others to the south or
										 * east, so there's need to */
										pnum = GlobalMembersHidden3d.store_polygon(vertices.end - 1, polygon_direction.pdir_NW, crvlen);
										/* The other two edges of this
										 * polygon need to be checked
										 * against the neighboring
										 * polygons' orientations, before
										 * being coloured */
										GlobalMembersHidden3d.color_edges(e3, these_edges[3 * (i - 1) + 1], pnum, these_polygons[2 * (i - 1) + 1], above, below);
										GlobalMembersHidden3d.color_edges(e3, north_edges[3 * i], pnum, north_polygons[2 * i], above, below);
									}
								}
								break; // nothing else to do for invalid vertex
							}

							/* Coming here means that the current vertex
							 * is valid: check the other three of this
							 * cell, by trying to set up the edges from
							 * this one to there */
							these_edges[i * 3] = e1 = GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_west, crvlen, lp, above);

							if (crv > 0) // vertices to the north exist
							{
								these_edges[i * 3 + 1] = e2 = GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_north, crvlen, lp, above);
								these_edges[i * 3 + 2] = e3 = GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_NW, crvlen, lp, above);
								if (e3 > -2)
								{
									/* diagonal edge of this cell is OK,
									 * so try to build both the polygons:
									 * */
									if (e1 > -2)
									{
										/* one pair of edges is valid: put
										 * first polygon, which points
										 * towards the southwest */
										these_polygons[2 * i] = pnum = GlobalMembersHidden3d.store_polygon(thisvertex, polygon_direction.pdir_SW, crvlen);
										GlobalMembersHidden3d.color_edges(e1, these_edges[3 * (i - 1) + 1], pnum, these_polygons[2 * (i - 1) + 1], above, below);
									}
									if (e2 > -2)
									{
										/* other pair of two is fine, put
										 * the northeast polygon: */
										these_polygons[2 * i + 1] = pnum = GlobalMembersHidden3d.store_polygon(thisvertex, polygon_direction.pdir_NE, crvlen);
										GlobalMembersHidden3d.color_edges(e2, north_edges[3 * i], pnum, north_polygons[2 * i], above, below);
									}
									/* In case these two new polygons
									 * differ in orientation, find good
									 * coloring of the diagonal */
									GlobalMembersHidden3d.color_edges(e3, e3, these_polygons[2 * i], these_polygons[2 * i + 1], above, below);
								} // if e3 valid
								else if ((e1 > -2) && (e2 > -2) && hiddenShowAlternativeDiagonal != 0)
								{
									/* looks like all but the north-west
									 * vertex are usable, so we set up the
									 * southeast-pointing triangle, using
									 * the 'wrong' diagonal: */
									these_edges[3 * i + 2] = e3 = GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_NE, crvlen, lp, above);
									if (e3 > -2)
									{
										/* fill this polygon into *both*
										 * polygon places for this
										 * quadrangle, as this triangle
										 * coincides with both edges that
										 * will be used by later polygons
										 * */
										these_polygons[2 * i] = these_polygons[2 * i + 1] = pnum = GlobalMembersHidden3d.store_polygon(thisvertex, polygon_direction.pdir_SE, crvlen);
										/* This case is somewhat special:
										 * all edges are new, so there is
										 * no other polygon orientation to
										 * consider */
										if (!(mesh_triangle) polygons.v[pnum].frontfacing)
											(edge) edges.v[e1].style = (edge) edges.v[e2].style = (edge) edges.v[e3].style = below;
									}
								}
							}
						}
						else if ((crv > 0) && (thisvertex >= 0))
						{
							/* We're at the west border of the grid, but
							 * not on the north one: put vertical end-wall
							 * edge:*/
							these_edges[3 * i + 1] = GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_north, crvlen, lp, above);
						}
						break;

					case BOXES:
					case FILLEDCURVES:
					case IMPULSES:
						if (thisvertex < 0)
							break;

						/* set second vertex to the low end of zrange */
						{
							double remember_z = points[i].z;

							points[i].z = GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].min;
							basevertex = GlobalMembersHidden3d.store_vertex(points + i, lp_style, color_from_column);
							points[i].z = remember_z;
						}
						if (basevertex > 0)
							GlobalMembersHidden3d.store_edge(basevertex, edge_direction.edir_impulse, 0, lp, above);
						break;

					case POINTSTYLE:
					default: // treat all the others like 'points'
						if (thisvertex < 0) // Ignore invalid vertex
							break;
						GlobalMembersHidden3d.store_edge(thisvertex, edge_direction.edir_point, crvlen, lp, above);
						break;
					} // switch
				} // for(i)

				/* Swap the 'north' lists of polygons and edges with
				 * 'these' ones, which have been filled in the pass
				 * through this isocurve */
				{
					int temp = north_polygons;
					north_polygons = these_polygons;
					these_polygons = temp;

					temp = north_edges;
					north_edges = these_edges;
					these_edges = temp;
				}
			} // for(isocrv)
		} // for(plot)

		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(these_polygons);
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(north_polygons);
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(these_edges);
		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(north_edges);
	}

	/* Sort the elist in order of growing zmax. Uses qsort on an array of
	 * plist indices, and then fills in the 'next' fields in struct
	 * polygon to store the resulting order inside the plist */
	/* HBB 20010720: removed 'static' to avoid HP-sUX gcc bug */
	public static int compare_edges_by_zmin(Object p1, Object p2)
	{
		return ((((vertex GPHUGE *) vertices.v[(edge) edges.v[(Integer) p1].v2].z - (vertex GPHUGE *) vertices.v[(edge) edges.v[(Integer) p2].v2].z)<-DefineConstants.EPSILON) ? - 1: (((vertex GPHUGE *) vertices.v[(edge) edges.v[(Integer) p1].v2].z - (vertex GPHUGE *) vertices.v[(edge) edges.v[(Integer) p2].v2].z)>DefineConstants.EPSILON));
	}

	/* HBB 20010720: removed 'static' to avoid HP-sUX gcc bug */
	public static int compare_polys_by_zmax(Object p1, Object p2)
	{
		return (((((mesh_triangle) polygons.v[(Integer) p1].zmax - (mesh_triangle) polygons.v[(Integer) p2].zmax)<-DefineConstants.EPSILON) ? - 1: (((mesh_triangle) polygons.v[(Integer) p1].zmax - (mesh_triangle) polygons.v[(Integer) p2].zmax)>DefineConstants.EPSILON)));
	}
	public static void sort_edges_by_z()
	{
		int[] sortarray;
		int i;
		edge GPHUGE this;

		if (edges.end == 0)
			return;

		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		sortarray = GlobalMembersAlloc.gp_alloc(sizeof(int) * edges.end, "hidden sort edges");
		/* initialize sortarray with an identity mapping */
		for (i = 0; i < edges.end; i++)
			sortarray[i] = i;
		/* sort it */
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(sortarray, (int) edges.end, sizeof(int), GlobalMembersHidden3d.compare_edges_by_zmin);

		/* traverse plist in the order given by sortarray, and set the
		 * 'next' pointers */
		this = (edge) edges.v + sortarray[0];
		for (i = 1; i < edges.end; i++)
		{
			this.next = sortarray[i];
			this = (edge) edges.v + sortarray[i];
		}
		this.next = -1;

		/* 'efirst' is the index of the leading element of plist */
		efirst = sortarray[0];

		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(sortarray);
	}
	public static void sort_polys_by_z()
	{
		int[] sortarray;
		int i;
		mesh_triangle GPHUGE this;

		if (polygons.end == 0)
			return;

		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		sortarray = GlobalMembersAlloc.gp_alloc(sizeof(int) * polygons.end, "hidden sortarray");

		/* initialize sortarray with an identity mapping */
		for (i = 0; i < polygons.end; i++)
			sortarray[i] = i;

		/* sort it */
		//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(sortarray, (int) polygons.end, sizeof(int), GlobalMembersHidden3d.compare_polys_by_zmax);

		/* traverse plist in the order given by sortarray, and set the
		 * 'next' pointers */
		///#if HIDDEN3D_QUADTREE
		/* HBB 20000716: Loop backwards, to ease construction of
		 * linked lists from the head: */
		{
			int grid_x;
			int grid_y;
			int grid_x_low;
			int grid_x_high;
			int grid_y_low;
			int grid_y_high;

			for (grid_x = 0; grid_x < DefineConstants.QUADTREE_GRANULARITY; grid_x++)
				for (grid_y = 0; grid_y < DefineConstants.QUADTREE_GRANULARITY; grid_y++)
					quadtree[grid_x][grid_y] = -1;

			for (i = polygons.end - 1; i >= 0; i--)
			{
				this = (mesh_triangle) polygons.v + sortarray[i];

				grid_x_low = GlobalMembersHidden3d.coord_to_treecell(this.xmin);
				grid_x_high = GlobalMembersHidden3d.coord_to_treecell(this.xmax);
				grid_y_low = GlobalMembersHidden3d.coord_to_treecell(this.ymin);
				grid_y_high = GlobalMembersHidden3d.coord_to_treecell(this.ymax);

				for (grid_x = grid_x_low; grid_x <= grid_x_high; grid_x++)
				{
					for (grid_y = grid_y_low; grid_y <= grid_y_high; grid_y++)
					{
						qtreelist GPHUGE * newhead = GlobalMembersDynarray.nextfrom_dynarray(qtree);

						newhead.next = quadtree[grid_x][grid_y];
						newhead.p = sortarray[i];

						quadtree[grid_x][grid_y] = newhead - (qtreelist) qtree.v;
					}
				}
			}
		}

		///#else // HIDDEN3D_QUADTREE
		//    this = plist + sortarray[0];
		//    for (i = 1; i < polygons.end; i++) {
		//	this->next = sortarray[i];
		//	this = plist + sortarray[i];
		//    }
		//    this->next = -1L;
		// /* 'pfirst' is the index of the leading element of plist */
		///#endif // HIDDEN3D_QUADTREE
		pfirst = sortarray[0];

		//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(sortarray);
	}

	/* Calculate the normal equation coefficients of the plane of polygon
	 * 'p'. Uses is the 'signed projected area' method. Its benefit is
	 * that it doesn't rely on only three of the vertices of 'p', as the
	 * naive cross product method does. */
	public static boolean get_plane(mesh_triangle GPHUGE poly, double[] plane)
	{
		int i;
		vertex GPHUGE * v1, *v2;
		double x;
		double y;
		double z;
		double s;
		boolean frontfacing = true;

		/* calculate the signed areas of the polygon projected onto the
		 * planes x=0, y=0 and z=0, respectively. The three areas form
		 * the components of the plane's normal vector: */
		v1 = (vertex GPHUGE *) vertices.v + poly.vertex[DefineConstants.POLY_NVERT - 1];
		v2 = (vertex GPHUGE *) vertices.v + poly.vertex[0];
		plane[0] = (v1.y - v2.y) * (v1.z + v2.z);
		plane[1] = (v1.z - v2.z) * (v1.x + v2.x);
		plane[2] = (v1.x - v2.x) * (v1.y + v2.y);
		for (i = 1; i < DefineConstants.POLY_NVERT; i++)
		{
			v1 = v2;
			v2 = (vertex GPHUGE *) vertices.v + poly.vertex[i];
			plane[0] += (v1.y - v2.y) * (v1.z + v2.z);
			plane[1] += (v1.z - v2.z) * (v1.x + v2.x);
			plane[2] += (v1.x - v2.x) * (v1.y + v2.y);
		}

		/* Normalize the resulting normal vector */
		s = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);

		if (((0.0) >= (s) - DefineConstants.EPSILON))
		{
			/* The normal vanishes, i.e. the polygon is degenerate. We build
			 * another vector that is orthogonal to the line of the polygon */
			v1 = (vertex GPHUGE *) vertices.v + poly.vertex[0];
			for (i = 1; i < DefineConstants.POLY_NVERT; i++)
			{
				v2 = (vertex GPHUGE *) vertices.v + poly.vertex[i];
				if (!(((0.0) >= (Math.abs((v1).x - (v2).x) + Math.abs((v1).y - (v2).y) + Math.abs((v1).z - (v2).z)) - DefineConstants.EPSILON)))
					break;
			}

			/* build (x,y,z) that should be linear-independant from <v1, v2> */
			x = v1.x;
			y = v1.y;
			z = v1.z;
			if ((Math.abs((y) - (v2.y)) < DefineConstants.EPSILON))
				y += 1.0;
			else
				x += 1.0;

			/* Re-do the signed area computations */
			plane[0] = v1.y * (v2.z - z) + v2.y * (z - v1.z) + y * (v1.z - v2.z);
			plane[1] = v1.z * (v2.x - x) + v2.z * (x - v1.x) + z * (v1.x - v2.x);
			plane[2] = v1.x * (v2.y - y) + v2.x * (y - v1.y) + x * (v1.y - v2.y);
			s = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		}

		/* ensure that normalized c is > 0 */
		if (plane[2] < 0.0)
		{
			s *= -1.0;
			frontfacing = false;
		}

		plane[0] /= s;
		plane[1] /= s;
		plane[2] /= s;

		/* Now we have the normalized normal vector, insert one of the
		 * vertices into the equation to get 'd'. For an even better result,
		 * an average over all the vertices might be used */
		plane[3] = -plane[0] * v1.x - plane[1] * v1.y - plane[2] * v1.z;

		return frontfacing;
	}

	/*************************************************************/
	/*************************************************************/
	/*******   The depth sort algorithm (in_front) and its  ******/
	/*******   whole lot of helper functions                ******/
	/*************************************************************/
	/*************************************************************/

	/* Split a given line segment into two at an inner point. The inner
	 * point is specified as a fraction of the line-length (0 is V1, 1 is
	 * V2) */
	/* HBB 20001108: changed to now take two vertex pointers as its
	 * arguments, rather than an edge pointer. */
	/* HBB 20001204: changed interface again. Now use vertex indices,
	 * rather than pointers, to avoid problems with dangling pointers
	 * after nextfrom_dynarray() call. */
	public static int split_line_at_ratio(int vnum1, int vnum2, double w)
	{
		vertex GPHUGE * v;

		/* Create a new vertex */
		v = GlobalMembersDynarray.nextfrom_dynarray(vertices);

		v.x = ((vertex GPHUGE *) vertices.v[vnum2].x - (vertex GPHUGE *) vertices.v[vnum1].x) * w + (vertex GPHUGE *) vertices.v[vnum1].x;
		v.y = ((vertex GPHUGE *) vertices.v[vnum2].y - (vertex GPHUGE *) vertices.v[vnum1].y) * w + (vertex GPHUGE *) vertices.v[vnum1].y;
		v.z = ((vertex GPHUGE *) vertices.v[vnum2].z - (vertex GPHUGE *) vertices.v[vnum1].z) * w + (vertex GPHUGE *) vertices.v[vnum1].z;
		v.real_z = ((vertex GPHUGE *) vertices.v[vnum2].real_z - (vertex GPHUGE *) vertices.v[vnum1].real_z) * w + (vertex GPHUGE *) vertices.v[vnum1].real_z;

		/* no point symbol for vertices generated by splitting an edge */
		v.lp_style = DefineConstants.NULL;

		/* additional checks to prevent adding unnecessary vertices */
		if ((((0.0) >= (Math.abs((v).x - ((vertex GPHUGE *) vertices.v + vnum1).x) + Math.abs((v).y - ((vertex GPHUGE *) vertices.v + vnum1).y) + Math.abs((v).z - ((vertex GPHUGE *) vertices.v + vnum1).z)) - DefineConstants.EPSILON)))
		{
			GlobalMembersDynarray.droplast_dynarray(vertices);
			return vnum1;
		}
		if ((((0.0) >= (Math.abs((v).x - ((vertex GPHUGE *) vertices.v + vnum2).x) + Math.abs((v).y - ((vertex GPHUGE *) vertices.v + vnum2).y) + Math.abs((v).z - ((vertex GPHUGE *) vertices.v + vnum2).z)) - DefineConstants.EPSILON)))
		{
			GlobalMembersDynarray.droplast_dynarray(vertices);
			return vnum2;
		}

		return (v - (vertex GPHUGE *) vertices.v);
	}

	/* Compute the 'signed area' of 3 points in their 2d projection
	 * to the x-y plane. Essentially the z component of the crossproduct.
	 * Should come out positive if v1, v2, v3 are ordered counter-clockwise */

	public static __inline__ double area2D(vertex GPHUGE v1, vertex GPHUGE v2, vertex GPHUGE v3)
	{
		double dx12 = v2.x - v1.x; // x/y components of (v2-v1) and (v3-v1)
		double dx13 = v3.x - v1.x;
		double dy12 = v2.y - v1.y;
		double dy13 = v3.y - v1.y;
		return (dx12 * dy13 - dy12 * dx13);
	}

	/************************************************/
	/*******            Drawing the polygons ********/
	/************************************************/

	/* draw a single vertex as a point symbol, if requested by the chosen
	 * plot style (linespoints, points, or dots...) */
	public static void draw_vertex(vertex GPHUGE v)
	{
		int x;
		int y;

		{
			x = ((int)((v).x * GlobalMembersGraph3d.xscaler)) + GlobalMembersGraph3d.xmiddle;
			y = ((int)((v).y * GlobalMembersGraph3d.yscaler)) + GlobalMembersGraph3d.ymiddle;
		};
		if (v.lp_style != null && v.lp_style.p_type >= -1 && GlobalMembersGadgets.clip_point(x, y) == 0)
		{
			int colortype = v.lp_style.pm3d_color.type;

			if (v.label != null)
			{
				GlobalMembersGadgets.write_label(x, y, v.label);
				v.lp_style = DefineConstants.NULL;
				return;
			}

			/* EAM DEBUG - Check for extra point properties */
			if (colortype == DefineConstants.TC_LT)
				/* Should have been set already! */
				;
			else if (colortype == DefineConstants.TC_RGB && v.lp_style.pm3d_color.lt == DefineConstants.LT_COLORFROMCOLUMN)
				GlobalMembersColor.set_rgbcolor(v.real_z);
			else if (colortype == DefineConstants.TC_RGB)
				GlobalMembersColor.set_rgbcolor(v.lp_style.pm3d_color.lt);
			else if (colortype == DefineConstants.TC_Z)
				GlobalMembersColor.set_color(GlobalMembersPm3d.cb2gray(GlobalMembersPm3d.z2cb(v.real_z)));

			///#ifdef HIDDEN3D_VAR_PTSIZE
			if (v.lp_style.p_size == DefineConstants.PTSZ_VARIABLE)
				(GlobalMembersTerm.term.pointsize)(GlobalMembersGadgets.pointsize * v.original.xlow);
			///#endif

			(GlobalMembersTerm.term.point)(x,y, v.lp_style.p_type);

			/* vertex has been drawn --> flag it as done */
			v.lp_style = DefineConstants.NULL;
		}
	}

	/* The function that actually does the drawing of the visible portions
	 * of lines */
	/* HBB 20001108: changed to take the pointers to the end vertices as
	 * additional arguments. */
	public static void draw_edge(edge GPHUGE e, vertex GPHUGE v1, vertex GPHUGE v2)
	{
		assert e >= (edge) edges.v && e < (edge) edges.v + edges.end;

		GlobalMembersUtil3d.draw3d_line_unconditional(v1, v2, e.lp, e.style);
		if (e.lp.pointflag != 0)
		{
			GlobalMembersHidden3d.draw_vertex(v1);
			GlobalMembersHidden3d.draw_vertex(v2);
		}
	}

	/* Utility routine: takes an edge and makes a new one, which is a fragment
	 * of the old one. The fragment inherits the line style and stuff of the
	 * given edge; only the two new vertices are different. The new edge
	 * is then passed to in_front, for recursive handling */
	/* HBB 20001108: Changed from edge pointer to edge index. Don't
	 * allocate a fresh anymore, as this is no longer needed after the
	 * change to in_front().  What remains of this function may no longer
	 * be worth having. I.e. it can be replaced by a direct recursion call
	 * of in_front(), sometime soon. */
	public static __inline__ void handle_edge_fragment(int edgenum, int vnum1, int vnum2, int firstpoly)
	{
		///#if !HIDDEN3D_QUADTREE
		// /* Avoid checking against the same polygon again. */
		//    firstpoly = plist[firstpoly].next;
		///#endif
		GlobalMembersHidden3d.in_front(edgenum, vnum1, vnum2, firstpoly);
	}

	/*********************************************************************/
	/* The actual heart of all this: determines if edge at index 'edgenum'
	 * of the elist is in_front of all the polygons, or not. If necessary,
	 * it will recursively call itself to isolate more than one visible
	 * fragment of the input edge. Wherever possible, recursion is
	 * avoided, by in-place modification of the edge.
	 *
	 * The visible fragments are then drawn by a call to 'draw_edge' from
	 * inside this routine. */
	/*********************************************************************/
	/* HBB 20001108: changed to now take the vertex numbers as additional
	 * arguments. The idea is to not overwrite the endpoint stored with
	 * the edge, so Test 2 will catch on even after the subject edge has
	 * been split up before one of its two polygons is tested against it. */

	public static int in_front(int edgenum, int vnum1, int vnum2, int firstpoly)
	{
		mesh_triangle GPHUGE * GlobalMembersAnsi2knr.p; // pointer to current testing polygon
		int polynum; // ... and its index in the plist
		vertex GPHUGE * v1, *v2; // pointers to vertices of input edge

		double xmin; // all of these are for the edge
		double xmax;
		double ymin;
		double ymax;
		double zmin;
		double zmax;
		///#if HIDDEN3D_GRIDBOX
		int xextent; // extent bitmask in x direction
		int yextent; // same, in y direction

		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define SET_XEXTENT xextent = ((~(~0U << (unsigned int) (((((xmax)) / surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(unsigned int) + (1)))) & (~0U << (unsigned int) ((((xmin) / surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(unsigned int) + (0))));
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define SET_YEXTENT yextent = ((~(~0U << (unsigned int) (((((ymax)) / surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(unsigned int) + (1)))) & (~0U << (unsigned int) ((((ymin) / surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(unsigned int) + (0))));
		///#else
		///#define SET_XEXTENT // nothing
		///#define SET_YEXTENT // nothing
		///#endif
		///#if HIDDEN3D_QUADTREE
		int grid_x;
		int grid_y;
		int grid_x_low;
		int grid_x_high;
		int grid_y_low;
		int grid_y_high;
		int listhead;
		///#endif

		/* zmin of the edge, as it started out. This is needed separately to
		 * allow modifying '*firstpoly', without moving it too far to the
		 * front. */
		double first_zmin;

		/* Keep track of number of vertices before the process and compare
		 * at end of process to know how many vertices to remove. */
		int enter_vertices;

		/* macro for eliminating tail-recursion inside in_front: when the
		 * current edge is modified, recompute all function-wide status
		 * variables. Note that it guarantees that v1 is always closer to
		 * the viewer than v2 (in z direction) */
		/* HBB 20001108: slightly changed so it can be called with vnum1
		 * and vnum2 as its arguments, too */
		//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
		///#define setup_edge(vert1, vert2) do { if (vlist[vert1].z > vlist[vert2].z) { v1 = vlist + (vert1); v2 = vlist + (vert2); } else { v1 = vlist + (vert2); v2 = vlist + (vert1); } vnum1 = v1 - vlist; vnum2 = v2 - vlist; zmax = v1->z; zmin = v2->z; if (v1->x > v2->x) { xmin = v2->x; xmax = v1->x; } else { xmin = v1->x; xmax = v2->x; } SET_XEXTENT; if (v1->y > v2->y) { ymin = v2->y; ymax = v1->y; } else { ymin = v1->y; ymax = v2->y; } SET_YEXTENT; } while (0)

		/* use the macro for initial setup, too: */
		do
		{
			if ((vertex GPHUGE *) vertices.v[vnum1].z > (vertex GPHUGE *) vertices.v[vnum2].z)
			{
				v1 = (vertex GPHUGE *) vertices.v + (vnum1);
				v2 = (vertex GPHUGE *) vertices.v + (vnum2);
			}
			else
			{
				v1 = (vertex GPHUGE *) vertices.v + (vnum2);
				v2 = (vertex GPHUGE *) vertices.v + (vnum1);
			}
			vnum1 = v1 - (vertex GPHUGE *) vertices.v;
			vnum2 = v2 - (vertex GPHUGE *) vertices.v;
			zmax = v1.z;
			zmin = v2.z;
			if (v1.x > v2.x)
			{
				xmin = v2.x;
				xmax = v1.x;
			}
			else
			{
				xmin = v1.x;
				xmax = v2.x;
			}
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			xextent = ((~(~0 << (int)(((((xmax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((xmin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
			;
			if (v1.y > v2.y)
			{
				ymin = v2.y;
				ymax = v1.y;
			}
			else
			{
				ymin = v1.y;
				ymax = v2.y;
			}
			//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			yextent = ((~(~0 << (int)(((((ymax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((ymin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
			;
		} while (0);

		first_zmin = zmin;

		enter_vertices = vertices.end;

		///#if HIDDEN3D_QUADTREE
		grid_x_low = GlobalMembersHidden3d.coord_to_treecell(xmin);
		grid_x_high = GlobalMembersHidden3d.coord_to_treecell(xmax);
		grid_y_low = GlobalMembersHidden3d.coord_to_treecell(ymin);
		grid_y_high = GlobalMembersHidden3d.coord_to_treecell(ymax);

		for (grid_x = grid_x_low; grid_x <= grid_x_high; grid_x++)
			for (grid_y = grid_y_low; grid_y <= grid_y_high; grid_y++)
				for (listhead = quadtree[grid_x][grid_y]; listhead >= 0; listhead = (qtreelist) qtree.v[listhead].next)
					///#else // HIDDEN3D_QUADTREE
					// /* loop over all the polygons in the sorted list, starting at the
					//  * currently first (i.e. furthest, from the viewer) polygon. */
					//    for (polynum = *firstpoly; polynum >=0; polynum = p->next)
					///#endif // HIDDEN3D_QUADTREE
				{
					/* shortcut variables for the three vertices of 'p':*/
					vertex GPHUGE * w1, *w2, *w3;

					///#if HIDDEN3D_QUADTREE
					polynum = (qtreelist) qtree.v[listhead].p;
					///#endif
					GlobalMembersAnsi2knr.p = (mesh_triangle) polygons.v + polynum;

					/* OK, off we go with the real work. This algorithm had its
					 * beginnings as the one of 'HLines.java', as described in
					 * the book 'Computer Graphics for Java Programmers', by
					 * Dutch professor Leen Ammeraal, published by J. Wiley &
					 * Sons, ISBN 0 471 98142 7.
					 *
					 * However, it was revamped with an approach that breaks
					 * up the edge into five possible subsegments and removes
					 * the one contiguous subsegment, if any, that is hidden.
					 */

					/* Test 1 (2D): minimax tests. Do x/y ranges of polygon
					 * and edge have any overlap? */
					///#if HIDDEN3D_GRIDBOX
					/* First, check by comparing the extent bit patterns: */
					if (0 || (!(xextent & GlobalMembersAnsi2knr.p.xbits)) || (!(yextent & GlobalMembersAnsi2knr.p.ybits)) || (GlobalMembersAnsi2knr.p.xmax < xmin) || (GlobalMembersAnsi2knr.p.xmin > xmax) || (GlobalMembersAnsi2knr.p.ymax < ymin) || (GlobalMembersAnsi2knr.p.ymin > ymax))
						///#else
						//        if (0
						///#endif
						continue;

					/* Tests 2 and 3 switched... */

					/* Test 3 (3D): Is edge completely in front of polygon? */
					if (GlobalMembersAnsi2knr.p.zmax < zmin)
					{
						/* Polygon completely behind this edge. Move start of
						 * relevant plist to this point, to speed up next
						 * run. This makes use of the fact that elist is also
						 * kept in upwardly sorted order of zmin, i.e. the
						 * condition found here will also hold for all coming
						 * edges in the list */
						if (GlobalMembersAnsi2knr.p.zmax < first_zmin)
							firstpoly = polynum;
						continue; // this polygon is done with
					}

					/* Test 2 (0D): does edge belong to this very polygon? */
					/* 20001108: to make this rejector more effective, do keep
					 * the original edge vertices unchanged */
					if (1 && (0 || (GlobalMembersAnsi2knr.p.vertex[0] == (edge) edges.v[edgenum].v1) || (GlobalMembersAnsi2knr.p.vertex[1] == (edge) edges.v[edgenum].v1) || (GlobalMembersAnsi2knr.p.vertex[2] == (edge) edges.v[edgenum].v1)) && (0 || (GlobalMembersAnsi2knr.p.vertex[0] == (edge) edges.v[edgenum].v2) || (GlobalMembersAnsi2knr.p.vertex[1] == (edge) edges.v[edgenum].v2) || (GlobalMembersAnsi2knr.p.vertex[2] == (edge) edges.v[edgenum].v2)))
						continue;

					w1 = (vertex GPHUGE *) vertices.v + GlobalMembersAnsi2knr.p.vertex[0];
					w2 = (vertex GPHUGE *) vertices.v + GlobalMembersAnsi2knr.p.vertex[1];
					w3 = (vertex GPHUGE *) vertices.v + GlobalMembersAnsi2knr.p.vertex[2];


					/* The final 'catch-all' handler: [was Test 4-9 (3D)]
					 * Daniel Sebald 2007
					 * ---------------------------------------------------
					 * If one examines the possible scenarios for an edge (v1,v2)
					 * passing through a triangular 3D element in 2D space, it
					 * is evident that at most 4 breaks in the edge are possible,
					 * one for each infinite triangle side intersection and
					 * one for the edge possibly passing directly through the
					 * polygon.  We first compute all these intersections in terms
					 * of parameterization v = v1 + u * (v2 - v1).  That gives us
					 * four values of u.  They likely will not all be in the range
					 * (0,1), i.e., between v1 and v2.  We discard all those not
					 * in the range, and the remaining associated points along with
					 * endpoint v1 and v2 describe a series of subsegements that are
					 * considered individually.  If any contiguous subgroup is
					 * hidden (there can only be at most one for a convex polygon),
					 * it is removed.
					 *
					 * This routine is general in the sense that the earlier tests
					 * it are only need for speed.
					 *
					 * The following website illustrates geometrical concepts and
					 * formulas:  http://local.wasp.uwa.edu.au/~pbourke/geometry/
					 */

					{
						double[] u_int = new double[4]; // Intersection points along edge v1, v2
						double[] u_seg = new double[6]; // Sorted subsegment points
						int segs; // Number of segments
						int i;

						u_int[0] = GlobalMembersHidden3d.intersect_line_plane(v1, v2, GlobalMembersAnsi2knr.p.plane);
						u_int[1] = GlobalMembersHidden3d.intersect_line_line(v1, v2, w1, w2);
						u_int[2] = GlobalMembersHidden3d.intersect_line_line(v1, v2, w2, w3);
						u_int[3] = GlobalMembersHidden3d.intersect_line_line(v1, v2, w3, w1);

						/* Check if between v1 and v2 */
						u_seg[0] = 0;
						segs = 1;
						for (i = 0; i < 4; i++)
						{
							if ((0 < u_int[i]) && (u_int[i] < 1))
							{
								u_seg[segs] = u_int[i];
								segs++;
							}
						}
						u_seg[segs] = 1;

						/* Sort the points.  First and last point already in order. */
						for (i = 1; i < segs; i++)
						{
							int j = i + 1;
							for (; j < segs; j++)
							{
								if (u_seg[i] > u_seg[j])
								{
									double temp = u_seg[i];
									u_seg[i] = u_seg[j];
									u_seg[j] = temp;
								}
							}
						}

						/* Check if contiguous segments or segment is covered */
						for (i = 0; i < segs; i++)
						{
							int covA = GlobalMembersHidden3d.cover_point_poly(v1, v2, u_seg[i], GlobalMembersAnsi2knr.p);
							if (covA != 0)
							{
								/* First covered point, now look for last covered point */
								int j;
								int covB = 0;
								for (j = i; j < segs; j++)
								{
									int cover = GlobalMembersHidden3d.cover_point_poly(v1, v2, u_seg[j + 1], GlobalMembersAnsi2knr.p);
									if (cover == 0)
										break;
									covB = cover;
								}
								if (i == j)
									break; // Only one covered point, no segment covered
								if (covA == 2 && covB == 2)
									break; // Points covered, but both are on the plane
								else
								{
									/* This is the hidden segment */
									if (i == 0)
									{
										/* Missing segment is at start of v1, v2 */
										if (j == segs)
										{
											/* Whole edge is hidden */
											while (vertices.end > enter_vertices)
												GlobalMembersDynarray.droplast_dynarray(vertices);
											return 0;
										}
										else
										{
											/* Shrink the edge and continue */
											int newvert = GlobalMembersHidden3d.split_line_at_ratio(vnum1, vnum2, u_seg[j]);
											do
											{
												if ((vertex GPHUGE *) vertices.v[newvert].z > (vertex GPHUGE *) vertices.v[vnum2].z)
												{
													v1 = (vertex GPHUGE *) vertices.v + (newvert);
													v2 = (vertex GPHUGE *) vertices.v + (vnum2);
												}
												else
												{
													v1 = (vertex GPHUGE *) vertices.v + (vnum2);
													v2 = (vertex GPHUGE *) vertices.v + (newvert);
												}
												vnum1 = v1 - (vertex GPHUGE *) vertices.v;
												vnum2 = v2 - (vertex GPHUGE *) vertices.v;
												zmax = v1.z;
												zmin = v2.z;
												if (v1.x > v2.x)
												{
													xmin = v2.x;
													xmax = v1.x;
												}
												else
												{
													xmin = v1.x;
													xmax = v2.x;
												}
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												xextent = ((~(~0 << (int)(((((xmax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((xmin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
												;
												if (v1.y > v2.y)
												{
													ymin = v2.y;
													ymax = v1.y;
												}
												else
												{
													ymin = v1.y;
													ymax = v2.y;
												}
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												yextent = ((~(~0 << (int)(((((ymax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((ymin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
												;
											} while (0);
											break;
										}
									}
									else if (j == segs)
									{
										/* Missing segment is at end of v1, v2.  The i = 0
										 * case already tested, so shrink edge and continue */
										int newvert = GlobalMembersHidden3d.split_line_at_ratio(vnum1, vnum2, u_seg[i]);
										do
										{
											if ((vertex GPHUGE *) vertices.v[vnum1].z > (vertex GPHUGE *) vertices.v[newvert].z)
											{
												v1 = (vertex GPHUGE *) vertices.v + (vnum1);
												v2 = (vertex GPHUGE *) vertices.v + (newvert);
											}
											else
											{
												v1 = (vertex GPHUGE *) vertices.v + (newvert);
												v2 = (vertex GPHUGE *) vertices.v + (vnum1);
											}
											vnum1 = v1 - (vertex GPHUGE *) vertices.v;
											vnum2 = v2 - (vertex GPHUGE *) vertices.v;
											zmax = v1.z;
											zmin = v2.z;
											if (v1.x > v2.x)
											{
												xmin = v2.x;
												xmax = v1.x;
											}
											else
											{
												xmin = v1.x;
												xmax = v2.x;
											}
											//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
											xextent = ((~(~0 << (int)(((((xmax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((xmin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
											;
											if (v1.y > v2.y)
											{
												ymin = v2.y;
												ymax = v1.y;
											}
											else
											{
												ymin = v1.y;
												ymax = v2.y;
											}
											//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
											yextent = ((~(~0 << (int)(((((ymax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((ymin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
											;
										} while (0);
										break;
									}
									else
									{
										/* Handle new edge then shrink edge */
										int[] newvert = new int[2];
										newvert[0] = GlobalMembersHidden3d.split_line_at_ratio(vnum1, vnum2, u_seg[i]);
										newvert[1] = GlobalMembersHidden3d.split_line_at_ratio(vnum1, vnum2, u_seg[j]);
										/* If the newvert[1] is vnum1 this would be an infinite
										 * loop and stack overflow if not checked since in_front()
										 * was just called with vnum1 and vnum2 and got to this
										 * point.  This is the equivalent of snipping out a tiny
										 * segment near end of an edge.  Simply ignore.
										 */
										if (newvert[1] != vnum1)
										{
											GlobalMembersHidden3d.handle_edge_fragment(edgenum, newvert[1], vnum2, polynum);
											do
											{
												if ((vertex GPHUGE *) vertices.v[vnum1].z > (vertex GPHUGE *) vertices.v[newvert[0]].z)
												{
													v1 = (vertex GPHUGE *) vertices.v + (vnum1);
													v2 = (vertex GPHUGE *) vertices.v + (newvert[0]);
												}
												else
												{
													v1 = (vertex GPHUGE *) vertices.v + (newvert[0]);
													v2 = (vertex GPHUGE *) vertices.v + (vnum1);
												}
												vnum1 = v1 - (vertex GPHUGE *) vertices.v;
												vnum2 = v2 - (vertex GPHUGE *) vertices.v;
												zmax = v1.z;
												zmin = v2.z;
												if (v1.x > v2.x)
												{
													xmin = v2.x;
													xmax = v1.x;
												}
												else
												{
													xmin = v1.x;
													xmax = v2.x;
												}
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												xextent = ((~(~0 << (int)(((((xmax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((xmin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
												;
												if (v1.y > v2.y)
												{
													ymin = v2.y;
													ymax = v1.y;
												}
												else
												{
													ymin = v1.y;
													ymax = v2.y;
												}
												//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
												yextent = ((~(~0 << (int)(((((ymax)) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (1)))) & (~0 << (int)((((ymin) / GlobalMembersGraph3d.surface_scale) + 1.0) / 2.0 * CHAR_BIT * sizeof(int) + (0))));
												;
											} while (0);
										}
										break;
									}
								}
							}
						}

						/* Nothing is covered */
						continue;

					} // end of part 'T4-9'
				} // for (polygons in list)

		/* Came here, so there's something left of this edge, which needs
		 * to be drawn.  But the vertices are different, now, so copy our
		 * new vertices back into 'e' */

		GlobalMembersHidden3d.draw_edge((edge) edges.v + edgenum, (vertex GPHUGE *) vertices.v + vnum1, (vertex GPHUGE *) vertices.v + vnum2);

		while (vertices.end > enter_vertices)
			GlobalMembersDynarray.droplast_dynarray(vertices);

		return 1;
	}


	/* HBB 20000617: reimplemented this routine from scratch */
	/* Externally callable function to draw a line, but hide it behind the
	 * visible surface. */
	/* NB: The p_vertex arguments are not allowed to be pointers into the
	 * hidden3d 'vlist' structure. If they are, they may become invalid
	 * before they're used, because of the nextfrom_dynarray() call. */
	public static void draw_line_hidden(vertex v1, vertex v2, lp_style_type lp) // line and point style to draw in -  pointers to the end vertices
	{
		int vstore1;
		int vstore2;
		int edgenum;
		int temp_pfirst;

		/* If no polygons have been stored, nothing can be hidden, and we
		 * can't use in_front() because the datastructures are partly
		 * invalid. So just draw the line and be done with it */
		if (polygons.end == 0)
		{
			GlobalMembersUtil3d.draw3d_line_unconditional(v1, v2, lp, lp.l_type);
			return;
		}

		/* Copy two vertices into hidden3d arrays: */
		GlobalMembersDynarray.nextfrom_dynarray(vertices);
		vstore1 = vertices.end - 1;
		(vertex GPHUGE *) vertices.v[vstore1] = v1;
		if (v2 != null)
		{
			(vertex GPHUGE *) vertices.v[vstore1].lp_style = DefineConstants.NULL;
			GlobalMembersDynarray.nextfrom_dynarray(vertices);
			vstore2 = vertices.end - 1;
			(vertex GPHUGE *) vertices.v[vstore2] = v2;
			(vertex GPHUGE *) vertices.v[vstore2].lp_style = DefineConstants.NULL;
		}
		else
		{
			/* v2 == NULL --> this is a point symbol to be drawn. Make two
			 * vertex pointers the same, and set up the 'style' field */
			vstore2 = vstore1;
			(vertex GPHUGE *) vertices.v[vstore2].lp_style = lp;
		}

		/* store the edge into the hidden3d datastructures */
		edgenum = GlobalMembersHidden3d.make_edge(vstore1, vstore2, lp, lp.l_type, -1);

		/* remove hidden portions of the line, and draw what remains */
		temp_pfirst = pfirst;
		GlobalMembersHidden3d.in_front(edgenum, (edge) edges.v[edgenum].v1, (edge) edges.v[edgenum].v2, temp_pfirst);

		/* release allocated storage slots: */
		GlobalMembersDynarray.droplast_dynarray(edges);
		GlobalMembersDynarray.droplast_dynarray(vertices);
		if (v2 != null)
			GlobalMembersDynarray.droplast_dynarray(vertices);
	}
}