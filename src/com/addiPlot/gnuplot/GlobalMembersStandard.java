package com.addiPlot.gnuplot;

public class GlobalMembersStandard
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	//public static String RCSid()
	//{
	//	return GlobalMembersAlloc.RCSid("$Id: standard.c,v 1.29 2008/05/31 20:03:40 sfeam Exp $");
	//}
	///#endif

	/* GNUPLOT - standard.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * $Id: standard.h,v 1.12 2008/03/30 03:03:48 sfeam Exp $
	 */

	/* GNUPLOT - standard.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif

	/* Type definitions */

	/* Variables of standard.c needed by other modules: */

	/* Prototypes of functions exported by standard.c */

	/* These are the more 'usual' functions built into the stack machine */
	public static void f_real(argument arg)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersEval.real(GlobalMembersEval.pop_or_convert_from_string(a)), 0.0));
	}
	public static void f_imag(argument arg)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersEval.imag(GlobalMembersEval.pop_or_convert_from_string(a)), 0.0));
	}
	public static void f_int(argument arg)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (int) GlobalMembersEval.real(GlobalMembersEval.pop_or_convert_from_string(a))));
	}

	/* ang2rad is 1 if we are in radians, or pi/180 if we are in degrees */
	public static void f_arg(argument arg)
	{
		value a = new value();

		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersEval.angle(GlobalMembersEval.pop_or_convert_from_string(a)) / GlobalMembersGadgets.ang2rad, 0.0));
	}
	public static void f_conjg(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersEval.real(a), -GlobalMembersEval.imag(a)));
	}

	/* ang2rad is 1 if we are in radians, or pi/180 if we are in degrees */

	public static void f_sin(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.sin(GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) * Math.cosh(GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a)), Math.cos(GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) * Math.sinh(GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a))));
	}
	public static void f_cos(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.cos(GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) * Math.cosh(GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a)), -Math.sin(GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) * Math.sinh(GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a))));
	}
	public static void f_tan(argument arg)
	{
		value a = new value();
		double den;

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (GlobalMembersEval.imag(a) == 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.tan(GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)), 0.0));
		else
		{
			den = Math.cos(2 * GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) + Math.cosh(2 * GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a));
			if (den == 0.0)
			{
				GlobalMembersEval.undefined = true;
				GlobalMembersEval.push(a);
			}
			else
				GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.sin(2 * GlobalMembersGadgets.ang2rad * GlobalMembersEval.real(a)) / den, Math.sinh(2 * GlobalMembersGadgets.ang2rad * GlobalMembersEval.imag(a)) / den));
		}
	}
	public static void f_asin(argument arg)
	{
		value a = new value();
		double alpha;
		double beta;
		double x;
		double y;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = GlobalMembersEval.real(a);
		y = GlobalMembersEval.imag(a);
		if (y == 0.0 && Math.abs(x) <= 1.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.asin(x) / GlobalMembersGadgets.ang2rad, 0.0));
		}
		else if (x == 0.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, -Math.log(-y + Math.sqrt(y * y + 1)) / GlobalMembersGadgets.ang2rad));
		}
		else
		{
			beta = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 - Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			if (beta > 1)
				beta = 1; // Avoid rounding error problems
			alpha = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 + Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.asin(beta) / GlobalMembersGadgets.ang2rad, -Math.log(alpha + Math.sqrt(alpha * alpha - 1)) / GlobalMembersGadgets.ang2rad));
		}
	}
	public static void f_acos(argument arg)
	{
		value a = new value();
		double x;
		double y;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = GlobalMembersEval.real(a);
		y = GlobalMembersEval.imag(a);
		if (y == 0.0 && Math.abs(x) <= 1.0)
		{
			/* real result */
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.acos(x) / GlobalMembersGadgets.ang2rad, 0.0));
		}
		else
		{
			double alpha = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 + Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			double beta = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 - Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			if (beta > 1)
				beta = 1; // Avoid rounding error problems
			else if (beta < -1)
				beta = -1;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (y > 0? - 1: 1) * Math.acos(beta) / GlobalMembersGadgets.ang2rad, Math.log(alpha + Math.sqrt(alpha * alpha - 1)) / GlobalMembersGadgets.ang2rad));
		}
	}
	public static void f_atan(argument arg)
	{
		value a = new value();
		double x;
		double y;
		double u;
		double v;
		double w;
		double z;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = GlobalMembersEval.real(a);
		y = GlobalMembersEval.imag(a);
		if (y == 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.atan(x) / GlobalMembersGadgets.ang2rad, 0.0));
		else if (x == 0.0 && Math.abs(y) >= 1.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, 0.0));
		}
		else
		{
			if (x >= 0)
			{
				u = x;
				v = y;
			}
			else
			{
				u = -x;
				v = -y;
			}

			z = Math.atan(2 * u / (1 - u * u - v * v));
			w = Math.log((u * u + (v + 1) * (v + 1)) / (u * u + (v - 1) * (v - 1))) / 4;
			if (z < 0)
				z = z + 2 * DefineConstants.PI_ON_TWO;
			if (x < 0)
			{
				z = -z;
				w = -w;
			}
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.5 * z / GlobalMembersGadgets.ang2rad, w));
		}
	}

	/* real parts only */
	public static void f_atan2(argument arg)
	{
		value a = new value();
		double x;
		double y;

		x = GlobalMembersEval.real(GlobalMembersEval.pop_or_convert_from_string(a));
		y = GlobalMembersEval.real(GlobalMembersEval.pop_or_convert_from_string(a));

		if (x == 0.0 && y == 0.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, 0));
		}
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.atan2(y, x) / GlobalMembersGadgets.ang2rad, 0.0));
	}
	public static void f_sinh(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.sinh(GlobalMembersEval.real(a)) * Math.cos(GlobalMembersEval.imag(a)), Math.cosh(GlobalMembersEval.real(a)) * Math.sin(GlobalMembersEval.imag(a))));
	}
	public static void f_cosh(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.cosh(GlobalMembersEval.real(a)) * Math.cos(GlobalMembersEval.imag(a)), Math.sinh(GlobalMembersEval.real(a)) * Math.sin(GlobalMembersEval.imag(a))));
	}
	public static void f_tanh(argument arg)
	{
		value a = new value();
		double den;
		double real_2arg;
		double imag_2arg;

		GlobalMembersEval.pop_or_convert_from_string(a);

		real_2arg = 2.* GlobalMembersEval.real(a);
		imag_2arg = 2.* GlobalMembersEval.imag(a);

		///#ifdef E_MINEXP
		//    if (-fabs(real_2arg) < E_MINEXP) {
		//	push(Gcomplex(&a, real_2arg < 0 ? -1.0 : 1.0, 0.0));
		//	return;
		//    }
		///#else
		{
			int old_errno = errno;

			if (Math.exp(-Math.abs(real_2arg)) == 0.0)
			{
				/* some libm's will raise a silly ERANGE in cosh() and sin() */
				errno = old_errno;
				GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, real_2arg < 0 ? - 1.0 : 1.0, 0.0));
				return;
			}
		}
		///#endif

		den = Math.cosh(real_2arg) + Math.cos(imag_2arg);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.sinh(real_2arg) / den, Math.sin(imag_2arg) / den));
	}
	public static void f_asinh(argument arg)
	{
		value a = new value(); // asinh(z) = -I*asin(I*z)
		double alpha;
		double beta;
		double x;
		double y;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = -GlobalMembersEval.imag(a);
		y = GlobalMembersEval.real(a);
		if (y == 0.0 && Math.abs(x) <= 1.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, -Math.asin(x) / GlobalMembersGadgets.ang2rad));
		}
		else if (y == 0.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, 0.0));
			GlobalMembersEval.undefined = true;
		}
		else if (x == 0.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(y + Math.sqrt(y * y + 1)) / GlobalMembersGadgets.ang2rad, 0.0));
		}
		else
		{
			beta = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 - Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			alpha = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 + Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(alpha + Math.sqrt(alpha * alpha - 1)) / GlobalMembersGadgets.ang2rad, -Math.asin(beta) / GlobalMembersGadgets.ang2rad));
		}
	}
	public static void f_acosh(argument arg)
	{
		value a = new value();
		double alpha; // acosh(z) = I*acos(z)
		double beta;
		double x;
		double y;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = GlobalMembersEval.real(a);
		y = GlobalMembersEval.imag(a);
		if (y == 0.0 && Math.abs(x) <= 1.0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, Math.acos(x) / GlobalMembersGadgets.ang2rad));
		}
		else if (y == 0)
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(x + Math.sqrt(x * x - 1)) / GlobalMembersGadgets.ang2rad, 0.0));
		}
		else
		{
			alpha = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 + Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			beta = Math.sqrt((x + 1) * (x + 1) + y * y) / 2 - Math.sqrt((x - 1) * (x - 1) + y * y) / 2;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(alpha + Math.sqrt(alpha * alpha - 1)) / GlobalMembersGadgets.ang2rad, (y < 0 ? - 1 : 1) * Math.acos(beta) / GlobalMembersGadgets.ang2rad));
		}
	}
	public static void f_atanh(argument arg)
	{
		value a = new value();
		double x; // atanh(z) = -I*atan(I*z)
		double y;
		double u;
		double v;
		double w;
		double z;

		GlobalMembersEval.pop_or_convert_from_string(a);
		x = -GlobalMembersEval.imag(a);
		y = GlobalMembersEval.real(a);
		if (y == 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, -Math.atan(x) / GlobalMembersGadgets.ang2rad));
		else if (x == 0.0 && Math.abs(y) >= 1.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, 0.0));
		}
		else
		{
			if (x >= 0)
			{
				u = x;
				v = y;
			}
			else
			{
				u = -x;
				v = -y;
			}

			z = Math.atan(2 * u / (1 - u * u - v * v));
			w = Math.log((u * u + (v + 1) * (v + 1)) / (u * u + (v - 1) * (v - 1))) / 4;
			if (z < 0)
				z = z + 2 * DefineConstants.PI_ON_TWO;
			if (x < 0)
			{
				z = -z;
				w = -w;
			}
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, w, -0.5 * z / GlobalMembersGadgets.ang2rad));
		}
	}
	public static void f_ellip_first(argument arg)
	{
		value a = new value();
		double ak;
		double q;

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do elliptic integrals of reals");

		ak = GlobalMembersEval.real(a);
		q = (1.0 - ak) * (1.0 + ak);
		if (q > 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersStandard.carlson_elliptic_rf(0.0, q, 1.0), 0.0));
		else
		{
			GlobalMembersEval.push(a);
			GlobalMembersEval.undefined = true;
		}

	}
	public static void f_ellip_second(argument arg)
	{
		value a = new value();
		double ak;
		double q;
		double e;

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do elliptic integrals of reals");

		ak = GlobalMembersEval.real(a);
		q = (1.0 - ak) * (1.0 + ak);
		if (q > 0.0)
		{
			e = GlobalMembersStandard.carlson_elliptic_rf(0.0, q, 1.0) - (ak * ak) * GlobalMembersStandard.carlson_elliptic_rd(0.0, q, 1.0) / 3.0;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, e, 0.0));

		}
		else if (q < 0.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a);

		}
		else
		{
			e = 1.0;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, e, 0.0));
		}


	}
	public static void f_ellip_third(argument arg)
	{
		value a1 = new value();
		value a2 = new value();
		double ak;
		double en;
		double q;

		GlobalMembersEval.pop_or_convert_from_string(a1);
		GlobalMembersEval.pop_or_convert_from_string(a2);
		if (Math.abs(GlobalMembersEval.imag(a1)) > GlobalMembersGadgets.zero || Math.abs(GlobalMembersEval.imag(a2)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do elliptic integrals of reals");

		ak = GlobalMembersEval.real(a1);
		en = GlobalMembersEval.real(a2);
		q = (1.0 - ak) * (1.0 + ak);
		if (q > 0.0 && en < 1.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a2, GlobalMembersStandard.carlson_elliptic_rf(0.0, q, 1.0) + en * GlobalMembersStandard.carlson_elliptic_rj(0.0, q, 1.0, 1.0 - en) / 3.0, 0.0));
		else
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a1);
		}

	}
	//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void f_void(argument x);
	public static void f_abs(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, Math.abs(a.v.int_val)));
			break;
		case CMPLX:
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersEval.magnitude(a), 0.0));
			break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : argument neither INT or CMPLX");
		}
	}
	public static void f_sgn(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (a.v.int_val > 0) ? 1 : (a.v.int_val < 0) ? - 1 : 0));
			break;
		case CMPLX:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (a.v.cmplx_val.real > 0.0) ? 1 : (a.v.cmplx_val.real < 0.0) ? - 1 : 0));
			break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : argument neither INT or CMPLX");
		}
	}
	public static void f_sqrt(argument arg)
	{
		value a = new value();
		double mag;

		GlobalMembersEval.pop_or_convert_from_string(a);
		mag = Math.sqrt(GlobalMembersEval.magnitude(a));
		if (GlobalMembersEval.imag(a) == 0.0)
		{
			if (GlobalMembersEval.real(a) < 0.0)
				GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, mag));
			else
				GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, mag, 0.0));
		}
		else
		{
			/* -pi < ang < pi, so real(sqrt(z)) >= 0 */
			double ang = GlobalMembersEval.angle(a) / 2.0;
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, mag * Math.cos(ang), mag * Math.sin(ang)));
		}
	}
	public static void f_exp(argument arg)
	{
		value a = new value();
		double mag;
		double ang;

		GlobalMembersEval.pop_or_convert_from_string(a);
		mag = GlobalMembersEval.gp_exp(GlobalMembersEval.real(a));
		ang = GlobalMembersEval.imag(a);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, mag * Math.cos(ang), mag * Math.sin(ang)));
	}
	public static void f_log10(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (GlobalMembersEval.magnitude(a) == 0.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a);
		}
		else
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(GlobalMembersEval.magnitude(a)) / DefineConstants.M_LN10, GlobalMembersEval.angle(a) / DefineConstants.M_LN10));
	}
	public static void f_log(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (GlobalMembersEval.magnitude(a) == 0.0)
		{
			GlobalMembersEval.undefined = true;
			GlobalMembersEval.push(a);
		}
		else
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, Math.log(GlobalMembersEval.magnitude(a)), GlobalMembersEval.angle(a)));
	}
	public static void f_floor(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (int) Math.floor((double) a.v.int_val)));
			break;
		case CMPLX:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (int) Math.floor(a.v.cmplx_val.real)));
			break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : argument neither INT or CMPLX");
		}
	}
	public static void f_ceil(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (int) Math.ceil((double) a.v.int_val)));
			break;
		case CMPLX:
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, (int) Math.ceil(a.v.cmplx_val.real)));
			break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : argument neither INT or CMPLX");
		}
	}

	/* FIXME HBB 20010726: should bessel functions really call int_error,
	 * right in the middle of evaluating some mathematical expression?
	 * Couldn't they just flag 'undefined', or ignore the real part of the
	 * complex number? */

	public static void f_besj0(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do bessel functions of reals");
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersStandard.rj0(GlobalMembersEval.real(a)), 0.0));
	}
	public static void f_besj1(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do bessel functions of reals");
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersStandard.rj1(GlobalMembersEval.real(a)), 0.0));
	}
	public static void f_besy0(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do bessel functions of reals");
		if (GlobalMembersEval.real(a) > 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersStandard.ry0(GlobalMembersEval.real(a)), 0.0));
		else
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, 0.0));
			GlobalMembersEval.undefined = true;
		}
	}
	public static void f_besy1(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);
		if (Math.abs(GlobalMembersEval.imag(a)) > GlobalMembersGadgets.zero)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only do bessel functions of reals");
		if (GlobalMembersEval.real(a) > 0.0)
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, GlobalMembersStandard.ry1(GlobalMembersEval.real(a)), 0.0));
		else
		{
			GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, 0.0, 0.0));
			GlobalMembersEval.undefined = true;
		}
	}

	/* EAM - replacement for defined(foo) + f_pushv + f_isvar
	 *       implements      exists("foo") instead
	 */
	public static void f_exists(argument arg)
	{
		value a = new value();

		GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type == DATA_TYPES.STRING)
		{
			udvt_entry udv = GlobalMembersEval.add_udv_by_name(a.v.string_val);
			GlobalMembersEval.gpfree_string(a);
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, udv.udv_undef ? 0 : 1));
		}
		else
		{
			GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, 0));
		}
	}

	public static void f_tmsec(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmmin(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmhour(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmmday(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmmon(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmyear(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmwday(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}
	public static void f_tmyday(argument arg)
	{
		value a = new value();
		tm tm = new tm();
		GlobalMembersEval.pop_or_convert_from_string(a);
		GlobalMembersTime.ggmtime(tm, GlobalMembersEval.real(a));
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, (double)tm.field, 0.0));
	}



	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif
	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif

	public static double carlson_elliptic_rc(double x, double y)
	{
		double alamb;
		double ave;
		double s;
		double w;
		double xt;
		double yt;
		double ans;

		if (y > 0.0)
		{
			xt = x;
			yt = y;
			w = 1.0;
		}
		else
		{
			xt = x - y;
			yt = -y;
			w = Math.sqrt(x) / Math.sqrt(xt);
		}

		do
		{
			alamb = 2.0 * Math.sqrt(xt) * Math.sqrt(yt) + yt;
			xt = 0.25 * (xt + alamb);
			yt = 0.25 * (yt + alamb);
			ave = (1.0 / 3.0) * (xt + yt + yt);
			s = (yt - ave) / ave;
		} while (Math.abs(s) > 0.0012);

		ans = w * (1.0 + s * s * (DefineConstants.C1 + s * (1.0 / 7.0 + s * (DefineConstants.C3 + s * 9.0 / 22.0)))) / Math.sqrt(ave);

		return (ans);
	}
	public static double carlson_elliptic_rf(double x, double y, double z)
	{
		double alamb;
		double ave;
		double delx;
		double dely;
		double delz;
		double e2;
		double e3;
		double sqrtx;
		double sqrty;
		double sqrtz;
		double xt;
		double yt;
		double zt;
		xt = x;
		yt = y;
		zt = z;
		do
		{
			sqrtx = Math.sqrt(xt);
			sqrty = Math.sqrt(yt);
			sqrtz = Math.sqrt(zt);
			alamb = sqrtx * (sqrty + sqrtz) + sqrty * sqrtz;
			xt = 0.25 * (xt + alamb);
			yt = 0.25 * (yt + alamb);
			zt = 0.25 * (zt + alamb);
			ave = (1.0 / 3.0) * (xt + yt + zt);
			delx = (ave - xt) / ave;
			dely = (ave - yt) / ave;
			delz = (ave - zt) / ave;
		} while (Math.abs(delx) > 0.0025 || Math.abs(dely) > 0.0025 || Math.abs(delz) > 0.0025);
		e2 = delx * dely - delz * delz;
		e3 = delx * dely * delz;

		return ((1.0 + ((1.0 / 24.0) * e2 - (0.1) - (3.0 / 44.0) * e3) * e2 + (1.0 / 14.0) * e3) / Math.sqrt(ave));
	}
	public static double carlson_elliptic_rd(double x, double y, double z)
	{
		double alamb;
		double ave;
		double delx;
		double dely;
		double delz;
		double ea;
		double eb;
		double ec;
		double ed;
		double ee;
		double fac;
		double sqrtx;
		double sqrty;
		double sqrtz;
		double sum;
		double xt;
		double yt;
		double zt;
		double ans;

		xt = x;
		yt = y;
		zt = z;
		sum = 0.0;
		fac = 1.0;
		do
		{
			sqrtx = Math.sqrt(xt);
			sqrty = Math.sqrt(yt);
			sqrtz = Math.sqrt(zt);
			alamb = sqrtx * (sqrty + sqrtz) + sqrty * sqrtz;
			sum += fac / (sqrtz * (zt + alamb));
			fac = 0.25 * fac;
			xt = 0.25 * (xt + alamb);
			yt = 0.25 * (yt + alamb);
			zt = 0.25 * (zt + alamb);
			ave = 0.2 * (xt + yt + 3.0 * zt);
			delx = (ave - xt) / ave;
			dely = (ave - yt) / ave;
			delz = (ave - zt) / ave;
		} while (Math.abs(delx) > 0.0015 || Math.abs(dely) > 0.0015 || Math.abs(delz) > 0.0015);
		ea = delx * dely;
		eb = delz * delz;
		ec = ea - eb;
		ed = ea - 6.0 * eb;
		ee = ed + ec + ec;
		ans = 3.0 * sum + fac * (1.0 + ed * (-3.0 / 14.0 + 0.25 * 9.0 / 22.0 * ed - 1.5 * 3.0 / 26.0 * delz * ee) + delz * (1.0 / 6.0 * ee + delz * (-9.0 / 22.0 * ec + delz * 3.0 / 26.0 * ea))) / (ave * Math.sqrt(ave));

		return (ans);
	}
	public static double carlson_elliptic_rj(double x, double y, double z, double p)
	{
		double a;
		double alamb;
		double alpha;
		double ans;
		double ave;
		double b;
		double beta;
		double delp;
		double delx;
		double dely;
		double delz;
		double ea;
		double eb;
		double ec;
		double ed;
		double ee;
		double fac;
		double pt;
		double rcx;
		double rho;
		double sqrtx;
		double sqrty;
		double sqrtz;
		double sum;
		double tau;
		double xt;
		double yt;
		double zt;

		sum = 0.0;
		fac = 1.0;
		if (p > 0.0)
		{
			xt = x;
			yt = y;
			zt = z;
			pt = p;
			a = b = rcx = 0.0;
		}
		else
		{
			xt = ((((x) < (y) ? (x) : (y))) < (z) ? (((x) < (y) ? (x) : (y))) : (z));
			zt = ((((x) > (y) ? (x) : (y))) > (z) ? (((x) > (y) ? (x) : (y))) : (z));
			yt = x + y + z - xt - zt;
			a = 1.0 / (yt - p);
			b = a * (zt - yt) * (yt - xt);
			pt = yt + b;
			rho = xt * zt / yt;
			tau = p * pt / yt;
			rcx = GlobalMembersStandard.carlson_elliptic_rc(rho, tau);
		}

		do
		{
			sqrtx = Math.sqrt(xt);
			sqrty = Math.sqrt(yt);
			sqrtz = Math.sqrt(zt);
			alamb = sqrtx * (sqrty + sqrtz) + sqrty * sqrtz;
			alpha = ((pt * (sqrtx + sqrty + sqrtz) + sqrtx * sqrty * sqrtz) * (pt * (sqrtx + sqrty + sqrtz) + sqrtx * sqrty * sqrtz));
			beta = pt * ((pt + alamb) * (pt + alamb));
			sum += fac * GlobalMembersStandard.carlson_elliptic_rc(alpha, beta);
			fac = 0.25 * fac;
			xt = 0.25 * (xt + alamb);
			yt = 0.25 * (yt + alamb);
			zt = 0.25 * (zt + alamb);
			pt = 0.25 * (pt + alamb);
			ave = 0.2 * (xt + yt + zt + pt + pt);
			delx = (ave - xt) / ave;
			dely = (ave - yt) / ave;
			delz = (ave - zt) / ave;
			delp = (ave - pt) / ave;
		} while (Math.abs(delx) > 0.0015 || Math.abs(dely) > 0.0015 || Math.abs(delz) > 0.0015 || Math.abs(delp) > 0.0015);

		ea = delx * (dely + delz) + dely * delz;
		eb = delx * dely * delz;
		ec = delp * delp;
		ed = ea - 3.0 * ec;
		ee = eb + 2.0 * delp * (ea - ec);

		ans = 3.0 * sum + fac * (1.0 + ed * (-3.0 / 14.0 + 0.75 * 3.0 / 22.0 * ed - 1.5 * 3.0 / 26.0 * ee) + eb * (0.5 * 1.0 / 3.0 + delp * (-3.0 / 22.0 + 3.0 / 22.0 + delp * 3.0 / 26.0)) + delp * ea * (1.0 / 3.0 - delp * 3.0 / 22.0) - 1.0 / 3.0 * delp * ec) / (ave * Math.sqrt(ave));

		if (p <= 0.0)
			ans = a * (b * ans + 3.0 * (rcx - GlobalMembersStandard.carlson_elliptic_rf(xt, yt, zt)));

		return (ans);
	}

	/* bessel function approximations */

	public static double jzero(double x)
	{
		double p;
		double q;
		double x2;
		int n;

		x2 = x * x;
		p = pjzero[8];
		q = qjzero[8];
		for (n = 7; n >= 0; n--)
		{
			p = p * x2 + pjzero[n];
			q = q * x2 + qjzero[n];
		}
		return (p / q);
	}
	public static double pzero(double x)
	{
		double p;
		double q;
		double z;
		double z2;
		int n;

		z = 8.0 / x;
		z2 = z * z;
		p = ppzero[5];
		q = qpzero[5];
		for (n = 4; n >= 0; n--)
		{
			p = p * z2 + ppzero[n];
			q = q * z2 + qpzero[n];
		}
		return (p / q);
	}
	public static double qzero(double x)
	{
		double p;
		double q;
		double z;
		double z2;
		int n;

		z = 8.0 / x;
		z2 = z * z;
		p = pqzero[5];
		q = qqzero[5];
		for (n = 4; n >= 0; n--)
		{
			p = p * z2 + pqzero[n];
			q = q * z2 + qqzero[n];
		}
		return (p / q);
	}
	public static double yzero(double x)
	{
		double p;
		double q;
		double x2;
		int n;

		x2 = x * x;
		p = pyzero[8];
		q = qyzero[8];
		for (n = 7; n >= 0; n--)
		{
			p = p * x2 + pyzero[n];
			q = q * x2 + qyzero[n];
		}
		return (p / q);
	}
	public static double rj0(double x)
	{
		if (x <= 0.0)
			x = -x;
		if (x < 8.0)
			return (GlobalMembersStandard.jzero(x));
		else
			return (Math.sqrt(DefineConstants.TWO_ON_PI / x) * (GlobalMembersStandard.pzero(x) * Math.cos(x - DefineConstants.PI_ON_FOUR) - 8.0 / x * GlobalMembersStandard.qzero(x) * Math.sin(x - DefineConstants.PI_ON_FOUR)));

	}
	public static double ry0(double x)
	{
		if (x < 0.0)
			return (dzero / dzero); // error
		if (x < 8.0)
			return (GlobalMembersStandard.yzero(x) + DefineConstants.TWO_ON_PI * GlobalMembersStandard.rj0(x) * Math.log(x));
		else
			return (Math.sqrt(DefineConstants.TWO_ON_PI / x) * (GlobalMembersStandard.pzero(x) * Math.sin(x - DefineConstants.PI_ON_FOUR) + (8.0 / x) * GlobalMembersStandard.qzero(x) * Math.cos(x - DefineConstants.PI_ON_FOUR)));

	}
	public static double jone(double x)
	{
		double p;
		double q;
		double x2;
		int n;

		x2 = x * x;
		p = pjone[8];
		q = qjone[8];
		for (n = 7; n >= 0; n--)
		{
			p = p * x2 + pjone[n];
			q = q * x2 + qjone[n];
		}
		return (p / q);
	}
	public static double pone(double x)
	{
		double p;
		double q;
		double z;
		double z2;
		int n;

		z = 8.0 / x;
		z2 = z * z;
		p = ppone[5];
		q = qpone[5];
		for (n = 4; n >= 0; n--)
		{
			p = p * z2 + ppone[n];
			q = q * z2 + qpone[n];
		}
		return (p / q);
	}
	public static double qone(double x)
	{
		double p;
		double q;
		double z;
		double z2;
		int n;

		z = 8.0 / x;
		z2 = z * z;
		p = pqone[5];
		q = qqone[5];
		for (n = 4; n >= 0; n--)
		{
			p = p * z2 + pqone[n];
			q = q * z2 + qqone[n];
		}
		return (p / q);
	}
	public static double yone(double x)
	{
		double p;
		double q;
		double x2;
		int n;

		x2 = x * x;
		p = 0.0;
		q = qyone[8];
		for (n = 7; n >= 0; n--)
		{
			p = p * x2 + pyone[n];
			q = q * x2 + qyone[n];
		}
		return (p / q);
	}
	public static double rj1(double x)
	{
		double v;
		double w;
		v = x;
		if (x < 0.0)
			x = -x;
		if (x < 8.0)
			return (v * GlobalMembersStandard.jone(x));
		else
		{
			w = Math.sqrt(DefineConstants.TWO_ON_PI / x) * (GlobalMembersStandard.pone(x) * Math.cos(x - DefineConstants.THREE_PI_ON_FOUR) - 8.0 / x * GlobalMembersStandard.qone(x) * Math.sin(x - DefineConstants.THREE_PI_ON_FOUR));
			if (v < 0.0)
				w = -w;
			return (w);
		}
	}
	public static double ry1(double x)
	{
		if (x <= 0.0)
			return (dzero / dzero); // error
		if (x < 8.0)
			return (x * GlobalMembersStandard.yone(x) + DefineConstants.TWO_ON_PI * (GlobalMembersStandard.rj1(x) * Math.log(x) - 1.0 / x));
		else
			return (Math.sqrt(DefineConstants.TWO_ON_PI / x) * (GlobalMembersStandard.pone(x) * Math.sin(x - DefineConstants.THREE_PI_ON_FOUR) + (8.0 / x) * GlobalMembersStandard.qone(x) * Math.cos(x - DefineConstants.THREE_PI_ON_FOUR)));
	}

	/* The bessel function approximations here are from
	 * "Computer Approximations"
	 * by Hart, Cheney et al.
	 * John Wiley & Sons, 1968
	 */

	/* There appears to be a mistake in Hart, Cheney et al. on page 149.
	 * Where it list Qn(x)/x ~ P(z*z)/Q(z*z), z = 8/x, it should read
	 *               Qn(x)/z ~ P(z*z)/Q(z*z), z = 8/x
	 * In the functions below, Qn(x) is implementated using the later
	 * equation.
	 * These bessel functions are accurate to about 1e-13
	 */

	///#define PI_ON_FOUR 0.78539816339744830961566084581987572
	///#define PI_ON_TWO 1.57079632679489661923131269163975144
	///#define THREE_PI_ON_FOUR 2.35619449019234492884698253745962716
	///#define TWO_ON_PI 0.63661977236758134307553505349005744

	public static double dzero = 0.0;

	/* jzero for x in [0,8]
	 * Index 5849, 19.22 digits precision
	 */
	public static double[] pjzero = {0.4933787251794133561816813446e+21, -0.11791576291076105360384408e+21, 0.6382059341072356562289432465e+19, -0.1367620353088171386865416609e+18, 0.1434354939140346111664316553e+16, -0.8085222034853793871199468171e+13, 0.2507158285536881945555156435e+11, -0.4050412371833132706360663322e+8, 0.2685786856980014981415848441e+5};

	public static double[] qjzero = {0.4933787251794133562113278438e+21, 0.5428918384092285160200195092e+19, 0.3024635616709462698627330784e+17, 0.1127756739679798507056031594e+15, 0.3123043114941213172572469442e+12, 0.669998767298223967181402866e+9, 0.1114636098462985378182402543e+7, 0.1363063652328970604442810507e+4, 0.1e+1};

	/* pzero for x in [8,inf]
	 * Index 6548, 18.16 digits precision
	 */
	public static double[] ppzero = {0.2277909019730468430227002627e+5, 0.4134538663958076579678016384e+5, 0.2117052338086494432193395727e+5, 0.348064864432492703474453111e+4, 0.15376201909008354295771715e+3, 0.889615484242104552360748e+0};

	public static double[] qpzero = {0.2277909019730468431768423768e+5, 0.4137041249551041663989198384e+5, 0.2121535056188011573042256764e+5, 0.350287351382356082073561423e+4, 0.15711159858080893649068482e+3, 0.1e+1};

	/* qzero for x in [8,inf]
	 * Index 6948, 18.33 digits precision
	 */
	public static double[] pqzero = {-0.8922660020080009409846916e+2, -0.18591953644342993800252169e+3, -0.11183429920482737611262123e+3, -0.2230026166621419847169915e+2, -0.124410267458356384591379e+1, -0.8803330304868075181663e-2};

	public static double[] qqzero = {0.571050241285120619052476459e+4, 0.1195113154343461364695265329e+5, 0.726427801692110188369134506e+4, 0.148872312322837565816134698e+4, 0.9059376959499312585881878e+2, 0.1e+1};


	/* yzero for x in [0,8]
	 * Index 6245, 18.78 digits precision
	 */
	public static double[] pyzero = {-0.2750286678629109583701933175e+20, 0.6587473275719554925999402049e+20, -0.5247065581112764941297350814e+19, 0.1375624316399344078571335453e+18, -0.1648605817185729473122082537e+16, 0.1025520859686394284509167421e+14, -0.3436371222979040378171030138e+11, 0.5915213465686889654273830069e+8, -0.4137035497933148554125235152e+5};

	public static double[] qyzero = {0.3726458838986165881989980739e+21, 0.4192417043410839973904769661e+19, 0.2392883043499781857439356652e+17, 0.9162038034075185262489147968e+14, 0.2613065755041081249568482092e+12, 0.5795122640700729537380087915e+9, 0.1001702641288906265666651753e+7, 0.1282452772478993804176329391e+4, 0.1e+1};


	/* jone for x in [0,8]
	 * Index 6050, 20.98 digits precision
	 */
	public static double[] pjone = {0.581199354001606143928050809e+21, -0.6672106568924916298020941484e+20, 0.2316433580634002297931815435e+19, -0.3588817569910106050743641413e+17, 0.2908795263834775409737601689e+15, -0.1322983480332126453125473247e+13, 0.3413234182301700539091292655e+10, -0.4695753530642995859767162166e+7, 0.270112271089232341485679099e+4};

	public static double[] qjone = {0.11623987080032122878585294e+22, 0.1185770712190320999837113348e+20, 0.6092061398917521746105196863e+17, 0.2081661221307607351240184229e+15, 0.5243710262167649715406728642e+12, 0.1013863514358673989967045588e+10, 0.1501793594998585505921097578e+7, 0.1606931573481487801970916749e+4, 0.1e+1};


	/* pone for x in [8,inf]
	 * Index 6749, 18.11 digits precision
	 */
	public static double[] ppone = {0.352246649133679798341724373e+5, 0.62758845247161281269005675e+5, 0.313539631109159574238669888e+5, 0.49854832060594338434500455e+4, 0.2111529182853962382105718e+3, 0.12571716929145341558495e+1};

	public static double[] qpone = {0.352246649133679798068390431e+5, 0.626943469593560511888833731e+5, 0.312404063819041039923015703e+5, 0.4930396490181088979386097e+4, 0.2030775189134759322293574e+3, 0.1e+1};

	/* qone for x in [8,inf]
	 * Index 7149, 18.28 digits precision
	 */
	public static double[] pqone = {0.3511751914303552822533318e+3, 0.7210391804904475039280863e+3, 0.4259873011654442389886993e+3, 0.831898957673850827325226e+2, 0.45681716295512267064405e+1, 0.3532840052740123642735e-1};

	public static double[] qqone = {0.74917374171809127714519505e+4, 0.154141773392650970499848051e+5, 0.91522317015169922705904727e+4, 0.18111867005523513506724158e+4, 0.1038187585462133728776636e+3, 0.1e+1};


	/* yone for x in [0,8]
	 * Index 6444, 18.24 digits precision
	 */
	public static double[] pyone = {-0.2923821961532962543101048748e+20, 0.7748520682186839645088094202e+19, -0.3441048063084114446185461344e+18, 0.5915160760490070618496315281e+16, -0.4863316942567175074828129117e+14, 0.2049696673745662182619800495e+12, -0.4289471968855248801821819588e+9, 0.3556924009830526056691325215e+6};

	public static double[] qyone = {0.1491311511302920350174081355e+21, 0.1818662841706134986885065935e+19, 0.113163938269888452690508283e+17, 0.4755173588888137713092774006e+14, 0.1500221699156708987166369115e+12, 0.3716660798621930285596927703e+9, 0.726914730719888456980191315e+6, 0.10726961437789255233221267e+4, 0.1e+1};
}
/*
 * Make all the following internal routines perform autoconversion
 * from string to numeric value.
 */
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define pop(x) pop_or_convert_from_string(x)

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define BAD_DEFAULT default: int_error(NO_CARET, "internal error : argument neither INT or CMPLX")

/* Terminate the autoconversion from string to numeric values */
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef pop


/* functions for accessing fields from tm structure, for time series
 * they are all the same, so define a macro
 */
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define TIMEFUNC(name, field) void name(union argument *arg) { struct value a; struct tm tm; (void) arg; (void) pop_or_convert_from_string(&a); ggmtime(&tm, real(&a)); push(Gcomplex(&a, (double)tm.field, 0.0)); }


/*****************************************************************************/

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define SQR(a) ((a)*(a))

///#define C1 0.3
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C2 (1.0/7.0)
///#define C3 0.375
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C4 (9.0/22.0)

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C4
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C3
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C2
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C1

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C1 (3.0/14.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C2 (1.0/6.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C3 (9.0/22.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C4 (3.0/26.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C5 (0.25*C3)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C6 (1.5*C4)

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C6
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C5
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C4
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C3
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C2
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C1

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C1 (3.0/14.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C2 (1.0/3.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C3 (3.0/22.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C4 (3.0/26.0)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C5 (0.75*C3)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C6 (1.5*C4)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C7 (0.5*C2)
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define C8 (C3+C3)

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C6
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C5
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C4
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C3
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C2
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C1
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C8
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef C7

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef SQR

/*****************************************************************************/
