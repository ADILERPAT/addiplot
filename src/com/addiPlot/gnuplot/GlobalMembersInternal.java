package com.addiPlot.gnuplot;

public class GlobalMembersInternal
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: internal.c,v 1.51 2008/09/25 18:33:50 sfeam Exp $");
	}
	///#endif

	/* GNUPLOT - internal.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/*
	 * $Id: internal.h,v 1.19 2007/08/28 06:13:07 sfeam Exp $
	 */

	/* GNUPLOT - internal.h */

	/*[
	 * Copyright 1999, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* #if... / #include / #define collection: */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif

	/* Prototypes from file "internal.c" */

	/* the basic operators of our stack machine for function evaluation: */
	public static void f_push(argument x)
	{
		udvt_entry udv;

		udv = x.udv_arg;
		if (udv.udv_undef) // undefined
		{
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "undefined variable: %s", udv.udv_name);
		}
		GlobalMembersEval.push((udv.udv_value));
	}
	public static void f_pushc(argument x)
	{
		GlobalMembersEval.push((x.v_arg));
	}
	public static void f_pushd1(argument x)
	{
		GlobalMembersEval.push((x.udf_arg.dummy_values[0]));
	}
	public static void f_pushd2(argument x)
	{
		GlobalMembersEval.push((x.udf_arg.dummy_values[1]));
	}
	public static void f_pushd(argument x)
	{
		value param = new value();
		() GlobalMembersEval.pop(param);
		GlobalMembersEval.push((x.udf_arg.dummy_values[param.v.int_val]));
	}
	public static void f_pop(argument x)
	{
		value dummy = new value();
		GlobalMembersEval.pop(dummy);
		GlobalMembersEval.gpfree_string(dummy);
	}

/* execute a udf */
	public static void f_call(argument x)
	{
		udft_entry udf;
		value save_dummy = new value();

		udf = x.udf_arg;
		if (udf.at == null) // undefined
		{
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "undefined function: %s", udf.udf_name);
		}
		save_dummy = udf.dummy_values[0];
		() GlobalMembersEval.pop((udf.dummy_values[0]));

		if (udf.dummy_num != 1)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "function %s requires %d variables", udf.udf_name, udf.dummy_num);

		GlobalMembersEval.execute_at(udf.at);
		GlobalMembersEval.gpfree_string(udf.dummy_values[0]);
		udf.dummy_values[0] = save_dummy;
	}

/* execute a udf of n variables */
	public static void f_calln(argument x)
	{
		udft_entry udf;
		value[] save_dummy = new value[DefineConstants.MAX_NUM_VAR];

		int i;
		int num_pop;
		value num_params = new value();

		udf = x.udf_arg;
		if (udf.at == null) // undefined
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "undefined function: %s", udf.udf_name);
		for (i = 0; i < DefineConstants.MAX_NUM_VAR; i++)
		save_dummy[i] = udf.dummy_values[i];

		() GlobalMembersEval.pop(num_params);

		if (num_params.v.int_val != udf.dummy_num)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "function %s requires %d variable%c", udf.udf_name, udf.dummy_num, (udf.dummy_num == 1)?'\0':'s');

		/* if there are more parameters than the function is expecting */
		/* simply ignore the excess */
		if (num_params.v.int_val > DefineConstants.MAX_NUM_VAR)
		{
		/* pop and discard the dummies that there is no room for */
		num_pop = num_params.v.int_val - DefineConstants.MAX_NUM_VAR;
		for (i = 0; i < num_pop; i++)
			() GlobalMembersEval.pop((udf.dummy_values[0]));

		num_pop = DefineConstants.MAX_NUM_VAR;
		}
		else
		{
		num_pop = num_params.v.int_val;
		}

		/* pop parameters we can use */
		for (i = num_pop - 1; i >= 0; i--)
		() GlobalMembersEval.pop((udf.dummy_values[i]));

		GlobalMembersEval.execute_at(udf.at);
		for (i = 0; i < DefineConstants.MAX_NUM_VAR; i++)
		{
		GlobalMembersEval.gpfree_string(udf.dummy_values[i]);
		udf.dummy_values[i] = save_dummy[i];
		}
	}
	public static void f_lnot(argument arg)
	{
		value a = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val == 0));
	}
	public static void f_bnot(argument arg)
	{
		value a = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, ~a.v.int_val));
	}
	public static void f_lor(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(b));
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val || b.v.int_val != 0));
	}
	public static void f_land(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(b));
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val && b.v.int_val != 0));
	}
	public static void f_bor(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(b));
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val | b.v.int_val));
	}
	public static void f_xor(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(b));
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val ^ b.v.int_val));
	}
	public static void f_band(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		GlobalMembersEval.int_check(GlobalMembersEval.pop(b));
		GlobalMembersEval.int_check(GlobalMembersEval.pop(a));
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val & b.v.int_val));
	}
	public static void f_uminus(argument arg)
	{
		value a = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		a.v.int_val = -a.v.int_val;
		break;
		case CMPLX:
		a.v.cmplx_val.real = -a.v.cmplx_val.real;
		a.v.cmplx_val.imag = -a.v.cmplx_val.imag;
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(a);
	}
	public static void f_eq(argument arg)
	{
		/* note: floating point equality is rare because of roundoff error! */
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val == b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val == b.v.cmplx_val.real && b.v.cmplx_val.imag == 0.0);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (b.v.int_val == a.v.cmplx_val.real && a.v.cmplx_val.imag == 0.0);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real == b.v.cmplx_val.real && a.v.cmplx_val.imag == b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_ne(argument arg)
	{
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val != b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val != b.v.cmplx_val.real || b.v.cmplx_val.imag != 0.0);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (b.v.int_val != a.v.cmplx_val.real || a.v.cmplx_val.imag != 0.0);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real != b.v.cmplx_val.real || a.v.cmplx_val.imag != b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_gt(argument arg)
	{
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val > b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val > b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.cmplx_val.real > b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real > b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_lt(argument arg)
	{
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val < b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val < b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.cmplx_val.real < b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real < b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_ge(argument arg)
	{
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val >= b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val >= b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.cmplx_val.real >= b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real >= b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_le(argument arg)
	{
		value a = new value();
		value b = new value();
		int result = 0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.int_val <= b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.int_val <= b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			result = (a.v.cmplx_val.real <= b.v.int_val);
			break;
		case CMPLX:
			result = (a.v.cmplx_val.real <= b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, result));
	}
	public static void f_plus(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Ginteger(result, a.v.int_val + b.v.int_val);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.int_val + b.v.cmplx_val.real, b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Gcomplex(result, b.v.int_val + a.v.cmplx_val.real, a.v.cmplx_val.imag);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.cmplx_val.real + b.v.cmplx_val.real, a.v.cmplx_val.imag + b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(result);
	}
	public static void f_minus(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);
		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Ginteger(result, a.v.int_val - b.v.int_val);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.int_val - b.v.cmplx_val.real, -b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Gcomplex(result, a.v.cmplx_val.real - b.v.int_val, a.v.cmplx_val.imag);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.cmplx_val.real - b.v.cmplx_val.real, a.v.cmplx_val.imag - b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(result);
	}
	public static void f_mult(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Ginteger(result, a.v.int_val * b.v.int_val);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.int_val * b.v.cmplx_val.real, a.v.int_val * b.v.cmplx_val.imag);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			() GlobalMembersEval.Gcomplex(result, b.v.int_val * a.v.cmplx_val.real, b.v.int_val * a.v.cmplx_val.imag);
			break;
		case CMPLX:
			() GlobalMembersEval.Gcomplex(result, a.v.cmplx_val.real * b.v.cmplx_val.real - a.v.cmplx_val.imag * b.v.cmplx_val.imag, a.v.cmplx_val.real * b.v.cmplx_val.imag + a.v.cmplx_val.imag * b.v.cmplx_val.real);
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(result);
	}
	public static void f_div(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();
		double square;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			if (b.v.int_val != 0)
			() GlobalMembersEval.Ginteger(result, a.v.int_val / b.v.int_val);
			else
			{
			() GlobalMembersEval.Ginteger(result, 0);
			GlobalMembersEval.undefined = true;
			}
			break;
		case CMPLX:
			square = b.v.cmplx_val.real * b.v.cmplx_val.real + b.v.cmplx_val.imag * b.v.cmplx_val.imag;
			if (square != 0)
			() GlobalMembersEval.Gcomplex(result, a.v.int_val * b.v.cmplx_val.real / square, -a.v.int_val * b.v.cmplx_val.imag / square);
			else
			{
			() GlobalMembersEval.Gcomplex(result, 0.0, 0.0);
			GlobalMembersEval.undefined = true;
			}
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			if (b.v.int_val != 0)
			() GlobalMembersEval.Gcomplex(result, a.v.cmplx_val.real / b.v.int_val, a.v.cmplx_val.imag / b.v.int_val);
			else
			{
			() GlobalMembersEval.Gcomplex(result, 0.0, 0.0);
			GlobalMembersEval.undefined = true;
			}
			break;
		case CMPLX:
			square = b.v.cmplx_val.real * b.v.cmplx_val.real + b.v.cmplx_val.imag * b.v.cmplx_val.imag;
			if (square != 0)
			() GlobalMembersEval.Gcomplex(result, (a.v.cmplx_val.real * b.v.cmplx_val.real + a.v.cmplx_val.imag * b.v.cmplx_val.imag) / square, (a.v.cmplx_val.imag * b.v.cmplx_val.real - a.v.cmplx_val.real * b.v.cmplx_val.imag) / square);
			else
			{
			() GlobalMembersEval.Gcomplex(result, 0.0, 0.0);
			GlobalMembersEval.undefined = true;
			}
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(result);
	}
	public static void f_mod(argument arg)
	{
		value a = new value();
		value b = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type != DATA_TYPES.INTGR || b.type != DATA_TYPES.INTGR)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "can only mod ints");
		if (b.v.int_val != 0)
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, a.v.int_val % b.v.int_val));
		else
		{
		GlobalMembersEval.push(GlobalMembersEval.Ginteger(a, 0));
		GlobalMembersEval.undefined = true;
		}
	}
	public static void f_power(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();
		int i;
		int t;
		int count;
		double mag;
		double ang;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		switch (a.type)
		{
		case INTGR:
		switch (b.type)
		{
		case INTGR:
			count = Math.abs(b.v.int_val);
			t = 1;
			/* this ought to use bit-masks and squares, etc */
			for (i = 0; i < count; i++)
			t *= a.v.int_val;
			if (b.v.int_val >= 0)
			() GlobalMembersEval.Ginteger(result, t);
			else if (t != 0)
			() GlobalMembersEval.Gcomplex(result, 1.0 / t, 0.0);
			else
			{
			GlobalMembersEval.undefined = true;
			() GlobalMembersEval.Gcomplex(result, 0.0, 0.0);
			}
			break;
		case CMPLX:
			if (a.v.int_val == 0)
			{
			if (b.v.cmplx_val.imag != 0 || b.v.cmplx_val.real < 0)
			{
				GlobalMembersEval.undefined = true;
			}
			/* return 1.0 for 0**0 */
			GlobalMembersEval.Gcomplex(result, b.v.cmplx_val.real == 0 ? 1.0 : 0.0, 0.0);
			}
			else
			{
			mag = Math.pow(GlobalMembersEval.magnitude(a), Math.abs(b.v.cmplx_val.real));
			if (b.v.cmplx_val.real < 0.0)
			{
				if (mag != 0.0)
				mag = 1.0 / mag;
				else
				GlobalMembersEval.undefined = true;
			}
			mag *= GlobalMembersEval.gp_exp(-b.v.cmplx_val.imag * GlobalMembersEval.angle(a));
			ang = b.v.cmplx_val.real * GlobalMembersEval.angle(a) + b.v.cmplx_val.imag * Math.log(GlobalMembersEval.magnitude(a));
			() GlobalMembersEval.Gcomplex(result, mag * Math.cos(ang), mag * Math.sin(ang));
			}
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		case CMPLX:
		switch (b.type)
		{
		case INTGR:
			if (a.v.cmplx_val.imag == 0.0)
			{
			mag = Math.pow(a.v.cmplx_val.real, (double) Math.abs(b.v.int_val));
			if (b.v.int_val < 0)
			{
				if (mag != 0.0)
				mag = 1.0 / mag;
				else
				GlobalMembersEval.undefined = true;
			}
			() GlobalMembersEval.Gcomplex(result, mag, 0.0);
			}
			else
			{
			/* not so good, but...! */
			mag = Math.pow(GlobalMembersEval.magnitude(a), (double) Math.abs(b.v.int_val));
			if (b.v.int_val < 0)
			{
				if (mag != 0.0)
				mag = 1.0 / mag;
				else
				GlobalMembersEval.undefined = true;
			}
			ang = GlobalMembersEval.angle(a) * b.v.int_val;
			() GlobalMembersEval.Gcomplex(result, mag * Math.cos(ang), mag * Math.sin(ang));
			}
			break;
		case CMPLX:
			if (a.v.cmplx_val.real == 0 && a.v.cmplx_val.imag == 0)
			{
			if (b.v.cmplx_val.imag != 0 || b.v.cmplx_val.real < 0)
			{
				GlobalMembersEval.undefined = true;
			}
			/* return 1.0 for 0**0 */
			GlobalMembersEval.Gcomplex(result, b.v.cmplx_val.real == 0 ? 1.0 : 0.0, 0.0);
			}
			else
			{
			mag = Math.pow(GlobalMembersEval.magnitude(a), Math.abs(b.v.cmplx_val.real));
			if (b.v.cmplx_val.real < 0.0)
			{
				if (mag != 0.0)
				mag = 1.0 / mag;
				else
				GlobalMembersEval.undefined = true;
			}
			mag *= GlobalMembersEval.gp_exp(-b.v.cmplx_val.imag * GlobalMembersEval.angle(a));
			ang = b.v.cmplx_val.real * GlobalMembersEval.angle(a) + b.v.cmplx_val.imag * Math.log(GlobalMembersEval.magnitude(a));
			() GlobalMembersEval.Gcomplex(result, mag * Math.cos(ang), mag * Math.sin(ang));
			}
			break;
			default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		break;
		default: GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : type neither INT or CMPLX"); return;
		}
		GlobalMembersEval.push(result);
	}
	public static void f_factorial(argument arg)
	{
		value a = new value();
		int i;
		double val = 0.0;

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(a);

		switch (a.type)
		{
		case INTGR:
		val = 1.0;
		for (i = a.v.int_val; i > 1; i--) //fpe's should catch overflows
			val *= i;
		break;
		default:
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "factorial (!) argument must be an integer");
		return; // avoid gcc -Wall warning about val
		}

		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(a, val, 0.0));

	}

	public static void f_concatenate(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (b.type == DATA_TYPES.INTGR)
		{
		int i = b.v.int_val;
		b.type = DATA_TYPES.STRING;
		b.v.string_val = (String)GlobalMembersAlloc.gp_alloc(32, "str_const");
	///#ifdef HAVE_SNPRINTF
		snprintf(b.v.string_val,32,"%d",i);
	///#else
	//	sprintf(b.v.string_val,"%d",i);
	///#endif
		}

		if (a.type != DATA_TYPES.STRING || b.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : STRING operator applied to non-STRING type");

		() GlobalMembersEval.Gstring(result, GlobalMembersUtil.gp_stradd(a.v.string_val, b.v.string_val));
		GlobalMembersEval.gpfree_string(a);
		GlobalMembersEval.gpfree_string(b);
		GlobalMembersEval.push(result);
		GlobalMembersEval.gpfree_string(result); // free string allocated within gp_stradd()
	}
	public static void f_eqs(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type != DATA_TYPES.STRING || b.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : STRING operator applied to non-STRING type");

		() GlobalMembersEval.Ginteger(result, !strcmp(a.v.string_val, b.v.string_val));
		GlobalMembersEval.gpfree_string(a);
		GlobalMembersEval.gpfree_string(b);
		GlobalMembersEval.push(result);
	}
	public static void f_nes(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type != DATA_TYPES.STRING || b.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : STRING operator applied to non-STRING type");

		() GlobalMembersEval.Ginteger(result, (int)(strcmp(a.v.string_val, b.v.string_val) != 0));
		GlobalMembersEval.gpfree_string(a);
		GlobalMembersEval.gpfree_string(b);
		GlobalMembersEval.push(result);
	}

/* EAM July 2004 - Gnuplot's own string formatting conventions.
 * Currently this routine assumes base 10 representation, because
 * it is not clear where it could be specified to be anything else.
 */
	public static void f_gprintf(argument arg)
	{
		value fmt = new value();
		value val = new value();
		value result = new value();
		String buffer;
		int length;
		double base;

		/* Retrieve parameters from top of stack */
		GlobalMembersEval.pop_or_convert_from_string(val);
		GlobalMembersEval.pop_or_convert_from_string(fmt);

	///#ifdef DEBUG
	//    fprintf(stderr,"----------\nGot gprintf parameters\nfmt: ");
	//	disp_value(stderr, &fmt, TRUE);
	//    fprintf(stderr,"\nval: ");
	//	disp_value(stderr, &val, TRUE);
	//    fprintf(stderr,"\n----------\n");
	///#endif

		/* Make sure parameters are of the correct type */
		if (fmt.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "First parameter to gprintf must be a format string");

		/* EAM FIXME - I have no idea where we would learn another base is wanted */
		base = 10.;

		/* Make sure we have at least as much space in the output as the format itself */
		length = 80 + fmt.v.string_val.length();
		buffer = GlobalMembersAlloc.gp_alloc(length, "f_gprintf");

		/* Call the old internal routine */
		GlobalMembersUtil.gprintf(buffer, length, fmt.v.string_val, base, GlobalMembersEval.real(val));

		GlobalMembersFit.a((stderr," gprintf result = \"%s\"\n",buffer));
		GlobalMembersEval.push(GlobalMembersEval.Gstring(result, buffer));

		GlobalMembersEval.gpfree_string(fmt);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(buffer);
	}
	public static void f_range(argument arg)
	{
		value beg = new value();
		value end = new value();
		value full = new value();
		value substr = new value();

		() arg; // avoid -Wunused warning
		() GlobalMembersEval.pop_or_convert_from_string(end);
		() GlobalMembersEval.pop_or_convert_from_string(beg);
		() GlobalMembersEval.pop_or_convert_from_string(full);

		if (end.type != DATA_TYPES.INTGR || beg.type != DATA_TYPES.INTGR)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: substring range specifiers must have integer values");

		if (full.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: substring range operator applied to non-STRING type");

		GlobalMembersFit.a((stderr,"f_range( \"%s\", %d, %d)\n", full.v.string_val, beg.v.int_val, end.v.int_val));

		if (end.v.int_val > full.v.string_val.length())
		end.v.int_val = full.v.string_val.length();
		if (beg.v.int_val < 1)
		beg.v.int_val = 1;
		if (beg.v.int_val > end.v.int_val)
		beg.v.int_val = full.v.string_val.length() + 1;

		full.v.string_val = tangible.StringFunctions.changeCharacter(full.v.string_val, end.v.int_val, '\0');
		GlobalMembersEval.push(GlobalMembersEval.Gstring(substr, full.v.string_val.charAt(beg.v.int_val - 1)));
		GlobalMembersEval.gpfree_string(full);
	}

/* EAM July 2004  (revised to dynamic buffer July 2005)
 * There are probably an infinite number of things that can
 * go wrong if the user mis-matches arguments and format strings
 * in the call to sprintf, but I hope none will do worse than
 * result in a garbage output string.
 */
	public static void f_sprintf(argument arg)
	{
		value[] a = new value[10];
		value args;
		value num_params = new value();
		value result = new value();
		String buffer;
		int DefineConstants.bufsize;
		String next_start;
		String outpos;
		byte tempchar;
		int next_length;
		String prev_start;
		int prev_pos;
		int i;
		int remaining;
		int nargs = 0;
		DATA_TYPES spec_type;

		/* Retrieve number of parameters from top of stack */
		GlobalMembersEval.pop_or_convert_from_string(num_params);
		nargs = num_params.v.int_val;
		if (nargs > 10) // Fall back to slow but sure allocation
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		args = GlobalMembersAlloc.gp_alloc(sizeof(GlobalMembersMouse.struct GlobalMembersGplt_x11.value) * nargs, "sprintf args");
		}
		else
		args = a;

		for (i = 0; i < nargs; i++)
		GlobalMembersEval.pop_or_convert_from_string(args[i]);

		/* Make sure we got a format string of some sort */
		if (args[nargs - 1].type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "First parameter to sprintf must be a format string");

		/* Allocate space for the output string. If this isn't */
		/* long enough we can reallocate a larger space later. */
		DefineConstants.bufsize = 80 + String.valueOf(args[nargs - 1].v.string_val).length();
		buffer = GlobalMembersAlloc.gp_alloc(DefineConstants.bufsize, "f_sprintf");

		/* Copy leading fragment of format into output buffer */
		outpos = buffer;
		next_start = args[nargs - 1].v.string_val;
		next_length = strcspn(next_start,"%");
		outpos = next_start.substring(0, next_length);

		next_start += next_length;
		outpos += next_length;

		/* Format the remaining sprintf() parameters one by one */
		prev_start = next_start;
		prev_pos = next_length;
		remaining = nargs - 1;

		/* If the user has set an explicit LC_NUMERIC locale, apply it */
		/* to sprintf calls during expression evaluation.              */
		() do {if (GlobalMembersUtil.numeric_locale != null && strcmp(GlobalMembersUtil.numeric_locale,"C")) setlocale(LC_NUMERIC,GlobalMembersUtil.numeric_locale);} while (0)();

		/* Each time we start this loop we are pointing to a % character */
		while (remaining - .0 && next_start.charAt(0) && next_start.charAt(1))
		{
		value next_param = args[remaining];

		/* Check for %%; print as literal and don't consume a parameter */
		if (!strncmp(next_start,"%%",2))
		{
			next_start++;
			do
			{
			outpos++= next_start++;
			} while (next_start != null && !next_start.equals('%'));
			remaining++;
			continue;
		}

		next_length = strcspn(next_start + 1,"%") + 1;
		tempchar = next_start.charAt(next_length);
		next_start = tangible.StringFunctions.changeCharacter(next_start, next_length, '\0');

		spec_type = GlobalMembersInternal.sprintf_specifier(next_start);

		/* string value <-> numerical value check */
		if (spec_type == DATA_TYPES.STRING && next_param.type != DATA_TYPES.STRING)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "f_sprintf: attempt to print numeric value with string format");
		if (spec_type != DATA_TYPES.STRING && next_param.type == DATA_TYPES.STRING)
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "f_sprintf: attempt to print string value with numeric format");

	///#ifdef HAVE_SNPRINTF
		/* Use the format to print next arg */
		switch (spec_type)
		{
		case INTGR:
			snprintf(outpos,DefineConstants.bufsize - (outpos - buffer), next_start, (int)GlobalMembersEval.real(next_param));
			break;
		case CMPLX:
			snprintf(outpos,DefineConstants.bufsize - (outpos - buffer), next_start, GlobalMembersEval.real(next_param));
			break;
		case STRING:
			snprintf(outpos,DefineConstants.bufsize - (outpos - buffer), next_start, next_param.v.string_val);
			break;
		default:
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: invalid spec_type");
		}
	///#else
	// /* FIXME - this is bad; we should dummy up an snprintf equivalent */
	//	switch(spec_type) {
	//	case INTGR:
	//	    sprintf(outpos, next_start, (int)real(next_param));
	//	    break;
	//	case CMPLX:
	//	    sprintf(outpos, next_start, real(next_param));
	//	    break;
	//	case STRING:
	//	    sprintf(outpos, next_start, next_param->v.string_val);
	//	    break;
	//	default:
	//	    int_error(NO_CARET,"internal error: invalid spec_type");
	//	}
	///#endif

		next_start = tangible.StringFunctions.changeCharacter(next_start, next_length, tempchar);
		next_start += next_length;
		outpos = buffer.charAt(buffer.length());

		/* Check whether previous parameter output hit the end of the buffer */
		/* If so, reallocate a larger buffer, go back and try it again.      */
		if (buffer.length() >= DefineConstants.bufsize-2)
		{
			DefineConstants.bufsize *= 2;
			buffer = GlobalMembersAlloc.gp_realloc(buffer, DefineConstants.bufsize, "f_sprintf");
			next_start = prev_start;
			outpos = buffer + prev_pos;
			remaining++;
			continue;
		}
		else
		{
			prev_start = next_start;
			prev_pos = outpos - buffer;
		}

		}

		/* Copy the trailing portion of the format, if any */
		/* We could just call snprintf(), but it doesn't check for */
		/* whether there really are more variables to handle.      */
		i = DefineConstants.bufsize - (outpos - buffer);
		while (next_start != null && --i > 0)
		{
		if (next_start.equals('%') && *(next_start + 1) == '%')
			next_start++;
		outpos++= next_start++;
		}
		outpos = '\0';

		a((stderr," snprintf result = \"%s\"\n",buffer));
		GlobalMembersEval.push(GlobalMembersEval.Gstring(result, buffer));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(buffer);

		/* Free any strings from parameters we have now used */
		for (i = 0; i < nargs; i++)
		GlobalMembersEval.gpfree_string(args[i]);

		if (args != a)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(args);

		/* Return to C locale for internal use */
		() do {if (GlobalMembersUtil.numeric_locale != null && strcmp(GlobalMembersUtil.numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)();

	}
	public static void f_strlen(argument arg)
	{
		value a = new value();
		value result = new value();

		() arg;
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : strlen of non-STRING argument");

		() GlobalMembersEval.Ginteger(result, (int)a.v.string_val.length());
		GlobalMembersEval.gpfree_string(a);
		GlobalMembersEval.push(result);
	}
	public static void f_strstrt(argument arg)
	{
		value needle = new value();
		value haystack = new value();
		value result = new value();
		String start;

		() arg;
		() GlobalMembersEval.pop_or_convert_from_string(needle);
		() GlobalMembersEval.pop_or_convert_from_string(haystack);

		if (needle.type != DATA_TYPES.STRING || haystack.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : non-STRING argument to strstrt");

		start = tangible.StringFunctions.strStr(haystack.v.string_val, needle.v.string_val);
		() GlobalMembersEval.Ginteger(result, (int)(start != null ? (start - haystack.v.string_val) + 1 : 0));
		GlobalMembersEval.gpfree_string(needle);
		GlobalMembersEval.gpfree_string(haystack);
		GlobalMembersEval.push(result);
	}

/* execute a system call and return stream from STDOUT */
	public static void f_system(argument arg)
	{
		value val = new value();
		value result = new value();
		udvt_entry errno_var;
		String output;
		int output_len;
		int ierr;

		/* Retrieve parameters from top of stack */
		GlobalMembersEval.pop_or_convert_from_string(val);

		/* Make sure parameters are of the correct type */
		if (val.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "non-string argument to system()");

		GlobalMembersFit.a((stderr," f_system input = \"%s\"\n", val.v.string_val));

	tangible.RefObject<String[]> tempRef_output = new tangible.RefObject<String[]>(output);
		ierr = GlobalMembersCommand.do_system_func(val.v.string_val, tempRef_output);
		output = tempRef_output.argvalue;
		if ((errno_var = GlobalMembersEval.add_udv_by_name("ERRNO")))
		{
		errno_var.udv_undef = false;
		GlobalMembersEval.Ginteger(errno_var.udv_value, ierr);
		}
		output_len = output.length();

		/* chomp result */
		if (output_len > 0 && output.charAt(output_len - 1) == '\n')
		output = tangible.StringFunctions.changeCharacter(output, output_len - 1, DefineConstants.NUL);

		GlobalMembersFit.a((stderr," f_system result = \"%s\"\n", output));

		GlobalMembersEval.push(GlobalMembersEval.Gstring(result, output));

		GlobalMembersEval.gpfree_string(result); // free output
		GlobalMembersEval.gpfree_string(val); // free command string
	}
	public static void f_words(argument arg)
	{
		value a = new value();
		value b = new value();
		value result = new value();
		int nwords = 0;
		int ntarget;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * s;

		() arg;
		if (GlobalMembersEval.pop_or_convert_from_string(b).type != DATA_TYPES.INTGR)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : non-INTGR argument");
		ntarget = b.v.int_val;

		if (GlobalMembersEval.pop_or_convert_from_string(a).type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error : non-STRING argument");
		s = a.v.string_val;

		GlobalMembersEval.Gstring(result, "");
		while (*s)
		{
		while (Character.isWhitespace(*s))
			s++;
		if (!*s)
			break;
		nwords++;
		if (nwords == ntarget) // Found the one we wanted
		{
			GlobalMembersEval.Gstring(result, s);
			s = result.v.string_val;
		}
		while (*s && !Character.isWhitespace(*s))
			s++;
		if (nwords == ntarget) // Terminate this word cleanly
		{
			*s = (byte)'\0';
			break;
		}
		}

		if (ntarget < 0)
		/* words(s) = word(s,-1) = # of words in string */
		GlobalMembersEval.Ginteger(result, nwords);

		GlobalMembersEval.push(result);
		GlobalMembersEval.gpfree_string(a);
	}

/* Output time given in seconds from year 2000 into string */
	public static void f_strftime(argument arg)
	{
		value fmt = new value();
		value val = new value();
		String fmtstr;
		String buffer;
		int fmtlen;
		int buflen;
		int length;

		() arg; // Avoid compiler warnings

		/* Retrieve parameters from top of stack */
		GlobalMembersEval.pop_or_convert_from_string(val);
		GlobalMembersEval.pop_or_convert_from_string(fmt);
		if (fmt.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "First parameter to strftime must be a format string");

		/* Prepare format string.
		 * Make sure the resulting string not empty by adding a space.
		 * Otherwise, the return value of gstrftime doesn't give enough
		 * information.
		 */
		fmtlen = fmt.v.string_val.length() + 1;
		fmtstr = GlobalMembersAlloc.gp_alloc(fmtlen + 1, "f_strftime: fmt");
		fmtstr = fmt.v.string_val.substring(0, fmtlen);
		strncat(fmtstr, " ", fmtlen);
		buflen = 80 + 2 * fmtlen;
		buffer = GlobalMembersAlloc.gp_alloc(buflen, "f_strftime: buffer");

		/* Get time_str */
		length = GlobalMembersTime.gstrftime(buffer, buflen, fmtstr, GlobalMembersEval.real(val));
		if (length == 0 || length >= buflen)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Resulting string is too long");

		/* Remove trailing space */
		assert buffer.charAt(length - 1) == ' ';
		buffer = tangible.StringFunctions.changeCharacter(buffer, length - 1, DefineConstants.NUL);

		GlobalMembersEval.gpfree_string(val);
		GlobalMembersEval.gpfree_string(fmt);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(fmtstr);

		GlobalMembersEval.push(GlobalMembersEval.Gstring(val, buffer));
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(buffer);
	}

/* Convert string into seconds from year 2000 */
	public static void f_strptime(argument arg)
	{
		value fmt = new value();
		value val = new value();
		tm time_tm = new tm();
		double result;

		() arg; // Avoid compiler warnings

		GlobalMembersEval.pop_or_convert_from_string(val);
		GlobalMembersEval.pop_or_convert_from_string(fmt);

		if (fmt.type != DATA_TYPES.STRING || val.type != DATA_TYPES.STRING)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Both parameters to strptime must be strings");
		if (fmt.v.string_val == null || val.v.string_val == null)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Internal error: string not allocated");


		/* string -> time_tm */
		GlobalMembersTime.gstrptime(val.v.string_val, fmt.v.string_val, time_tm);

		/* time_tm -> result */
		result = GlobalMembersTime.gtimegm(time_tm);
		GlobalMembersFit.a((stderr," strptime result = %g seconds \n", result));

		GlobalMembersEval.gpfree_string(val);
		GlobalMembersEval.gpfree_string(fmt);
		GlobalMembersEval.push(GlobalMembersEval.Gcomplex(val, result, 0.0));
	}

/* Variable assignment operator */
	public static void f_assign(argument arg)
	{
		value a = new value();
		value b = new value();
		() arg;
		() GlobalMembersEval.pop_or_convert_from_string(b);
		() GlobalMembersEval.pop_or_convert_from_string(a);

		if (a.type == DATA_TYPES.STRING)
		{
		udvt_entry udv;
		if (!strncmp(a.v.string_val,"GPVAL_",6) || !strncmp(a.v.string_val,"MOUSE_",6))
			GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Attempt to assign to a read-only variable");
		udv = GlobalMembersEval.add_udv_by_name(a.v.string_val);
		GlobalMembersEval.gpfree_string(a);
		if (!udv.udv_undef)
			GlobalMembersEval.gpfree_string((udv.udv_value));
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
//ORIGINAL LINE: udv->udv_value = b;
		udv.udv_value.copyFrom(b);
		udv.udv_undef = false;
		GlobalMembersEval.push(b);
		}
		else
		{
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "attempt to assign to something other than a named variable");
		}
	}

/* Return which argument type sprintf will need for this format string:
 *   char*       STRING
 *   int         INTGR
 *   double      CMPLX
 * Should call int_err for any other type.
 * format is expected to start with '%'
 */



	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif


	/*
	 * Excerpt from the Solaris man page for matherr():
	 *
	 *   The The System V Interface Definition, Third Edition (SVID3)
	 *   specifies  that  certain  libm functions call matherr() when
	 *   exceptions are detected. Users may define their own  mechan-
	 *   isms  for handling exceptions, by including a function named
	 *   matherr() in their programs.
	 */

	public static DATA_TYPES sprintf_specifier(String format)
	{
		final String string_spec = "s";
		final String real_spec = "aAeEfFgG";
		final String int_spec = "cdiouxX";
		/* The following characters are used for use of invalid types */
		final String illegal_spec = "hlLqjzZtCSpn";

		int string_pos;
		int real_pos;
		int int_pos;
		int illegal_pos;

		/* check if really format specifier */
		if (format.charAt(0) != '%')
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "internal error: sprintf_specifier called without '%'\n");

		string_pos = strcspn(format, string_spec);
		real_pos = strcspn(format, real_spec);
		int_pos = strcspn(format, int_spec);
		illegal_pos = strcspn(format, illegal_spec);

		if (illegal_pos < int_pos && illegal_pos < real_pos && illegal_pos < string_pos)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "sprintf_specifier: used with invalid format specifier\n");
		else if (string_pos < real_pos && string_pos < int_pos)
		return DATA_TYPES.STRING;
		else if (real_pos < int_pos)
		return DATA_TYPES.CMPLX;
		else if (int_pos < format.length())
		return DATA_TYPES.INTGR;
		else
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "sprintf_specifier: no format specifier\n");

		return DATA_TYPES.INTGR; // Can't happen, but the compiler doesn't realize that
	}


	public static int matherr(exception x)
	{
		return (GlobalMembersEval.undefined = true); // don't print error message
	}
}
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define BAD_DEFAULT default: int_error(NO_CARET, "internal error : type neither INT or CMPLX"); return;


/*
 * Make all the following internal routines perform autoconversion
 * from string to numeric value.
 */
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
///#define pop(x) pop_or_convert_from_string(x)

/*
 * Terminate the autoconversion from string to numeric values
 */
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
///#undef pop

