package com.addiPlot.gnuplot;

public class GlobalMembersPm3d
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: pm3d.c,v 1.77 2009/03/26 00:49:16 sfeam Exp $");
	}
	///#endif


//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern pm3d_struct pm3d;

/* Read the option for 'pm3d at' command.
 * Used by 'set pm3d at ...' or by 'splot ... with pm3d at ...'.
 * If no option given, then returns empty string, otherwise copied there.
 * The string is unchanged on error, and 1 is returned.
 * On success, 0 is returned.
 */


	/****
	  Declaration of routines
	****/

	public static int get_pm3d_at_option(String pm3d_where)
	{
		String c;

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersCommand.token[GlobalMembersCommand.c_token].length >= sizeof(pm3d.where))
		{
		GlobalMembersPm3d.pm3d_option_at_error();
		return 1;
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
		memcpy(pm3d_where, GlobalMembersCommand.gp_input_line + GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index, GlobalMembersCommand.token[GlobalMembersCommand.c_token].length);
		pm3d_where = pm3d_where.substring(0, GlobalMembersCommand.token[GlobalMembersCommand.c_token].length);
		/* verify the parameter */
		for (c = pm3d_where; c; c++)
		{
		if (!c.equals('C')) // !!!!! CONTOURS, UNDOCUMENTED, THIS LINE IS TEMPORARILY HERE !!!!!
			if (!c.equals(DefineConstants.PM3D_AT_BASE) && !c.equals(DefineConstants.PM3D_AT_TOP) && !c.equals(DefineConstants.PM3D_AT_SURFACE))
			{
			GlobalMembersPm3d.pm3d_option_at_error();
			return 1;
			}
		}
		GlobalMembersCommand.c_token++;
		return 0;
	}
	public static void pm3d_depth_queue_clear()
	{
		if (pm3d.direction != DefineConstants.PM3D_DEPTH)
		return;

		if (quadrangles != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(quadrangles);
		quadrangles = (quadrangle)0;
		allocated_quadrangles = 0;
		current_quadrangle = 0;
	}
	public static void pm3d_depth_queue_flush()
	{
		if (pm3d.direction != DefineConstants.PM3D_DEPTH)
		return;

		if (current_quadrangle > 0 && quadrangles != null)
		{

//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		quadrangle * qp = new quadrangle();
		quadrangle qe;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		gpdPoint * gpdPtr = new gpdPoint();
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		gpiPoint * gpiPtr = new gpiPoint();
		vertex out = new vertex();
		double z = 0; // assignment keeps the compiler happy
		double w = GlobalMembersGraph3d.trans_mat[3][3];
		int i;

		for (qp = quadrangles, qe = quadrangles + current_quadrangle; qp != qe; qp++)
		{

//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
//ORIGINAL LINE: gpdPtr = qp->corners;
			gpdPtr.copyFrom(qp.corners);
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'copyFrom' method should be created if it does not yet exist:
//ORIGINAL LINE: gpiPtr = qp->icorners;
			gpiPtr.copyFrom(qp.icorners);

			for (i = 0; i < 4; i++, gpdPtr++, gpiPtr++)
			{

			GlobalMembersUtil3d.map3d_xyz(gpdPtr.x, gpdPtr.y, gpdPtr.z, out);

			if (i == 0 || out.z > z)
				z = out.z;

			gpiPtr.x = (int)((out.x * GlobalMembersGraph3d.xscaler / w) + GlobalMembersGraph3d.xmiddle);
			gpiPtr.y = (int)((out.y * GlobalMembersGraph3d.yscaler / w) + GlobalMembersGraph3d.ymiddle);
			}

			qp.z = z; // maximal z value of all four corners
		}

//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(quadrangles, current_quadrangle, sizeof(quadrangle), GlobalMembersPm3d.compare_quadrangles);

		for (qp = quadrangles, qe = quadrangles + current_quadrangle; qp != qe; qp++)
		{

			GlobalMembersColor.set_color(qp.gray);
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: ifilled_quadrangle(qp->icorners);
			GlobalMembersColor.ifilled_quadrangle(new gpiPoint(qp.icorners));
		}
		}

		GlobalMembersPm3d.pm3d_depth_queue_clear();
	}

/*
 * unset pm3d for the reset command
 */
	public static void pm3d_reset()
	{
		pm3d.where = "s";
		pm3d.flush = DefineConstants.PM3D_FLUSH_BEGIN;
		pm3d.ftriangles = 0;
		pm3d.direction = DefineConstants.PM3D_SCANS_AUTOMATIC;
		pm3d.clip = DefineConstants.PM3D_CLIP_4IN;
		pm3d.hidden3d_tag = 0;
		pm3d.implicit = PM3D_IMPL_MODE.PM3D_EXPLICIT;
		pm3d.which_corner_color = PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MEAN;
		pm3d.interp_i = 1;
		pm3d.interp_j = 1;
	}

/*
 * Draw (one) PM3D color surface.
 */
	public static void pm3d_draw_one(surface_points plot)
	{
		int i = 0;
		String where = plot.pm3d_where.charAt(0) ? plot.pm3d_where : pm3d.where;
		/* Draw either at 'where' option of the given surface or at pm3d.where
		 * global option. */

		if (!where.charAt(0))
		{
		return;
		}

		/* for pm3dCompress.awk */
		if (GlobalMembersTerm.gppsfile != null && (pm3d.direction != DefineConstants.PM3D_DEPTH))
		fputs("%pm3d_map_begin\n", GlobalMembersTerm.gppsfile);

		for (; where.charAt(i); i++)
		{
		GlobalMembersPm3d.pm3d_plot(plot, where.charAt(i));
		}

		if (tangible.StringFunctions.strChr(where, 'C') != DefineConstants.NULL)
		{
		/* !!!!! FILLED COLOR CONTOURS, *UNDOCUMENTED*
		   !!!!! LATER CHANGE TO STH LIKE
		   !!!!!   (if_filled_contours_requested)
		   !!!!!      ...
		   Currently filled color contours do not work because gnuplot generates
		   open contour lines, i.e. not closed on the graph boundary.
		 */
		if (GlobalMembersGraph3d.draw_contour & en_contour_placement.CONTOUR_SRF != 0)
			GlobalMembersPm3d.filled_color_contour_plot(plot, en_contour_placement.CONTOUR_SRF);
		if (GlobalMembersGraph3d.draw_contour & en_contour_placement.CONTOUR_BASE != 0)
			GlobalMembersPm3d.filled_color_contour_plot(plot, en_contour_placement.CONTOUR_BASE);
		}

		/* for pm3dCompress.awk */
		if (GlobalMembersTerm.gppsfile != null && (pm3d.direction != DefineConstants.PM3D_DEPTH))
		fputs("%pm3d_map_end\n", GlobalMembersTerm.gppsfile);
	}

/*
* Now the routines which are really just those for pm3d.c
*/

/*
 * Rescale z to cb values. Nothing to do if both z and cb are linear or log of the
 * same base, other it has to un-log z and subsequently log it again.
 */
	public static double z2cb(double z)
	{
		if (!GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log && !GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log) // both are linear
		return z;
		if (GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log && !GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log) // log z, linear cb
		return Math.exp(z * GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log_base); // unlog(z)
		if (!GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log && GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log) // linear z, log cb
		return (Math.log(z) / GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log_base);
		/* both are log */
		if (GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].base == GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].base) // can we compare double numbers like that?
		return z;
		return z * GlobalMembersAxis.axis_array[GlobalMembersAxis.z_axis.getValue()].log_base / GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].log_base; // log_cb(unlog_z(z))
	}

/*
 * Rescale cb (color) value into the interval of grays [0,1], taking care
 * of palette being positive or negative.
 * Note that it is OK for logarithmic cb-axis too.
 */
	public static double cb2gray(double cb)
	{
		if (cb <= GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min)
		return (GlobalMembersColor.sm_palette.positive == DefineConstants.SMPAL_POSITIVE) ? 0 : 1;
		if (cb >= GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max)
		return (GlobalMembersColor.sm_palette.positive == DefineConstants.SMPAL_POSITIVE) ? 1 : 0;
		cb = (cb - GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min) / (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].max - GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].min);
		return (GlobalMembersColor.sm_palette.positive == DefineConstants.SMPAL_POSITIVE) ? cb : 1 - cb;
	}

/*
 * Rearrange scan array
 *
 * Allocates *first_ptr (and eventually *second_ptr)
 * which must be freed by the caller
 */
	public static void pm3d_rearrange_scan_array(surface_points this_plot, iso_curve[][] first_ptr, int first_n, int first_invert, iso_curve[][] second_ptr, int second_n, int second_invert)
	{
		if (first_ptr != null)
		{
		GlobalMembersPm3d.pm3d_rearrange_part(this_plot.iso_crvs, this_plot.num_iso_read, first_ptr, first_invert);
		first_n = this_plot.num_iso_read;
		}
		if (second_ptr != null)
		{
		iso_curve icrvs = this_plot.iso_crvs;
		iso_curve icrvs2;
		int i;
		/* advance until second part */
		for (i = 0; i < this_plot.num_iso_read; i++)
			icrvs = icrvs.next;
		/* count the number of scans of second part */
		for (i = 0, icrvs2 = icrvs; icrvs2; icrvs2 = icrvs2.next)
			i++;
		if (i > 0)
		{
			second_n = i;
			GlobalMembersPm3d.pm3d_rearrange_part(icrvs, i, second_ptr, second_invert);
		}
		else
		{
			second_ptr = (GlobalMembersMouse.struct iso_curve * *) 0;
		}
		}
	}

/* Set flag plot_has_palette to TRUE if there is any element on the graph
 * which requires palette of continuous colors.
 */

	public static void set_plot_with_palette(int plot_num, int plot_mode)
	{
		surface_points this_3dplot = GlobalMembersPlot3d.first_3dplot;
		curve_points this_2dplot = GlobalMembersPlot2d.first_plot;
		int surface = 0;
		text_label this_label = GlobalMembersGadgets.first_label;

		plot_has_palette = true;
		/* Is pm3d switched on globally? */
		if (pm3d.implicit == PM3D_IMPL_MODE.PM3D_IMPLICIT)
		return;

		/* Check 2D plots */
		if (plot_mode == MODE_PLOT_TYPE.MODE_PLOT.getValue())
		{
		while (this_2dplot != null)
		{
			if (this_2dplot.plot_style == PLOT_STYLE.IMAGE)
			return;
			if (this_2dplot.lp_properties.use_palette && this_2dplot.lp_properties.pm3d_color.type > DefineConstants.TC_RGB)
			return;
			if (this_2dplot.labels != null && this_2dplot.labels.textcolor.type >= DefineConstants.TC_CB)
			return;
			this_2dplot = this_2dplot.next;
		}
		}

		/* Check 3D plots */
		if (plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
		{
		/* Any surface 'with pm3d', 'with image' or 'with line|dot palette'? */
		while (surface++ < plot_num)
		{
			if (this_3dplot.plot_style == PLOT_STYLE.PM3DSURFACE)
			return;
			if (this_3dplot.plot_style == PLOT_STYLE.IMAGE)
			return;
			if (this_3dplot.lp_properties.use_palette)
			{
				int type = this_3dplot.lp_properties.pm3d_color.type;
			if (type == DefineConstants.TC_LT || type == DefineConstants.TC_LINESTYLE || type == DefineConstants.TC_RGB)
				/* don't return yet */
				;
			else
				/* TC_DEFAULT: splot x with line|lp|dot palette */
				return;
			}
			if (this_3dplot.labels != null && this_3dplot.labels.textcolor.type >= DefineConstants.TC_CB)
			return;
			this_3dplot = this_3dplot.next_sp;
		}
		}

		/* Any label with 'textcolor palette'? */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TC_USES_PALETTE(tctype) (tctype==TC_Z) || (tctype==TC_CB) || (tctype==TC_FRAC)
		for (; this_label != DefineConstants.NULL; this_label = this_label.next)
		{
		if ((this_label.textcolor.type == DefineConstants.TC_Z) || (this_label.textcolor.type == DefineConstants.TC_CB) || (this_label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		}
		/* Any of title, xlabel, ylabel, zlabel, ... with 'textcolor palette'? */
		if ((GlobalMembersGadgets.title.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersGadgets.title.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersGadgets.title.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_X_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.SECOND_Y_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if (plot_mode == MODE_PLOT_TYPE.MODE_SPLOT.getValue())
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_Z_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
		if ((GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_Z) || (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_CB) || (GlobalMembersAxis.axis_array[AXIS_INDEX.COLOR_AXIS.getValue()].label.textcolor.type == DefineConstants.TC_FRAC))
			return;
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef TC_USES_PALETTE

		/* Palette with continuous colors is not used. */
		plot_has_palette = false; // otherwise it stays TRUE
	}

	public static boolean is_plot_with_palette()
	{
		return plot_has_palette;
	}
	public static boolean is_plot_with_colorbox()
	{
		return plot_has_palette && (GlobalMembersGadgets.color_box.where != DefineConstants.SMCOLOR_BOX_NO);
	}



	/* eof pm3d.h */

	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#ifdef HIDDEN3D_VAR_PTSIZE // Needed for variable pointsize, but takes space
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FLAG_VERTEX_AS_UNDEFINED(v) do { (v).z = -2.0; } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VERTEX_IS_UNDEFINED(v) ((v).z == -2.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define V_EQUAL(a,b) ( GE(0.0, fabs((a)->x - (b)->x) + fabs((a)->y - (b)->y) + fabs((a)->z - (b)->z)) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOORD(v,xvar,yvar) { xvar = ((int)((v)->x * xscaler)) + xmiddle; yvar = ((int)((v)->y * yscaler)) + ymiddle; }
	///#ifndef LITE
	///#endif
	///#define PROGRAM "G N U P L O T"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_NUM_OR_TIME(fp, x, axis) do{ if (axis_array[axis].is_timedata) { char s[80]; putc('"', fp); gstrftime(s,80,axis_array[axis].timefmt,(double)(x)); fputs(conv_text(s), fp); putc('"', fp); } else { fprintf(fp,"%#g",x); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif



	/*
	  Global options for pm3d algorithm (to be accessed by set / show).
	*/

	public static pm3d_struct pm3d = new pm3d_struct("s", DefineConstants.PM3D_FLUSH_BEGIN, 0, DefineConstants.PM3D_SCANS_AUTOMATIC, DefineConstants.PM3D_CLIP_4IN, 0, PM3D_IMPL_MODE.PM3D_EXPLICIT, PM3D_WHICH_CORNERS2COLOR.PM3D_WHICHCORNER_MEAN, 1, 1);

	public static int allocated_quadrangles = 0;
	public static int current_quadrangle = 0;
	public static quadrangle quadrangles = (quadrangle*)0;

	/* Internal prototypes for this module */
	public static boolean plot_has_palette;

/*
 * Utility routines.
 */

/* Geometrical mean = pow( prod(x_i > 0) x_i, 1/N )
 * Sign of the result: result is positive if 3 or 4 x_i are positive,
 * it is negative if 3 or all 4 x_i are negative. Helps to splot surface
 * with all color coordinates negative.
 */
	public static double geomean4(double x1, double x2, double x3, double x4)
	{
	///#if 0
	//// /* return 0 if any of the number is negative */
	////    if (x1 <= 0) x1 = 1;
	////    if (x2 > 0) x1 *= x2;
	////    if (x3 > 0) x1 *= x3;
	////    if (x4 > 0) x1 *= x4;
	////    return pow(x1, 0.25);
	///#else
		/* honor signess, i.e. sign(geomean) = sign(prod(x_i)) */
		int neg = (x1 < 0) + (x2 < 0) + (x3 < 0) + (x4 < 0);
		x1 *= x2 * x3 * x4;
		if (x1 == 0)
			return 0;
		/* pow(x, 0.25) is slightly faster than sqrt(sqrt(x)) */
		x1 = Math.sqrt(Math.sqrt(Math.abs(x1)));
	///#if 0
	//// /* such a warning could be helpful, but under normal usage it is just an overhead */
	////    if (neg > 1 && interactive && notwarned) {
	////	    int notwarned = 1;  ... to be set on every new splot
	////	    if (notwarned)
	////		int_warn(NO_CARET, "corners2color geomean with negative data points");
	////	    notwarned = 0;
	////    }
	///#endif
		return (neg <= 2) ? x1 : -x1;
	///#endif
	}

/* Median: sort values, and then: for N odd, it is the middle value; for N even,
 * it is mean of the two middle values.
 */
	public static double median4(double x1, double x2, double x3, double x4)
	{
		double tmp;
		/* sort them: x1 < x2 and x3 < x4 */
		if (x1 > x2)
		{
			tmp = x2;
			x2 = x1;
			x1 = tmp;
		}
		if (x3 > x4)
		{
			tmp = x3;
			x3 = x4;
			x4 = tmp;
		}
		/* sum middle numbers */
		tmp = (x1 < x3) ? x3 : x1;
		tmp += (x2 < x4) ? x2 : x4;
		return tmp * 0.5;
	}

/*
 * Now the implementation of the pm3d (s)plotting mode
 *
 * Note: the input parameter at_which_z is char, but an old HP cc requires
 * ANSI C K&R routines with int only.
 */
	public static void pm3d_plot(surface_points this_plot, int at_which_z)
	{
		int j;
		int i;
		int i1;
		int ii;
		int ii1;
		int from;
		int curve;
		int scan;
		int up_to;
		int up_to_minus;
		int invert = 0;
		int go_over_pts;
		int max_pts;
		int are_ftriangles;
		int ftriangles_low_pt = -999;
		int ftriangles_high_pt = -999;
		iso_curve scanA;
		iso_curve scanB;
		coordinate pointsA;
		coordinate pointsB;
		iso_curve[] scan_array;
		int scan_array_n;
		double avgC;
		double gray;
		double cb1;
		double cb2;
		double cb3;
		double cb4;
		gpdPoint[] corners = new gpdPoint[4];
		int interp_i;
		int interp_j;
	///#ifdef EXTENDED_COLOR_SPECS
	//    gpiPoint icorners[4];
	///#endif
		gpdPoint[] bl_point = DefineConstants.NULL; // used for bilinear interpolation

		/* just a shortcut */
		boolean color_from_column = this_plot.pm3d_color_from_column;

		if (this_plot == DefineConstants.NULL)
		return;

		if (at_which_z != DefineConstants.PM3D_AT_BASE && at_which_z != DefineConstants.PM3D_AT_TOP && at_which_z != DefineConstants.PM3D_AT_SURFACE)
		return;

		/* return if the terminal does not support filled polygons */
		if (!GlobalMembersTerm.term.filled_polygon)
		return;

		switch (at_which_z)
		{
		case DefineConstants.PM3D_AT_BASE:
		corners[0].z = corners[1].z = corners[2].z = corners[3].z = GlobalMembersGraph3d.base_z;
		break;
		case DefineConstants.PM3D_AT_TOP:
		corners[0].z = corners[1].z = corners[2].z = corners[3].z = GlobalMembersGraph3d.ceiling_z;
		break;
		/* the 3rd possibility is surface, PM3D_AT_SURFACE, coded below */
		}

		scanA = this_plot.iso_crvs;
		curve = 0;

		GlobalMembersPm3d.pm3d_rearrange_scan_array(this_plot, scan_array, scan_array_n, invert, (GlobalMembersMouse.struct iso_curve * **) 0, (int) 0, (int) 0);

		interp_i = pm3d.interp_i;
		interp_j = pm3d.interp_j;

		if (interp_i <= 0 || interp_j <= 0)
		{
		/* Number of interpolations will be determined from desired number of points.
		   Search for number of scans and maximal number of points in a scan for points
		   which will be plotted (INRANGE). Then set interp_i,j so that number of points
		   will be a bit larger than |interp_i,j|.
		   If (interp_i,j==0) => set this number of points according to DEFAULT_OPTIMAL_NB_POINTS.
		   Ideally this should be comparable to the resulution of the output device, which
		   can hardly by done at this high level instead of the driver level.
		   */
		///#define DEFAULT_OPTIMAL_NB_POINTS 200
		int max_scan_pts = 0;
		int max_scans = 0;
		int pts;
		for (scan = 0; scan < this_plot.num_iso_read - 1; scan++)
		{
			scanA = scan_array[scan];
			pointsA = scanA.points;
			pts = 0;
			for (j = 0; j < scanA.p_count; j++)
			if (pointsA[j].type == coord_type.INRANGE)
				pts++;
			if (pts > 0)
			{
			max_scan_pts = ((max_scan_pts) > (pts) ? (max_scan_pts) : (pts));
			max_scans++;
			}
		}

		if (interp_i <= 0)
		{
			ii = (interp_i == 0) ? DefineConstants.DEFAULT_OPTIMAL_NB_POINTS : -interp_i;
			interp_i = Math.floor(ii / max_scan_pts) + 1;
		}
		if (interp_j <= 0)
		{
			ii = (interp_j == 0) ? DefineConstants.DEFAULT_OPTIMAL_NB_POINTS : -interp_j;
			interp_j = Math.floor(ii / max_scans) + 1;
		}
	///#if 0
	////	fprintf(stderr, "pm3d.interp_i=%i\t pm3d.interp_j=%i\n", pm3d.interp_i, pm3d.interp_j);
	////	fprintf(stderr, "INRANGE: max_scans=%i  max_scan_pts=%i\n", max_scans, max_scan_pts);
	////	fprintf(stderr, "seting interp_i=%i\t interp_j=%i => there will be %i and %i points\n",
	////		interp_i, interp_j, interp_i*max_scan_pts, interp_j*max_scans);
	///#endif
		}

		if (pm3d.direction == DefineConstants.PM3D_DEPTH)
		{

		for (scan = 0; scan < this_plot.num_iso_read - 1; scan++)
		{

			scanA = scan_array[scan];
			scanB = scan_array[scan + 1];

			are_ftriangles = pm3d.ftriangles && (scanA.p_count != scanB.p_count);
			if (are_ftriangles == 0)
			allocated_quadrangles += ((scanA.p_count) < (scanB.p_count) ? (scanA.p_count) : (scanB.p_count)) - 1;
			else
			{
			allocated_quadrangles += ((scanA.p_count) > (scanB.p_count) ? (scanA.p_count) : (scanB.p_count)) - 1;
			}
		}
		allocated_quadrangles *= (interp_i > 1) ? interp_i : 1;
		allocated_quadrangles *= (interp_j > 1) ? interp_j : 1;
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		quadrangles = (quadrangle)GlobalMembersAlloc.gp_realloc(quadrangles, allocated_quadrangles * sizeof(quadrangle), "pm3d_plot->quadrangles");
		/* DEBUG: fprintf(stderr, "allocated_quadrangles = %d\n", allocated_quadrangles); */
		}
		/* pm3d_rearrange_scan_array(this_plot, (struct iso_curve***)0, (int*)0, &scan_array, &invert); */

	///#if 0
	//// /* debugging: print scan_array */
	////    for (scan = 0; scan < this_plot->num_iso_read; scan++) {
	////	printf("**** SCAN=%d  points=%d\n", scan, scan_array[scan]->p_count);
	////    }
	///#endif

	///#if 0
	//// /* debugging: this loop prints properties of all scans */
	////    for (scan = 0; scan < this_plot->num_iso_read; scan++) {
	////	struct coordinate GPHUGE *points;
	////	scanA = scan_array[scan];
	////	printf("\n#IsoCurve = scan nb %d, %d points\n#x y z type(in,out,undef)\n", scan, scanA->p_count);
	////	for (i = 0, points = scanA->points; i < scanA->p_count; i++) {
	////	    printf("%g %g %g %c\n",
	////		   points[i].x, points[i].y, points[i].z, points[i].type == INRANGE ? 'i' : points[i].type == OUTRANGE ? 'o' : 'u');
	//// /* Note: INRANGE, OUTRANGE, UNDEFINED */
	////	}
	////    }
	////    printf("\n");
	///#endif

		/*
		 * if bilinear interpolation is enabled, allocate memory for the
		 * interpolated points here
		 */
		if (interp_i > 1 || interp_j > 1)
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		bl_point = (gpdPoint)GlobalMembersAlloc.gp_alloc(sizeof(gpdPoint) * (interp_i + 1), "bl-interp along scan");
		for (i1 = 0; i1 <= interp_i; i1++)
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			bl_point[i1] = (gpdPoint)GlobalMembersAlloc.gp_alloc(sizeof(gpdPoint) * (interp_j + 1), "bl-interp between scan");
		}

		/*
		 * this loop does the pm3d draw of joining two curves
		 *
		 * How the loop below works:
		 * - scanB = scan last read; scanA = the previous one
		 * - link the scan from A to B, then move B to A, then read B, then draw
		 */
		for (scan = 0; scan < this_plot.num_iso_read - 1; scan++)
		{
		scanA = scan_array[scan];
		scanB = scan_array[scan + 1];

		GlobalMembersFit.a((stderr,"\n#IsoCurveA = scan nb %d has %d points   ScanB has %d points\n", scan, scanA.p_count, scanB.p_count));

		pointsA = scanA.points;
		pointsB = scanB.points;
		/* if the number of points in both scans is not the same, then the
		 * starting index (offset) of scan B according to the flushing setting
		 * has to be determined
		 */
		from = 0; // default is pm3d.flush==PM3D_FLUSH_BEGIN
		if (pm3d.flush == DefineConstants.PM3D_FLUSH_END)
			from = Math.abs(scanA.p_count - scanB.p_count);
		else if (pm3d.flush == DefineConstants.PM3D_FLUSH_CENTER)
			from = Math.abs(scanA.p_count - scanB.p_count) / 2;
		/* find the minimal number of points in both scans */
		up_to = ((scanA.p_count) < (scanB.p_count) ? (scanA.p_count) : (scanB.p_count)) - 1;
		up_to_minus = up_to - 1; // calculate only once
		are_ftriangles = pm3d.ftriangles && (scanA.p_count != scanB.p_count);
		if (are_ftriangles == 0)
			go_over_pts = up_to;
		else
		{
			max_pts = ((scanA.p_count) > (scanB.p_count) ? (scanA.p_count) : (scanB.p_count));
			go_over_pts = max_pts - 1;
			/* the j-subrange of quadrangles; in the remaing of the interval
			 * [0..up_to] the flushing triangles are to be drawn */
			ftriangles_low_pt = from;
			ftriangles_high_pt = from + up_to_minus;
		}
		/* Go over
		 *   - the minimal number of points from both scans, if only quadrangles.
		 *   - the maximal number of points from both scans if flush triangles
		 *     (the missing points in the scan of lower nb of points will be
		 *     duplicated from the begin/end points).
		 *
		 * Notice: if it would be once necessary to go over points in `backward'
		 * direction, then the loop body below would require to replace the data
		 * point indices `i' by `up_to-i' and `i+1' by `up_to-i-1'.
		 */
		for (j = 0; j < go_over_pts; j++)
		{
			/* Now i be the index of the scan with smaller number of points,
			 * ii of the scan with larger number of points. */
			if (are_ftriangles != 0 && (j < ftriangles_low_pt || j > ftriangles_high_pt))
			{
			i = (j <= ftriangles_low_pt) ? 0 : ftriangles_high_pt - from + 1;
			ii = j;
			i1 = i;
			ii1 = ii + 1;
			}
			else
			{
			int jj = are_ftriangles != 0 ? j - from : j;
			i = jj;
			if (DefineConstants.PM3D_SCANS_AUTOMATIC == pm3d.direction && invert != 0)
				i = up_to_minus - jj;
			ii = i + from;
			i1 = i + 1;
			ii1 = ii + 1;
			}
			/* From here, i is index to scan A, ii to scan B */
			if (scanA.p_count > scanB.p_count)
			{
				int itmp = i;
			i = ii;
			ii = itmp;
			itmp = i1;
			i1 = ii1;
			ii1 = itmp;
			}

			GlobalMembersFit.a((stderr,"j=%i:  i=%i i1=%i  [%i]   ii=%i ii1=%i  [%i]\n", j,i,i1,scanA.p_count,ii,ii1,scanB.p_count));

			/* choose the clipping method */
			if (pm3d.clip == DefineConstants.PM3D_CLIP_4IN)
			{
			/* (1) all 4 points of the quadrangle must be in x and y range */
			if (!(pointsA[i].type == coord_type.INRANGE && pointsA[i1].type == coord_type.INRANGE && pointsB[ii].type == coord_type.INRANGE && pointsB[ii1].type == coord_type.INRANGE))
				continue;
			} // (pm3d.clip == PM3D_CLIP_1IN)
			else
			{
			/* (2) all 4 points of the quadrangle must be defined */
			if (pointsA[i].type == coord_type.UNDEFINED || pointsA[i1].type == coord_type.UNDEFINED || pointsB[ii].type == coord_type.UNDEFINED || pointsB[ii1].type == coord_type.UNDEFINED)
				continue;
			/* and at least 1 point of the quadrangle must be in x and y range */
			if (pointsA[i].type == coord_type.OUTRANGE && pointsA[i1].type == coord_type.OUTRANGE && pointsB[ii].type == coord_type.OUTRANGE && pointsB[ii1].type == coord_type.OUTRANGE)
				continue;
			}

			if ((interp_i <= 1 && interp_j <= 1) || pm3d.direction == DefineConstants.PM3D_DEPTH)
			{
	///#ifdef EXTENDED_COLOR_SPECS
	//	      if (!supply_extended_color_specs) {
	///#endif
			/* Get the gray as the average of the corner z- or gray-positions
			   (note: log scale is already included). The average is calculated here
			   if there is no interpolation (including the "pm3d depthorder" option),
			   otherwise it is done for each interpolated quadrangle later.
			   I always wonder what is faster: d*0.25 or d/4? Someone knows? -- 0.25 (joze) */
			if (color_from_column)
			{
				/* color is set in plot3d.c:get_3ddata() */
				cb1 = pointsA[i].ylow;
				cb2 = pointsA[i1].ylow;
				cb3 = pointsB[ii].ylow;
				cb4 = pointsB[ii1].ylow;
			}
			else
			{
				cb1 = GlobalMembersPm3d.z2cb(pointsA[i].z);
				cb2 = GlobalMembersPm3d.z2cb(pointsA[i1].z);
				cb3 = GlobalMembersPm3d.z2cb(pointsB[ii].z);
				cb4 = GlobalMembersPm3d.z2cb(pointsB[ii1].z);
			}
			switch (pm3d.which_corner_color)
			{
				case PM3D_WHICHCORNER_MEAN:
					avgC = (cb1 + cb2 + cb3 + cb4) * 0.25;
					break;
				case PM3D_WHICHCORNER_GEOMEAN:
					avgC = GlobalMembersPm3d.geomean4(cb1, cb2, cb3, cb4);
					break;
				case PM3D_WHICHCORNER_MEDIAN:
					avgC = GlobalMembersPm3d.median4(cb1, cb2, cb3, cb4);
					break;
				case PM3D_WHICHCORNER_MIN:
					avgC = GlobalMembersPm3d.minimum4(cb1, cb2, cb3, cb4);
					break;
				case PM3D_WHICHCORNER_MAX:
					avgC = GlobalMembersPm3d.maximum4(cb1, cb2, cb3, cb4);
					break;
				case PM3D_WHICHCORNER_C1:
					avgC = cb1;
					break;
				case PM3D_WHICHCORNER_C2:
					avgC = cb2;
					break;
				case PM3D_WHICHCORNER_C3:
					avgC = cb3;
					break;
				case PM3D_WHICHCORNER_C4:
					avgC = cb4;
					break;
				default:
					GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "cannot be here");
					avgC = 0;
			}
			/* transform z value to gray, i.e. to interval [0,1] */
			gray = GlobalMembersPm3d.cb2gray(avgC);

			/* print the quadrangle with the given color */
			GlobalMembersFit.a((stderr, "averageColor %g\tgray=%g\tM %g %g L %g %g L %g %g L %g %g\n", avgC, gray, pointsA[i].x, pointsA[i].y, pointsB[ii].x, pointsB[ii].y, pointsB[ii1].x, pointsB[ii1].y, pointsA[i1].x, pointsA[i1].y));

			/* set the color */
			if (pm3d.direction != DefineConstants.PM3D_DEPTH)
				GlobalMembersColor.set_color(gray);
	///#ifdef EXTENDED_COLOR_SPECS
	//	      }
	///#endif
			}

			corners[0].x = pointsA[i].x;
			corners[0].y = pointsA[i].y;
			corners[1].x = pointsB[ii].x;
			corners[1].y = pointsB[ii].y;
			corners[2].x = pointsB[ii1].x;
			corners[2].y = pointsB[ii1].y;
			corners[3].x = pointsA[i1].x;
			corners[3].y = pointsA[i1].y;

			if (interp_i > 1 || interp_j > 1 || at_which_z == DefineConstants.PM3D_AT_SURFACE)
			{
			/* always supply the z value if
			 * EXTENDED_COLOR_SPECS is defined
			 */
			corners[0].z = pointsA[i].z;
			corners[1].z = pointsB[ii].z;
			corners[2].z = pointsB[ii1].z;
			corners[3].z = pointsA[i1].z;
			if (color_from_column)
			{
				corners[0].c = pointsA[i].ylow;
				corners[1].c = pointsB[ii].ylow;
				corners[2].c = pointsB[ii1].ylow;
				corners[3].c = pointsA[i1].ylow;
			}
			}
	///#ifdef EXTENDED_COLOR_SPECS
	//	    if (supply_extended_color_specs) {
	//		if (color_from_column) {
	//		    icorners[0].z = pointsA[i].CRD_COLOR;
	//		    icorners[1].z = pointsB[ii].CRD_COLOR;
	//		    icorners[2].z = pointsB[ii1].CRD_COLOR;
	//		    icorners[3].z = pointsA[i1].CRD_COLOR;
	//		} else {
	// /* the target wants z and gray value */
	//		    icorners[0].z = pointsA[i].z;
	//		    icorners[1].z = pointsB[ii].z;
	//		    icorners[2].z = pointsB[ii1].z;
	//		    icorners[3].z = pointsA[i1].z;
	//		}
	//		for (i = 0; i < 4; i++) {
	//		    icorners[i].spec.gray =
	//			cb2gray( color_from_column ? icorners[i].z : z2cb(icorners[i].z) );
	//		}
	//	    }
	//	    if (pm3d.direction == PM3D_DEPTH) {
	// /* copy quadrangle */
	//		quadrangle* qp = quadrangles + current_quadrangle;
	//		memcpy(qp->corners, corners, 4 * sizeof (gpdPoint));
	//		qp->gray = gray;
	//		for (i = 0; i < 4; i++) {
	//		    qp->icorners[i].z = icorners[i].z;
	//		    qp->icorners[i].spec.gray = icorners[i].spec.gray;
	//		}
	//		current_quadrangle++;
	//
	//	    } else
	//    		filled_quadrangle(corners, icorners);
	///#else
			if (interp_i > 1 || interp_j > 1)
			{
			/* Interpolation is enabled.
			 * interp_i is the # of points along scan lines
			 * interp_j is the # of points between scan lines
			 * Algorithm is to first sample i points along the scan lines
			 * defined by corners[3],corners[0] and corners[2],corners[1]. */
			int j1;
			for (i1 = 0; i1 <= interp_i; i1++)
			{
				bl_point[i1][0].x = ((corners[3].x - corners[0].x) / interp_i) * i1 + corners[0].x;
				bl_point[i1][interp_j].x = ((corners[2].x - corners[1].x) / interp_i) * i1 + corners[1].x;
				bl_point[i1][0].y = ((corners[3].y - corners[0].y) / interp_i) * i1 + corners[0].y;
				bl_point[i1][interp_j].y = ((corners[2].y - corners[1].y) / interp_i) * i1 + corners[1].y;
				bl_point[i1][0].z = ((corners[3].z - corners[0].z) / interp_i) * i1 + corners[0].z;
				bl_point[i1][interp_j].z = ((corners[2].z - corners[1].z) / interp_i) * i1 + corners[1].z;
				if (color_from_column)
				{
				bl_point[i1][0].c = ((corners[3].c - corners[0].c) / interp_i) * i1 + corners[0].c;
				bl_point[i1][interp_j].c = ((corners[2].c - corners[1].c) / interp_i) * i1 + corners[1].c;
				}
				/* Next we sample j points between each of the new points
				 * created in the previous step (this samples between
				 * scan lines) in the same manner. */
				for (j1 = 1; j1 < interp_j; j1++)
				{
				bl_point[i1][j1].x = ((bl_point[i1][interp_j].x - bl_point[i1][0].x) / interp_j) * j1 + bl_point[i1][0].x;
				bl_point[i1][j1].y = ((bl_point[i1][interp_j].y - bl_point[i1][0].y) / interp_j) * j1 + bl_point[i1][0].y;
				bl_point[i1][j1].z = ((bl_point[i1][interp_j].z - bl_point[i1][0].z) / interp_j) * j1 + bl_point[i1][0].z;
				if (color_from_column)
					bl_point[i1][j1].c = ((bl_point[i1][interp_j].c - bl_point[i1][0].c) / interp_j) * j1 + bl_point[i1][0].c;
				}
			}
			/* Once all points are created, move them into an appropriate
			 * structure and call set_color on each to retrieve the
			 * correct color mapping for this new sub-sampled quadrangle. */
			for (i1 = 0; i1 < interp_i; i1++)
			{
				for (j1 = 0; j1 < interp_j; j1++)
				{
				corners[0].x = bl_point[i1][j1].x;
				corners[0].y = bl_point[i1][j1].y;
				corners[0].z = bl_point[i1][j1].z;
				corners[1].x = bl_point[i1 + 1][j1].x;
				corners[1].y = bl_point[i1 + 1][j1].y;
				corners[1].z = bl_point[i1 + 1][j1].z;
				corners[2].x = bl_point[i1 + 1][j1 + 1].x;
				corners[2].y = bl_point[i1 + 1][j1 + 1].y;
				corners[2].z = bl_point[i1 + 1][j1 + 1].z;
				corners[3].x = bl_point[i1][j1 + 1].x;
				corners[3].y = bl_point[i1][j1 + 1].y;
				corners[3].z = bl_point[i1][j1 + 1].z;
				if (color_from_column)
				{
					corners[0].c = bl_point[i1][j1].c;
					corners[1].c = bl_point[i1 + 1][j1].c;
					corners[2].c = bl_point[i1 + 1][j1 + 1].c;
					corners[3].c = bl_point[i1][j1 + 1].c;
				}

				GlobalMembersFit.a((stderr,"(%g,%g),(%g,%g),(%g,%g),(%g,%g)\n", corners[0].x, corners[0].y, corners[1].x, corners[1].y, corners[2].x, corners[2].y, corners[3].x, corners[3].y));

				/* If the colors are given separately, we already loaded them above */
				if (!color_from_column)
				{
					cb1 = GlobalMembersPm3d.z2cb(corners[0].z);
					cb2 = GlobalMembersPm3d.z2cb(corners[1].z);
					cb3 = GlobalMembersPm3d.z2cb(corners[2].z);
					cb4 = GlobalMembersPm3d.z2cb(corners[3].z);
				}
				else
				{
					cb1 = corners[0].c;
					cb2 = corners[1].c;
					cb3 = corners[2].c;
					cb4 = corners[3].c;
				}
				switch (pm3d.which_corner_color)
				{
					case PM3D_WHICHCORNER_MEAN:
						avgC = (cb1 + cb2 + cb3 + cb4) * 0.25;
						break;
					case PM3D_WHICHCORNER_GEOMEAN:
						avgC = GlobalMembersPm3d.geomean4(cb1, cb2, cb3, cb4);
						break;
					case PM3D_WHICHCORNER_MEDIAN:
						avgC = GlobalMembersPm3d.median4(cb1, cb2, cb3, cb4);
						break;
					case PM3D_WHICHCORNER_MIN:
						avgC = GlobalMembersPm3d.minimum4(cb1, cb2, cb3, cb4);
						break;
					case PM3D_WHICHCORNER_MAX:
						avgC = GlobalMembersPm3d.maximum4(cb1, cb2, cb3, cb4);
						break;
					case PM3D_WHICHCORNER_C1:
						avgC = cb1;
						break;
					case PM3D_WHICHCORNER_C2:
						avgC = cb2;
						break;
					case PM3D_WHICHCORNER_C3:
						avgC = cb3;
						break;
					case PM3D_WHICHCORNER_C4:
						avgC = cb4;
						break;
					default:
						GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "cannot be here");
						avgC = 0;
				}
				/* transform z value to gray, i.e. to interval [0,1] */
				gray = GlobalMembersPm3d.cb2gray(avgC);
				if (pm3d.direction != DefineConstants.PM3D_DEPTH)
				{
					GlobalMembersColor.set_color(gray);
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: filled_quadrangle(corners);
					GlobalMembersColor.filled_quadrangle(new gpdPoint(corners));
				}
				else
				{
					/* copy quadrangle */
					quadrangle qp = quadrangles + current_quadrangle;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
					memcpy(qp.corners, corners, 4 * sizeof(gpdPoint));
					qp.gray = gray;
					current_quadrangle++;
				}
				}
			}
			} // thus (interp_i == 1 && interp_j == 1)
			else
			{
			if (pm3d.direction != DefineConstants.PM3D_DEPTH)
			{
//C++ TO JAVA CONVERTER WARNING: The following line was determined to be a copy constructor call - this should be verified and a copy constructor should be created if it does not yet exist:
//ORIGINAL LINE: filled_quadrangle(corners);
				GlobalMembersColor.filled_quadrangle(new gpdPoint(corners));
			}
			else
			{
				/* copy quadrangle */
				quadrangle qp = quadrangles + current_quadrangle;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				memcpy(qp.corners, corners, 4 * sizeof(gpdPoint));
				qp.gray = gray;
				current_quadrangle++;
			}
			} // interpolate between points
	///#endif
		} // loop quadrangles over points of two subsequent scans
		} // loop over scans

		if (bl_point != null)
		{
		for (i1 = 0; i1 <= interp_i; i1++)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(bl_point[i1]);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(bl_point);
		}
		/* free memory allocated by scan_array */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(scan_array);
	} // end of pm3d splotting mode

/* Display an error message for the routine get_pm3d_at_option() below.
 */

	public static void pm3d_option_at_error()
	{
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "parameter to `pm3d at` requires combination of up to 6 characters b,s,t\n\t(drawing at bottom, surface, top)");
	}

/*
 * Rearrange...
 */
	public static void pm3d_rearrange_part(iso_curve src, int len, iso_curve[][] dest, int invert)
	{
		iso_curve scanA;
		iso_curve scanB;
		iso_curve[] scan_array;
		int i;
		int scan;
		int invert_order = 0;

		/* loop over scans in one surface
		   Scans are linked from this_plot->iso_crvs in the opposite order than
		   they are in the datafile.
		   Therefore it is necessary to make vector scan_array of iso_curves.
		   Scans are sorted in scan_array according to pm3d.direction (this can
		   be PM3D_SCANS_FORWARD or PM3D_SCANS_BACKWARD).
		 */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		scan_array = dest = GlobalMembersAlloc.gp_alloc(len * sizeof(scanA), "pm3d scan array");

		if (pm3d.direction == DefineConstants.PM3D_SCANS_AUTOMATIC)
		{
		int cnt;
		int len2 = len;
		boolean exit_outer_loop = false;

		for (scanA = src; scanA && 0 == exit_outer_loop; scanA = scanA.next, len2--)
		{

			int from;
			int i;
			vertex vA = new vertex();
			vertex vA2 = new vertex();

			if ((cnt = scanA.p_count - 1) <= 0)
			continue;

			/* ordering within one scan */
			for (from = 0; from <= cnt; from++) // find 1st non-undefined point
			if (scanA.points[from].type != coord_type.UNDEFINED)
			{
				GlobalMembersUtil3d.map3d_xyz(scanA.points[from].x, scanA.points[from].y, 0, vA);
				break;
			}
			for (i = cnt; i > from; i--) // find the last non-undefined point
			if (scanA.points[i].type != coord_type.UNDEFINED)
			{
				GlobalMembersUtil3d.map3d_xyz(scanA.points[i].x, scanA.points[i].y, 0, vA2);
				break;
			}

			if (i - from > cnt * 0.1)
			/* it is completely arbitrary to request at least
			 * 10% valid samples in this scan. (joze Jun-05-2002) */
			invert = (vA2.z > vA.z) ? 0 : 1;
			else
			continue; // all points were undefined, so check next scan


			/* check the z ordering between scans
			 * Find last scan. If this scan has all points undefined,
			 * find last but one scan, an so on. */

			for (; len2 >= 3 && !exit_outer_loop; len2--)
			{
			for (scanB = scanA.next, i = len2 - 2; i && scanB != null; i--)
				scanB = scanB.next; // skip over to last scan
			if (scanB != null && scanB.p_count != 0)
			{
				vertex vB = new vertex();
				for (i = from ; i < scanB.p_count; i++) // we compare vA.z with vB.z
				{
					   /* find 1st non-undefined point */
				if (scanB.points[i].type != coord_type.UNDEFINED)
				{
					GlobalMembersUtil3d.map3d_xyz(scanB.points[i].x, scanB.points[i].y, 0, vB);
					invert_order = (vB.z > vA.z) ? 0 : 1;
					exit_outer_loop = true;
					break;
				}
				}
			}
			}
		}
		}

		GlobalMembersFit.a((stderr, "(pm3d_rearrange_part) invert       = %d\n", invert));
		GlobalMembersFit.a((stderr, "(pm3d_rearrange_part) invert_order = %d\n", invert_order));

		for (scanA = src, scan = len - 1, i = 0; scan >= 0; --scan, i++)
		{
		if (pm3d.direction == DefineConstants.PM3D_SCANS_AUTOMATIC)
		{
			switch (invert_order)
			{
			case 1:
			scan_array[scan] = scanA;
			break;
			case 0:
			default:
			scan_array[i] = scanA;
			break;
			}
		}
		else if (pm3d.direction == DefineConstants.PM3D_SCANS_FORWARD)
			scan_array[scan] = scanA;
		else // PM3D_SCANS_BACKWARD: i counts scans
			scan_array[i] = scanA;
		scanA = scanA.next;
		}
	}

/*
 *  Now the implementation of the filled color contour plot
*/
	public static void filled_color_contour_plot(surface_points this_plot, int contours_where)
	{
		double gray;
		gnuplot_contours cntr;

		/* just a shortcut */
		boolean color_from_column = this_plot.pm3d_color_from_column;

		if (this_plot == DefineConstants.NULL || this_plot.contours == DefineConstants.NULL)
		return;
		if (contours_where != en_contour_placement.CONTOUR_SRF.getValue() && contours_where != en_contour_placement.CONTOUR_BASE.getValue())
		return;

		/* return if the terminal does not support filled polygons */
		if (!GlobalMembersTerm.term.filled_polygon)
		return;

		/* TODO: CHECK FOR NUMBER OF POINTS IN CONTOUR: IF TOO SMALL, THEN IGNORE! */
		cntr = this_plot.contours;
		while (cntr != null)
		{
		System.out.printf("# Contour: points %i, z %g, label: %s\n", cntr.num_pts, cntr.coords[0].z, (cntr.label) ? cntr.label : "<no>");
		if (cntr.isNewLevel != 0)
		{
			System.out.print("\t...it isNewLevel\n");
			/* contour split across chunks */
			/* fprintf(gpoutfile, "\n# Contour %d, label: %s\n", number++, c->label); */
			/* What is the color? */
			/* get the z-coordinate */
			/* transform contour z-coordinate value to gray, i.e. to interval [0,1] */
			if (color_from_column)
			gray = GlobalMembersPm3d.cb2gray(cntr.coords[0].ylow);
			else
			gray = GlobalMembersPm3d.cb2gray(GlobalMembersPm3d.z2cb(cntr.coords[0].z));
			GlobalMembersColor.set_color(gray);
		}
		/* draw one countour */
		if (contours_where == en_contour_placement.CONTOUR_SRF.getValue()) // at CONTOUR_SRF
			GlobalMembersColor.filled_polygon_3dcoords(cntr.num_pts, cntr.coords);
		else // at CONTOUR_BASE
			GlobalMembersColor.filled_polygon_3dcoords_zfixed(cntr.num_pts, cntr.coords, GlobalMembersGraph3d.base_z);
		/* next contour */
		cntr = cntr.next;
		}
	} // end of filled color contour plot splot mode


	/* Minimum of 4 numbers.
	 */
	public static double minimum4(double x1, double x2, double x3, double x4)
	{
		x1 = ((x1) < (x2) ? (x1) : (x2));
		x3 = ((x3) < (x4) ? (x3) : (x4));
		return ((x1) < (x3) ? (x1) : (x3));
	}


	/* Maximum of 4 numbers.
	 */
	public static double maximum4(double x1, double x2, double x3, double x4)
	{
		x1 = ((x1) > (x2) ? (x1) : (x2));
		x3 = ((x3) > (x4) ? (x3) : (x4));
		return ((x1) > (x3) ? (x1) : (x3));
	}

	public static int compare_quadrangles(Object v1, Object v2)
	{
		final quadrangle q1 = (quadrangle)v1;
		final quadrangle q2 = (quadrangle)v2;

		if (q1.z > q2.z)
		return 1;
		else if (q1.z < q2.z)
		return -1;
		else
		return 0;
	}
}