package com.addiPlot.gnuplot;

public class GlobalMembersTerm
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: term.c,v 1.184.2.7 2010/02/18 04:34:49 sfeam Exp $");
	}
	///#endif

	/* GNUPLOT - term.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	 /* This module is responsible for looking after the terminal
	  * drivers at the lowest level. Only this module (should)
	  * know about all the various rules about interpreting
	  * the terminal capabilities exported by the terminal
	  * drivers in the table.
	  *
	  * Note that, as far as this module is concerned, a
	  * terminal session lasts only until _either_ terminal
	  * or output file changes. Before either is changed,
	  * the terminal is shut down.
	  *
	  * Entry points : (see also term/README)
	  *
	  * term_set_output() : called when  set output  invoked
	  *
	  * term_initialise()  : optional. Prepare the terminal for first
	  *                use. It protects itself against subsequent calls.
	  *
	  * term_start_plot() : called at start of graph output. Calls term_init
	  *                     if necessary
	  *
	  * term_apply_lp_properties() : apply linewidth settings
	  *
	  * term_end_plot() : called at the end of a plot
	  *
	  * term_reset() : called during int_error handling, to shut
	  *                terminal down cleanly
	  *
	  * term_start_multiplot() : called by   set multiplot
	  *
	  * term_end_multiplot() : called by  set nomultiplot
	  *
	  * term_check_multiplot_okay() : called just before an interactive
	  *                        prompt is issued while in multiplot mode,
	  *                        to allow terminal to suspend if necessary,
	  *                        Raises an error if interactive multiplot
	  *                       is not supported.
	  */

	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#ifdef HAVE_CONFIG_H
	///#endif
	///#define TC_DEFAULT 0
	///#define TC_LT 1
	///#define TC_LINESTYLE 2
	///#define TC_RGB 3
	///#define TC_CB 4
	///#define TC_FRAC 5
	///#define TC_Z 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_COLORSPEC {TC_DEFAULT, 0, 0.0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define BLACK_COLORSPEC {TC_LT, LT_BLACK, 0.0}
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#define STACK_DEPTH 100
	///#define MAX_AT_LEN 150
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
	///#ifdef __ZTC__
	///#else
	///#endif
	///#ifdef APOLLO
	///#endif
	///#define SMPAL_NEGATIVE 'n'
	///#define SMPAL_POSITIVE 'p'
	///#ifdef EXTENDED_COLOR_SPECS
	///#endif
	///#ifdef EXTENDED_COLOR_SPECS
	///#else
	///#endif
	///#if defined(PIPE_IPC) || defined(WIN_IPC)
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#define LT_AXIS (-1)
	///#define LT_BLACK (-2)
	///#define LT_NODRAW (-3)
	///#define LT_BACKGROUND (-4)
	///#define LT_UNDEFINED (-5)
	///#define LT_COLORFROMCOLUMN (-6)
	///#define LT_DEFAULT (-7)
	///#define TEXT_VERTICAL (-270)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_LP_STYLE_TYPE {0, -2, 0, 0, 1.0, PTSZ_DEFAULT, FALSE, DEFAULT_COLORSPEC}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FS_OPAQUE (FS_SOLID + (100<<4))
	///#define TERM_CAN_MULTIPLOT 1
	///#define TERM_CANNOT_MULTIPLOT 2
	///#define TERM_BINARY 4
	///#define TERM_INIT_ON_REPLOT 8
	///#define TERM_IS_POSTSCRIPT 16
	///#define TERM_ENHANCED_TEXT 32
	///#define TERM_NO_OUTPUTFILE 64
	///#define TERM_CAN_CLIP 128
	///#define TERM_CAN_DASH 256
	///#define TERM_ALPHA_CHANNEL 512
	///#define TERM_MONOCHROME 1024
	///#define TERM_LINEWIDTH 2048
	///#ifdef WIN16
	///#else
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef WIN16
	///#define termentry TERMENTRY far
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define termentry TERMENTRY
	///#endif
	///#ifdef PIPE_IPC
	///#endif // PIPE_IPC 
	///#if 0 // UNUSED
	///#endif // UNUSED 
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifdef LINUXVGA
	///#endif
	///#ifdef PC
	///#endif
	///#ifdef VMS
	///#endif
	///#ifdef OS2
	///#ifdef USE_MOUSE
	///#endif
	///#endif

	///#define PTSZ_DEFAULT (-2)
	///#define PTSZ_VARIABLE (-3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_LABELSTRUCT {NULL, -2, {character, character, character, 0.0, 0.0, 0.0}, CENTRE, 0, 0, NULL, NULL, {TC_LT, -2, 0.0}, DEFAULT_LP_STYLE_TYPE, {character, character, character, 0.0, 0.0, 0.0}, FALSE }
	///#ifdef EAM_OBJECTS
	///#define OBJ_RECTANGLE (1)
	///#define OBJ_CIRCLE (2)
	///#define OBJ_ELLIPSE (3)
	///#define OBJ_POLYGON (4)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define EMPTY_FILLEDCURVES_OPTS { 0, 0, 0.0, 0.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_HISTOGRAM_STYLE { HT_NONE, 2, 1, 0.0, 0.0, LT_UNDEFINED, LT_UNDEFINED, 0, NULL, EMPTY_LABELSTRUCT }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEYBOX_LP { 0, LT_NODRAW, 0, 1.0, 1.0, 0 }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_POSITION { graph, graph, graph, 0.9, 0.9, 0. }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_KEY_PROPS { TRUE, GPKEY_AUTO_INTERIOR_LRTBC, GPKEY_RMARGIN, DEFAULT_KEY_POSITION, JUST_TOP, RIGHT, GPKEY_RIGHT, GPKEY_VERTICAL, 4.0, 1.0, 0.0, 0.0, FILENAME_KEYTITLES, FALSE, FALSE, TRUE, DEFAULT_KEYBOX_LP, "", NULL, {TC_LT, LT_BLACK, 0.0} }
	///#define SMCOLOR_BOX_NO 'n'
	///#define SMCOLOR_BOX_DEFAULT 'd'
	///#define SMCOLOR_BOX_USER 'u'
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_MARGIN_POSITION {character, character, character, -1, -1, -1}
	///#ifdef EAM_OBJECTS
	///#endif
	///#ifndef DEFAULT_TIMESTAMP_FORMAT
	///#define DEFAULT_TIMESTAMP_FORMAT "%a %b %d %H:%M:%S %Y"
	///#endif
	///#define ZERO 1e-8
	///#define SOUTH 1
	///#define WEST 2
	///#define NORTH 4
	///#define EAST 8
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_east (draw_border & EAST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_west (draw_border & WEST)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_south (draw_border & SOUTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_north (draw_border & NORTH)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define border_complete ((draw_border & 15) == 15)
	///#define SAMPLES 100
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ALMOST2D ( !is_3d_plot || ( fabs(fmod(surface_rot_z,90.0))<0.1 && (surface_rot_x>179.9 || surface_rot_x<0.1) ) )
	///#ifdef VOLATILE_REFRESH
	///#else
	///#define refresh_ok FALSE
	///#endif
	///#define LAYER_BEHIND -1
	///#define LAYER_BACK 0
	///#define LAYER_FRONT 1
	///#define LAYER_PLOTLABELS 99
	///#ifdef EAM_OBJECTS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_RECTANGLE_STYLE { NULL, -1, 0, OBJ_RECTANGLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.rectangle = {0, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}, {0,0.,0.,0.}}} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_CIRCLE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.circle = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0., 360. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_ELLIPSE_STYLE { NULL, -1, 0, OBJ_CIRCLE, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BACKGROUND, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.ellipse = {1, {0,0.,0.,0.}, {0,0.,0.,0.}, 0. }} }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_POLYGON_STYLE { NULL, -1, 0, OBJ_POLYGON, {FS_SOLID, 100, 0, BLACK_COLORSPEC}, {1, LT_BLACK, 0, 0, 1.0, 0.0, FALSE, DEFAULT_COLORSPEC}, {.polygon = {0, NULL} } }
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#define FIRST_AXES 0
	///#define SECOND_AXES 4
	///#define NO_AXIS 99
	///#define AXIS_ARRAY_SIZE 11
	///#define NO_TICS 0
	///#define TICS_ON_BORDER 1
	///#define TICS_ON_AXIS 2
	///#define TICS_MASK 3
	///#define TICS_MIRROR 4
	///#if 0 // HBB 20010806 --- move GRID flags into axis struct
	////#define GRID_OFF    0
	////#define GRID_X      (1<<0)
	////#define GRID_Y      (1<<1)
	////#define GRID_Z      (1<<2)
	////#define GRID_X2     (1<<3)
	////#define GRID_Y2     (1<<4)
	////#define GRID_MX     (1<<5)
	////#define GRID_MY     (1<<6)
	////#define GRID_MZ     (1<<7)
	////#define GRID_MX2    (1<<8)
	////#define GRID_MY2    (1<<9)
	////#define GRID_CB     (1<<10)
	////#define GRID_MCB    (1<<11)
	///#endif // 0 
	///#define RANGE_WRITEBACK 1
	///#define RANGE_REVERSE 2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_TICDEF {TIC_COMPUTED, NULL, {TC_DEFAULT, 0, 0}, {NULL, {0,0}, FALSE}, { character, character, character, 0., 0., 0. }, FALSE }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_ZEROAXIS {0, -3, 0, 1.0, 1.0, 0}
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULT_AXIS_STRUCT { AUTOSCALE_BOTH, AUTOSCALE_BOTH, 0, FALSE, -10.0, 10.0, -10.0, 10.0, -10.0, 10.0, 0.0, 0.0, 0, 0, 0, 0, FALSE, 0.0, 0.0, 0, 1, DEF_FORMAT, TIMEFMT, NO_TICS, DEFAULT_AXIS_TICDEF, 0, FALSE, FALSE, MINI_DEFAULT, 10, 1.0, 0.5, TRUE, EMPTY_LABELSTRUCT, DEFAULT_AXIS_ZEROAXIS }
	///#define DEF_FORMAT "% g"
	///#define TIMEFMT "%d/%m/%y,%H:%M"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X_AXIS axis_array[x_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y_AXIS axis_array[y_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Z_AXIS axis_array[z_axis]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CB_AXIS axis_array[COLOR_AXIS]
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAP(axis, variable) (int) ((axis_array[axis].term_lower) + ((variable) - axis_array[axis].min) * axis_array[axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_MAPBACK(axis, pos) (((double)(pos)-axis_array[axis].term_lower)/axis_array[axis].term_scale + axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x(x) (int) ((axis_array[x_axis].term_lower) + ((x) - axis_array[x_axis].min) * axis_array[x_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y(y) (int) ((axis_array[y_axis].term_lower) + ((y) - axis_array[y_axis].min) * axis_array[y_axis].term_scale + 0.5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_SETSCALE(axis, out_low, out_high) axis_array[axis].term_scale = ((out_high) - (out_low)) / (axis_array[axis].max - axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_WRITEBACK(axis) do { axis *this = axis_array + axis; if (this->range_flags & RANGE_WRITEBACK) { if (this->autoscale & AUTOSCALE_MIN) this->set_min = this->min; if (this->autoscale & AUTOSCALE_MAX) this->set_max = this->max; } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DO_LOG(axis,value) (log(value) / axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UNDO_LOG(axis,value) exp((value) * axis_array[axis].log_base)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_LOG_VALUE(axis,value) (axis_array[axis].log ? (log(value) / axis_array[axis].log_base) : (value))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_DE_LOG_VALUE(axis,coordinate) (axis_array[axis].log ? exp((coordinate) * axis_array[axis].log_base): (coordinate))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT3D(axis, islog_override, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; if ((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE && this->set_max < this->set_min) { this->min = this->set_max; this->max = this->set_min; } else { this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; } if (islog_override) { this->log = 0; this->base = 1; this->log_base = 0; } else { this->log_base = this->log ? log(this->base) : 0; } this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE : this->set_min; this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE : this->set_max; this->log_base = this->log ? log(this->base) : 0; this->data_min = VERYLARGE; this->data_max = -VERYLARGE; } while(0)
	///#ifdef VOLATILE_REFRESH
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_INIT2D_REFRESH(axis, infinite) do { axis *this = axis_array + axis; this->autoscale = this->set_autoscale; this->min = (infinite && (this->set_autoscale & AUTOSCALE_MIN)) ? VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_min) / axis_array[axis].log_base) : (this->set_min)); this->max = (infinite && (this->set_autoscale & AUTOSCALE_MAX)) ? -VERYLARGE*1e-3 : (axis_array[axis].log ? (log(this->set_max) / axis_array[axis].log_base) : (this->set_max)); this->log_base = this->log ? log(this->base) : 0; } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_UPDATE2D_REFRESH(axis) do { axis *this_axis = axis_array + axis; if ((this_axis->set_autoscale & AUTOSCALE_MIN) == 0) this_axis->min = (axis_array[axis].log ? (log(this_axis->set_min) / axis_array[axis].log_base) : (this_axis->set_min)); if ((this_axis->set_autoscale & AUTOSCALE_MAX) == 0) this_axis->max = (axis_array[axis].log ? (log(this_axis->set_max) / axis_array[axis].log_base) : (this_axis->set_max)); } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_REVERSE(axis) do { axis *this = axis_array + axis; if (((this->autoscale & AUTOSCALE_BOTH) == AUTOSCALE_NONE) && (this->max < this->min)) { double temp = this->min; this->min = this->max; this->max = temp; this->range_is_reverted = 1; } else this->range_is_reverted = (this->range_flags & RANGE_REVERSE); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MIN(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].max : axis_array[axis].min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ACTUAL_MAX(axis) (axis_array[axis].range_flags & RANGE_REVERSE ? axis_array[axis].min : axis_array[axis].max)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SAVE_WRITEBACK_ALL_AXES do { AXIS_INDEX axis; for (axis = 0; axis < AXIS_ARRAY_SIZE; axis++) if(axis_array[axis].range_flags & RANGE_WRITEBACK) { set_writeback_min(axis); set_writeback_max(axis); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_RANGE(axis) do { if (equals(c_token, "[")) { c_token++; axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PARSE_NAMED_RANGE(axis, dummy_token) do { if (equals(c_token, "[")) { c_token++; if (isletter(c_token)) { if (equals(c_token + 1, "=")) { dummy_token = c_token; c_token += 2; } } axis_array[axis].autoscale = load_range(axis, &axis_array[axis].min, &axis_array[axis].max, axis_array[axis].autoscale); if (!equals(c_token, "]")) int_error(c_token, "']' expected"); c_token++; } } while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUMBER_OR_TIME(store,axes,axis) do { if (((axes) >= 0) && (axis_array[(axes)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GET_NUM_OR_TIME(store,axis) do { (store) = 0; do { if (((FIRST_AXES) >= 0) && (axis_array[(FIRST_AXES)+(axis)].is_timedata) && (isstring(c_token) || type_udv(c_token)==STRING)) { struct tm tm; char *ss = try_to_get_string(); if (gstrptime(ss,axis_array[axis].timefmt,&tm)) (store) = (double) gtimegm(&tm); free(ss); } else { (store) = real_expression(); } } while(0); } while (0);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { TYPE = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { TYPE = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; TYPE = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (TYPE != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { TYPE = OUTRANGE; OUT_ACTION; } } } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COLOR_STORE_WITH_LOG_AND_UPDATE_RANGE(STORE, VALUE, TYPE, axis, NOAUTOSCALE, OUT_ACTION, UNDEF_ACTION) { coord_type c_type_tmp = TYPE; do { if (axis == NO_AXIS) break; if (! (VALUE > -VERYLARGE && VALUE < VERYLARGE)) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } if (axis_array[axis].log) { if (VALUE<0.0) { c_type_tmp = UNDEFINED; UNDEF_ACTION; break; } else if (VALUE == 0.0) { STORE = -VERYLARGE; c_type_tmp = OUTRANGE; OUT_ACTION; break; } else { STORE = (log(VALUE) / axis_array[axis].log_base); } } else STORE = VALUE; if (NOAUTOSCALE) break; if (c_type_tmp != INRANGE) break; if ((int)axis < 0) break; if ( VALUE<axis_array[axis].data_min ) axis_array[axis].data_min = VALUE; if ( VALUE<axis_array[axis].min ) { if (axis_array[axis].autoscale & AUTOSCALE_MIN) axis_array[axis].min = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; break; } } if ( VALUE>axis_array[axis].data_max ) axis_array[axis].data_max = VALUE; if ( VALUE>axis_array[axis].max ) { if (axis_array[axis].autoscale & AUTOSCALE_MAX) axis_array[axis].max = VALUE; else { c_type_tmp = OUTRANGE; OUT_ACTION; } } } while(0); }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NOOP ((void)0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INIT_AXIS_ARRAY(field, value) do { int tmp; for (tmp=0; tmp<AXIS_ARRAY_SIZE; tmp++) axis_array[tmp].field=(value); } while(0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define AXIS_ARRAY_INITIALIZER(value) { value, value, value, value, value, value, value, value, value, value, value }
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SET_DEFFORMAT(axis, flag_array) if (flag_array[axis]) { (void) strcpy(axis_array[axis].formatstring,DEF_FORMAT); axis_array[axis].format_is_numeric = 1; }
	///#define SIGNIF (0.01)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define NEED_PALETTE(plot) (PM3DSURFACE == (plot)->plot_style || PM3D_IMPLICIT == pm3d.implicit || 1 == (plot)->lp_properties.use_palette)
	///#define FNT_CHARS 96
	///#define FNT5X9 0
	///#define FNT5X9_VCHAR 11
	///#define FNT5X9_VBITS 9
	///#define FNT5X9_HCHAR 7
	///#define FNT5X9_HBITS 5
	///#define FNT9X17 1
	///#define FNT9X17_VCHAR 21
	///#define FNT9X17_VBITS 17
	///#define FNT9X17_HCHAR 13
	///#define FNT9X17_HBITS 9
	///#define FNT13X25 2
	///#define FNT13X25_VCHAR 31
	///#define FNT13X25_VBITS 25
	///#define FNT13X25_HCHAR 19
	///#define FNT13X25_HBITS 13
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
	///#ifdef USE_MOUSE
	///#define PAUSE_BUTTON1 001
	///#define PAUSE_BUTTON2 002
	///#define PAUSE_BUTTON3 004
	///#define PAUSE_CLICK 007
	///#define PAUSE_KEYSTROKE 010
	///#define PAUSE_WINCLOSE 020
	///#define PAUSE_ANY 077
	///#endif
	///#ifdef GP_MACROS
	///#endif
	///#ifndef STDOUT
	///#define STDOUT 1
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#endif                         // DJGPP 
	///#ifdef __TURBOC__
	///#ifndef _Windows
	///#endif                        // _Windows 
	///#endif                         // TURBOC 
	///#endif // MSDOS 
	///#ifdef _Windows
	///#define SET_CURSOR_WAIT SetCursor(LoadCursor((HINSTANCE) NULL, IDC_WAIT))
	///#define SET_CURSOR_ARROW SetCursor(LoadCursor((HINSTANCE) NULL, IDC_ARROW))
	///#else
	///#define SET_CURSOR_WAIT
	///#define SET_CURSOR_ARROW
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#else
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef X11
	///#endif
	///#ifdef _Windows
	///#endif
	///#ifdef WXWIDGETS
	///#endif
	///#ifdef USE_MOUSE
	///#else
	///#define bind_command()
	///#endif
	///#ifdef VOLATILE_REFRESH
	///#endif
	///#ifdef USE_MOUSE
	///#endif
	///#ifdef VMS // HBB 990829: used only on VMS
	///#endif
	/* $Id: driver.h,v 1.22 2006/10/08 21:11:08 sfeam Exp $ */

	/* GNUPLOT - driver.h */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/





	/* functions provided by term.c */

	public static void do_point(int x, int y, int number)
	{
		int htic;
		int vtic;
		TERMENTRY t = term;

		if (number < 0) // do dot
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y);
		return;
		}
		number %= DefineConstants.POINT_TYPES;
		/* should be in term_tbl[] in later version */
		htic = (term_pointsize * t.h_tic / 2);
		vtic = (term_pointsize * t.v_tic / 2);

		/* point types 1..4 are same as in postscript, png and x11
		   point types 5..6 are "similar"
		   (note that (number) equals (pointtype-1)
		*/
		switch (number)
		{
		case 4: // do diamond
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y);
		break;
		case 0: // do plus
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y + vtic);
		break;
		case 3: // do box
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y);
		break;
		case 1: // do X
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y - vtic);
		break;
		case 5: // do triangle
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y + (4 * vtic / 3));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - (4 * htic / 3), y - (2 * vtic / 3));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + (4 * htic / 3), y - (2 * vtic / 3));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y + (4 * vtic / 3));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y);
		break;
		case 2: // do star
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y - vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x - htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x - htic, y + vtic);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + htic, y - vtic);
		break;
		}
	}

/*
 * general point routine
 */
	public static void line_and_point(int x, int y, int number)
	{
		/* temporary(?) kludge to allow terminals with bad linetypes
		   to make nice marks */

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.linetype)(DefineConstants.NICE_LINE);
		GlobalMembersTerm.do_point(x, y, number);
	}

/* Dummy functions for unavailable features */
/* return success if they asked for default - this simplifies code
 * where param is passed as a param. Client can first pass it here,
 * and only if it fails do they have to see what was trying to be done
 */

/* change angle of text.  0 is horizontal left to right.
   * 1 is vertical bottom to top (90 deg rotate)
 */
	public static int null_text_angle(int ang)
	{
		return (ang == 0);
	}

/* change justification of text.
 * modes are LEFT (flush left), CENTRE (centred), RIGHT (flush right)
 */
	public static int null_justify_text(JUSTIFY just)
	{
		return (just == JUSTIFY.LEFT);
	}

/* Change scale of plot.
 * Parameters are x,y scaling factors for this plot.
 * Some terminals (eg latex) need to do scaling themselves.
 */
	public static int null_scale(double x, double y)
	{
		() x; // avoid -Wunused warning
		() y;
		return false; // can't be done
	}
	public static void options_null()
	{
		term_options = tangible.StringFunctions.changeCharacter(term_options, 0, '\0'); // we have no options
	}
	public static void UNKNOWN_null()
	{
	}
	/* static int set_font_null __PROTO((const char *s));     */	 /* unused */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_font_null NULL

//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern FILE *gpoutfile;
//C++ TO JAVA CONVERTER NOTE: 'extern' variable declarations are not required in Java:
	//extern struct TERMENTRY *term;

	/* for use by all drivers */
	///#ifndef NEXT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define sign(x) ((x) >= 0 ? 1 : -1)
	///#else
	// /* it seems that sign as macro causes some conflict with precompiled headers */
	//static int sign(int x)
	//{
	//    return x >= 0 ? 1 : -1;
	//}
	///#endif // NEXT 

	/* abs as macro is now uppercase, there are conflicts with a few C compilers
	   that have abs as macro, even though ANSI defines abs as function
	   (int abs(int)). Most calls to ABS in term/ could be changed to abs if
	   they use only int arguments and others to fabs, but for the time being,
	   all calls are done via the macro */
	///#ifndef ABS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ABS(x) ((x) >= 0 ? (x) : -(x))
	///#endif // ABS 

	///#define NICE_LINE 0
	///#define POINT_TYPES 6


	///#if defined(sun386) || defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef EAM_OBJECTS
	///#else
	///#define place_objects(listhead,layer,dimensions,clip_area) // void() 
	///#endif
	///#define H_FOUND 0
	///#define H_NOTFOUND 1
	///#define H_ERROR (-1)
	///#ifdef USE_MOUSE
	///#ifdef _MOUSE_C
	///#endif // _MOUSE_C 
	///#if 0
	///#endif
	///#if defined(_MOUSE_C)
	///#else
	///#endif
	///#endif
	///#ifdef OS2
	///#endif
	///#ifdef LINUXVGA
	///#endif // LINUXVGA 
	///#ifdef OS2
	///#endif
	/*
	 * $Id: term.h,v 1.42 2009/01/09 00:30:35 sfeam Exp $
	 */

	/* GNUPLOT - term.h */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * term.h: terminal support definitions
	 *   Edit this file depending on the set of terminals you wish to support.
	 * Comment out the terminal types that you don't want or don't have, and
	 * uncomment those that you want included. Be aware that some terminal
	 * types (eg, SUN, UNIXPLOT) will require changes in the makefile
	 * LIBS definition.
	 */

	/*
	 * first draft after all terminals are converted to new layout
	 * Stefan Bodewig Dec. 1995
	 */

	/*
	 * >>> CONFIGURATION OPTIONS FOLLOW <<<  PLEASE READ
	 *
	 * pslatex and epslatex support is now provided by the combination of
	 * post.trm and pslatex.trm.  You cannot build pslatex without post.
	 * Both drivers are selected by default, but you can disable them below.
	 */
	///#define GP_ENH_EST 1
	///#define POSTSCRIPT_DRIVER 1
	///#define PSLATEX_DRIVER 1

	///#if defined(PSLATEX_DRIVER) && !defined(POSTSCRIPT_DRIVER)
	///#define POSTSCRIPT_DRIVER
	///#endif


	/* Define SHORT_TERMLIST to select a few terminals. It is easier
	 * to define the macro and list desired terminals in this section.
	 * Sample configuration for a Unix workstation
	 */
	///#ifdef SHORT_TERMLIST
	///#include "dumb.trm"		// dumb terminal 
	//
	///#ifdef GP_ENH_EST
	///#include "estimate.trm"	// used for enhanced text processing 
	///#endif
	//
	///#ifdef POSTSCRIPT_DRIVER
	///#ifdef  PSLATEX_DRIVER
	///#undef PSLATEX_DRIVER
	///#endif
	///#include "post.trm"		// postscript 
	///#endif
	//
	///#ifdef X11
	///#include "x11.trm"		// X Window system 
	///#endif				// X11 
	///#ifdef OS2
	///#include "pm.trm"		// OS/2 Presentation Manager 
	///#endif
	///#ifdef _Windows
	///#include "win.trm"		// MS-Windows 
	///#endif
	///#else // include all applicable terminals not commented out 

	/****************************************************************************/
	/* Platform dependent part                                                  */
	/****************************************************************************/

	/* Amiga */
	///#ifdef AMIGA
	///#include "amiga.trm"
	///#endif


	/* Apple Macintosh */
	///#ifdef _Macintosh
	///#include "mac.trm"
	///#endif


	/* BeOS */
	///#ifdef __BEOS__
	///#include "be.trm"
	///#endif


	/****************************************************************************/
	/* MS-DOS and Windows */
	///#if defined(MSDOS) || defined(_Windows) || defined(DOS386)
	//
	// /* MSDOS with emx-gcc compiler */
	///#if defined(MSDOS) && defined(__EMX__)
	// /* Vesa-Cards */
	///#define EMXVESA
	///#include "emxvga.trm"
	///#endif				// MSDOS && EMX 
	//
	// /* MSDOS with djgpp compiler */
	///#if defined(DJGPP) && (!defined(DJSVGA) || (DJSVGA != 0))
	///#include "djsvga.trm"
	///#endif
	//
	// /* MSDOS with Zortech-C++ Compiler */
	///#ifdef __ZTC__
	///#include "fg.trm"
	///#endif
	//
	// /* All other Compilers */
	///#ifndef _Windows
	///#ifdef PC
	// /* uncomment the next line to include SuperVGA support */
	///#define BGI_NAME "svga256"	// the name of the SVGA.BGI for Borland C 
	// /* this also triggers the inclusion of Super VGA support */
	///#include "pc.trm"		// all PC types except MS WINDOWS 
	///#endif
	///#else				// _Windows 
	///#include "win.trm"		// MS-Windows 
	///#endif				// _Windows 
	///#endif // MSDOS || _Windows 
	/****************************************************************************/


	/* NeXT */
	///#ifdef NEXT
	///#include "next.trm"
	///#endif

	/* Apple Mac OS X Server 1.0 (Openstep Unix) */
	/* Apparently, Openstep code won't work on newer versions of
	 * MacOS X. If someone can fix this, and provide a proper
	 * configure test, let us know.
	 */
	/*
	 * #if defined(__APPLE__) && defined(__MACH__)
	 * # include "openstep.trm"
	 * #endif
	*/

	/* Apple Mac OS X */
	///#ifdef HAVE_LIBAQUATERM
	// /* support for AquaTerm.app */
	///#include "aquaterm.trm"
	///#endif

	/* OS/2 */
	///#ifdef OS2
	// /* presentation manager */
	///#include "pm.trm"
	///#ifdef EMXVESA
	// /* works with DOS and OS/2 (windowed/full screen) */
	///#include "emxvga.trm"
	///#endif
	///#endif // OS2 


	/***************************************************************************/
	/* Terminals for various Unix platforms                                    */
	/***************************************************************************/

	/* Apollo Graphics Primitive Resource */
	///#ifdef APOLLO
	// /* with resizeable windows */
	///#include "apollo.trm"
	///#ifdef GPR
	// /* with fixed windows */
	///#include "gpr.trm"
	///#endif
	///#endif // Apollo 

	/* Linux VGA */
	///#ifdef LINUXVGA
	///#include "linux.trm"
	//
	// /* Linux VGAGL */
	///#if defined(VGAGL) && defined (THREEDKIT)
	///#include "vgagl.trm"
	///#endif
	///#endif // LINUXVGA 

	/* MGR Window system */
	///#ifdef MGR
	///#include "mgr.trm"
	///#endif

	/* Redwood Graphics Interface Protocol UNIPLEX */
	/* Metafile, requires POSIX */
	///#ifdef RGIP
	///#include "rgip.trm"
	///#endif


	/* SCO CGI drivers */
	///#ifdef SCO
	///#include "cgi.trm"
	///#endif

	/* SunView */
	///#ifdef SUN
	///#include "sun.trm"
	///#endif


	/* VAX Windowing System requires UIS libraries */
	///#ifdef UIS
	///#include "vws.trm"
	///#endif

	/* AT&T Unix-PC */
	///#ifdef UNIXPC
	///#include "unixpc.trm"
	///#endif

	/****************************************************************************/
	/* Terminals not relevant for MSDOS, MS-Windows, Amiga             */
	///#if !(defined(MSDOS) || defined(_Windows) || defined(AMIGA))

	/* AED 512 and AED 767 graphics terminals */
	/* # include "aed.trm" */

	///#if defined(UNIXPLOT) || defined(GNUGRAPH)
	///#ifdef GNUGRAPH
	///#include "gnugraph.trm"
	///#else
	///#include "unixplot.trm"
	///#endif			// !GNUGRAPH 
	///#endif				// UNIXPLOT || GNUGRAPH 

	/* gpic for groff */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: gpic.trm,v 1.18 2006/07/21 02:35:46 sfeam Exp $
	 */

	/* GNUPLOT - gpic.trm */

	/*[
	 * Copyright 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 */

	/*
	 * This terminal driver supports:
	 *   The GPIC graphics language for groff
	 *
	 * AUTHOR
	 *  Sigfrid Lundberg
	 *
	 * send your comments or suggestions to (siglun@volterra.teorekol.lu.se).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(gpic)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void GPIC_options __PROTO((void));
	//TERM_PUBLIC void GPIC_init __PROTO((void));
	//TERM_PUBLIC void GPIC_graphics __PROTO((void));
	//TERM_PUBLIC void GPIC_text __PROTO((void));
	//TERM_PUBLIC void GPIC_linetype __PROTO((int linetype));
	//TERM_PUBLIC void GPIC_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void GPIC_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void GPIC_arrow __PROTO((unsigned int sx, unsigned int sy,
	//				     unsigned int ex, unsigned int ey,
	//				     int head));
	//TERM_PUBLIC void GPIC_put_text __PROTO((unsigned int x, unsigned int y,
	//					const char str[]));
	//TERM_PUBLIC int GPIC_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int GPIC_text_angle __PROTO((int ang));
	//TERM_PUBLIC void GPIC_reset __PROTO((void));
	///#define GPIC_DOTS_PER_INCH (300)
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define GPIC_XMAX (5*GPIC_DOTS_PER_INCH)
	///#define GPIC_YMAX (3*GPIC_DOTS_PER_INCH)
	//
	///#define GPIC_HTIC (5*GPIC_DOTS_PER_INCH/72)
	///#define GPIC_VTIC (5*GPIC_DOTS_PER_INCH/72)
	///#define GPIC_HCHAR (GPIC_DOTS_PER_INCH*53/10/72)
	///#define GPIC_VCHAR (GPIC_DOTS_PER_INCH*11/72)
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#define GPIC_PTS_PER_INCH (72.27)
	// /* dot size in pt */
	///#define GPIC_UNIT (GPIC_PTS_PER_INCH/GPIC_DOTS_PER_INCH)
	///#define GPIC_coord(x) ((float)x)/((float)GPIC_DOTS_PER_INCH)
	//
	//static void GPIC_close_line __PROTO((void));
	//static float GPIC_x, GPIC_y;
	//static unsigned int GPIC_ltype;
	//static enum JUSTIFY GPIC_justify = LEFT;
	//
	// /* for DOTS point style */
	//
	//static const char *GPIC_lines[] =
	//{
	//    "thickness 1.0",		// -2 border 
	//    "",				// -1 axes 
	//    "",				//  0 solid thin  
	//    "dotted",
	//    "dashed 0.05",		//  1 solid thick 
	//    "dashed 0.075",		//  2 solid Thick 
	//};
	//
	// /* number of linetypes above */
	///#define GPIC_NUMLINES (sizeof(GPIC_lines)/sizeof(char *))
	//
	//
	//static int GPIC_linecount = 0;	// number of points in line so far 
	//
	//
	//TERM_PUBLIC void
	//GPIC_options()
	//{
	//    float x, y;
	//    struct value a;
	//
	//    GPIC_x = 0;
	//    GPIC_y = 0;
	//
	//    if (!END_OF_COMMAND) {
	//	x = real(const_express(&a));
	//	if (!END_OF_COMMAND) {
	//	    y = real(const_express(&a));
	//	    GPIC_x = x;
	//	    GPIC_y = y;
	//	}
	//    }
	//    sprintf(term_options, "Origin is at (%f,%f)", GPIC_x, GPIC_y);
	//
	//}
	//
	//TERM_PUBLIC void
	//GPIC_init()
	//{
	//    GPIC_linetype(-1);
	//    fputs(".\\\"GNUPLOT: GROFF picture using the gpic preprocessor\n", gpoutfile);
	//}
	//
	//
	//
	//TERM_PUBLIC void
	//GPIC_graphics()
	//{
	//    register struct termentry *t = term;
	//
	//    fprintf(gpoutfile, ".PS %f %f\n", GPIC_coord(t->xmax),
	//	    GPIC_coord(t->ymax));
	//    fprintf(gpoutfile, "x=%f; y=%f\n", GPIC_x, GPIC_y);
	//}
	//
	//
	//TERM_PUBLIC void
	//GPIC_text()
	//{
	//    GPIC_close_line();
	//    fputs(".PE\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//GPIC_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype >= GPIC_NUMLINES - 2)
	//	linetype %= (GPIC_NUMLINES - 2);
	//    GPIC_ltype = linetype;
	//}
	//
	//static void
	//GPIC_close_line()
	//{
	//    if (GPIC_linecount > 0) {
	//	fputs("; reset linewid\n", gpoutfile);
	//	GPIC_linecount = 0;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//GPIC_move(unsigned int x, unsigned int y)
	//{
	//    GPIC_close_line();
	//    fprintf(gpoutfile, "move to (x+%f,y+%f)\n", GPIC_coord(x), GPIC_coord(y));
	//    GPIC_linecount = 1;
	//}
	//
	//
	//TERM_PUBLIC void
	//GPIC_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (GPIC_linecount == 1) {
	//	fprintf(gpoutfile, "line %s to (x+%f,y+%f)",
	//		GPIC_lines[GPIC_ltype + 2],
	//		GPIC_coord(ux), GPIC_coord(uy));
	//    } else {
	//	fprintf(gpoutfile, "
	// \\\n
	//   then to (x+%f,y+%f)",
	//		GPIC_coord(ux), GPIC_coord(uy));
	//    }
	//    GPIC_linecount++;
	//}
	//
	//
	//TERM_PUBLIC void
	//GPIC_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    GPIC_close_line();
	//    if (head) {
	//	fprintf(gpoutfile, "arrowhead=7; arrow from x+%f,y+%f to x+%f,y+%f\n",
	//		GPIC_coord(sx), GPIC_coord(sy), GPIC_coord(ex), GPIC_coord(ey));
	//    } else {
	//	fprintf(gpoutfile, "line from x+%f,y+%f to x+%f,y+%f\n",
	//		GPIC_coord(sx), GPIC_coord(sy), GPIC_coord(ex), GPIC_coord(ey));
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//GPIC_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    GPIC_close_line();
	//    fprintf(gpoutfile, "\"%s\" ", str);
	//    switch (GPIC_justify) {
	//    case LEFT:{
	//	    fputs("ljust ", gpoutfile);
	//	    break;
	//	}
	//    case CENTRE:{
	//	    fputs(" ", gpoutfile);
	//	    break;
	//	}
	//    case RIGHT:{
	//	    fputs("rjust ", gpoutfile);
	//	    break;
	//	}
	//    }
	//    fprintf(gpoutfile, "at x+%f,y+%f\n", GPIC_coord(x), GPIC_coord(y));
	//}
	//
	//
	//
	//TERM_PUBLIC int
	//GPIC_justify_text(enum JUSTIFY mode)
	//{
	//    GPIC_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//GPIC_text_angle(int ang)
	//{
	//    (void) ang;
	//    GPIC_close_line();
	//    return (FALSE);
	//}
	//
	//TERM_PUBLIC void
	//GPIC_reset()
	//{
	//    fflush(gpoutfile);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(gpic_driver)
	//    "gpic", "GPIC -- Produce graphs in groff using the gpic preprocessor",
	//    GPIC_XMAX, GPIC_YMAX, GPIC_VCHAR, GPIC_HCHAR,
	//    GPIC_VTIC, GPIC_HTIC, GPIC_options, GPIC_init, GPIC_reset,
	//    GPIC_text, null_scale, GPIC_graphics, GPIC_move, GPIC_vector,
	//    GPIC_linetype, GPIC_put_text, GPIC_text_angle,
	//    GPIC_justify_text, line_and_point, GPIC_arrow, set_font_null
	//TERM_TABLE_END(gpic_driver)
	///#undef LAST_TERM
	///#define LAST_TERM gpic_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(gpic)
	//"1 gpic",
	//"?commands set terminal gpic",
	//"?set terminal gpic",
	//"?set term gpic",
	//"?terminal gpic",
	//"?term gpic",
	//"?gpic",
	//" The `gpic` terminal driver generates GPIC graphs in the Free Software",
	//" Foundations's \"groff\" package.  The default size is 5 x 3 inches.  The only",
	//" option is the origin, which defaults to (0,0).",
	//"",
	//" Syntax:",
	//"       set terminal gpic {<x> <y>}",
	//"",
	//" where `x` and `y` are in inches.",
	//"",
	//" A simple graph can be formatted using",
	//"",
	//"       groff -p -mpic -Tps file.pic > file.ps.",
	//"",
	//" The output from pic can be pipe-lined into eqn, so it is possible to put",
	//" complex functions in a graph with the `set label` and `set {x/y}label`",
	//" commands.  For instance,",
	//"",
	//"       set ylab '@space 0 int from 0 to x alpha ( t ) roman d t@'",
	//"",
	//" will label the y axis with a nice integral if formatted with the command:",
	//"",
	//"       gpic filename.pic | geqn -d@@ -Tps | groff -m[macro-package] -Tps",
	//"           > filename.ps",
	//"",
	//" Figures made this way can be scaled to fit into a document.  The pic language",
	//" is easy to understand, so the graphs can be edited by hand if need be.  All",
	//" co-ordinates in the pic-file produced by `gnuplot` are given as x+gnuplotx",
	//" and y+gnuploty.  By default x and y are given the value 0.  If this line is",
	//" removed with an editor in a number of files, one can put several graphs in",
	//" one figure like this (default size is 5.0x3.0 inches):",
	//"",
	//"       .PS 8.0",
	//"       x=0;y=3",
	//"       copy \"figa.pic\"",
	//"       x=5;y=3",
	//"       copy \"figb.pic\"",
	//"       x=0;y=0",
	//"       copy \"figc.pic\"",
	//"       x=5;y=0",
	//"       copy \"figd.pic\"",
	//"       .PE",
	//"",
	//" This will produce an 8-inch-wide figure with four graphs in two rows on top",
	//" of each other.",
	//"",
	//" One can also achieve the same thing by the command",
	//"",
	//"       set terminal gpic x y",
	//"",
	//" for example, using",
	//"",
	//"       .PS 6.0",
	//"       copy \"trig.pic\"",
	//"       .PE"
	//END_HELP(gpic)
	///#endif // TERM_HELP 


	/* REGIS graphics language */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: regis.trm,v 1.15 2006/07/21 02:35:48 sfeam Exp $
	 *
	 */

	/* GNUPLOT - regis.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  REGIS devices
	 *
	 * AUTHORS
	 *  Colin Kelley, Thomas Williams
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */


	///#ifdef TERM_REGISTER
	//register_term(regis)
	///#endif


	///#ifdef TERM_PROTO
	//TERM_PUBLIC void REGIS_init __PROTO((void));
	//TERM_PUBLIC void REGIS_graphics __PROTO((void));
	//TERM_PUBLIC void REGIS_init __PROTO((void));
	//TERM_PUBLIC void REGIS_graphics __PROTO((void));
	//TERM_PUBLIC void REGIS_text __PROTO((void));
	//TERM_PUBLIC void REGIS_linetype __PROTO((int linetype));
	//TERM_PUBLIC void REGIS_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void REGIS_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void REGIS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int REGIS_text_angle __PROTO((int ang));
	//TERM_PUBLIC void REGIS_reset __PROTO((void));
	//TERM_PUBLIC void REGIS_options __PROTO((void));
	//
	///#define REGISXMAX 800
	///#define REGISYMAX 440
	//
	///#define REGISXLAST (REGISXMAX - 1)
	///#define REGISYLAST (REGISYMAX - 1)
	//
	///#define REGISVCHAR		20
	///#define REGISHCHAR		9
	///#define REGISVTIC		8
	///#define REGISHTIC		6
	//
	// /* is defined in plot.h
	// #define TRUE 1
	// #define FALSE 0
	// */
	///#endif



	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static int REGIS16color = FALSE;
	//
	//static int REGISang = 0;
	//
	//TERM_PUBLIC void
	//REGIS_init()
	//{
	//    fputs("\033[r\033[24;1H", gpoutfile);
	// /*     1     2
	//  * 1. reset scrolling region
	//  * 2. locate cursor on bottom line
	//  */
	//}
	//
	//
	// /* thanks to calmasd!dko (Dan O'Neill) for adding S(E) for vt125s */
	//TERM_PUBLIC void
	//REGIS_graphics()
	//{
	//    fputs("\033[2J\033P1pS(C0)S(E)T(A0)\n", gpoutfile);
	// /*     1      2      3    4   5
	//  * 1. clear screen
	//  * 2. enter ReGIS graphics
	//  * 3. turn off graphics diamond cursor
	//  * 4. clear graphics screen
	//  * 5. character set option.
	//  */
	//    (void) REGIS_text_angle(0);	// select text size and angle 
	//}
	//
	//
	//TERM_PUBLIC void
	//REGIS_text()
	//{
	//    fputs("\033\\\033[24;1H", gpoutfile);
	// /*     1    2
	//  * 1. Leave ReGIS graphics mode
	//  * 2. locate cursor on last line of screen
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//REGIS_linetype(int linetype)
	//{
	// /* This will change color in order G,R,B,G-dot,R-dot,B-dot */
	//
	//    static int in_16_map[15 + 2] = { 7, 7, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
	//    static int lt_16_map[15 + 2] = { 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
	//    static int in_map[9 + 2] = { 2, 2, 3, 2, 1, 3, 2, 1, 3, 2, 1 };
	//    static int lt_map[9 + 2] = { 1, 4, 1, 1, 1, 4, 4, 4, 6, 6, 6 };
	//
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//
	//    if (!REGIS16color) {
	//	if (linetype >= 9)
	//	    linetype %= 9;
	//	fprintf(gpoutfile, "W(I%d)\n", in_map[linetype + 2]);
	//	fprintf(gpoutfile, "W(P%d)\n", lt_map[linetype + 2]);
	//    } else {
	//	if (linetype >= 15)
	//	    linetype %= 15;
	//	fprintf(gpoutfile, "W(I%d)\n", in_16_map[linetype + 2]);
	//	fprintf(gpoutfile, "W(P%d)\n", lt_16_map[linetype + 2]);
	//    }
	//}
	//
	//
	//
	// /*
	// ** The \n was added in the functions below (and above) in order to not cause
	// ** a buffer overflow in devices that can't deal with long line lengths.
	// ** The DEC vt-340 doesn't need this, but Reflection 4, a vt-340 emulator
	// ** for PC's under MS-DOS and Microsoft Windows does need it.
	// ** Also needed for DECterm, a vt-340 emulator for use with Motif 1.0
	// ** on Open/VMS.
	// ** NGB 9/13/93
	// */
	//
	//TERM_PUBLIC void
	//REGIS_move(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "P[%d,%d]\n", x, REGISYLAST - y);
	//}
	//
	//
	//TERM_PUBLIC void
	//REGIS_vector(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "v[]v[%d,%d]\n", x, REGISYLAST - y);
	// /* the initial v[] is needed to get the first pixel plotted */
	//}
	//
	//
	// /* put_text and text_angle by rjl */
	//TERM_PUBLIC void
	//REGIS_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    if (REGISang == 1)
	//	REGIS_move(x - REGISVCHAR / 2 - 1, y);
	//    else
	//	REGIS_move(x, y + REGISVCHAR / 2 - 1);
	//    (void) putc('T', gpoutfile);
	//    (void) putc('\'', gpoutfile);
	//    while (*str) {
	//	(void) putc(*str, gpoutfile);
	//	if (*str == '\'')
	//	    (void) putc('\'', gpoutfile);	// send out another one 
	//	str++;
	//    }
	//    (void) putc('\'', gpoutfile);
	//    (void) putc('\n', gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC int
	//REGIS_text_angle(int ang)
	//{
	//    REGISang = (ang ? 1 : 0);
	//    if (REGISang == 1)
	//	fputs("T(D90,S1)\n", gpoutfile);
	//    else
	//	fputs("T(D0,S1)\n", gpoutfile);
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC void
	//REGIS_reset()
	//{
	//    fputs("\033[2J\033[24;1H", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//REGIS_options()
	//{
	//    int i = 0;
	//    struct value a;
	//
	//    if (!END_OF_COMMAND) {
	//	i = (int) real(const_express(&a));
	//    }
	//    REGIS16color = (i == 16);
	//    sprintf(term_options, "%s", REGIS16color ? "16" : "4");
	//}
	//
	///#endif


	///#ifdef TERM_TABLE
	//TERM_TABLE_START(regis_driver)
	//    "regis", "REGIS graphics language",
	//    REGISXMAX, REGISYMAX, REGISVCHAR, REGISHCHAR,
	//    REGISVTIC, REGISHTIC, REGIS_options, REGIS_init, REGIS_reset,
	//    REGIS_text, null_scale, REGIS_graphics, REGIS_move, REGIS_vector,
	//    REGIS_linetype, REGIS_put_text, REGIS_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(regis_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM regis_driver
	///#endif
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(regis)
	//"1 regis",
	//"?commands set terminal regis",
	//"?set terminal regis",
	//"?set term regis",
	//"?terminal regis",
	//"?term regis",
	//"?regis",
	//" The `regis` terminal device generates output in the REGIS graphics language.",
	//" It has the option of using 4 (the default) or 16 colors.",
	//"",
	//" Syntax:",
	//"       set terminal regis {4 | 16}"
	//END_HELP(regis)
	///#endif


	/* Tektronix 4106, 4107, 4109 and 420x terminals */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: t410x.trm,v 1.16 2006/07/21 02:35:48 sfeam Exp $
	 *
	 */

	/* GNUPLOT - t410x.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports: Tektronix 410x and 420x series terminals
	 *
	 * AUTHORS
	 *   Colin Kelley, Thomas Williams
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* Tektronix 410X and 420X driver written by Cary D. Renzema.
	 * email address: caryr@mxim.com
	 *
	 * I've tested this driver on the following terminals: 4106, 4107A, 4109
	 * and 4207.  It should work, without editing, on other terminals in the
	 * 410x and 420x families.  It will probably need to be changed to work
	 * on a 4105 (screen size and character rotation are two guesses).  This
	 * file can also be used as a start for a 411x driver.
	 *
	 * Cary R.
	 * April 5, 1990
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(tek410x)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void T410X_init __PROTO((void));
	//TERM_PUBLIC void T410X_reset __PROTO((void));
	//TERM_PUBLIC void T410X_graphics __PROTO((void));
	//TERM_PUBLIC void T410X_text __PROTO((void));
	//TERM_PUBLIC void T410X_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void T410X_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void T410X_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void T410X_linetype __PROTO((int linetype));
	//TERM_PUBLIC void T410X_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC int T410X_text_angle __PROTO((int ang));
	///#define T410XXMAX 4095
	///#define T410XYMAX 3131
	//
	///#define T410XVCHAR	71
	///#define T410XHCHAR	51
	///#define T410XVTIC	36
	///#define T410XHTIC	36
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static void T410X_encode_x_y __PROTO((unsigned int x, unsigned int y));
	//static void T410X_encode_int __PROTO((int number));
	//
	//
	//static int T410X_angle = 0;
	//
	//TERM_PUBLIC void
	//T410X_init()
	//{
	//    fputs("\033%%!0\033MN0\033MCB7C;\033MQ1\033MT1", gpoutfile);
	//    fputs("\033MG1\033RK!\033SK!\033LZ\033%%!1", gpoutfile);
	// /*
	// 	 1. set tek mode
	// 	 2. set character path to 0 (characters placed equal to rotation)
	// 	 3. set character size to 59 height
	// 	 4. set character precision to string
	// 	 5. set character text index to 1
	// 	 6. set character write mode to overstrike
	// 	 7. clear the view
	// 	 8. clear the segments
	// 	 9. clear the dialog buffer
	// 	10. set ansi mode
	// */
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_reset()
	//{
	//    fputs("\033%%!0\033LZ\033%%!1", gpoutfile);
	// /*
	// 	1. set tek mode
	// 	2. clear the dialog buffer
	// 	3. set ansi mode
	// */
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_graphics()
	//{
	//    fputs("\033%%!0\033\014\033LV0", gpoutfile);
	// /*
	// 	1. set tek mode
	// 	2. clear the screen
	// 	3. set dialog area invisible
	// */
	//    (void) fflush(gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//T410X_text()
	//{
	//    fputs("\033LV1\033%%!1", gpoutfile);
	// /*
	// 	1. set dialog area visible
	// 	2. set ansi mode
	// */
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_move(unsigned int x, unsigned int y)
	//{
	//    fputs("\033LF", gpoutfile);
	//
	//    (void) T410X_encode_x_y(x, y);
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_vector(unsigned int x, unsigned int y)
	//{
	//    fputs("\033LG", gpoutfile);
	//    (void) T410X_encode_x_y(x, y);
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_point(unsigned int x, unsigned int y, int number)
	//{
	//    fputs("\033MM", gpoutfile);
	//    (void) T410X_encode_int(GPMAX(number, 0) % 11);
	//    fputs("\033LH", gpoutfile);
	//    (void) T410X_encode_x_y(x, y);
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//
	//    switch (linetype) {
	//    case LT_AXIS:
	//	fputs("\033ML5", gpoutfile);
	//	break;
	//    case LT_BLACK:
	//	fputs("\033ML?", gpoutfile);
	//	break;
	//    default:
	//	fputs("\033ML", gpoutfile);
	//	(void) T410X_encode_int(linetype % 14 + 2);
	//	break;
	//    }
	//    fputs("\033MV", gpoutfile);
	//    (void) T410X_encode_int(GPMAX(linetype, 0) % 8);
	//    (void) fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//T410X_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//
	//    if (T410X_angle == 0) {
	//	(void) T410X_move(x, y - T410XVCHAR / 2 + 6);
	//	fputs("\033MR00", gpoutfile);
	//    } else {
	//	(void) T410X_move(x + T410XHCHAR / 2 - 6, y);
	//	fputs("\033MRE:0", gpoutfile);
	//    }
	//    (void) fputs("\033LT", gpoutfile);
	//    (void) T410X_encode_int(strlen(str));
	//    (void) fputs(str, gpoutfile);
	//    (void) fflush(gpoutfile);
	//}
	//
	//TERM_PUBLIC int
	//T410X_text_angle(int ang)
	//{
	//
	//    T410X_angle = ang;
	//    return (TRUE);
	//}
	//
	// /* These last two routines are based on fortran code found in the
	//  * 4106/4107/4109/CX PROGRAMMERS manual.
	//  */
	//
	//static void
	//T410X_encode_x_y(unsigned int x, unsigned int y)
	//{
	//    static char chix = 0, chiy = 0, cloy = 0, ceb = 0;
	//
	//    register unsigned int hix, lox, hiy, loy, eb, lx, ly;
	//
	//    lx = (x <= T410XXMAX) ? x : T410XXMAX;
	//    ly = (y <= T410XYMAX) ? y : T410XYMAX;
	//
	//    hix = lx / 128 + 32;
	//    lox = (lx / 4) % 32 + 64;
	//    hiy = ly / 128 + 32;
	//    loy = (ly / 4) % 32 + 96;
	//    eb = (ly % 4) * 4 + lx % 4 + 96;
	//
	//    if (chiy != hiy)
	//	(void) putc(hiy, gpoutfile);
	//    if (ceb != eb)
	//	(void) putc(eb, gpoutfile);
	//    if ((cloy != loy) || (ceb != eb) || (chix != hix))
	//	(void) putc(loy, gpoutfile);
	//    if (chix != hix)
	//	(void) putc(hix, gpoutfile);
	//    (void) putc(lox, gpoutfile);
	//
	//    chix = hix;
	//    chiy = hiy;
	//    cloy = loy;
	//    ceb = eb;
	//}
	//
	//
	//static void
	//T410X_encode_int(int number)
	//{
	//    register unsigned int mag, hi1, hi2, lo;
	//
	//    mag = ABS(number);
	//
	//    hi1 = mag / 1024 + 64;
	//    hi2 = (mag / 16) % 64 + 64;
	//    lo = mag % 16 + 32;
	//
	//    if (number >= 0)
	//	lo += 16;
	//
	//    if (hi1 != 64)
	//	(void) putc(hi1, gpoutfile);
	//    if ((hi2 != 64) || (hi1 != 64))
	//	(void) putc(hi2, gpoutfile);
	//    (void) putc(lo, gpoutfile);
	//
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(tek410x_driver)
	//    "tek410x", "Tektronix 4106, 4107, 4109 and 420X terminals",
	//    T410XXMAX, T410XYMAX, T410XVCHAR, T410XHCHAR,
	//    T410XVTIC, T410XHTIC, options_null, T410X_init, T410X_reset,
	//    T410X_text, null_scale, T410X_graphics, T410X_move, T410X_vector,
	//    T410X_linetype, T410X_put_text, T410X_text_angle,
	//    null_justify_text, T410X_point, do_arrow, set_font_null
	//TERM_TABLE_END(tek410x_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM tek410x_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(tek410x)
	//"1 tek410x",
	//"?commands set terminal tek410x",
	//"?set terminal tek410x",
	//"?set term tek410x",
	//"?terminal tek410x",
	//"?term tek410x",
	//"?tek410x",
	//" The `tek410x` terminal driver supports the 410x and 420x family of Tektronix",
	//" terminals.  It has no options."
	//END_HELP(tek410x)
	///#endif


	/* a Tek 4010 and others including VT-style */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: tek.trm,v 1.19.2.1 2009/08/14 01:24:05 sfeam Exp $
	 *
	 */

	/* GNUPLOT - tek.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  tek40xx, bitgraph, kermit_color_tek40xx, kermit_mono_tek40xx, selanar
	 *  ln03plus, xterm
	 *
	 * AUTHORS
	 *   Colin Kelley, Thomas Williams, Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * Modified June 1995 Ian MacPhedran to support newterm format
	 */
	///#define TEK
	///#define CTEK
	///#define VTTEK
	///#define XTERM

	/* Version 4.3: still available, but no longer built by default */
	///#if 0
	////#define KERMIT
	////#define SELANAR
	////#define BITGRAPH
	///#endif


	///#ifdef TERM_REGISTER
	//register_term(tek40)
	///#ifdef VTTEK
	//register_term(vttek)
	///#endif
	///#ifdef XTERM
	//register_term(xterm)
	///#endif
	///#ifdef KERMIT
	//register_term(kc_tek40)
	//register_term(km_tek40)
	///#endif
	///#ifdef SELANAR
	//register_term(selanar)
	///#endif
	///#ifdef BITGRAPH
	//register_term(bitgraph)
	///#endif
	///#endif // TERM_REGISTER 

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void TEK40init __PROTO((void));
	//TERM_PUBLIC void TEK40graphics __PROTO((void));
	//TERM_PUBLIC void TEK40text __PROTO((void));
	//TERM_PUBLIC void TEK40move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TEK40vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TEK40put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void TEK40reset __PROTO((void));
	///#ifdef BITGRAPH
	//TERM_PUBLIC void BG_text __PROTO((void));
	//TERM_PUBLIC void BG_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	///#endif
	///#if defined(SELANAR) || defined(BITGRAPH)
	//TERM_PUBLIC void TEK40linetype __PROTO((int linetype));
	///#endif
	///#ifdef KERMIT
	//TERM_PUBLIC void KTEK40graphics __PROTO((void));
	//TERM_PUBLIC void KTEK40Ctext __PROTO((void));
	//TERM_PUBLIC void KTEK40Clinetype __PROTO((int linetype));
	//TERM_PUBLIC void KTEK40Mlinetype __PROTO((int linetype));
	//TERM_PUBLIC void KTEK40reset __PROTO((void));
	///#endif
	///#ifdef SELANAR
	//TERM_PUBLIC void SEL_init __PROTO((void));
	//TERM_PUBLIC void SEL_graphics __PROTO((void));
	//TERM_PUBLIC void SEL_text __PROTO((void));
	//TERM_PUBLIC void SEL_reset __PROTO((void));
	///#endif
	//TERM_PUBLIC void VTTEK40init __PROTO((void));
	//TERM_PUBLIC void VTTEK40reset __PROTO((void));
	//TERM_PUBLIC void VTTEK40linetype __PROTO((int linetype));
	//TERM_PUBLIC void VTTEK40put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void XTERM_graphics __PROTO((void));
	//TERM_PUBLIC void XTERM_resume __PROTO((void));
	//TERM_PUBLIC void XTERM_text __PROTO((void));
	//TERM_PUBLIC int  XTERM_set_font __PROTO((const char * fontname));
	//TERM_PUBLIC void CTEK_linetype __PROTO((int linetype));
	//TERM_PUBLIC void CTEK_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void CTEK_vector __PROTO((unsigned int x, unsigned int y));
	//
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#ifdef TEK
	//
	///#define TEK40XMAX 1024
	///#define TEK40YMAX 780
	//
	///#define TEK40XLAST (TEK40XMAX - 1)
	///#define TEK40YLAST (TEK40YMAX - 1)
	//
	///#define TEK40VCHAR		25
	///#define TEK40HCHAR		14
	///#define TEK40VTIC		11
	///#define TEK40HTIC		11
	//
	///#define HX 0x20			// bit pattern to OR over 5-bit data 
	///#define HY 0x20
	///#define LX 0x40
	///#define LY 0x60
	//
	///#define LOWER5 31
	///#define UPPER5 (31<<5)
	//
	//
	//TERM_PUBLIC void
	//TEK40init()
	//{
	//}
	//
	//
	//TERM_PUBLIC void
	//TEK40graphics()
	//{
	///#ifdef VMS
	//    term_pasthru();
	///#endif // VMS 
	//    fputs("\033\014", gpoutfile);
	// /*                   1
	// 	1. clear screen
	// */
	//    (void) fflush(gpoutfile);
	//    sleep(1);
	// /* sleep 1 second to allow screen time to clear on real
	//    tektronix terminals */
	//}
	//
	//TERM_PUBLIC void
	//TEK40text()
	//{
	///#ifdef VMS
	//    (void) fflush(gpoutfile);	// finish the graphics 
	///#endif
	//    TEK40move(0, 12);
	//    fputs("\037", gpoutfile);
	// /*                   1
	// 	1. into alphanumerics
	// */
	///#ifdef VMS
	//    term_nopasthru();
	///#endif // VMS 
	//}
	//
	//
	///#if defined(SELANAR) || defined(BITGRAPH)
	//TERM_PUBLIC void
	//TEK40linetype(int linetype)
	//{
	//    (void) linetype;
	//}
	///#endif
	//
	//TERM_PUBLIC void
	//TEK40move(unsigned int x, unsigned int y)
	//{
	//    (void) putc('\035', gpoutfile);	// into graphics 
	//    TEK40vector(x, y);
	//}
	//
	//
	//TERM_PUBLIC void
	//TEK40vector(unsigned int x, unsigned int y)
	//{
	//    (void) putc((HY | (y & UPPER5) >> 5), gpoutfile);
	//    (void) putc((LY | (y & LOWER5)), gpoutfile);
	//    (void) putc((HX | (x & UPPER5) >> 5), gpoutfile);
	//    (void) putc((LX | (x & LOWER5)), gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//TEK40put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    TEK40move(x, y - 11);
	//    fprintf(gpoutfile, "\037%s\n", str);
	//}
	//
	//
	//TERM_PUBLIC void
	//TEK40reset()
	//{
	//}
	//
	///#endif // TEK 
	//
	//
	// /* thanks to dukecdu!evs (Ed Simpson) for the BBN BitGraph driver */
	//
	///#ifdef BITGRAPH
	//
	///#define BG_XMAX			 	768	// width of plot area 
	///#define BG_YMAX			 	768	// height of plot area 
	///#define BG_SCREEN_HEIGHT	1024	// full screen height 
	//
	///#define BG_XLAST	 (BG_XMAX - 1)
	///#define BG_YLAST	 (BG_YMAX - 1)
	//
	///#define BG_VCHAR	16
	///#define BG_HCHAR	 9
	///#define BG_VTIC		 8
	///#define BG_HTIC		 8
	//
	//
	///#define BG_init TEK40init
	///#define BG_graphics TEK40graphics
	///#define BG_linetype TEK40linetype
	///#define BG_move TEK40move
	///#define BG_vector TEK40vector
	///#define BG_reset TEK40reset
	//
	//
	//TERM_PUBLIC void
	//BG_text()
	//{
	///#ifdef VMS
	//    (void) fflush(gpoutfile);	// finish the graphics 
	///#endif
	//    BG_move(0, BG_SCREEN_HEIGHT - 2 * BG_VCHAR);
	//    fputs("\037", gpoutfile);
	// /*                   1
	// 	1. into alphanumerics
	// */
	//}
	//
	//
	//TERM_PUBLIC void
	//BG_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    BG_move(x, y - 11);
	//    fprintf(gpoutfile, "\037%s\n", str);
	//}
	//
	//
	///#endif // BITGRAPH 
	//
	//
	// /* Color and Monochrome specials for the MS-DOS Kermit Tektronix Emulator
	//    by Russell Lang,  eln272v@monu1.cc.monash.oz  */
	//
	///#ifdef KERMIT
	//
	///#define KTEK40HCHAR		13
	//
	//TERM_PUBLIC void
	//KTEK40graphics()
	//{
	///#ifdef VMS
	//    term_mode_tek();
	//    term_pasthru();
	///#endif // VMS 
	//    fputs("\033\014", gpoutfile);
	// /*                   1
	// 	1. clear screen
	// */
	// /* kermit tektronix emulation doesn't need to wait */
	//}
	//
	//TERM_PUBLIC void
	//KTEK40Ctext()
	//{
	//    TEK40text();
	//    KTEK40Clinetype(0);		// change to green 
	///#ifdef VMS
	//    term_nopasthru();
	///#endif // VMS 
	//}
	//
	// /* special color linetypes for MS-DOS Kermit v2.31 tektronix emulator */
	// /*	0 = normal, 1 = bright
	// 	foreground color (30-37) = 30 + colors
	// 		where colors are   1=red, 2=green, 4=blue */
	//static const char *kermit_color[15] =
	//{"\033[0;37m", "\033[1;30m",
	// "\033[0;32m", "\033[0;36m", "\033[0;31m", "\033[0;35m",
	// "\033[1;34m", "\033[1;33m", "\033[1;31m", "\033[1;37m",
	// "\033[1;35m", "\033[1;32m", "\033[1;36m", "\033[0;34m",
	// "\033[0;33m"};
	//
	//TERM_PUBLIC void
	//KTEK40Clinetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype >= 13)
	//	linetype %= 13;
	//    fprintf(gpoutfile, "%s", kermit_color[linetype + 2]);
	//}
	//
	//
	// /* linetypes for MS-DOS Kermit v2.30 tektronix emulator */
	// /* `=solid, a=fine dots, b=short dashes, c=dash dot,
	//    d=long dash dot, e=dash dot dot */
	//static const char *kerm_linetype = "`a`abcde";
	//
	//TERM_PUBLIC void
	//KTEK40Mlinetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype >= 6)
	//	linetype %= 6;
	//    fprintf(gpoutfile, "\033%c", kerm_linetype[linetype + 2]);
	//}
	//
	//TERM_PUBLIC void
	//KTEK40reset()
	//{
	//    fputs("\030\n", gpoutfile);	// turn off Tek emulation 
	///#ifdef VMS
	//    term_mode_native();
	///#endif // VMS 
	//}
	//
	///#endif // KERMIT 
	//
	//
	// /* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
	//    Selanar driver */
	//
	///#ifdef SELANAR
	//
	//TERM_PUBLIC void
	//SEL_init()
	//{
	//    fputs("\033\062", gpoutfile);
	// /*					1
	// 	1. set to ansi mode
	// */
	//}
	//
	//
	//TERM_PUBLIC void
	//SEL_graphics()
	//{
	//    fputs("\033[H\033[J\033\061\033\014", gpoutfile);
	// /*                   1           2       3
	// 	1. clear ANSI screen
	// 	2. set to TEK mode
	// 	3. clear screen
	// */
	///#ifdef VMS
	//    term_pasthru();
	///#endif // VMS 
	//}
	//
	//
	//TERM_PUBLIC void
	//SEL_text()
	//{
	///#ifdef VMS
	//    (void) fflush(gpoutfile);	// finish the graphics 
	///#endif
	//    TEK40move(0, 12);
	//    fputs("\033\062", gpoutfile);
	// /*                   1
	// 	1. into ANSI mode
	// */
	///#ifdef VMS
	//    term_nopasthru();
	///#endif // VMS 
	//}
	//
	//TERM_PUBLIC void
	//SEL_reset()
	//{
	//    fputs("\033\061\033\012\033\062\033[H\033[J", gpoutfile);
	// /*                   1        2       3      4
	// 1       set tek mode
	// 2       clear screen
	// 3       set ansi mode
	// 4       clear screen
	// */
	//}
	//
	///#endif // SELANAR 
	//
	///#ifdef VTTEK
	//
	//TERM_PUBLIC void
	//VTTEK40init()
	//{
	//    fputs("\033[?38h", gpoutfile);
	//    fflush(gpoutfile);
	//    sleep(1);
	// /* sleep 1 second to allow screen time to clear on some terminals */
	///#ifdef VMS
	//    term_mode_tek();
	///#endif // VMS 
	//}
	//
	//TERM_PUBLIC void
	//VTTEK40reset()
	//{
	//    fputs("\033[?38l", gpoutfile);
	//    fflush(gpoutfile);
	//    sleep(1);
	// /* sleep 1 second to allow screen time to clear on some terminals */
	///#ifdef VMS
	//    term_mode_native();
	///#endif // VMS 
	//}
	//
	// /* linetypes for VT-type terminals in tektronix emulator mode */
	// /* `=solid, a=fine dots, b=short dashes, c=dash dot,
	//    d=long dash dot, h=bold solid, i=bold fine dots, j=bold short dashes,
	//    k=bold dash dot, l=bold long dash dot */
	//static const char *vt_linetype = "`a`abcdhijkl";
	//static int last_vt_linetype = 0;
	//
	//TERM_PUBLIC void
	//VTTEK40linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype >= 10)
	//	linetype %= 10;
	//    fprintf(gpoutfile, "\033%c", vt_linetype[linetype + 2]);
	//    last_vt_linetype = linetype;
	//}
	//
	//TERM_PUBLIC void
	//VTTEK40put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    int linetype;
	//    linetype = last_vt_linetype;
	//    VTTEK40linetype(0);
	//    TEK40put_text(x, y, str);
	//    VTTEK40linetype(linetype);
	//}
	//
	///#endif // VTTEK 
	//
	///#ifdef XTERM
	//
	///#define XT_TEK_ESC "\033"
	///#define XT_TEK_GFX XT_TEK_ESC "[?38h"
	///#define XT_TEK_ANSI XT_TEK_ESC "\003"
	///#define XT_TEK_CLR XT_TEK_ESC "\014"
	///#define XT_TEK_ALPHA "\037"
	//
	//static const char *xt_tek_fontsize = "89:;";
	//
	//TERM_PUBLIC void
	//XTERM_graphics()
	//{
	//    XTERM_resume();
	//    fputs(XT_TEK_CLR, gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//XTERM_resume()
	//{
	//    fputs(XT_TEK_GFX, gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//XTERM_text()
	//{
	//    fputs(XT_TEK_ALPHA XT_TEK_ANSI, gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC int
	//XTERM_set_font(const char *fontname)
	//{
	//    char size = 0;
	//    if (fontname) {
	//      size_t lp = strlen(fontname);
	//      if (lp>0) size = fontname[lp-1]-'1';
	//    }
	//    fprintf(gpoutfile, XT_TEK_ESC "%c",
	//            xt_tek_fontsize[size>0&&size<4?size:0]);
	//
	//    return(TRUE);
	//}
	//
	///#endif // XTERM 
	//
	///#ifdef LN03P
	//
	//TERM_PUBLIC void
	//LN03Pinit()
	//{
	//    fputs("\033[?38h", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//LN03Preset()
	//{
	//    fputs("\033[?38l", gpoutfile);
	//}
	//
	///#endif // LN03P 
	//
	//
	//
	// /* tek40xx (monochrome) with linetype support by Jay I. Choe */
	///#ifdef CTEK
	//
	// /*#define ABS(A) (((A)>=0)? (A):-(A))*/
	///#define SIGN(A) (((A) >= 0)? 1:-1)
	//
	//static void CT_solid_vector __PROTO((int x, int y));
	//static void CT_draw_vpoint __PROTO((int x, int y, int last));
	//static void CT_pattern_vector __PROTO((int x1, int y1));
	//
	// /* CT_lines are line types defined as bit pattern */
	//static unsigned long CT_lines[] =
	//{~(unsigned long)0,			// solid line 
	// 0x000fffff,			// long dash 
	// 0x00ff00ff,			// short dash 
	// 0x00f00fff,			// dash-dot 
	// 0x00f07fff,			// long dash - dot 
	// 0x07070707,
	// 0x07ff07ff,
	// 0x070707ff};
	//
	// /* current line pattern */
	//static unsigned long *CT_pattern = &CT_lines[0];
	//
	// /* we need to keep track of tek cursor location */
	//static int CT_last_linetype = 0, CT_last_x, CT_last_y;
	//
	//TERM_PUBLIC void
	//CTEK_linetype(int linetype)
	//{
	//    if (linetype < 0)
	//	linetype = 0;
	//    linetype %= (sizeof(CT_lines) / sizeof(unsigned long));
	//    CT_pattern = &CT_lines[linetype];
	//    CT_last_linetype = linetype;
	//}
	//
	//TERM_PUBLIC void
	//CTEK_move(unsigned int x, unsigned int y)
	//{
	//    TEK40move(x, y);
	//    CT_last_x = x;
	//    CT_last_y = y;
	//}
	//
	//static void
	//CT_solid_vector(int x, int y)
	//{
	//    TEK40vector(x, y);
	//    CT_last_x = x;
	//    CT_last_y = y;
	//}
	//
	// /*
	//    simulate pixel draw using tek vector draw.
	//    delays actual line drawing until maximum line segment is determined
	//    (or first/last point is defined)
	// */
	//static int CT_penon = 0;	// is Pen on? 
	//
	//static void
	//CT_draw_vpoint(int x, int y, int last)
	//{
	//    static int xx0, yy0, xx1, yy1;
	//
	//    if ((*CT_pattern) & 1) {
	//	if (CT_penon) {		// This point is a continuation of current line 
	//	    xx1 = x;
	//	    yy1 = y;
	//	} else {		// beginning of new line 
	//	    xx0 = xx1 = x;
	//	    yy0 = yy1 = y;
	//	    CT_penon = 1;
	//	}
	//	*CT_pattern = ((*CT_pattern) >> 1) | ((unsigned long)1 << 31);	// rotate the pattern 
	//	if (last) {		// draw the line anyway if this is the last point 
	//	    TEK40move(xx0, yy0);
	//	    TEK40vector(xx1, yy1);
	//	    CT_penon = 0;
	//	}
	//    } else {			// do not draw this pixel 
	//	if (CT_penon) {		// last line segment ended at the previous pixel. 
	// /* draw the line */
	//	    TEK40move(xx0, yy0);
	//	    TEK40vector(xx1, yy1);
	//	    CT_penon = 0;
	//	}
	//	*CT_pattern = (*CT_pattern) >> 1;	// rotate the current pattern 
	//    }
	//}
	//
	// /*
	//    draw vector line with pattern
	// */
	//
	//static void
	//CT_pattern_vector(int x1, int y1)
	//{
	//    int op;			// order parameter 
	//    int x0 = CT_last_x;
	//    int y0 = CT_last_y;
	//    int dx = x1 - x0;
	//    int dy = y1 - y0;
	//    int ax = ABS(dx) << 1;
	//    int ay = ABS(dy) << 1;
	//    int sx = SIGN(dx);
	//    int sy = SIGN(dy);
	//
	//    if (ax >= ay) {
	//	for (op = ay - (ax >> 1); x0 != x1; x0 += sx, op += ay) {
	//	    CT_draw_vpoint(x0, y0, 0);
	//	    if (op > 0 || (op == 0 && sx == 1)) {
	//		op -= ax;
	//		y0 += sy;
	//	    }
	//	}
	//    } else {			// ax < ay 
	//	for (op = ax - (ay >> 1); y0 != y1; y0 += sy, op += ax) {
	//	    CT_draw_vpoint(x0, y0, 0);
	//	    if (op > 0 || (op == 0 && sy == 1)) {
	//		op -= ay;
	//		x0 += sx;
	//	    }
	//	}
	//    }
	//    CT_draw_vpoint(x0, y0, 1);	// last point 
	//    CT_last_x = x1;
	//    CT_last_y = y1;
	//}
	//
	//TERM_PUBLIC void
	//CTEK_vector(unsigned int x, unsigned int y)
	//{
	//    if (CT_last_linetype <= 0)
	//	CT_solid_vector(x, y);
	//    else
	//	CT_pattern_vector(x, y);
	//}
	//
	///#endif // CTEK 
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	///#ifdef CTEK
	//TERM_TABLE_START(tek40_driver)
	//    "tek40xx", "Tektronix 4010 and others; most TEK emulators",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, TEK40init, TEK40reset,
	//    TEK40text, null_scale, TEK40graphics, CTEK_move, CTEK_vector,
	//    CTEK_linetype, TEK40put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(tek40_driver)
	///#endif // CTEK 
	//
	///#undef LAST_TERM
	///#define LAST_TERM tek40_driver
	//
	///#ifdef VTTEK
	//TERM_TABLE_START(vttek_driver)
	//    "vttek", "VT-like tek40xx terminal emulator",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, VTTEK40init, VTTEK40reset,
	//    TEK40text, null_scale, TEK40graphics, TEK40move, TEK40vector,
	//    VTTEK40linetype, VTTEK40put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(vttek_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM vttek_driver
	//
	///#endif // VTTEK 
	//
	///#ifdef XTERM
	//TERM_TABLE_START(xterm_driver)
	//    "xterm", "Xterm Tektronix 4014 Mode",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, TEK40init, TEK40reset,
	//    XTERM_text, null_scale, XTERM_graphics, TEK40move, TEK40vector,
	//    VTTEK40linetype, VTTEK40put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, XTERM_set_font, 0,
	//    TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE, XTERM_text, XTERM_resume
	//TERM_TABLE_END(xterm_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM xterm_driver
	//
	///#endif // XTERM 
	//
	///#ifdef KERMIT
	//TERM_TABLE_START(kc_tek40_driver)
	//   "kc_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - color",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, KTEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset,
	//    KTEK40Ctext, null_scale, KTEK40graphics, TEK40move, TEK40vector,
	//    KTEK40Clinetype, TEK40put_text, null_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null
	//TERM_TABLE_END(kc_tek40_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM kc_tek40_driver
	//
	//TERM_TABLE_START(km_tek40_driver)
	//    "km_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - monochrome",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, KTEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset,
	//    TEK40text, null_scale, KTEK40graphics, TEK40move, TEK40vector,
	//    KTEK40Mlinetype, TEK40put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(km_tek40_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM km_tek40_driver
	//
	///#endif // KERMIT 
	//
	///#ifdef SELANAR
	//TERM_TABLE_START(selanar_driver)
	//    "selanar", "Selanar",
	//    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
	//    TEK40VTIC, TEK40HTIC, options_null, SEL_init, SEL_reset,
	//    SEL_text, null_scale, SEL_graphics, TEK40move, TEK40vector,
	//    TEK40linetype, TEK40put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(selanar_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM selanar_driver
	//
	///#endif // SELANAR 
	//
	///#ifdef BITGRAPH
	//TERM_TABLE_START(bitgraph_driver)
	//    "bitgraph", "BBN Bitgraph Terminal",
	//    BG_XMAX, BG_YMAX, BG_VCHAR, BG_HCHAR,
	//    BG_VTIC, BG_HTIC, options_null, BG_init, BG_reset,
	//    BG_text, null_scale, BG_graphics, BG_move, BG_vector,
	//    BG_linetype, BG_put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(bitgraph_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM bitgraph_driver
	//
	///#endif // BITGRAPH 
	//
	///#endif // TERM_TABLE 

	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(tek40)
	//"1 tek40",
	//"?commands set terminal tek40xx",
	//"?set terminal tek40xx",
	//"?set term tek40xx",
	//"?terminal tek40xx",
	//"?term tek40xx",
	//"?tek40",
	//"?commands set terminal vttek",
	//"?set terminal vttek",
	//"?set term vttek",
	//"?terminal vttek",
	//"?term vttek",
	//"?vttek",
	//"?commands set terminal xterm",
	//"?set terminal xterm",
	//"?set term xterm",
	//"?terminal xterm",
	//"?term xterm",
	//"?xterm",
	///#ifdef KERMIT
	//"?commands set terminal kc-tek40xx",
	//"?set terminal kc-tek40xx",
	//"?set term kc-tek40xx",
	//"?terminal kc-tek40xx",
	//"?term kc-tek40xx",
	//"?kc-tek40xx",
	//"?commands set terminal km-tek40xx",
	//"?set terminal km-tek40xx",
	//"?set term km-tek40xx",
	//"?terminal km-tek40xx",
	//"?term km-tek40xx",
	//"?km-tek40xx",
	///#endif
	///#ifdef SELANAR
	//"?commands set terminal selanar",
	//"?set terminal selanar",
	//"?set term selanar",
	//"?terminal selanar",
	//"?term selanar",
	//"?selanar",
	///#endif
	///#ifdef BITGRAPH
	//"?commands set terminal bitgraph",
	//"?set terminal bitgraph",
	//"?set term bitgraph",
	//"?terminal bitgraph",
	//"?term bitgraph",
	//"?bitgraph",
	///#endif
	//" This family of terminal drivers supports a variety of VT-like terminals.",
	//" `tek40xx` supports Tektronix 4010 and others as well as most TEK emulators.",
	//" `vttek` supports VT-like tek40xx terminal emulators.",
	//" The following are present only if selected when gnuplot is built:",
	//" `kc-tek40xx` supports MS-DOS Kermit Tek4010 terminal emulators in color;",
	//" `km-tek40xx` supports them in monochrome. `selanar` supports Selanar graphics.",
	//" `bitgraph` supports BBN Bitgraph terminals.",
	//" None have any options."
	//END_HELP(tek40)
	///#endif // TERM_HELP 



	///#endif // !MSDOS && !_Windows && !AMIGA 
	/****************************************************************************/


	/****************************************************************************/
	/* These terminals can be used on any system */

	///#ifdef X11
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: x11.trm,v 1.184.2.1 2009/09/13 17:54:09 sfeam Exp $
	 *
	 */

	/* GNUPLOT - x11.trm */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 *    x11.trm  --- inboard terminal driver for X11
	 */

	/* Petr Mikulik and Johannes Zellner: added mouse support (October 1999)
	 * Implementation and functionality is based on pm.trm
	 */

	/* X11 support for Petr Mikulik's pm3d
	 * by Johannes Zellner <johannes@zellner.org>
	 * (November 1999 - January 2000)
	 */

	/* Dynamic font support, enhanced text mode support,
	 * additional feedback from outboard driver
	 * Ethan A Merritt <merritt@u.washington.edu>
	 * 2003
	 */

	/* Daniel Sebald: added X11 support for images. (27 February 2003)
	 */


	///#ifdef TERM_REGISTER
	//register_term(x11)
	///#endif

	///#ifdef TERM_PROTO
	//int X11_args __PROTO((int argc, char *argv[]));
	//
	//TERM_PUBLIC void X11_options __PROTO((void));
	//TERM_PUBLIC void X11_init __PROTO((void));
	//TERM_PUBLIC void X11_graphics __PROTO((void));
	//TERM_PUBLIC void X11_text __PROTO((void));
	//TERM_PUBLIC int  X11_set_font __PROTO((const char * fontname));
	//TERM_PUBLIC void X11_reset __PROTO((void));
	//TERM_PUBLIC void X11_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void X11_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void X11_linewidth __PROTO((double lw));
	//TERM_PUBLIC void X11_pointsize __PROTO((double ps));
	//TERM_PUBLIC void X11_linetype __PROTO((int lt));
	//TERM_PUBLIC void X11_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC int X11_text_angle __PROTO((int i));
	//TERM_PUBLIC int X11_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void X11_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void X11_fillbox __PROTO((int style, unsigned int x, unsigned int y, unsigned int width, unsigned int height));
	//
	//TERM_PUBLIC void X11_send_endianess __PROTO((void));
	//
	///#ifdef USE_MOUSE
	//TERM_PUBLIC int X11_waitforinput __PROTO((void));
	//TERM_PUBLIC void X11_set_ruler __PROTO((int, int));
	//TERM_PUBLIC void X11_set_cursor __PROTO((int, int, int));
	//TERM_PUBLIC void X11_put_tmptext __PROTO((int, const char str[]));
	//TERM_PUBLIC void X11_set_clipboard __PROTO((const char[]));
	///#endif
	//
	//TERM_PUBLIC void X11_update_opts __PROTO((void));
	//TERM_PUBLIC int X11_make_palette __PROTO((t_sm_palette *));
	//TERM_PUBLIC void X11_set_color __PROTO((t_colorspec *));
	//TERM_PUBLIC void X11_filled_polygon __PROTO((int, gpiPoint *));
	//
	//TERM_PUBLIC void X11_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
	//
	// /* To support "set term x11 enhanced" */
	//TERM_PUBLIC void ENHX11_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void ENHX11_OPEN __PROTO((char * fontname, double fontsize,
	//				double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//				int overprint));
	//TERM_PUBLIC void ENHX11_FLUSH __PROTO((void));
	//
	///#define X11_XMAX 4096
	///#define X11_YMAX 4096
	//
	//static int X11_SIZE_X = 640;
	//static int X11_SIZE_Y = 450;
	//static int X11_POSITION_X = 0;
	//static int X11_POSITION_Y = 0;
	//
	// /* approximations for typical font/screen sizes */
	///#define X11_VCHAR (X11_YMAX/25)
	///#define X11_HCHAR (X11_XMAX/100)
	///#define X11_VTIC (X11_YMAX/100)
	///#define X11_HTIC (X11_XMAX/150)
	///#endif	// TERM_PROTO 


	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "gplt_x11.h"
	//
	// /* non-zero if '-display' found on command line */
	//static int X11_Display = 0;
	//
	// /* Fonts can have very long names */
	// /* EAM FIXME - these should be dynamically allocated */
	///#define X11_MAX_FONTNAME_LENGTH 255
	//static char X11_default_font[X11_MAX_FONTNAME_LENGTH+1] = {'\0'};
	//static int  X11_default_fontsize = 12;
	//static char X11_last_font_used[X11_MAX_FONTNAME_LENGTH+1] = {'\01','\0'};
	//static char X11_next_font_used[X11_MAX_FONTNAME_LENGTH+1] = {'\0'};
	//static enum JUSTIFY X11_last_justification = LEFT;
	//
	//static void X11_atexit __PROTO((void));
	//static void X11_set_default_font __PROTO((void));
	//
	//static void transmit_gradient __PROTO((gradient_struct *gradient, int cnt));
	//
	// /* Merged the old char X11_opts[] and int X11_optarg[]
	//  * into one array of structs.
	//  * Loosely based on XrmOptionDescRec, the use of which
	//  * would probably be overkill here. */
	//typedef enum { hasNoArg, hasArg } OptionArg;
	//
	//static struct x11opt {
	//    const char *option;		// Name of option 
	//    OptionArg arg;		// Whether option has argument 
	//} X11_cmdopts[] = {
	//    { "-mono", hasNoArg}, { "-gray", hasNoArg}, { "-clear", hasNoArg},
	//    { "-tvtwm", hasNoArg}, { "-pointsize", hasArg},
	//    { "-iconic", hasNoArg}, { "-rv", hasNoArg},
	//    { "-reverse", hasNoArg}, { "+rv", hasNoArg},
	//    { "-synchronous", hasNoArg},
	//    { "-display", hasArg}, { "-geometry", hasArg}, { "-bg", hasArg},
	//    { "-background", hasArg}, { "-bd", hasArg},
	//    { "-bordercolor", hasArg}, { "-bw", hasArg},
	//    { "-borderwidth", hasArg}, { "-fg", hasArg},
	//    { "-foreground", hasArg}, { "-fn", hasArg}, { "-font", hasArg},
	//    { "-name", hasArg},
	//    { "-selectionTimeout", hasArg}, { "-title", hasArg},
	//    { "-xnllanguage", hasArg}, { "-xrm", hasArg},
	//    { "-raise", hasNoArg}, { "-noraise", hasNoArg},
	//    { "-solid", hasNoArg}, { "-dashed", hasNoArg}
	///#ifdef USE_MOUSE
	//    , { "-nofeedback", hasNoArg}
	//    , { "-noevents", hasNoArg}
	//    , { "-ctrlq", hasNoArg}
	///#endif
	//};
	//
	///#define X11_nopts (sizeof(X11_cmdopts) / sizeof(X11_cmdopts[0]))
	//
	//static FILE *X11_ipc = (FILE *) 0;
	///#ifdef PIPE_IPC
	///#define X11_ipc_back_fd ipc_back_fd
	///#endif
	//
	//static char **xargv = (char **) NULL;
	// /* reserve a minimum 10 driver opts */
	//static char *optvec[2 * X11_nopts + 1 + 10];
	//
	// /* gnuplot_x11 has extension .exe on OS/2 and Windows (and on RSX/VMS, but
	//    these construct their own full path GNUPLOT_X11 in their build script).
	// */
	///#if defined(OS2) || defined(_Windows)
	///#ifndef GNUPLOT_X11
	//static char X11_default_command[] = "gnuplot_x11.exe";
	///#else
	//static char X11_default_command[] = GNUPLOT_X11 ".exe";
	///#endif
	///#else  // thus !OS/2 && !Windows 
	///#ifndef GNUPLOT_X11
	//static char X11_default_command[] = "gnuplot_x11";
	///#else
	//static char X11_default_command[] = GNUPLOT_X11;
	///#endif
	///#endif	// OS/2 || Windows 
	//
	//static char *X11_command = X11_default_command;
	//static char *X11_command_parsed = NULL;
	//static char *X11_full_command_path = NULL;
	//
	// /* must match the definition in src/gplt_x11.c: */
	//static int persist = UNSET;
	//static int do_raise = UNSET;
	//static int dashedlines = UNSET;
	//static int ctrlq = UNSET;
	//static int set_size = UNSET;
	//static int set_position = UNSET;
	//
	// /* driver properties managed by x11.trm rather than gnuplot_x11 */
	//static double X11_linewidth_multiplier = 1.0;
	//
	///#ifdef USE_MOUSE
	// /* Interlock to prevent the mouse channel from being coopted more than
	//  * once per plot by the gnuplot_x11<->x11.trm font information query.
	//  */
	//static TBOOLEAN default_font_size_known = FALSE;
	//static TBOOLEAN X11_MOUSE_FEEDBACK = TRUE;
	///#endif
	///#ifdef PIPE_IPC
	//static TBOOLEAN IPC_LOCK = FALSE;
	///#endif
	//
	//static int parse_driver __PROTO((const char *));
	//
	//static int
	//parse_driver(const char *cmd)
	//{
	//    int nr = 0;
	//    char *ptr;
	//
	// /* make a copy of cmd, as parsing will modify the string */
	//    X11_command_parsed = gp_realloc(X11_command_parsed,
	//				    strlen(cmd) + 1, "x11->parse_driver");
	//    strcpy(X11_command_parsed, X11_command);
	//    ptr = X11_command_parsed;
	//
	//    while (*ptr != '\0' && nr < sizeof(optvec) / sizeof(char)) {
	//
	// /* Strip whitespace.  Use nulls, so that
	//  * the previous argument is terminated
	//  * automatically.
	//  */
	//	while (isspace((unsigned char)*ptr))
	//	    *ptr++ = '\0';
	//
	//	if (!(*ptr))		// don't count the terminating NULL 
	//	    break;
	//
	// /* Save the argument. */
	//	optvec[nr++] = ptr;
	//
	// /* Skip over the argument. */
	//	while ('\0' != *ptr && !isspace((unsigned char)*ptr)) {
	//	    ptr++;
	//	}
	//    }
	//
	// /* HBB 20020214: new code to prepend the environment X11_DRIVER_DIR
	//  * to the command name, if it doesn't contain any slashes yet */
	//    if (!strchr(optvec[0],'/')) {
	//	char *dir = getenv("GNUPLOT_DRIVER_DIR");
	//
	//	if (!dir)
	//	    dir = X11_DRIVER_DIR;
	///#ifndef OS2
	//	if (dir[0] != '/' && dir[0] != '.') {
	// /* Can't call int_error because longjump has not been set up yet */
	//	    int_warn(NO_CARET, "Illegal X11 driver directory name! Using default");
	//	    dir = "";
	//	}
	///#endif
	//	X11_full_command_path = gp_realloc(X11_full_command_path,
	//					   strlen(dir) + strlen(optvec[0]) + 2,
	//					   "x11 driver pathname");
	// /* optvec[0] = X11_full_command_path; */
	//	if (*dir)
	//	    sprintf(X11_full_command_path, "%s/%s", dir, optvec[0]);
	//	else
	//	    sprintf(X11_full_command_path, "%s", optvec[0]);
	//    }
	//
	//    return nr;
	//}
	//
	// /*   X11_args - scan gnuplot command line for standard X Toolkit options
	//  * called from plot.c so must not be TERM_PUBLIC (which may be static)
	//  */
	//
	//int
	//X11_args(int argc, char *argv[])
	//{
	//    int nx11 = 0, i, n;
	//
	//    xargv = (char **) gp_alloc(argc * sizeof(char *), "<xargv>");
	//
	//    if (!xargv) {
	//	fputs("not enough memory to copy argv - quitting\n", stderr);
	//	exit(EXIT_FAILURE);
	//    }
	//
	// /* We make a copy of the argument vector because
	//  * argv is modified later. */
	//    memcpy(xargv, argv, argc * sizeof(char *));
	//    i = parse_driver(X11_command);
	//
	//    if (persist_cl) {
	//	optvec[i++] = "-persist";
	//    }
	//
	//    while (++argv, ++xargv, --argc > 0) {
	//	if (!strcmp(*argv,"--persist") || !strncmp(*argv,"-p",2)) {
	//	    nx11++;
	//	    continue;
	//	}
	//	for (n = 0; n < X11_nopts; n++) {
	//	    if (strcmp(*argv, X11_cmdopts[n].option) == 0) {
	//		optvec[i++] = *xargv;
	///#ifdef USE_MOUSE
	//		if (strcmp(*argv, "-nofeedback") == 0)
	//		    X11_MOUSE_FEEDBACK = FALSE;
	///#endif
	//		if (strcmp(*argv, "-display") == 0)
	//		    X11_Display++;
	//		if (X11_cmdopts[n].arg == hasArg) {
	//		    if (--argc <= 0)
	//			return nx11;
	//		    optvec[i++] = *++xargv, ++argv;
	//		    nx11++;
	//		}
	//		if (i >= (sizeof(optvec) / sizeof(char))) {
	//		    fprintf(stderr, "warning: X11 options will be truncated\n");
	//		    return nx11;	// optvec is full 
	//		}
	//		nx11++;
	//		break;
	//	    }
	//	}
	//	if (n == X11_nopts)
	//	    break;
	//    }
	//
	//    return (nx11);
	//}
	//
	//
	//enum X11_id {
	//    X11_RESET,
	//    X11_CLOSE,
	//    X11_PERSIST,
	//    X11_NOPERSIST,
	//    X11_RAISE,
	//    X11_NORAISE,
	//    X11_FONT,
	//    X11_TITLE,
	//    X11_ENHANCED,
	//    X11_NOENHANCED,
	//    X11_SOLID,
	//    X11_DASHED,
	//    X11_LINEWIDTH,
	//    X11_CTRLQ,
	//    X11_NOCTRLQ,
	//    X11_SIZE,
	//    X11_POSITION,
	///#ifdef EXTERNAL_X11_WINDOW
	//    X11_WINDOW,
	///#endif
	//    X11_OTHER
	//};
	//
	//static struct gen_table X11_opts[] = {
	//    {"res$et", X11_RESET},
	//    {"cl$ose", X11_CLOSE},
	//    {"per$sist", X11_PERSIST},
	//    {"noper$sist", X11_NOPERSIST},
	//    {"rai$se", X11_RAISE},
	//    {"norai$se", X11_NORAISE},
	//    {"font",   X11_FONT},
	//    {"fn$ame", X11_FONT},
	//    {"ti$tle", X11_TITLE},
	//    {"enh$anced", X11_ENHANCED},
	//    {"noenh$anced", X11_NOENHANCED},
	//    {"solid", X11_SOLID},
	//    {"dash$ed", X11_DASHED},
	//    {"linew$idth", X11_LINEWIDTH},
	//    {"lw", X11_LINEWIDTH},
	//    {"ctrl$q", X11_CTRLQ},
	//    {"noctrl$q", X11_NOCTRLQ},
	//    {"si$ze", X11_SIZE},
	//    {"pos$ition", X11_POSITION},
	///#ifdef EXTERNAL_X11_WINDOW
	//    {"w$indow", X11_WINDOW},
	///#endif
	//    {NULL, X11_OTHER}
	//};
	//
	//
	//TERM_PUBLIC void
	//X11_options()
	//{
	//
	///#define NOT_PROCESS_IF_DUPLICATION 1
	//
	//    int c_title_token = 0;
	//    int new_term_number = 0;
	//    TBOOLEAN duplication = FALSE;
	//    TBOOLEAN set_reset = FALSE, set_persist = FALSE, set_raise = FALSE, set_font = FALSE;
	//    TBOOLEAN set_ctrlq = FALSE;
	//    TBOOLEAN set_title = FALSE, set_number = FALSE, set_close = FALSE, set_solid = FALSE;
	///#ifdef EXTERNAL_X11_WINDOW
	//    unsigned long existing_X11_window_id = 0;
	//    TBOOLEAN set_window = FALSE;
	///#endif
	//
	//    do_raise = dashedlines = ctrlq = UNSET;
	//    set_size = set_position = UNSET;
	//    persist = persist_cl;	// previously set from command line 
	//
	//    while (!END_OF_COMMAND) {
	//	switch (lookup_table(&X11_opts[0], c_token)) {
	//	case X11_RESET:
	//	    c_token++;
	//	    if (set_reset) duplication=TRUE;
	//	    set_reset = TRUE;
	//	    break;
	//	case X11_CLOSE:
	//	    c_token++;
	//	    if (set_close) duplication=TRUE;
	//	    set_close = TRUE;
	//	    break;
	//	case X11_PERSIST:
	//	    persist = yes;
	//	    c_token++;
	//	    if (set_persist) duplication=TRUE;
	//	    set_persist = TRUE;
	//	    break;
	//	case X11_NOPERSIST:
	//	    persist = no;
	//	    c_token++;
	//	    if (set_persist) duplication=TRUE;
	//	    set_persist = TRUE;
	//	    break;
	//	case X11_CTRLQ:
	//	    ctrlq = yes;
	//	    c_token++;
	//	    if (set_ctrlq) duplication=TRUE;
	//	    set_ctrlq = TRUE;
	//	    break;
	//	case X11_NOCTRLQ:
	//	    ctrlq = no;
	//	    c_token++;
	//	    if (set_ctrlq) duplication=TRUE;
	//	    set_ctrlq = TRUE;
	//	    break;
	//	case X11_SOLID:
	//	    dashedlines = FALSE;
	//	    c_token++;
	//	    if (set_solid) duplication=TRUE;
	//	    set_solid = TRUE;
	//	    break;
	//	case X11_DASHED:
	//	    dashedlines = TRUE;
	//	    c_token++;
	//	    if (set_solid) duplication=TRUE;
	//	    set_solid = TRUE;
	//	    break;
	//	case X11_LINEWIDTH:
	//	    c_token++;
	//	    X11_linewidth_multiplier = real_expression();
	//	    if (X11_linewidth_multiplier <= 0)
	//		X11_linewidth_multiplier = 1.0;
	//	    break;
	//	case X11_RAISE:
	//	    do_raise = yes;
	//	    c_token++;
	//	    if (set_raise) duplication=TRUE;
	//	    set_raise = TRUE;
	//	    break;
	//	case X11_NORAISE:
	//	    do_raise = no;
	//	    c_token++;
	//	    if (set_raise) duplication=TRUE;
	//	    set_raise = TRUE;
	//	    break;
	//	case X11_FONT:
	//	    c_token++;
	//	    if (END_OF_COMMAND)
	//		int_error(c_token, "expecting font name");
	//	    if (isstringvalue(c_token)) {
	//		char *s = try_to_get_string();
	//		strncpy(X11_default_font, s, sizeof(X11_default_font));
	//		free(s);
	//	    } else {
	//		copy_str(X11_default_font, c_token, sizeof(X11_default_font));
	//		c_token++;
	//	    }
	//	    if (strchr(X11_default_font,','))
	//		sscanf(strchr(X11_default_font,',')+1, "%d",
	//			&X11_default_fontsize);
	//	    if (set_font) duplication=TRUE;
	//	    set_font = TRUE;
	//	    break;
	//	case X11_TITLE:
	//	    c_token++;
	//	    if (END_OF_COMMAND)
	//		int_error(c_token, "expecting title text");
	//	    c_title_token = c_token;
	//	    c_token++;
	//	    if (set_title) duplication=TRUE;
	//	    set_title = TRUE;
	//	    break;
	//	case X11_ENHANCED:
	//	    term->put_text = ENHX11_put_text;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    c_token++;
	//	    break;
	//	case X11_NOENHANCED:
	//	    term->put_text = X11_put_text;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    c_token++;
	//	    break;
	//	case X11_SIZE:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "expecting X[,Y]");
	//	    } else {
	//		int x_in, y_in;
	//		x_in = int_expression();
	//		if (x_in > 0)
	//		    X11_SIZE_X = x_in;
	//		else
	//		    int_error(c_token, "X size must be > 0");
	//		if (equals(c_token, ",")) {
	//		    c_token++;
	//		    y_in = int_expression();
	//		    if (y_in > 0)
	//			X11_SIZE_Y = y_in;
	//		    else
	//			int_error(c_token, "Y size must be > 0");
	//		}
	//		set_size = yes;
	//	    }
	//	    break;
	//	case X11_POSITION:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "expecting X[,Y]");
	//	    } else {
	//		X11_POSITION_X = int_expression();
	//		if (equals(c_token, ",")) {
	//		    c_token++;
	//		    X11_POSITION_Y = int_expression();
	//		}
	//		set_position = yes;
	//	    }
	//	    break;
	//
	///#ifdef EXTERNAL_X11_WINDOW
	//	case X11_WINDOW:
	//	{
	//	    char *windowid;
	//	    c_token++;
	//	    if (!(windowid = try_to_get_string()))
	//		int_error(c_token, "expecting X window ID as string in hex");
	//	    sscanf(windowid,"%lx",&existing_X11_window_id);
	//	    free(windowid);
	//	    if (!existing_X11_window_id)
	//		int_error(c_token, "expecting X window ID as string in hex");
	//	    if (set_window) duplication=TRUE;
	//	    set_window = TRUE;
	//	    break;
	//	}
	///#endif
	//	case X11_OTHER:
	//	default:
	//	    if (set_number) duplication=TRUE;
	// /* let gnuplot_x11 check range */
	//	    new_term_number = int_expression();
	//	    if (new_term_number < 0)
	//		int_error(c_token, "plot number must be non-negative");
	//	    set_number = TRUE;
	//	    break;
	//	}
	//
	//	if (duplication) {
	//	    int_error(c_token-1, "duplicated or contradicting arguments in X11 term options");
	//	}
	//
	//    }
	//
	//
	// /* Call own init routine; this might be xlib rather than x11 */
	//    term->init();
	//
	//    if (set_reset)
	//	X11_atexit();	// tell gnuplot_x11 to shut down 
	//
	// /* Leave the current window unchanged when closing an old window */
	//    if (X11_ipc) {
	//	if (set_close) {
	//	    fprintf(X11_ipc, (set_number ? "C%d\n" : "C\n"), new_term_number);
	//	    fflush(X11_ipc);
	//	} else if (set_number) {
	///#ifdef EXTERNAL_X11_WINDOW
	//	    if (set_window)
	//		int_error(NO_CARET,"an existing X11 window cannot be asigned to a plot number");
	///#endif
	//	    fprintf(X11_ipc, "N%d\n", new_term_number);
	//	    fflush(X11_ipc);
	///#ifdef EXTERNAL_X11_WINDOW
	//	} else if (set_window) {
	//	    fprintf(X11_ipc, "%c%lx\n", X11_GR_SET_WINDOW_ID, existing_X11_window_id);
	//	    fflush(X11_ipc);
	///#endif
	//	}
	//    }
	//
	///#ifdef EXTERNAL_X11_WINDOW
	//    if (set_window) {
	//	sprintf(term_options, "XID 0x%lX", existing_X11_window_id);
	//    } else
	///#endif
	//    if (set_number && new_term_number >= 0) {
	//	sprintf(term_options, "%d", new_term_number);
	//    }
	//    if (UNSET != do_raise) {
	//	strcat(term_options, (yes == do_raise ? " raise" : " noraise"));
	//    }
	//    if (UNSET != persist) {
	//	strcat(term_options, (yes == persist ? " persist" : " nopersist"));
	//    }
	//    if (UNSET != ctrlq) {
	//	strcat(term_options, (yes == ctrlq ? " ctrlq" : " noctrlq"));
	//    }
	//    if (UNSET != dashedlines) {
	//	strcat(term_options, (yes == dashedlines ? " dashed" : " solid"));
	//    }
	//    if (term->put_text == ENHX11_put_text) {
	//	strcat(term_options, " enhanced");
	//    }
	//    if (X11_linewidth_multiplier != 1.0) {
	//	sprintf(term_options + strlen(term_options),
	//		" linewidth %.2g", X11_linewidth_multiplier);
	//    }
	//    if (*X11_default_font) {
	//	strcat(term_options, " font \"");
	//	strcat(term_options, X11_default_font);
	//	strcat(term_options, "\"");
	//    }
	//    if (set_title) {
	//	char *title;
	//	int save_token = c_token;
	//	c_token = c_title_token;
	//	strncat(term_options, " title \"", MAX_LINE_LEN-strlen(term_options));
	//	title = term_options + strlen(term_options);
	//	if (isstringvalue(c_title_token)) {
	//	    char *s = try_to_get_string();
	//	    strncat(term_options, s, MAX_LINE_LEN-strlen(term_options));
	//	    free(s);
	//	} else
	//	    copy_str(term_options+strlen(term_options), c_title_token, MAX_LINE_LEN-strlen(term_options));
	//	if (X11_ipc) {
	// /* Send up to maximum buffer length minus three characters of
	//  * title string to account for required 'n', '\0', '\n'.
	//  */
	//	    int i;
	//	    fputc('n', X11_ipc);
	//	    for (i=0; i < X11_COMMAND_BUFFER_LENGTH-3 && title[i] != '\0'; i++)
	//		fputc(title[i], X11_ipc);
	//	    fputc('\0', X11_ipc);
	//	    fputc('\n', X11_ipc);
	//	    fflush(X11_ipc);
	//	}
	//	strncat(term_options, "\"", MAX_LINE_LEN-strlen(term_options));
	//	c_token = save_token;
	//    }
	//    if (set_size != UNSET)
	//	sprintf(term_options + strlen(term_options),
	//	      " size %d,%d ", X11_SIZE_X,X11_SIZE_Y);
	//
	//    if (set_position != UNSET)
	//	sprintf(term_options + strlen(term_options),
	//	      " position %d,%d ", X11_POSITION_X,X11_POSITION_Y);
	//
	//    X11_update_opts();
	//}
	//
	//
	//void
	//x11_raise_terminal_window(int number)
	//{
	// /* Send the raise character and a number. */
	//    if (X11_ipc) {
	//	fprintf(X11_ipc, "^%d\n", number);
	//	fflush(X11_ipc);
	//    }
	//}
	//
	//void
	//x11_raise_terminal_group(void)
	//{
	// /* Send just the raise character. */
	//    if (X11_ipc) {
	//	fprintf(X11_ipc, "^\n");
	//	fflush(X11_ipc);
	//    }
	//}
	//
	//void
	//x11_lower_terminal_window(int number)
	//{
	// /* Send the raise character and a number. */
	//    if (X11_ipc) {
	//	fprintf(X11_ipc, "v%d\n", number);
	//	fflush(X11_ipc);
	//    }
	//}
	//
	//void
	//x11_lower_terminal_group(void)
	//{
	// /* Send just the raise character. */
	//    if (X11_ipc) {
	//	fprintf(X11_ipc, "v\n");
	//	fflush(X11_ipc);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//X11_update_opts()
	//{
	//    if (!X11_ipc)
	//	return;
	//
	//    if (UNSET != do_raise || UNSET != persist || UNSET != dashedlines || UNSET != ctrlq) {
	//	fprintf(X11_ipc, "X %d %d %d %d\n", 
	//		do_raise, persist, dashedlines, ctrlq);
	//	fflush(X11_ipc);
	//    }
	//
	// /* pass size as a valid X11 geometry string WIDTHxHEIGHT[+XPOS+YPOS] */
	//    if (set_size != UNSET || set_position != UNSET) {
	//	if (set_size != UNSET && set_position == UNSET)
	//	    fprintf(X11_ipc, "s %dx%d\n", X11_SIZE_X, X11_SIZE_Y);
	//	else if (set_size == UNSET && set_position != UNSET)
	//	    fprintf(X11_ipc, "s %+d%+d\n", X11_POSITION_X, X11_POSITION_Y);
	//	else if (set_size != UNSET && set_position != UNSET)
	//	    fprintf(X11_ipc, "s %dx%d%+d%+d\n", X11_SIZE_X, X11_SIZE_Y,
	//		X11_POSITION_X, X11_POSITION_Y);
	//	fflush(X11_ipc);
	//    }
	//}
	//
	//
	// /*-----------------------------------------------------------------------------
	//  *   Three different versions of the remainder of the X11 terminal driver
	//  *   are provided to support three different types of IPC with the
	//  *   gnuplot_x11 outboard terminal driver:
	//  *
	//  *   DEFAULT_X11:      popen() pipe for most un*x platforms
	//  *
	//  *   CRIPPLED_SELECT : file IPC for un*x platforms with incomplete or faulty
	//  *                     implementation of BSD select()
	//  *
	//  *   VMS :             mailbox/spawn IPC
	//  *---------------------------------------------------------------------------*/
	//
	///#define DEFAULT_X11
	///#if defined(VMS) || defined(CRIPPLED_SELECT)
	///#undef DEFAULT_X11
	///#endif
	///#if defined(VMS) && defined(CRIPPLED_SELECT)
	//Error.Incompatible options.
	///#endif
	// /* we do not want to have to duplicate all the code, so we
	//  * do most of it with macros.
	//  * PRINT0(format), PRINT1(format, p1), PRINT2(format, p1, p2) etc
	//  * also  FLUSH0(format), etc, which do an additional flush
	//  */
	///#ifdef DEFAULT_X11
	// /*-----------------------------------------------------------------------------
	//  *   DEFAULT_X11 popen() pipe IPC
	//  *---------------------------------------------------------------------------*/
	//static void
	//X11_atexit()
	//{
	//    if (X11_ipc) {
	//	fputs("R\n", X11_ipc);
	//	fclose(X11_ipc);
	// /* dont wait(), since they might be -persist */
	//	X11_ipc = NULL;
	///#ifdef PIPE_IPC
	//	close(ipc_back_fd);
	//	ipc_back_fd = -1;
	///#endif
	//    }
	//}
	//
	///#ifdef USE_MOUSE
	//
	//TERM_PUBLIC int
	//X11_waitforinput()
	//{
	///#ifdef PIPE_IPC
	//    fd_set fds;
	//    static struct gp_event_t ge;
	//    static int l = 0;
	//    int n;
	//    int fd = fileno(stdin);
	//    int repeat_count = 0;
	//
	//AGAIN:
	// /* XXX:  if the input device it not a tty (e.g. /dev/null)
	//  *       mouse events are not processed. This is necessary
	//  *       as on some systems /dev/null is not selectable.
	//  * TODO: should we close the ipc_back_fd in this case ? */
	//    if (ipc_back_fd >= 0)
	//	do {
	//	    int ierr;
	//	    FD_ZERO(&fds);
	//	    FD_SET(fd, &fds);
	//	    FD_SET(ipc_back_fd, &fds);
	//	    ierr = select(ipc_back_fd + 1, SELECT_TYPE_ARG234 &fds, 0, 0, NULL);
	//	    if (ierr < 0 && errno == EINTR) {
	//		FD_ZERO(&fds);
	//		continue;
	//	    }
	//	    if (FD_ISSET(ipc_back_fd, &fds)) {
	//		n = read(ipc_back_fd, (void *) (l + (char *) &ge), sizeof(ge) - l);
	//		if (n == 0) {
	//		    close(ipc_back_fd);
	//		    ipc_back_fd = -1;
	// /* don't close X11_ipc, otherwise later writes
	//  * to it will cause a segfault */
	//		    IPC_LOCK = FALSE;
	//		    break;	// outboard driver has stopped 
	//		}
	//		l += n;
	//		if (l == sizeof(ge)) {
	// /* note: do_event() may not return (if an
	//  * error occurs), so need to reset l first */
	//		    l = 0;
	//		    do_event(&ge);
	//		    if (ge.type == GE_fontprops) {
	//		    	if (repeat_count > 0) {
	//		    	    FPRINTF((stderr,
	//			        "X11_waitforinput: caught GE_fontprops after %d tries\n",
	//				repeat_count));
	//			}
	//			return(GE_fontprops);
	//		    }
	//		    if (ge.type == GE_buttonrelease && (paused_for_mouse & PAUSE_CLICK)) {
	//			int button = ge.par1;
	//			if (button == 1 && (paused_for_mouse & PAUSE_BUTTON1))
	//			    paused_for_mouse = 0;
	//			if (button == 2 && (paused_for_mouse & PAUSE_BUTTON2))
	//			    paused_for_mouse = 0;
	//			if (button == 3 && (paused_for_mouse & PAUSE_BUTTON3))
	//			    paused_for_mouse = 0;
	//			if (paused_for_mouse == 0)
	//			    return '\0';
	//		    }
	//		    if (ge.type == GE_keypress && (paused_for_mouse & PAUSE_KEYSTROKE)) {
	// /* Ignore NULL keycode */
	//			if (ge.par1 > '\0') {
	//			    paused_for_mouse = 0;
	//			    return '\0';
	//			}
	//		    }
	//		}
	//	    }
	//	} while (!FD_ISSET(fd, &fds));
	//
	// /* If ipc_back_fd is not open, we will never see any mouse events! */
	//    else if (paused_for_mouse) {
	//	paused_for_mouse = 0;
	//	int_error(NO_CARET,"Mousing not active");
	//    }
	//
	// /* IPC_LOCK indicates that we are specifically waiting for a reply on */
	// /* the mousing channel.  If stdin unblocks first, defer reading it,   */
	// /* wait a few microseconds, and try again.                            */
	// /* FIXME EAM - Give up after a few seconds. This will drop input chars*/
	// /* but at least it won't hang forever if the X11 connection goes bad. */
	//    if (IPC_LOCK) {
	///#ifdef HAVE_USLEEP
	//	usleep(100);
	///#endif
	//        if (repeat_count++ < 10000)
	//	    goto AGAIN;
	//    }
	//
	// /* Same sort of thing if we are specifically waiting for mouse input. */
	//    if (paused_for_mouse) {
	///#ifdef HAVE_USLEEP
	//	usleep(10);
	///#endif
	//	goto AGAIN;
	//    }
	//
	///#endif // PIPE_IPC 
	//
	///#if 0
	// /* HBB 20010620: switching back and forth between X11 and a non-GUI
	//  * terminal, while stdin is redirected, causes gnuplot to terminate
	//  * right after it re-enters the X11 terminal --- read() returns a '\0'
	//  * character once, and then EOF. Switching to <stdio.h>'s getc() fixed
	//  * that, for me. */
	//    if (read(0, &c, 1) != 1)
	//	return EOF;
	//    else
	//	return c;
	///#else
	//    return getc(stdin);
	///#endif	// 0/1 
	//}
	///#endif // USE_MOUSE 
	//
	//
	//TERM_PUBLIC void
	//X11_init()
	//{
	//    static int been_here = 0;
	//
	//    if (!X11_ipc) {
	// /* first time through or after a reset */
	///#if defined(OSK)
	// /* OS-9 popen() does not block on close for child to end, so
	//  * we can safely use it here
	//  */
	// /* FIXME HBB 20020214: This doesn't understand X11_DRIVER_DIR
	//  * or $GNUPLOT_DRIVER_DIR yet. This may break execution of
	//  * freshly built gnuplot until 'make install' */
	//
	//	   X11_ipc = popen(X11_command, "w");
	///#else
	///#if defined(OS2)
	// /* FIXME amai 20020219: nice try...
	//  * But popen() does return a non-NULL handle to almost command,
	//  * it's just a new session which will stop if the command does
	//  * not exist... We should stat() for the argument?! */
	// /* X11_ipc = popen(X11_full_command_path, "w");
	// if (X11_ipc==NULL) */
	//      {
	//	   X11_ipc = popen(X11_command, "w");
	//      }
	///#else // !(OSK || OS/2) 
	//	int fdes[2];
	///#ifdef PIPE_IPC
	//	int fdes_back[2];
	//
	///#define X11_ALLOW_EVENTS (mouse_setting.on)
	//	if (X11_ALLOW_EVENTS) {
	//	    if (pipe(fdes_back))
	//		perror("pipe() failed:");
	//	}
	///#endif	// PIPE_IPC 
	//	if (pipe(fdes))
	//	    perror("pipe() failed:");
	//
	//	if (fork() == 0) {
	// /* child */
	///#ifdef PIPE_IPC
	//	    char noevents[] = "-noevents";
	//	    if (X11_ALLOW_EVENTS) {
	//		dup2(fdes_back[1], 1);	// stdout to pipe 
	//		close(fdes_back[0]);
	//	    } else {
	//		char **ptr;
	//		for (ptr = optvec; ptr && *ptr; ptr++)
	//		    ;		// do nothing: skip over set arguments 
	// /* tell the driver not to supply any events by
	//  * appending "-noevents" to the optvec list. */
	//		*ptr = noevents;
	//		*++ptr = (char *) 0;	// terminate 
	//	    }
	///#endif	// PIPE_IPC 
	// /* close the write side of the child's forward fd */
	//	    close(fdes[1]);
	//
	//	    dup2(fdes[0], 0);	// stdin from pipe 
	//	    execvp(X11_full_command_path, optvec);
	// /* if we get here, something went wrong */
	//	    fprintf(stderr,"Expected X11 driver: %s\n",X11_full_command_path);
	//	    perror("Exec failed");
	//	    fprintf(stderr,"See 'help x11' for more details\n");
	//	    exit(EXIT_FAILURE);
	//	}
	// /* parent */
	///#ifdef PIPE_IPC
	// /* X11_ipc_out = fdopen(fdes[0], "r"); */
	//	if (ipc_back_fd > 0) {
	//	    fprintf(stderr, "(X11_init) warning: unclosed ipc_back_fd.\n");
	//	    fprintf(stderr, "           this is probably a program error.\n");
	//	    close(ipc_back_fd);
	//	}
	//	if (X11_ALLOW_EVENTS) {
	//	    ipc_back_fd = fdes_back[0];
	//	    close(fdes_back[1]);	// the parent doesn't need this 
	//	} else {
	// /* we do not open a bidirectional communication
	//  * for non-tty's by default. If this is desired,
	//  * the mouse must be turned on explicitely *before*
	//  * starting the x11 driver.
	//  * So: if we're here, we close the ipc-back-channel
	//  * which will cause a SIGPIPE in the driver. This
	//  * is *ugly* but it works. (joze) */
	// /* close(fdes_back[0]); */
	// /* mark ipc_back_fd as unusable */
	//	    ipc_back_fd = IPC_BACK_UNUSABLE;
	//	}
	///#endif	// PIPE_IPC 
	// /* close the read side of the parent's forward fd */
	//	close(fdes[0]);
	//	X11_ipc = fdopen(fdes[1], "w");
	///#endif // !OSK  
	///#endif // !OS/2 
	//    }
	//
	//    if (!been_here) {
	//	GP_ATEXIT(X11_atexit);
	//	been_here++;
	//    }
	//    X11_send_endianess();
	///#ifdef USE_MOUSE
	//    default_font_size_known = FALSE;
	///#endif
	//    X11_update_opts();
	//}
	//
	//TERM_PUBLIC void
	//X11_reset()
	//{
	// /* Leave the pipe alone, until exit or  set term x11 reset */
	// /* but make sure that all locks are cleared.               */
	///#ifdef PIPE_IPC
	//    IPC_LOCK = FALSE;
	///#endif
	///#ifdef USE_MOUSE
	//    paused_for_mouse = 0;
	///#endif
	//}
	//
	///#define PRINT0(fmt)          fprintf(X11_ipc, fmt)
	///#define PRINT1(fmt,p1)       fprintf(X11_ipc, fmt,p1)
	///#define PRINT2(fmt,p1,p2)    fprintf(X11_ipc, fmt,p1,p2)
	///#define PRINT3(fmt,p1,p2,p3) fprintf(X11_ipc, fmt,p1,p2,p3)
	///#define PRINT4(fmt,p1,p2,p3,p4) fprintf(X11_ipc, fmt,p1,p2,p3,p4)
	///#define PRINT5(fmt,p1,p2,p3,p4,p5) fprintf(X11_ipc, fmt,p1,p2,p3,p4,p5)
	//
	///#define FFLUSH()             fflush(X11_ipc)
	//
	///#define BEFORE_GRAPHICS		// nowt 
	///#define AFTER_TEXT		// nowt 
	//
	//
	///#elif defined(CRIPPLED_SELECT)
	// /* PLEASE CAN SOMEONE CHECK THAT THIS STILL WORKS !!! */
	// /*-----------------------------------------------------------------------------
	//  *   CRIPPLED_SELECT file IPC
	//  *---------------------------------------------------------------------------*/
	//static char X11_tmp[32], X11_tmp0[32], X11_shutdown[32];
	//static int X11_pid;
	//
	//TERM_PUBLIC void
	//X11_init()
	//{
	//    if (!(X11_pid = fork())) {
	//	execvp(X11_full_command_path, optvec);
	//	_exit(1);
	//    }
	//    sprintf(X11_tmp, "/tmp/Gnuplot_%d", X11_pid);
	//    sprintf(X11_tmp0, "%s-", X11_tmp);
	//    sprintf(X11_shutdown, "echo R >%s", X11_tmp);
	//}
	//
	//TERM_PUBLIC void
	//X11_reset()
	//{
	//    system(X11_shutdown);
	//}
	//
	///#define BEFORE_GRAPHICS  if (!(X11_ipc = fopen(X11_tmp0, "w"))) {    perror(X11_tmp0); system(X11_shutdown); exit(1);  }
	//ignore
	//ignore
	//ignore
	//
	///#define AFTER_TEXT  { fclose(X11_ipc); rename(X11_tmp0, X11_tmp); }
	//ignore
	//
	///#define PRINT0(fmt)          fprintf(X11_ipc, fmt)
	///#define PRINT1(fmt,p1)       fprintf(X11_ipc, fmt,p1)
	///#define PRINT2(fmt,p1,p2)    fprintf(X11_ipc, fmt,p1,p2)
	///#define PRINT3(fmt,p1,p2,p3) fprintf(X11_ipc, fmt,p1,p2,p3)
	///#define PRINT4(fmt,p1,p2,p3,p4) fprintf(X11_ipc, fmt,p1,p2,p3,p4)
	///#define PRINT5(fmt,p1,p2,p3,p4,p5) fprintf(X11_ipc, fmt,p1,p2,p3,p4,p5)
	///#define FFLUSH()             fflush(X11_ipc)
	//
	//static void
	//X11_atexit()
	//{
	// /* WHAT SHOULD I DO ? */
	//}
	///#elif defined(VMS)
	// /*-----------------------------------------------------------------------------
	//  *   VMS mailbox/spawn IPC - Yehavi Bourvine - YEHAVI@VMS.HUJI.AC.IL
	//  *---------------------------------------------------------------------------*/
	///#include <iodef.h>
	///#include <descrip.h>
	///#include <dvidef.h>
	///#ifdef __DECC
	///#include <lib$routines.h>
	///#include <starlet.h>
	///#endif
	///#ifdef __GNUC__
	///#include <errno.h>
	///#else
	//int vaxc$errno;
	///#endif
	//
	///#define SS$_NORMAL 1		// or include <ssdef.h> for all SS$_ def's 
	//
	///#define MBXMXMSG 128		// DEFMBXMXMSG is set by SYSGEN 
	//
	//static short X11_channel;
	//
	//struct iosb {
	//    unsigned short stat;
	//    unsigned short count;
	//    unsigned long info;
	//};
	//
	//
	//
	//TERM_PUBLIC void
	//X11_init()
	//{
	//
	//    struct iosb iosb;
	//
	//    static char devnam_string[64];
	//    static $DESCRIPTOR(devnam, devnam_string);
	//
	//    struct {
	//	short int buf_len;
	//	short int item;
	//	char *buf_addr;
	//	unsigned short int *ret_len;
	//	int end;
	//    } item_list = {
	//    devnam.dsc$w_length, DVI$_DEVNAM, devnam.dsc$a_pointer, &devnam.dsc$w_length, 0};
	///#define CMDLEN 1024
	//    char cmdline[CMDLEN], *cmdp;
	//    int optindex;
	//
	//    if (!X11_channel) {
	//	int one = 1;
	//
	// /* Create a descriptor for the command line that starts
	//    GNUPLOT_X11. $DESCRIP doesn't work in this context... */
	//
	// /* FIXME!
	//  * This does not work anymore since X11 option passing has been
	//  * changed to use execvp() in the DEFAULT_X11 case
	//  */
	//	struct dsc$descriptor_s pgmdsc = { 0, DSC$K_DTYPE_T,
	//	    DSC$K_CLASS_S, 0
	//	};
	//	optindex = 0;
	//	strcpy(cmdline, optvec[optindex]);
	//	cmdp = cmdline + strlen(optvec[optindex]);
	//	while (optvec[++optindex] != NULL) {
	//	    *cmdp++ = ' ';
	//	    *cmdp++ = '\"';
	//	    strcpy(cmdp, optvec[optindex]);
	//	    cmdp += strlen(optvec[optindex]);
	//	    *cmdp++ = '\"';
	//	}
	//	pgmdsc.dsc$w_length = cmdp - cmdline;
	//	pgmdsc.dsc$a_pointer = cmdline;
	//
	// /* Create a mailbox which will be used as a pipe for commands to the
	//  * subprocess.  What we'll write to it will be read by the subprocess
	//  * as its STDIN.  Use an unnamed mailbox and refer to it by its device
	//  * number */
	//
	//	vaxc$errno = sys$crembx(0, &X11_channel, MBXMXMSG, MBXMXMSG, 0, 0, 0, 0);
	//	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
	//	    printf("SYS$CreMbx failed with status=%d\r\n", vaxc$errno);
	//	    os_error(NO_CARET, "sys$crembx failed");
	//	}
	//	vaxc$errno = sys$getdviw(0, X11_channel, 0, &item_list, &iosb, 0, 0, 0);
	//	if ((vaxc$errno & SS$_NORMAL) == SS$_NORMAL)
	//	    vaxc$errno = iosb.stat;
	//	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
	//	    printf("SYS$Getdviw failed with status=%d\r\n", vaxc$errno);
	//	    sys$dassgn(X11_channel);
	//	    X11_channel = 0;
	//	    os_error(NO_CARET, "sys$getdviw failed");
	//	}
	// /* Create a subprocess whose input is this mailbox. */
	//	vaxc$errno = lib$spawn(&pgmdsc, &devnam, 0, &one, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	//	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
	//	    printf("LIB$SPAWN failed with status=%d\r\n", vaxc$errno);
	//	    sys$dassgn(X11_channel);
	//	    X11_channel = 0;
	//	    os_error(NO_CARET, "lib$spawn failed");
	//	}
	//    }
	//    {
	//	static int been_here = 0;
	//	if (!been_here) {
	//	    GP_ATEXIT(X11_atexit);
	//	    been_here = 1;
	//	}
	//    }
	//}
	//
	//
	// /*   We use $QIO in order to avoid buffering problems, although it might
	//  *   work  as well with simple Fprintf calls.
	//  */
	//
	///#define GO(x) do {    char buffer[512]; int status; struct iosb iosb;   sprintf x;    if (strlen(buffer) >= MBXMXMSG)  {      printf("buffer contents (%d char) catenated to mailbox size (%d bytes)\n",      strlen(buffer), MBXMXMSG);      buffer[MBXMXMSG-1] = '\0';     printf("%s\n", buffer);    }    status = sys$qiow(0, X11_channel, IO$_WRITEVBLK, &iosb, 0, 0, buffer, strlen(buffer), 0, 0, 0, 0);    if ((status & SS$_NORMAL) == SS$_NORMAL) status = iosb.stat;    if((status & SS$_NORMAL) != SS$_NORMAL) exit(status);  } while (0)
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	///#define PRINT0(fmt)          GO((buffer, fmt))
	///#define PRINT1(fmt,p1)       GO((buffer, fmt,p1))
	///#define PRINT2(fmt,p1,p2)    GO((buffer, fmt,p1,p2))
	///#define PRINT3(fmt,p1,p2,p3) GO((buffer, fmt,p1,p2,p3))
	///#define PRINT4(fmt,p1,p2,p3,p4) GO((buffer, fmt,p1,p2,p3,p4))
	///#define PRINT5(fmt,p1,p2,p3,p4,p5) GO((buffer, fmt,p1,p2,p3,p4,p5))
	//
	///#define FFLUSH()		// nowt 
	///#define BEFORE_GRAPHICS		// nowt 
	///#define AFTER_TEXT		// nowt 
	//
	//static void
	//X11_atexit()
	//{
	//    if (X11_channel) {
	//	PRINT0("R\n");
	//	sleep(2);		// Wait for subprocess to finish 
	//	sys$dassgn(X11_channel);
	//	X11_channel = 0;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//X11_reset()
	//{
	// /* do nothing until exit */
	//}
	//
	///#else // !VMS 
	//    You lose.
	///#endif // !VMS 
	//
	// /* common stuff, using macros defined above */
	//
	//TERM_PUBLIC void
	//X11_graphics()
	//{
	///#ifdef USE_MOUSE
	//    static unsigned long windowid = 0;
	///#endif
	//    static enum set_encoding_id last_encoding = S_ENC_DEFAULT;
	//
	//    BEFORE_GRAPHICS;		// kludge for crippled select 
	//
	///#ifndef USE_MOUSE
	// /* for VMS sake, keep as separate prints */
	//    PRINT0("G\n");
	///#else
	///#ifdef PIPE_IPC
	// /* if we know the outboard driver has stopped, restart it */
	//    if (ipc_back_fd == IPC_BACK_CLOSED) {
	//	fclose(X11_ipc);
	//	X11_ipc = NULL;
	//	X11_init();
	//    }
	///#endif
	// /* send also XID of gnuplot window (<space> then raises it up) */
	//    if (!windowid) {
	//	char *window_env = getenv("WINDOWID");
	//	if (window_env)
	//	    sscanf(window_env, "%lu", &windowid);
	//    }
	///#ifndef OS2
	//    PRINT1("G%lu\n", windowid);
	///#else
	//    PRINT2("G%lu %i\n", windowid, getpid());
	///#endif
	///#endif // USE_MOUSE 
	//
	///#ifdef ULTRIX_KLUDGE
	//    fflush(X11_ipc);
	///#endif
	//
	//    if (encoding != last_encoding) {
	//	PRINT1("QE%d\n",encoding);
	//	last_encoding = encoding;
	//    }
	//
	///#if defined(USE_MOUSE) && defined(PIPE_IPC)
	// /* EAM June 2003 - Flush the set font command through the pipe */
	// /* to gnuplot_x11, then wait for it to return the resulting    */
	// /* font size information (v_char and h_char). The feedback is  */
	// /* caught by do_event() as an event of type GE_fontprops.      */
	//    if (ipc_back_fd >= 0 && X11_MOUSE_FEEDBACK) {
	//	if (!default_font_size_known) {
	//	    IPC_LOCK = TRUE;
	//	    PRINT1("QG%s\n",X11_default_font);
	//	    FFLUSH();
	//	    X11_waitforinput();
	//	    default_font_size_known = TRUE;
	//	    IPC_LOCK = FALSE;
	//	}
	//    }
	///#endif
	// /* Force default font at start of plot */
	//    *X11_last_font_used = '\01';
	//    X11_set_default_font();
	//    X11_set_font("");
	//}
	//
	//TERM_PUBLIC void
	//X11_text()
	//{
	//     if (!X11_ipc)
	// 	return;
	//
	///#ifdef USE_MOUSE
	// /* EAM July 2003:  send over a snapshot of the final axis scaling
	//  * so that subsequent mouse events can be transformed into plot
	//  * coordinates even though the plot is no longer active.
	//  */
	///#ifdef PIPE_IPC
	//    if (ipc_back_fd >= 0)
	///#endif
	//	{
	// /* Construct a mask showing which axes are active */
	//	int axis_mask = 0;
	//	int i;
	//
	//	for (i = FIRST_AXES; i < 2*SECOND_AXES; i++) {
	//	    if (axis_array[i].ticmode != NO_TICS)
	//		axis_mask |= (1 << i);
	//	}
	//	PRINT2("S %2d %d\n", -2, ALMOST2D);
	//	PRINT2("S %2d %d\n", -1, axis_mask);
	//	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", FIRST_X_AXIS,
	//		axis_array[FIRST_X_AXIS].min,
	//		axis_array[FIRST_X_AXIS].term_lower,
	//		axis_array[FIRST_X_AXIS].term_scale,
	//		axis_array[FIRST_X_AXIS].log ? axis_array[FIRST_X_AXIS].log_base : 0);
	//	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", FIRST_Y_AXIS,
	//		axis_array[FIRST_Y_AXIS].min,
	//		axis_array[FIRST_Y_AXIS].term_lower,
	//		axis_array[FIRST_Y_AXIS].term_scale,
	//		axis_array[FIRST_Y_AXIS].log ? axis_array[FIRST_Y_AXIS].log_base : 0);
	//	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", SECOND_X_AXIS,
	//		axis_array[SECOND_X_AXIS].min,
	//		axis_array[SECOND_X_AXIS].term_lower,
	//		axis_array[SECOND_X_AXIS].term_scale,
	//		axis_array[SECOND_X_AXIS].log ? axis_array[SECOND_X_AXIS].log_base : 0);
	//	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", SECOND_Y_AXIS,
	//		axis_array[SECOND_Y_AXIS].min,
	//		axis_array[SECOND_Y_AXIS].term_lower,
	//		axis_array[SECOND_Y_AXIS].term_scale,
	//		axis_array[SECOND_Y_AXIS].log ? axis_array[SECOND_Y_AXIS].log_base : 0);
	//    }
	///#endif
	//
	//    PRINT0("E\n");
	//    FFLUSH();
	///#ifdef ULTRIX_KLUDGE
	//    PRINT0("E\n");
	//    FFLUSH();
	///#endif
	//
	//    AFTER_TEXT;			// kludge for crippled select 
	//}
	//
	//TERM_PUBLIC void
	//X11_move(unsigned int x, unsigned int y)
	//{
	//    PRINT2("M%04d%04d\n", x, y);
	//}
	//
	//TERM_PUBLIC void
	//X11_vector(unsigned int x, unsigned int y)
	//{
	//    PRINT2("V%04d%04d\n", x, y);
	//}
	//
	//TERM_PUBLIC void
	//X11_pointsize(double ps)
	//{
	//    if (ps < 0)
	//	ps = 1;
	//    PRINT2("P-2 %d %d\n",	// size of point symbols 
	//	   (int) (term->h_tic * ps * 0.5), (int) (term->v_tic * ps * 0.5));
	//}
	//
	//TERM_PUBLIC void
	//X11_linewidth(double lw)
	//{
	//    PRINT1("W%04d\n", (int) (lw * X11_linewidth_multiplier + 0.5));
	//}
	//
	//TERM_PUBLIC void
	//X11_linetype(int lt)
	//{
	//    PRINT1("L%04d\n", lt);
	//}
	//
	//TERM_PUBLIC void
	//X11_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	// /* Only send the font change request to X11 if it really is a change */
	//    if (strcmp(X11_last_font_used,X11_next_font_used)) {
	//	strcpy(X11_last_font_used,X11_next_font_used);
	//	PRINT1("QF%s\n", X11_next_font_used);
	//    }
	//
	// /* badly outrange labels can overflow into text field */
	//    if (x < 10000 && y < 10000) {
	//	PRINT3("T%04d%04d%s\n", x, y, str);
	//    }
	//}
	//
	//TERM_PUBLIC int
	//X11_text_angle(int ang)
	//{
	//    PRINT1("A%d\n", ang);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int
	//X11_justify_text(enum JUSTIFY mode)
	//{
	//    PRINT1("J%04d\n", mode);
	//    X11_last_justification = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//X11_point(unsigned int x, unsigned int y, int number)
	//{
	//    PRINT3("P%d %d %d\n", number, x, y);
	//}
	//
	//TERM_PUBLIC int
	//X11_set_font(const char *fontname)
	//{
	//    PRINT1("QF%s\n", fontname?fontname:"");
	//    strncpy(X11_next_font_used,fontname?fontname:"",sizeof(X11_next_font_used)-1);
	//    return(TRUE);
	//}
	//
	//static void
	//X11_set_default_font()
	//{
	//    PRINT1("QD%s\n",X11_default_font);
	//}
	//
	//TERM_PUBLIC void
	//X11_fillbox(int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h)
	//{
	//    if (X11_ipc) {
	//	PRINT5("F%04d%04u%04u%04u%04u\n", style, x, y, w, h);
	//    }
	//}
	//
	///#ifdef USE_MOUSE
	//TERM_PUBLIC void
	//X11_put_tmptext(int i, const char str[])
	//{
	//    if (X11_ipc) {
	//	PRINT2("t%04d%s\n", i, str);
	//	FFLUSH();
	//    }
	//}
	//
	//TERM_PUBLIC void
	//X11_set_ruler(int x, int y)
	//{
	//    if (X11_ipc) {
	//	PRINT2("r%04d%04d\n", x < 9999 ? x : 9999, y < 9999 ? y : 9999);
	//	FFLUSH();
	//    }
	//}
	//
	//TERM_PUBLIC void
	//X11_set_cursor(int c, int x, int y)
	//{
	//    if (X11_ipc) {
	//	PRINT3("u%04d%04d%04d\n", c, x, y);
	//	FFLUSH();
	//    }
	//}
	//
	//TERM_PUBLIC void
	//X11_set_clipboard(const char s[])
	//{
	//    if (X11_ipc) {
	//	PRINT1("z%s\n", s);
	//	FFLUSH();
	//    }
	//}
	//
	///#endif // USE_MOUSE 
	//
	//
	//static void
	//transmit_gradient(gradient_struct *gradient, int cnt)
	//{
	//    int i = 0;
	//
	//    fprintf(X11_ipc, "%d", cnt);
	//    for(i=0; i<cnt; i++) {
	// /* this %50 *must* match the corresponding %50 in gplt_x11.c  */
	//        if(i%50 == 0) {
	//	    fputs("\n", X11_ipc);
	//	    fflush(X11_ipc);
	//	}
	//	fprintf(X11_ipc, "%s", gradient_entry_to_str(&(gradient[i])));
	//    }
	//    fputs("\n", X11_ipc);
	//}
	//
	//
	//TERM_PUBLIC int
	//X11_make_palette(t_sm_palette *palette)
	//{
	//    if(!palette) {
	//        return 0;
	//    }
	//
	//    if(!X11_ipc) {
	//	    fprintf(stderr, "(X11_make_palette) 0 == X11_ipc\n");
	//	    return -1;
	//	}
	//
	//    fprintf(X11_ipc, "%c %c %c %c %d\n",
	//	     X11_GR_MAKE_PALETTE, (char)(palette->colorMode),
	//	     (char)(palette->positive), (char)(palette->cmodel),
	//	     palette->use_maxcolors);
	//
	//    switch(palette->colorMode) {
	//    case SMPAL_COLOR_MODE_GRAY:
	//        fprintf(X11_ipc,"%g\n", palette->gamma);
	//        break;
	//    case SMPAL_COLOR_MODE_RGB:
	//        fprintf(X11_ipc, "%d %d %d\n", palette->formulaR,
	//		 palette->formulaG, palette->formulaB);
	//	break;
	//    case SMPAL_COLOR_MODE_GRADIENT:
	//        transmit_gradient(palette->gradient, palette->gradient_num);
	//	break;
	//    case SMPAL_COLOR_MODE_FUNCTIONS: {
	//        int cnt=0;
	//	gradient_struct *gradient;
	//	gradient = approximate_palette(palette, -1, -1, &cnt);
	//	transmit_gradient(gradient, cnt);
	//	free(gradient);
	//	break;
	//    }
	//    default:
	//        fprintf(stderr, "%s:%d ooops: Unknown colorMode '%c'.\n",
	//		 __FILE__, __LINE__, (char)(palette->colorMode));
	//    }
	//    fflush(X11_ipc);
	//    return 0;
	//}
	//
	//
	///#if 0
	// /* The following are some handy little routines to keep around
	//  * in case one wants to do statistics on the binary data being
	//  * passed to a terminal function.
	//  */
	//
	//int char_count[256];
	//
	//void histogram(unsigned char c) {
	//    char_count[c] += 1;
	//}
	//
	//void dump_histogram(void) {
	//  int i, sum;
	//  fprintf(stderr,"\n\n");
	//  for (i=0,sum=0; i<256; i++) {
	//    fprintf(stderr," %3.3d:%7.7d ", i, char_count[i]);
	//    sum += char_count[i];
	//  }
	//  fprintf(stderr,"\n\ntotal: %d\n\n",sum);
	//}
	///#endif
	//
	//TERM_PUBLIC void
	//X11_set_color(t_colorspec *colorspec)
	//{
	//    if (colorspec->type == TC_RGB) {
	//	fputc(X11_GR_SET_RGBCOLOR, X11_ipc);
	//	PRINT1("%6.6x\n", colorspec->lt);
	//	FFLUSH();
	//	return;
	//    }
	//
	//    if (colorspec->type == TC_LT) {
	//	fputc(X11_GR_SET_LINECOLOR, X11_ipc);
	//	PRINT1("%4d\n", colorspec->lt);
	//	FFLUSH();
	//	return;
	//    }
	//
	//    if (colorspec->type != TC_FRAC)
	//	return;
	//
	//    {
	//    char *c_ptr;
	//    unsigned short byte_remaining;
	//    float fgray = colorspec->value;
	//
	//    fputc(X11_GR_BINARY_COLOR, X11_ipc);
	//    byte_remaining = sizeof(fgray);
	//    c_ptr = (char *) &fgray;
	//
	//    while (byte_remaining) {
	//
	//	char c_tmp = *c_ptr++ - SET_COLOR_TRANSLATION_CHAR;
	//
	//	byte_remaining--;
	//
	//	if ( (c_tmp == '\n') || (c_tmp == SET_COLOR_CODE_CHAR) || (c_tmp == '\0') ) {
	//	    fputc(SET_COLOR_CODE_CHAR, X11_ipc);
	//	    c_tmp += 1;
	//	}
	//	fputc(c_tmp, X11_ipc);
	//
	//    }
	//
	//    fputc('\n', X11_ipc);
	//    FFLUSH();
	//    }
	//
	//}
	//
	//TERM_PUBLIC void
	//X11_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int int_cache[2];
	//    int i_corner;
	//    unsigned short i_buffer;
	//    unsigned short byte_remaining;
	//    unsigned int point_remaining;
	//
	// /* Encode and transfer data to the pipe, one character at a time. */
	//
	//    if (!points) return;
	//
	//    fputc(X11_GR_BINARY_POLYGON, X11_ipc);
	//    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//
	// /* First put number of points into the buffer.  Initialize the "cache"
	//  * to the number of points and the number of bytes to transfer to the
	//  * size of an int.  This will be the first transfer, so increase the
	//  * number of points by one.
	//  */
	//    int_cache[0] = points;
	//    int_cache[1] = corners->style;
	//    byte_remaining = 2*sizeof(int_cache[0]);
	//    point_remaining = points + 1;
	//    i_corner = 0;
	//
	//    while (point_remaining) {
	//
	//	unsigned char *uc_ptr = (unsigned char *) int_cache;
	//
	//	while (byte_remaining) {
	//
	//	    int sent_val;
	//
	//	    unsigned char uc_tmp = *uc_ptr++ - FILLED_POLYGON_TRANSLATION_CHAR;
	//	    byte_remaining--;
	//
	//	    if ( (uc_tmp == '\n') || (uc_tmp == FILLED_POLYGON_CODE_CHAR) || (uc_tmp == '\0') ) {
	//		uc_tmp += 1;
	//		sent_val = fputc(FILLED_POLYGON_CODE_CHAR, X11_ipc);
	//		if (sent_val != (int)FILLED_POLYGON_CODE_CHAR)
	//		    fprintf(stderr, "Bad character mapping %d -> %d\n", (int)FILLED_POLYGON_CODE_CHAR, sent_val);
	//		i_buffer--;
	//		if (!i_buffer) {
	//		    fputc('\n', X11_ipc);  FFLUSH();               // End of chunk. 
	//		    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//		    fputc(X11_GR_BINARY_POLYGON, X11_ipc);         // Will be another chunk. 
	//		}
	//	    }
	//
	//	    sent_val = fputc(uc_tmp, X11_ipc);
	//	    if (sent_val != (int)uc_tmp)
	//		fprintf(stderr, "Bad character mapping %d -> %d\n", (int)uc_tmp, sent_val);
	//	    i_buffer--;
	//	    if (!i_buffer) {
	//		fputc('\n', X11_ipc);  FFLUSH();                   // End of chunk. 
	//		i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//		if (point_remaining || byte_remaining)
	//		    fputc(X11_GR_BINARY_POLYGON, X11_ipc);         // Will be another chunk. 
	//	    }
	//
	//	}
	//
	//	byte_remaining = 2*sizeof(int);
	//	if (--point_remaining) {
	//	    int_cache[0] = corners[i_corner].x;
	//	    int_cache[1] = corners[i_corner].y;
	//	    i_corner++;
	//	}
	//    }
	//
	// /* Check if some characters were put in the buffer that need to be flushed. */
	//    if (i_buffer != BINARY_MAX_CHAR_PER_TRANSFER) {
	//	fputc('\n', X11_ipc);
	//	FFLUSH();
	//    }
	//
	//    return;
	//}
	//
	//
	// /*
	//  * Ethan A Merritt November 2003
	//  *	- Support for enhanced text mode
	//  *
	//  * PROBLEMS:
	//  *	- The default font must be scalable
	//  *	- Without more feedback from the outboard driver (gnuplot_x11) it is
	//  *	  hard to set up proper text rotation. The current approximation is so-so.
	//  *	- Right- and Center- justified text is problematic for the same reason.
	//  *	- The default font size is not really known, and font scaling
	//  *	  in general could be improved
	//  */
	//
	//static TBOOLEAN ENHx11_opened_string;
	//static TBOOLEAN ENHx11_sizeonly = FALSE;
	//static TBOOLEAN ENHx11_show = TRUE;
	//static int ENHx11_overprint = 0;
	//static TBOOLEAN ENHx11_widthflag = TRUE;
	//static double ENHx11_base;
	//static double ENHx11_fontsize;
	//static char  *ENHx11_font;
	//
	//TERM_PUBLIC void
	//ENHX11_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* If the overprint code requests a save or request, that's all we do */
	//    if (overprint == 3) {
	//	PRINT2("Tp%04d%04d\n", 0, 0);
	//	return;
	//    } else if (overprint == 4) {
	//	PRINT2("Tr%04d%04d\n", 0, 0);
	//	return;
	//    }
	//
	//    if (!ENHx11_opened_string) {
	//	ENHx11_opened_string = TRUE;
	//	enhanced_cur_text = &enhanced_text[0];
	//	ENHx11_font = fontname;
	//	ENHx11_fontsize = fontsize;
	//	ENHx11_base = base * 10;	// FIXME - should this be v_char? v_tic? 
	//	ENHx11_show = showflag;
	//	ENHx11_overprint = overprint;
	//	ENHx11_widthflag = widthflag;
	//    }
	//}
	//
	// /*
	//  * Write a string fragment and update current position.
	//  * We leave the real work up to gnuplot_x11!
	//  */
	//TERM_PUBLIC void
	//ENHX11_FLUSH()
	//{
	// /* Send a command to print this string at current position */
	//    if (ENHx11_opened_string) {
	//
	//	char tmpfont[128];	// FIXME - there must be a better way! 
	//	*enhanced_cur_text = '\0';
	//	sprintf(tmpfont,"%s,%.1f", ENHx11_font, ENHx11_fontsize);
	//	PRINT1("QF%s\n", tmpfont);
	//	*X11_last_font_used = '\01';
	//
	//	if (!ENHx11_show || ENHx11_sizeonly)
	//	    PRINT3("Ts%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
	//	else if (ENHx11_overprint == 1)
	//	    PRINT3("Tc%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
	//	else if (!ENHx11_widthflag && ENHx11_overprint != 0)
	//	    PRINT3("To%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
	//	else
	//	    PRINT3("Tu%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
	//
	//	ENHx11_opened_string = FALSE;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHX11_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char *original_string = (char *)str;
	//    static char *initial_font = NULL;
	//    int pass = 1;
	//
	//    if (ignore_enhanced_text) {
	//	X11_put_text(x,y,str);
	//	return;
	//    }
	//
	//    if (!strlen(str))
	//	return;
	//
	// /* if there are no magic characters, we should just be able
	//  * punt the string to X11_put_text()
	//  */
	//    if (!strpbrk(str, "{}^_@&~")) {
	//	X11_put_text(x,y,str);
	//	return;
	//    }
	//
	// /* set up the global variables needed by enhanced_recursion() */
	//    enhanced_fontscale = 1.25;
	//    ENHx11_opened_string = FALSE;
	//    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
	//
	//
	// /* Tell gnuplot_x11 to set the current position to (x,y) */
	//	PRINT2("Tl%04d%04d\n", x, y);
	//
	// /* Text justification requires two passes. During the first pass we */
	// /* don't draw anything, we just measure the space it will take.     */
	//    if (X11_last_justification != LEFT) {
	//	PRINT1("J%04d\n", LEFT);
	//	ENHx11_sizeonly = TRUE;
	//    }
	//PASS2:
	//
	// /* Make sure that we start out using the intended font.  */
	//	ENHx11_font = "DEFAULT";
	//	ENHx11_fontsize = X11_default_fontsize;
	//	if (*X11_next_font_used) {
	//	    int sep = strcspn(X11_next_font_used,",");
	//	    free(initial_font);
	//	    initial_font = gp_strdup(X11_next_font_used);
	//	    initial_font[sep] = '\0';
	//	    sscanf(&(X11_next_font_used[sep+1]),"%lf",&ENHx11_fontsize);
	//	    ENHx11_font = initial_font;
	//	    FPRINTF((stderr,"setting font to %s,%g\n",ENHx11_font,ENHx11_fontsize));
	//	}
	//
	// /* Set the recursion going. We say to keep going until a
	//  * closing brace, but we don't really expect to find one.
	//  * If the return value is not the nul-terminator of the
	//  * string, that can only mean that we did find an unmatched
	//  * closing brace in the string. We increment past it (else
	//  * we get stuck in an infinite loop) and try again.
	//  */
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//			ENHx11_font, ENHx11_fontsize,
	//			0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//
	// /* I think we can only get here if *str == '}' */
	//	    enh_err_check(str);
	//
	//	if (!*++str)
	//	    break; // end of string 
	//
	// /* else carry on and process the rest of the string */
	//    }
	//
	// /* Restore text justification flag after 2nd pass */
	//    if (pass > 1) {
	//	PRINT1("J%04d\n", X11_last_justification);
	//	return;
	//    }
	//
	// /* In order to do text justification we need to do a second pass that */
	// /* uses information stored by gnuplot_x11 during the first pass.      */
	//    if (X11_last_justification != LEFT) {
	//	ENHx11_sizeonly = FALSE;
	//
	//	if (X11_last_justification == RIGHT) {
	//		PRINT2("Tj%04d%04d\n", x, y);
	//	} else if (X11_last_justification == CENTRE) {
	//		PRINT2("Tk%04d%04d\n", x, y);
	//	}
	//	str = original_string;
	//	pass = 2;
	//	goto PASS2;
	//
	//    }
	//
	//}
	//
	//
	//TERM_PUBLIC void
	//X11_send_endianess(void)
	//{
	// /* Place an integer 1 in the pipe and see if the byte order agrees
	//  * with program on the other side.  Information used for routines
	//  * having encoded binary data.
	//  */
	//    unsigned short tmp = (unsigned short) ENDIAN_VALUE;
	//    fputc(X11_GR_CHECK_ENDIANESS, X11_ipc);
	//    fputc(((char *)&tmp)[0], X11_ipc);
	//    fputc(((char *)&tmp)[1], X11_ipc);
	//    fputc('\n', X11_ipc);
	//    fflush(X11_ipc);
	//}
	//
	//
	//TERM_PUBLIC void
	//X11_image(unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
	//{
	//
	// /* Avoid using floats or formatted I/O.  That's too slow for image data.
	//  *
	//  * To avoid using floats, we assume that the maximum resolution of the
	//  * color plane of the x11 device is 16 bits.  (Not an unreasonable
	//  * assumption.)  So we convert coordval to unsigned short and then
	//  * send those.  The driver then shifts these unsigned short values to
	//  * the right to match the size of its palette.
	//  *
	//  * The driver uses the '\n' character to mean end of command.  When the
	//  * core routine sees the '\n', it stops copying the remaining characters
	//  * that are in the buffer.  Therefore, we need to hide the '\n' character
	//  * from the data stream.  We also need to hide the '\0' because the core
	//  * routine also does an 'strcpy'.  So the scheme is as follows:
	//  *
	//  *   On the driver side, if the char CODE_WORD is found it
	//  *   should be ignored and replaced with the char that
	//  *   follows it, but subtract one from that value.
	//  *
	//  * This means that there exists the chance of the data stream enlarging
	//  * by a factor of two.  So the algorithm must make sure to keep the
	//  * number of bytes transfered less than the buffer length.
	//  *
	//  * Also note that the '\0' character is often prevalent in 16 bit image
	//  * data where the palette may be 8 bits or less.  For this reason, a
	//  * translation is first done on the character to make the '\0' occur less
	//  * often.  In this way, less amount of data is sent and fewer command
	//  * lines are used to store an image.
	//  */
	//
	//    unsigned short i_buffer;
	//    unsigned int coord_remaining;
	//    coordval *coord_ptr;
	//
	// /* Use formatted I/O to transfer image information.  Hexadecimal uses less characters.
	//  *
	//  * Note that X11 has different frame of reference (top left origin) than does Gnuplot
	//  * (bottom left origin)
	//  */
	//    fputc(X11_GR_IMAGE, X11_ipc);
	//    fprintf(X11_ipc,"%x %x %x %x %x %x %x %x %x %x %x\n", M, N, corner[0].x, corner[0].y, corner[1].x,
	//      corner[1].y, corner[2].x, corner[2].y, corner[3].x, corner[3].y, color_mode);
	//    FFLUSH();
	//
	// /* Encode and transfer data to the pipe, one character at a time. */
	//
	//    coord_remaining = M*N;
	//    if (color_mode == IC_RGB)
	//	coord_remaining *= 3;
	//    else if (color_mode == IC_RGBA)
	//	coord_remaining *= 4;
	//
	//    if (!coord_remaining) return;
	//
	//    fputc(X11_GR_IMAGE, X11_ipc);
	//    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//    coord_ptr = image;
	//
	//    while (coord_remaining) {
	//
	//	unsigned short us_tmp;
	//	unsigned short byte_remaining;
	//	unsigned char *uc_ptr;
	//
	// /* Convert coordinate value to an unsigned short.
	//  * Palette and RGB values are on scale [0:1] at this point,
	//  * but alpha values run from [0:255].  Why? I don't know.
	//  */
	//	if (color_mode == IC_RGBA && !((coord_remaining+3) % 4))
	//	    us_tmp = (*coord_ptr++);
	//	else
	//	    us_tmp = (unsigned short) ((*coord_ptr++)*IMAGE_PALETTE_VALUE_MAX + 0.5);
	//	coord_remaining--;
	//
	//	byte_remaining = sizeof(us_tmp);
	//	uc_ptr = (unsigned char *) &us_tmp;
	//
	//	while (byte_remaining) {
	//
	//	    int sent_val;
	//
	//	    unsigned char uc_tmp = *uc_ptr++ - IMAGE_TRANSLATION_CHAR;
	//	    byte_remaining--;
	//
	//	    if ((uc_tmp == '\n') || (uc_tmp == IMAGE_CODE_CHAR) || (uc_tmp == '\0') ) {
	//		uc_tmp += 1;
	//		sent_val = fputc(IMAGE_CODE_CHAR, X11_ipc);
	//		if (sent_val != (int)IMAGE_CODE_CHAR)
	//		    fprintf(stderr, "Bad character mapping %d -> %d\n", (int)IMAGE_CODE_CHAR, sent_val);
	//		i_buffer--;
	//		if (!i_buffer) {
	//		    fputc('\n', X11_ipc);  FFLUSH();               // End of chunk. 
	//		    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//		    fputc(X11_GR_IMAGE, X11_ipc);                  // Will be another chunk. 
	//		}
	//	    }
	//
	//	    sent_val = fputc(uc_tmp, X11_ipc);
	//	    if (sent_val != (int)uc_tmp)
	//		fprintf(stderr, "Bad character mapping %d -> %d\n", (int)uc_tmp, sent_val);
	//	    i_buffer--;
	//	    if (!i_buffer) {
	//		fputc('\n', X11_ipc);  FFLUSH();                   // End of chunk. 
	//		i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
	//		if (coord_remaining || byte_remaining)
	//		    fputc(X11_GR_IMAGE, X11_ipc);                  // Will be another chunk. 
	//	    }
	//
	//	}
	//
	//    }
	//
	// /* Check if some characters were put in the buffer that need to be flushed. */
	//    if (i_buffer != BINARY_MAX_CHAR_PER_TRANSFER) {fputc('\n', X11_ipc);  FFLUSH();}
	//
	//    return;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(x11_driver)
	//    "x11", "X11 Window System",
	//    X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR,
	//    X11_VTIC, X11_HTIC, X11_options, X11_init, X11_reset,
	//    X11_text, null_scale, X11_graphics, X11_move, X11_vector,
	//    X11_linetype, X11_put_text, X11_text_angle,
	//    X11_justify_text, X11_point, do_arrow, X11_set_font,
	//    X11_pointsize, 
	//    TERM_CAN_MULTIPLOT|TERM_INIT_ON_REPLOT|TERM_NO_OUTPUTFILE|TERM_CAN_DASH|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
	//    X11_text // suspend can use same routine 
	// , 0 // resume 
	// ,
	//    X11_fillbox, X11_linewidth
	///#ifdef USE_MOUSE
	//    , X11_waitforinput, X11_put_tmptext, X11_set_ruler, X11_set_cursor, X11_set_clipboard
	///#endif
	//    , X11_make_palette, 0 // X11_previous_palette 
	// ,
	//    X11_set_color, X11_filled_polygon
	//    , X11_image
	//    , ENHX11_OPEN, ENHX11_FLUSH, do_enh_writec
	//TERM_TABLE_END(x11_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM x11_driver
	//
	///#endif				// TERM_TABLE 
	///#endif				// TERM_PROTO_ONLY 


	///#ifdef TERM_HELP
	//START_HELP(x11)
	//"1 x11",
	//"?commands set terminal x11",
	//"?set terminal x11",
	//"?set term x11",
	//"?terminal x11",
	//"?term x11",
	//"?x11",
	//"?X11",
	//" `gnuplot` provides the `x11` terminal type for use with X servers.  This",
	//" terminal type is set automatically at startup if the `DISPLAY` environment",
	//" variable is set, if the `TERM` environment variable is set to `xterm`, or",
	//" if the `-display` command line option is used.",
	//"",
	//" Syntax:",
	//"    set terminal x11 {<n> | window \"<string>\"}",
	//"                     {title \"<string>\"}",
	//"                     {{no}enhanced} {font <fontspec>}",
	//"                     {linewidth LW} {solid|dashed}",
	//"                     {{no}persist} {{no}raise} {{no}ctrlq}",
	//"                     {close}",
	//"                     {size XX,YY} {position XX,YY}",
	//"    set terminal x11 {reset}",
	//"",
	//" Multiple plot windows are supported: `set terminal x11 <n>` directs the",
	//" output to plot window number n.  If n is not 0, the terminal number will be",
	//" appended to the window title (unless a title has been supplied manually)",
	//" and the icon will be labeled `Gnuplot <n>`.  The active window may be",
	//" distinguished by a change in cursor (from default to crosshair).",
	//"",
	//" The `x11` terminal can connect to X windows previously created by an outside",
	//" application via the option `window` followed by a string containing the",
	//" X ID for the window in hexadecimal format.  Gnuplot uses that external X",
	//" window as a container since X does not allow for multiple clients selecting",
	//" the ButtonPress event.  In this way, gnuplot's mouse features work within",
	//" the contained plot window.",
	//"",
	//"    set term x11 window \"220001e\"",
	//"",
	//" The x11 terminal supports enhanced text mode (see `enhanced`), subject",
	//" to the available fonts. In order for font size commands embedded in text",
	//" to have any effect, the default x11 font must be scalable. Thus the first",
	//" example below will work as expected, but the second will not.",
	//"",
	//"    set term x11 enhanced font \"arial,15\" ",
	//"    set title '{/=20 Big} Medium {/=5 Small}' ",
	//"",
	//"    set term x11 enhanced font \"terminal-14\" ",
	//"    set title '{/=20 Big} Medium {/=5 Small}' ",
	//"",
	//" Plot windows remain open even when the `gnuplot` driver is changed to a",
	//" different device.  A plot window can be closed by pressing the letter q",
	//" while that window has input focus, or by choosing `close` from a window",
	//" manager menu.  All plot windows can be closed by specifying `reset`, which",
	//" actually terminates the subprocess which maintains the windows (unless",
	//" `-persist` was specified).  The `close` command can be used to close",
	//" individual plot windows by number.  However, after a `reset`, those plot",
	//" windows left due to persist cannot be closed with the command `close`.",
	//" A `close` without a number closes the current active plot window.",
	//"",
	//" The gnuplot outboard driver, gnuplot_x11, is searched in a default place",
	//" chosen when the program is compiled.  You can override that by defining",
	//" the environment variable GNUPLOT_DRIVER_DIR to point to a different",
	//" location.",
	//"",
	//" Plot windows will automatically be closed at the end of the session",
	//" unless the `-persist` option was given.",
	//"",
	//" The options `persist` and `raise` are unset by default, which means that",
	//" the defaults (persist == no and raise == yes) or the command line options",
	//" -persist / -raise or the Xresources are taken.  If [no]persist or",
	//" [no]raise are specified, they will override command line options and",
	//" Xresources.  Setting one of these options takes place immediately, so",
	//" the behaviour of an already running driver can be modified.  If the window",
	//" does not get raised, see discussion in `raise`.",
	//"",
	//" The option `title \"<title name>\"` will supply the title name of the window",
	//" for the current plot window or plot window <n> if a number is given.",
	//" Where (or if) this title is shown depends on your X window manager.",
	//"",
	//" The size option can be used to set the size of the plot window.  The",
	//" size option will only apply to newly created windows.",
	//"",
	//" The position option can be used to set the position of the plot window.  The",
	//" position option will only apply to newly created windows.",
	//"",
	//" The size or aspect ratio of a plot may be changed by resizing the `gnuplot`",
	//" window.",
	//"",
	//" Linewidths and pointsizes may be changed from within `gnuplot` with",
	//" `set linestyle`.",
	//"",
	//" For terminal type `x11`, `gnuplot` accepts (when initialized) the standard",
	//" X Toolkit options and resources such as geometry, font, and name from the",
	//" command line arguments or a configuration file.  See the X(1) man page",
	//" (or its equivalent) for a description of such options.",
	//"",
	//"=X resources",
	//" A number of other `gnuplot` options are available for the `x11` terminal.",
	//" These may be specified either as command-line options when `gnuplot` is",
	//" invoked or as resources in the configuration file \".Xdefaults\".  They are",
	//" set upon initialization and cannot be altered during a `gnuplot` session.",
	//" (except `persist` and `raise`)",
	//"2 x11_fonts",
	//"?commands set terminal x11 x11_fonts",
	//"?set terminal x11 x11_fonts",
	//"?set term x11 x11_fonts",
	//"?x11 x11_fonts",
	//"?x11_fonts",
	//"=fonts",
	//" Upon initial startup, the default font is taken from the X11 resources",
	//" as set in the system or user .Xdefaults file or on the command line.",
	//"",
	//" Example:",
	//"       gnuplot*font: lucidasans-bold-12",
	//" A new default font may be specified to the x11 driver from inside",
	//" gnuplot using",
	//"      `set term x11 font \"<fontspec>\"`",
	//" The driver first queries the X-server for a font of the exact name given.",
	//" If this query fails, then it tries to interpret <fontspec> as",
	//" \"<font>,<size>,<slant>,<weight>\" and to construct a full X11 font name",
	//" of the form",
	//"       -*-<font>-<weight>-<s>-*-*-<size>-*-*-*-*-*-<encoding>",
	//"",
	//"  <font> is the base name of the font (e.g. Times or Symbol)",
	//"  <size> is the point size (defaults to 12 if not specified)",
	//"  <s> is `i` if <slant>==\"italic\" `o` if <slant>==\"oblique\" `r` otherwise",
	//"  <weight> is `medium` or `bold` if explicitly requested, otherwise `*`",
	//"  <encoding> is set based on the current character set (see `set encoding`).",
	//" So `set term x11 font \"arial,15,italic\"` will be translated to",
	//" -*-arial-*-i-*-*-15-*-*-*-*-*-iso8859-1 (assuming default encoding).",
	//" The <size>, <slant>, and <weight> specifications are all optional.",
	//" If you do not specify <slant> or <weight> then you will get whatever font ",
	//" variant the font server offers first.",
	//" You may set a default enconding via the corresponding X11 resource. E.g.",
	//"       gnuplot*encoding: iso8859-15",
	//" The driver also recognizes some common PostScript font names and",
	//" replaces them with possible X11 or TrueType equivalents.",
	//" This same sequence is used to process font requests from `set label`.",
	//"",
	//" If your gnuplot was built with configuration option --enable-x11-mbfonts,",
	//" you can specify multi-byte fonts by using the prefix \"mbfont:\" on the font",
	//" name. An additional font may be given, separated by a semicolon.",
	//" Since multi-byte font encodings are interpreted according to the locale",
	//" setting, you must make sure that the environmental variable LC_CTYPE is set",
	//" to some appropriate locale value such as ja_JP.eucJP, ko_KR.EUC, or zh_CN.EUC.",
	//"",
	//" Example:",
	//"       set term x11 font 'mbfont:kana14;k14'",
	//"             # 'kana14' and 'k14' are Japanese X11 font aliases, and ';'",
	//"             # is the separator of font names.",
	//"       set term x11 font 'mbfont:fixed,16,r,medium'",
	//"             # <font>,<size>,<slant>,<weight> form is also usable.",
	//"       set title '(mb strings)' font 'mbfont:*-fixed-medium-r-normal--14-*'",
	//"",
	//" The same syntax applies to the default font in Xresources settings,",
	//" for example,", 
	//"       gnuplot*font: \\",
	//"           mbfont:-misc-fixed-medium-r-normal--14-*-*-*-c-*-jisx0208.1983-0",
	//"",
	//" If gnuplot is built with --enable-x11-mbfonts, you can use two special",
	//" PostScript font names 'Ryumin-Light-*' and 'GothicBBB-Medium-*' (standard",
	//" Japanese PS fonts) without the prefix \"mbfont:\".",
	//"", 
	//"2 command-line_options",
	//"?commands set terminal x11 command-line-options",
	//"?set terminal x11 command-line-options",
	//"?set term x11 command-line-options",
	//"?x11 command-line-options",
	//"?command-line-options",
	//" In addition to the X Toolkit options, the following options may be specified",
	//" on the command line when starting `gnuplot` or as resources in your",
	//" \".Xdefaults\" file (note that `raise` and `persist` can be overridden",
	//" later by `set term x11 [no]raise [no]persist)`:",
	//"@start table - first is interactive cleartext form",
	//"  `-mono`     forces monochrome rendering on color displays.",
	//"  `-gray`     requests grayscale rendering on grayscale or color displays.",
	//"              (Grayscale displays receive monochrome rendering by default.)",
	//"  `-clear`    requests that the window be cleared momentarily before a",
	//"              new plot is displayed.",
	//"  `-tvtwm`    requests that geometry specifications for position of the",
	//"              window be made relative to the currently displayed portion",
	//"              of the virtual root.",
	//"  `-raise`    raises plot window after each plot",
	//"  `-noraise`  does not raise plot window after each plot",
	///#ifdef USE_MOUSE
	//"  `-noevents` does not process mouse and key events",
	//"  `-ctrlq   ` closes window on ctrl-q rather than q",
	///#endif
	//"  `-persist`  plot windows survive after main gnuplot program exits",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#`-mono`     & forces monochrome rendering on color displays.\\\\",
	//"#`-gray`     & requests grayscale rendering on grayscale or color displays.\\\\",
	//"#            & (Grayscale displays receive monochrome rendering by default.) \\\\",
	//"#`-clear`    & requests that the window be cleared momentarily before a\\\\",
	//"#            & new plot is displayed. \\\\",
	//"#`-tvtwm`    & requests that geometry specifications for position of the\\\\",
	//"#            & window be made relative to the currently displayed portion\\\\",
	//"#            & of the virtual root. \\\\",
	//"#`-raise`    & raises plot window after each plot. \\\\",
	//"#`-noraise`  & does not raise plot window after each plot. \\\\",
	///#ifdef USE_MOUSE
	//"#`-noevents` & does not process mouse and key events. \\\\",
	///#endif
	//"#`-persist`  & plot windows survive after main gnuplot program exits. \\\\",
	//"%c l .",
	//"%`-mono`@forces monochrome rendering on color displays.",
	//"%`-gray`@requests grayscale rendering on grayscale or color displays.",
	//"%       @(Grayscale displays receive monochrome rendering by default.)",
	//"%`-clear`@requests that the window be cleared momentarily before a",
	//"%        @new plot is displayed.",
	//"%`-tvtwm`@requests that geometry specifications for position of the",
	//"%        @window be made relative to the currently displayed portion",
	//"%        @of the virtual root.",
	//"%`-raise`@raises plot window after each plot",
	//"%`-noraise`@does not raise plot window after each plot",
	///#ifdef USE_MOUSE
	//"%`-novevents`@does not process mouse and key events",
	//"%`-ctrlq`@closes window on ctrl-q rather than q",
	///#endif
	//"%`-persist`@plot windows survive after main gnuplot program exits",
	//"@end table",
	//"=X resources",
	//" The options are shown above in their command-line syntax.  When entered as",
	//" resources in \".Xdefaults\", they require a different syntax.",
	//"",
	//" Example:",
	//"       gnuplot*gray:  on",
	//"       gnuplot*ctrlq: on",
	//"",
	//" `gnuplot` also provides a command line option (`-pointsize <v>`) and a",
	//" resource, `gnuplot*pointsize: <v>`, to control the size of points plotted",
	//" with the `points` plotting style.  The value `v` is a real number (greater",
	//" than 0 and less than or equal to ten) used as a scaling factor for point",
	//" sizes.  For example, `-pointsize 2` uses points twice the default size, and",
	//" `-pointsize 0.5` uses points half the normal size.",
	//"",
	//" The `-noevents` switch disables all mouse and key event processing (except",
	//" for `q` and `<space>` for closing the window). This is useful for programs",
	//" which use the x11 driver independent of the gnuplot main program.",
	//"",
	//" The `-ctrlq` switch changes the hot-key that closes a plot window from `q`",
	//" to `<ctrl>q`. This is useful is you are using the keystroke-capture feature",
	//" `pause mouse keystroke`, since it allows the character `q` to be captured",
	//" just as all other alphanumeric characters. The `-ctrlq` switch similarly",
	//" replaces the <space> hot-key with <ctrl><space> for the same reason.",
	//"",
	//"2 monochrome_options",
	//"?commands set terminal x11 monochrome_options",
	//"?set terminal x11 monochrome_options",
	//"?set term x11 monochrome_options",
	//"?x11 monochrome_options",
	//"?monochrome_options",
	//"=X resources",
	//" For monochrome displays, `gnuplot` does not honor foreground or background",
	//" colors.  The default is black-on-white.  `-rv` or `gnuplot*reverseVideo: on`",
	//" requests white-on-black.",
	//"",
	//"2 color_resources",
	//"?commands set terminal x11 color_resources",
	//"?set terminal x11 color_resources",
	//"?set term x11 color_resources",
	//"?x11 color_resources",
	//"?color_resources",
	//"=X resources",
	//" The X11 terminal honors the following resources (shown here with their",
	//" default values) or the greyscale resources.  The values may be color names",
	//" as listed in the X11 rgb.txt file on your system, hexadecimal RGB color",
	//" specifications (see X11 documentation), or a color name followed by a comma",
	//" and an `intensity` value from 0 to 1.  For example, `blue, 0.5` means a half",
	//" intensity blue.",
	//"@start table - first is interactive cleartext form",
	//"  gnuplot*background:  white",
	//"  gnuplot*textColor:   black",
	//"  gnuplot*borderColor: black",
	//"  gnuplot*axisColor:   black",
	//"  gnuplot*line1Color:  red",
	//"  gnuplot*line2Color:  green",
	//"  gnuplot*line3Color:  blue",
	//"  gnuplot*line4Color:  magenta",
	//"  gnuplot*line5Color:  cyan",
	//"  gnuplot*line6Color:  sienna",
	//"  gnuplot*line7Color:  orange",
	//"  gnuplot*line8Color:  coral",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*background: white\\\\",
	//"#&gnuplot*textColor: black\\\\",
	//"#&gnuplot*borderColor: black\\\\",
	//"#&gnuplot*axisColor: black\\\\",
	//"#&gnuplot*line1Color: red\\\\",
	//"#&gnuplot*line2Color: green\\\\",
	//"#&gnuplot*line3Color: blue\\\\",
	//"#&gnuplot*line4Color: magenta\\\\",
	//"#&gnuplot*line5Color: cyan\\\\",
	//"#&gnuplot*line6Color: sienna\\\\",
	//"#&gnuplot*line7Color: orange\\\\",
	//"#&gnuplot*line8Color: coral\\\\",
	//"%c l .",
	//"%@gnuplot*background: white",
	//"%@gnuplot*textColor: black",
	//"%@gnuplot*borderColor: black",
	//"%@gnuplot*axisColor: black",
	//"%@gnuplot*line1Color: red",
	//"%@gnuplot*line2Color: green",
	//"%@gnuplot*line3Color: blue",
	//"%@gnuplot*line4Color: magenta",
	//"%@gnuplot*line5Color: cyan",
	//"%@gnuplot*line6Color: sienna",
	//"%@gnuplot*line7Color: orange",
	//"%@gnuplot*line8Color: coral",
	//"@end table",
	//"",
	//" The command-line syntax for these is simple only for background,",
	//" which maps directly to the usual X11 toolkit option \"-bg\".  All",
	//" others can only be set on the command line by use of the generic",
	//" \"-xrm\" resource override option",
	//"",
	//" Examples:",
	//"",
	//"       gnuplot -background coral",
	//" to change the background color.",
	//"",
	//"       gnuplot -xrm 'gnuplot*line1Color:blue'",
	//" to override the first linetype color.",
	//"",
	//"2 grayscale_resources",
	//"?commands set terminal x11 grayscale_resources",
	//"?set terminal x11 grayscale_resources",
	//"?set term x11 grayscale_resources",
	//"?x11 grayscale_resources",
	//"?grayscale_resources",
	//"=X resources",
	//" When `-gray` is selected, `gnuplot` honors the following resources for",
	//" grayscale or color displays (shown here with their default values).  Note",
	//" that the default background is black.",
	//"@start table - first is interactive cleartext form",
	//"  gnuplot*background: black",
	//"  gnuplot*textGray:   white",
	//"  gnuplot*borderGray: gray50",
	//"  gnuplot*axisGray:   gray50",
	//"  gnuplot*line1Gray:  gray100",
	//"  gnuplot*line2Gray:  gray60",
	//"  gnuplot*line3Gray:  gray80",
	//"  gnuplot*line4Gray:  gray40",
	//"  gnuplot*line5Gray:  gray90",
	//"  gnuplot*line6Gray:  gray50",
	//"  gnuplot*line7Gray:  gray70",
	//"  gnuplot*line8Gray:  gray30",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*background: black\\\\",
	//"#&gnuplot*textGray: white\\\\",
	//"#&gnuplot*borderGray: gray50\\\\",
	//"#&gnuplot*axisGray: gray50\\\\",
	//"#&gnuplot*line1Gray: gray100\\\\",
	//"#&gnuplot*line2Gray: gray60\\\\",
	//"#&gnuplot*line3Gray: gray80\\\\",
	//"#&gnuplot*line4Gray: gray40\\\\",
	//"#&gnuplot*line5Gray: gray90\\\\",
	//"#&gnuplot*line6Gray: gray50\\\\",
	//"#&gnuplot*line7Gray: gray70\\\\",
	//"#&gnuplot*line8Gray: gray30\\\\",
	//"%c l .",
	//"%@gnuplot*background: black",
	//"%@gnuplot*textGray: white",
	//"%@gnuplot*borderGray: gray50",
	//"%@gnuplot*axisGray: gray50",
	//"%@gnuplot*line1Gray: gray100",
	//"%@gnuplot*line2Gray: gray60",
	//"%@gnuplot*line3Gray: gray80",
	//"%@gnuplot*line4Gray: gray40",
	//"%@gnuplot*line5Gray: gray90",
	//"%@gnuplot*line6Gray: gray50",
	//"%@gnuplot*line7Gray: gray70",
	//"%@gnuplot*line8Gray: gray30",
	//"@end table",
	//"",
	//"2 line_resources",
	//"?commands set terminal x11 line_resources",
	//"?set terminal x11 line_resources",
	//"?set term x11 line_resources",
	//"?x11 line_resources",
	//"?line_resources",
	//"=X resources",
	//" `gnuplot` honors the following resources for setting the width (in pixels) of",
	//" plot lines (shown here with their default values.)  0 or 1 means a minimal",
	//" width line of 1 pixel width.  A value of 2 or 3 may improve the appearance of",
	//" some plots.",
	//"@start table - first is interactive cleartext form",
	//"  gnuplot*borderWidth: 2",
	//"  gnuplot*axisWidth:   0",
	//"  gnuplot*line1Width:  0",
	//"  gnuplot*line2Width:  0",
	//"  gnuplot*line3Width:  0",
	//"  gnuplot*line4Width:  0",
	//"  gnuplot*line5Width:  0",
	//"  gnuplot*line6Width:  0",
	//"  gnuplot*line7Width:  0",
	//"  gnuplot*line8Width:  0",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*borderWidth: 2\\\\",
	//"#&gnuplot*axisWidth: 0\\\\",
	//"#&gnuplot*line1Width: 0\\\\",
	//"#&gnuplot*line2Width: 0\\\\",
	//"#&gnuplot*line3Width: 0\\\\",
	//"#&gnuplot*line4Width: 0\\\\",
	//"#&gnuplot*line5Width: 0\\\\",
	//"#&gnuplot*line6Width: 0\\\\",
	//"#&gnuplot*line7Width: 0\\\\",
	//"#&gnuplot*line8Width: 0\\\\",
	//"%c l .",
	//"%@gnuplot*borderWidth: 2",
	//"%@gnuplot*axisWidth: 0",
	//"%@gnuplot*line1Width: 0",
	//"%@gnuplot*line2Width: 0",
	//"%@gnuplot*line3Width: 0",
	//"%@gnuplot*line4Width: 0",
	//"%@gnuplot*line5Width: 0",
	//"%@gnuplot*line6Width: 0",
	//"%@gnuplot*line7Width: 0",
	//"%@gnuplot*line8Width: 0",
	//"@end table",
	//"",
	//" `gnuplot` honors the following resources for setting the dash style used for",
	//" plotting lines.  0 means a solid line.  A two-digit number `jk` (`j` and `k`",
	//" are >= 1 and <= 9) means a dashed line with a repeated pattern of `j` pixels",
	//" on followed by `k` pixels off.  For example, '16' is a dotted line with one",
	//" pixel on followed by six pixels off.  More elaborate on/off patterns can be",
	//" specified with a four-digit value.  For example, '4441' is four on, four off,",
	//" four on, one off.  The default values shown below are for monochrome displays",
	//" or monochrome rendering on color or grayscale displays.",
	//" Color displays default to dashed:off ",
	//"@start table - first is interactive cleartext form",
	//"  gnuplot*dashed:       off",
	//"  gnuplot*borderDashes:   0",
	//"  gnuplot*axisDashes:    16",
	//"  gnuplot*line1Dashes:    0",
	//"  gnuplot*line2Dashes:   42",
	//"  gnuplot*line3Dashes:   13",
	//"  gnuplot*line4Dashes:   44",
	//"  gnuplot*line5Dashes:   15",
	//"  gnuplot*line6Dashes: 4441",
	//"  gnuplot*line7Dashes:   42",
	//"  gnuplot*line8Dashes:   13",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*dashed: off\\\\",
	//"#&gnuplot*borderDashes: 0\\\\",
	//"#&gnuplot*axisDashes: 16\\\\",
	//"#&gnuplot*line1Dashes: 0\\\\",
	//"#&gnuplot*line2Dashes: 42\\\\",
	//"#&gnuplot*line3Dashes: 13\\\\",
	//"#&gnuplot*line4Dashes: 44\\\\",
	//"#&gnuplot*line5Dashes: 15\\\\",
	//"#&gnuplot*line6Dashes: 4441\\\\",
	//"#&gnuplot*line7Dashes: 42\\\\",
	//"#&gnuplot*line8Dashes: 13\\\\",
	//"%c l .",
	//"%@gnuplot*dashed: off",
	//"%@gnuplot*borderDashes: 0",
	//"%@gnuplot*axisDashes: 16",
	//"%@gnuplot*line1Dashes: 0",
	//"%@gnuplot*line2Dashes: 42",
	//"%@gnuplot*line3Dashes: 13",
	//"%@gnuplot*line4Dashes: 44",
	//"%@gnuplot*line5Dashes: 15",
	//"%@gnuplot*line6Dashes: 4441",
	//"%@gnuplot*line7Dashes: 42",
	//"%@gnuplot*line8Dashes: 13",
	//"@end table"
	//, "",
	//"2 x11 pm3d_resources",
	//"?commands set terminal x11 pm3d_resources",
	//"?set terminal x11 pm3d_resources",
	//"?set term x11 pm3d_resources",
	//"?x11 pm3d_resources",
	//"?pm3d_resources",
	//"?x11 pm3d",
	//"=X resources",
	//" Choosing the appropriate visual class and number of colors is a crucial",
	//" point in X11 applications and a bit awkward, since X11 supports six visual",
	//" types in different depths.",
	//"",
	//" By default `gnuplot` uses the default visual of the screen. The number of",
	//" colors which can be allocated depends on the visual class chosen. On a",
	//" visual class with a depth > 12bit, gnuplot starts with a maximal number",
	//" of 0x200 colors.  On a visual class with a depth > 8bit (but <= 12 bit)",
	//" the maximal number of colors is 0x100, on <= 8bit displays the maximum",
	//" number of colors is 240 (16 are left for line colors).",
	//"",
	//" Gnuplot first starts to allocate the maximal number of colors as stated",
	//" above.  If this fails, the number of colors is reduced by the factor 2",
	//" until gnuplot gets all colors which are requested. If dividing `maxcolors`",
	//" by 2 repeatedly results in a number which is smaller than `mincolors`",
	//" `gnuplot` tries to install a private colormap. In this case the window",
	//" manager is responsible for swapping colormaps when the pointer is moved",
	//" in and out the x11 driver's window.",
	//"",
	//" The default for `mincolors` is maxcolors / (num_colormaps > 1 ? 2 : 8),",
	//" where num_colormaps is the number of colormaps which are currently used",
	//" by gnuplot (usually 1, if only one x11 window is open).",
	//"",
	//" Some systems support multiple (different) visual classes together on one",
	//" screen. On these systems it might be necessary to force gnuplot to use a",
	//" specific visual class, e.g. the default visual might be 8bit PseudoColor",
	//" but the screen would also support 24bit TrueColor which would be the",
	//" preferred choice.",
	//"",
	//" The information about an Xserver's capabilities can be obtained with the",
	//" program `xdpyinfo`.  For the visual names below you can choose one of",
	//" StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor, DirectColor.",
	//" If an Xserver supports a requested visual type at different depths,",
	//" `gnuplot` chooses the visual class with the highest depth (deepest).",
	//" If the requested visual class matches the default visual and multiple",
	//" classes of this type are supported, the default visual is preferred.",
	//"",
	//" Example: on an 8bit PseudoColor visual you can force a private color map",
	//" by specifying `gnuplot*maxcolors: 240` and `gnuplot*mincolors: 240`.",
	//"",
	//"@start table - first is interactive cleartext form",
	//"  gnuplot*maxcolors:  <integer>",
	//"  gnuplot*mincolors:  <integer>",
	//"  gnuplot*visual:     <visual name>",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*maxcolors:  integer\\\\",
	//"#&gnuplot*mincolors:  integer\\\\",
	//"#&gnuplot*visual:     visual name\\\\",
	//"%c l .",
	//"%@gnuplot*maxcolors:  <integer number>",
	//"%@gnuplot*mincolors:  <integer number>",
	//"%@gnuplot*visual:     <visual name>",
	//"@end table"
	//, "",
	//"2 x11 other_resources",
	//"?commands set terminal x11 other_resources",
	//"?set terminal x11 other_resources",
	//"?set term x11 other_resources",
	//"?x11 other_resources",
	//"=X resources",
	//" By default the contents of the current plot window are exported to the X11",
	//" clipboard in response to X events in the window. Setting the resource",
	//" 'gnuplot*exportselection' to 'off' or 'false' will disable this.",
	//"",
	//" By default text rotation is done using a method that is fast, but can",
	//" corrupt nearby colors depending on the background.  If this is a problem,",
	//" you can set the resource 'gnuplot.fastrotate' to 'off'",
	//"",
	//"@start table - other x11 resources",
	//"  gnuplot*exportselection:  off",
	//"  gnuplot*fastrotate:  on",
	//"  gnuplot*ctrlq:  off",
	//"#\\begin{tabular}{|cl|} \\hline",
	//"#&gnuplot*exportselection:  off\\\\",
	//"#&gnuplot*fastrotate:  on\\\\",
	//"#&gnuplot*ctrlq:  off\\\\",
	//"%c l .",
	//"%@gnuplot*exportselection:  off",
	//"%@gnuplot*fastrotate:  on",
	//"%@gnuplot*ctrlq:  off",
	//"@end table"
	//
	//END_HELP(x11)
	///#endif				// TERM_HELP 

	/* Hello, Emacs, this is -*-C-*-
	 * $Id: xlib.trm,v 1.23 2009/03/26 00:49:29 sfeam Exp $
	 */

	/* GNUPLOT - xlib.trm */

	/*
	 * xlib.trm - inboard terminal driver for X11 (dumps gnuplot_x11 commands)
	 *
	 * New implementation November 2003
	 * Xlib_init() sets up the output channels, but otherwise all work is done
	 * by the main x11.trm driver routines.
	 * Ethan A Merritt <merritt@u.washington.edu>
	 */


	///#ifdef TERM_REGISTER
	//register_term(xlib)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void Xlib_init __PROTO((void));
	//TERM_PUBLIC void Xlib_text __PROTO((void));
	//TERM_PUBLIC void Xlib_reset __PROTO((void));
	///#define GOT_XLIB_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//TERM_PUBLIC void
	//Xlib_init()
	//{
	// /* x11.trm thinks it is writing to a private pipe, but here we */
	// /* set it to use the channel opened by 'set output <file>'     */
	//    X11_ipc = gpoutfile;
	//
	///#ifdef PIPE_IPC
	// /* There is, of course, no mouse feedback */
	//    ipc_back_fd = IPC_BACK_UNUSABLE;
	///#endif
	//}
	//
	//TERM_PUBLIC void
	//Xlib_text()
	//{
	//    PRINT0("E\n");
	//    FFLUSH();
	///#ifdef PIPE_IPC
	//    ipc_back_fd = IPC_BACK_UNUSABLE;
	///#endif
	//
	//}
	//
	//TERM_PUBLIC void
	//Xlib_reset()
	//{
	//    X11_ipc = NULL;
	//}
	//
	///#endif

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(xlib_driver)
	//    "xlib", "X11 Window System (gnulib_x11 dump)",
	//    X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR,
	//    X11_VTIC, X11_HTIC, X11_options, Xlib_init, Xlib_reset,
	//    Xlib_text, null_scale, X11_graphics, X11_move, X11_vector,
	//    X11_linetype, X11_put_text, X11_text_angle,
	//    X11_justify_text, X11_point, do_arrow, X11_set_font,
	//    X11_pointsize, TERM_CAN_MULTIPLOT|TERM_INIT_ON_REPLOT|TERM_CAN_DASH,
	//    X11_text // suspend can use same routine 
	// , 0 // resume 
	// ,
	//    X11_fillbox, X11_linewidth
	///#ifdef USE_MOUSE
	//    , X11_waitforinput, X11_put_tmptext, X11_set_ruler, X11_set_cursor, X11_set_clipboard
	///#endif
	//    , X11_make_palette, 0 // X11_previous_palette 
	// ,
	//    X11_set_color, X11_filled_polygon
	//    , X11_image
	//    , ENHX11_OPEN, ENHX11_FLUSH, do_enh_writec
	//TERM_TABLE_END(xlib_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM xlib_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(xlib)
	//"1 xlib",
	//"?commands set terminal xlib",
	//"?set terminal xlib",
	//"?set term xlib",
	//"?terminal xlib",
	//"?term xlib",
	//"?xlib",
	//" The `xlib` terminal driver supports the X11 Windows System.  It generates",
	//" gnuplot_x11 commands, but sends them to the output file specified by",
	//" `set output '<filename>'`. `set term x11` is equivalent to",
	//" `set output \"|gnuplot_x11 -noevents\"; set term xlib`.",
	//" `xlib` takes the same set of options as `x11`."
	//END_HELP(xlib)
	///#endif

	///#endif

	/* Adobe Illustrator Format */
	/* obsolete: use 'set term postscript level1 */
	/* #include "ai.trm" */

	/* HTML Canvas terminal */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: canvas.trm,v 1.25.2.6 2010/02/01 16:29:28 sfeam Exp $
	 *
	 */

	/* GNUPLOT - canvas.trm */

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   W3C HTML <canvas> tag
	 *
	 * AUTHOR
	 *   Bruce Lueckenhoff, Aug 2008
	 *   Bruce_Lueckenhoff@yahoo.com
	 *
	 * Additions
	 *   Ethan A Merritt, Jan 2009
	 *	CANVAS_set_color(), CANVAS_make_palette(), CANVAS_fillbox(), fillstyles, 
	 *	CANVAS_point(), CANVAS_pointsize()
	 *	"name <foo>" option to create only a callable javascript file foo.js
	 *	"fsize <F>" option to select font size (default remains 10.0)
	 *   Ethan A Merritt, Jan 2009
	 *	Prototype mousing code in separate file gnuplot_mouse.js
	 *   Ethan A Merritt, Feb 2009
	 *	Enhanced text support. Note: character placement could be done more
	 *	precisely by moving the enhanced text code into the javascript routines,
	 *	where exact character widths are known, and save/restore can be used.
	 *   Ethan A Merritt, Mar 2009
	 *	Oversampling and client-side zoom/unzoom, hotkeys
	 *   Ethan A Merritt, May 2009
	 *	Give each plot its own namespace for mousing (allows multiple mouseable
	 *	plots in a single HTML document).
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	///#ifdef TERM_REGISTER
	//register_term(canvas_driver)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void CANVAS_options __PROTO((void));
	//TERM_PUBLIC void CANVAS_init __PROTO((void));
	//TERM_PUBLIC void CANVAS_graphics __PROTO((void));
	//TERM_PUBLIC int CANVAS_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void CANVAS_text __PROTO((void));
	//TERM_PUBLIC void CANVAS_reset __PROTO((void));
	//TERM_PUBLIC void CANVAS_linetype __PROTO((int linetype));
	//TERM_PUBLIC void CANVAS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1,
	//					unsigned int width, unsigned int height));
	//TERM_PUBLIC void CANVAS_linewidth __PROTO((double linewidth));
	//TERM_PUBLIC void CANVAS_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void CANVAS_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void CANVAS_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void CANVAS_pointsize __PROTO((double size));
	//TERM_PUBLIC void CANVAS_put_text __PROTO((unsigned int x, unsigned int y,
	//					const char *str));
	//TERM_PUBLIC int CANVAS_text_angle __PROTO((int ang));
	//TERM_PUBLIC void CANVAS_filled_polygon __PROTO((int, gpiPoint *));
	//TERM_PUBLIC void CANVAS_set_color __PROTO((t_colorspec *colorspec));
	//TERM_PUBLIC int CANVAS_make_palette __PROTO((t_sm_palette *palette));
	//TERM_PUBLIC void CANVAS_layer __PROTO((t_termlayer));
	//TERM_PUBLIC void CANVAS_path __PROTO((int));
	//
	//TERM_PUBLIC void ENHCANVAS_OPEN __PROTO((char *, double, double, TBOOLEAN, TBOOLEAN, int));
	//TERM_PUBLIC void ENHCANVAS_FLUSH __PROTO((void));
	//TERM_PUBLIC void ENHCANVAS_put_text __PROTO((unsigned int, unsigned int, const char *));
	//
	///#define CANVAS_OVERSAMPLE	10.
	///#define CANVAS_XMAX		(600 * CANVAS_OVERSAMPLE) 
	///#define CANVAS_YMAX 		(400 * CANVAS_OVERSAMPLE)
	///#define CANVASVTIC		(10  * CANVAS_OVERSAMPLE)
	///#define CANVASHTIC		(10  * CANVAS_OVERSAMPLE)
	///#define CANVASVCHAR		(10  * CANVAS_OVERSAMPLE)
	///#define CANVASHCHAR		(8   * CANVAS_OVERSAMPLE)
	//
	///#endif // TERM_PROTO 

	///#ifdef TERM_BODY
	//
	///#define CANVAS_AXIS_CONST '\1'
	///#define CANVAS_BORDER_CONST '\2'
	//
	//static int canvas_x = -1;	// current X position 
	//static int canvas_y = -1;	// current Y position 
	//static int canvas_xmax = CANVAS_XMAX;
	//static int canvas_ymax = CANVAS_YMAX;
	//static int canvas_line_type = LT_UNDEFINED;
	//static double canvas_linewidth = 1.0;
	//static double CANVAS_ps = 1;	// pointsize multiplier 
	//static double canvas_font_size = 10;
	//static char *canvas_justify = "";
	//static int canvas_text_angle = 0;
	//static int canvas_in_a_path = FALSE;
	//static int already_closed = FALSE;
	//static TBOOLEAN CANVAS_mouseable = FALSE;
	//static TBOOLEAN CANVAS_standalone = TRUE;
	//static char *CANVAS_name = NULL;
	//static char *CANVAS_scriptdir = NULL;
	//static char *CANVAS_title = NULL;
	//
	//static struct {
	//    int  previous_linewidth;
	//    char color[18];		// rgb(rrr,ggg,bbb) 
	//    char previous_color[18];	// rgb(rrr,ggg,bbb) 
	//    char previous_fill[24];	// rgba(rrr,ggg,bbb,aaaa) 
	//} canvas_state;
	//
	//enum CANVAS_case {
	//    CANVAS_SIZE, CANVAS_FSIZE, CANVAS_NAME, CANVAS_STANDALONE, CANVAS_TITLE,
	//    CANVAS_LINEWIDTH, CANVAS_MOUSING, CANVAS_JSDIR, CANVAS_ENH, CANVAS_NOENH,
	//    CANVAS_OTHER
	//};
	//
	//static struct gen_table CANVAS_opts[] =
	//{
	//    { "fsize", CANVAS_FSIZE },
	//    { "name", CANVAS_NAME },
	//    { "size", CANVAS_SIZE },
	//    { "standalone", CANVAS_STANDALONE },
	//    { "mous$ing", CANVAS_MOUSING },
	//    { "mouse", CANVAS_MOUSING },
	//    { "js$dir", CANVAS_JSDIR },
	//    { "enh$anced", CANVAS_ENH },
	//    { "noenh$anced", CANVAS_NOENH },
	//    { "lw", CANVAS_LINEWIDTH },
	//    { "linew$idth", CANVAS_LINEWIDTH },
	//    { "title", CANVAS_TITLE },
	//    { NULL, CANVAS_OTHER }
	//};
	//
	//static void
	//CANVAS_start (void)
	//{
	//    if (canvas_in_a_path)
	//	return;
	//    fprintf(gpoutfile, "ctx.beginPath();\n");
	//    canvas_in_a_path = TRUE;
	//    already_closed = FALSE;
	//}
	//
	//static void
	//CANVAS_finish (void)
	//{
	//    if (!canvas_in_a_path)
	//	return;
	//    fprintf(gpoutfile, "ctx.stroke();\n");
	//
	//    if (!already_closed)
	//	fprintf(gpoutfile, "ctx.closePath();\n");
	//    canvas_in_a_path = FALSE;
	//    already_closed = TRUE;
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_options()
	//{
	// /* (c_token == 2) only in the case of 'set termoption'	*/
	// /* which is after we have already initialized everything.	*/
	//    if (c_token != 2) {
	// /* Re-initialize a few things */
	//	canvas_font_size = 10;
	//	CANVAS_standalone = TRUE;
	//	CANVAS_mouseable = FALSE;
	//	free(CANVAS_name);
	//	CANVAS_name = NULL;
	//	free(CANVAS_title);
	//	CANVAS_title = NULL;
	//	free(CANVAS_scriptdir);
	//	CANVAS_scriptdir = NULL;
	//	canvas_linewidth = 1.0;
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&CANVAS_opts[0],c_token++)) {
	//	case CANVAS_SIZE:
	//	    if (END_OF_COMMAND) {
	//		canvas_xmax = CANVAS_XMAX;
	//		canvas_ymax = CANVAS_YMAX;
	//	    } else {
	//		canvas_xmax = int_expression() * CANVAS_OVERSAMPLE;
	//		if (equals(c_token,",")) {
	//		    c_token++;
	//		    canvas_ymax = int_expression() * CANVAS_OVERSAMPLE;
	//		}
	//	    }
	//	    if (canvas_xmax <= 0)
	//		canvas_xmax = CANVAS_XMAX;
	//	    if (canvas_ymax <= 0)
	//		canvas_ymax = CANVAS_YMAX;
	//	    term->xmax = canvas_xmax;
	//	    term->ymax = canvas_ymax;
	// 	    break;
	//
	//	case CANVAS_TITLE:
	//	    CANVAS_title = try_to_get_string();
	//	    if (!CANVAS_title)
	//		int_error(c_token,"expecting an HTML title string");
	//	    break;
	//
	//	case CANVAS_NAME:
	//	    CANVAS_name = try_to_get_string();
	//	    if (!CANVAS_name)
	//		    int_error(c_token,"expecting a javascript function name");
	//	    if (CANVAS_name[strspn(CANVAS_name,
	//	        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890")])
	//		    int_error(c_token-1,"illegal javascript function name");
	//	    CANVAS_standalone = FALSE;
	//	    break;
	//
	//	case CANVAS_STANDALONE:
	//	    CANVAS_standalone = TRUE;
	//	    break;
	//
	//	case CANVAS_FSIZE:
	//	    canvas_font_size = real_expression();
	//	    if (canvas_font_size <= 0)
	//		canvas_font_size = 10;
	//	    break;
	//
	//	case CANVAS_MOUSING:
	//	    CANVAS_mouseable = TRUE;
	//	    break;
	//
	//	case CANVAS_JSDIR:
	//	    CANVAS_scriptdir = try_to_get_string();
	//	    break;
	//
	//	case CANVAS_ENH:
	//	    term->put_text = ENHCANVAS_put_text;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    break;
	//
	//	case CANVAS_NOENH:
	//	    term->put_text = CANVAS_put_text;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    break;
	//
	//	case CANVAS_LINEWIDTH:
	//	    canvas_linewidth = real_expression();
	//	    if (canvas_linewidth <= 0)
	//		canvas_linewidth = 1.0;
	//	    break;
	//
	//	default:
	//	    int_warn(c_token-1,"unrecognized terminal option");
	// 	    break;
	//	}
	//    }
	//
	//    term->v_char = canvas_font_size * CANVAS_OVERSAMPLE;
	//    term->h_char = canvas_font_size * 0.8 * CANVAS_OVERSAMPLE;
	//
	//    sprintf(term_options, "size %d,%d", (int)(term->xmax/CANVAS_OVERSAMPLE), (int)(term->ymax/CANVAS_OVERSAMPLE));
	//    sprintf(term_options + strlen(term_options), "%s fsize %g lw %g", 
	//	term->put_text == ENHCANVAS_put_text ? " enhanced" : "",
	//	canvas_font_size, canvas_linewidth);
	//    if (CANVAS_name)
	//	sprintf(term_options + strlen(term_options), " name \"%s\"", CANVAS_name);
	//    else {
	//	sprintf(term_options + strlen(term_options), " standalone");
	//	if (CANVAS_mouseable)
	//	    sprintf(term_options + strlen(term_options), " mousing");
	//	if (CANVAS_title)
	//	    sprintf(term_options + strlen(term_options), " title \"%s\"", CANVAS_title);
	//    }
	//    if (CANVAS_scriptdir)
	//	sprintf(term_options + strlen(term_options), " jsdir \"%s\"", CANVAS_scriptdir);
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_init()
	//{
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_graphics()
	//{
	///#if !defined(VMS)
	//    int len;
	///#endif
	// /* Force initialization at the beginning of each plot */
	//    canvas_line_type = LT_UNDEFINED;
	//    canvas_text_angle = 0;
	//    canvas_in_a_path = FALSE;
	//    canvas_state.previous_linewidth = -1;
	//    canvas_state.previous_color[0] = '\0';
	//    canvas_state.previous_fill[0] = '\0';
	//    strcpy(canvas_state.color,"rgb(000,000,000)");
	//
	// /* Figure out where the javascript should come from when the page is viewed */
	//    if (CANVAS_scriptdir == NULL) {
	//	char *canvas_default_jsdir = "";
	///#ifdef GNUPLOT_JS_DIR
	///#if defined(_Windows)
	// /* retrieve path relative to the gnuplot executable,
	//  * whose path is in szModuleName (winmain.c) */
	// /* EAM FIXME: memory leak */
	//	canvas_default_jsdir = gp_alloc(strlen((char*) szPackageDir)
	//			+ strlen(GNUPLOT_JS_DIR) + 2, "jsdir");
	//	strcpy(canvas_default_jsdir, (char*) szPackageDir);
	//	len = strlen(canvas_default_jsdir);
	//	if (*canvas_default_jsdir && canvas_default_jsdir[len-1] != '\\' && canvas_default_jsdir[len-1] != '/')
	//	    strcat(canvas_default_jsdir, "\\");
	// /* GNUPLOT_JS_DIR is _relative_ path */
	//	strcat(canvas_default_jsdir, GNUPLOT_JS_DIR);
	///#else // !_Windows 
	// /* use hardcoded _absolute_ path */
	//	canvas_default_jsdir = GNUPLOT_JS_DIR;
	///#endif
	///#endif // GNUPLOT_JS_DIR 
	//	CANVAS_scriptdir = gp_strdup(canvas_default_jsdir);
	//    }
	//
	///#if !defined(VMS)
	//    len = strlen(CANVAS_scriptdir);
	///#if defined(_Windows)
	//    if (*CANVAS_scriptdir && CANVAS_scriptdir[len-1] != '\\' && CANVAS_scriptdir[len-1] != '/') {
	//	CANVAS_scriptdir = gp_realloc(CANVAS_scriptdir, len+2, "jsdir");
	//	if (CANVAS_scriptdir[len-1] == '\\') // use backslash if used in jsdir, otherwise slash 
	//	    strcat(CANVAS_scriptdir,"\\");
	//	else
	//	    strcat(CANVAS_scriptdir,"/");
	//    }
	///#else
	//    if (*CANVAS_scriptdir && CANVAS_scriptdir[len-1] != '/') {
	//	CANVAS_scriptdir = gp_realloc(CANVAS_scriptdir, len+2, "jsdir");
	//	strcat(CANVAS_scriptdir,"/");
	//    }
	///#endif
	///#endif
	//
	//    if (CANVAS_standalone) {
	//	fprintf(gpoutfile,
	//		"<html>\n"
	//		"<head>\n"
	//		"<title>%s</title>\n",
	//		CANVAS_title ? CANVAS_title : "Gnuplot Canvas Graph"
	//		);
	//	if (encoding == S_ENC_UTF8)
	//	    fprintf(gpoutfile,
	//		"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n"
	//	    );
	//	fprintf(gpoutfile,
	//		"<!--[if IE]><script type=\"text/javascript\" src=\"excanvas.js\"></script><![endif]-->\n"
	//		"<script src=\"%scanvastext.js\"></script>\n"
	//		"<script src=\"%sgnuplot_common.js\"></script>\n"
	//		, CANVAS_scriptdir
	//		, CANVAS_scriptdir);
	//	if (CANVAS_mouseable)
	//	    fprintf(gpoutfile,
	//		"<script src=\"%sgnuplot_mouse.js\"></script>\n"
	//		, CANVAS_scriptdir);
	//	fprintf(gpoutfile,
	//		"<script type=\"text/javascript\">\n"
	//		"var canvas, ctx;\n"
	//		"var grid_lines = true;\n"
	//		"var zoomed = false;\n"
	//		"var active_plot_name = \"gnuplot_canvas\";\n\n"
	//		"function gnuplot_canvas() {\n"
	//		"canvas = document.getElementById(\"gnuplot_canvas\");\n"
	//		"ctx = canvas.getContext(\"2d\");\n"
	//	);
	//
	//    } else {
	//	fprintf(gpoutfile,
	//		"function %s() {\n"
	//		"canvas = document.getElementById(\"%s\");\n"
	//		"ctx = canvas.getContext(\"2d\");\n",
	//		CANVAS_name, CANVAS_name
	//	);
	//	fprintf(gpoutfile,
	//	    "// Reinitialize mouse tracking and zoom for this particular plot\n"
	//	    "if ((typeof(active_plot) == \"undefined\" || active_plot != %s)  &&  typeof(mouse_update) != \"undefined\") {\n"
	//	    "  active_plot_name = \"%s\";\n"
	//	    "  active_plot = %s;\n"
	//	    "  canvas.onmousemove = mouse_update;\n"
	//	    "  canvas.onmouseup = zoom_in;\n"
	//	    "  canvas.onmousedown = saveclick;\n"
	//	    "  canvas.onkeypress = do_hotkey;\n"
	//	    "  if (canvas.attachEvent) {canvas.attachEvent('mouseover', %s);}\n"
	//	    "  else if (canvas.addEventListener) {canvas.addEventListener('mouseover', %s, false);} \n"
	//	    "  zoomed = false;\n"
	//	    "  zoom_axis_width = 0;\n"
	//	    "  zoom_in_progress = false;\n"
	//	    "  ctx.clearRect(0,0,%d,%d);\n"
	//	    "}\n",
	//		CANVAS_name, CANVAS_name, CANVAS_name, CANVAS_name, CANVAS_name,
	//		(int)(term->xmax / CANVAS_OVERSAMPLE), (int)(term->ymax / CANVAS_OVERSAMPLE)
	//	);
	//    }
	//
	//    fprintf(gpoutfile,
	//	    "CanvasTextFunctions.enable(ctx);\n"
	//	    "ctx.strokeStyle = \"rgb(215,215,215)\";\n"
	//	    "ctx.lineWidth = %.1g;\n",
	//	canvas_linewidth
	//    );
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_text()
	//{
	//    CANVAS_finish();
	//
	// /* FIXME: I am not sure whether these variable names should always be the */
	// /* same, so that they are re-used by all plots in a document, or whether  */
	// /* they should be tied to the function name and hence private.            */
	//    if (TRUE) {
	//	struct udvt_entry *udv;
	//	fprintf(gpoutfile, "\n// plot boundaries and axis scaling information for mousing \n");
	//	fprintf(gpoutfile, "plot_term_xmax = %d;\n", (int)(term->xmax / CANVAS_OVERSAMPLE));
	//	fprintf(gpoutfile, "plot_term_ymax = %d;\n", (int)(term->ymax / CANVAS_OVERSAMPLE));
	//	fprintf(gpoutfile, "plot_xmin = %.1f;\n", (double)plot_bounds.xleft / CANVAS_OVERSAMPLE);
	//	fprintf(gpoutfile, "plot_xmax = %.1f;\n", (double)plot_bounds.xright / CANVAS_OVERSAMPLE);
	//	fprintf(gpoutfile, "plot_ybot = %.1f;\n", (double)(term->ymax-plot_bounds.ybot) / CANVAS_OVERSAMPLE);
	//	fprintf(gpoutfile, "plot_ytop = %.1f;\n", (double)(term->ymax-plot_bounds.ytop) / CANVAS_OVERSAMPLE);
	//	fprintf(gpoutfile, "plot_width = %.1f;\n", (double)(plot_bounds.xright - plot_bounds.xleft) / CANVAS_OVERSAMPLE);
	//	fprintf(gpoutfile, "plot_height = %.1f;\n", (double)(plot_bounds.ytop - plot_bounds.ybot) / CANVAS_OVERSAMPLE);
	//
	// /* Get true axis ranges as used in the plot */
	//	update_gpval_variables(1);
	//
	///#define	MOUSE_PARAM( GP_NAME, js_NAME ) 	if ((udv = add_udv_by_name(GP_NAME))) { 	    if (udv->udv_value.type == INTGR)   		fprintf(gpoutfile, "%s = %d;\n", js_NAME, udv->udv_value.v.int_val); 	    else if (udv->udv_value.type == CMPLX) 		fprintf(gpoutfile, "%s = %g;\n", js_NAME, udv->udv_value.v.cmplx_val.real); 	}
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//	MOUSE_PARAM("GPVAL_X_MIN", "plot_axis_xmin");
	//	MOUSE_PARAM("GPVAL_X_MAX", "plot_axis_xmax");
	//	MOUSE_PARAM("GPVAL_Y_MIN", "plot_axis_ymin");
	//	MOUSE_PARAM("GPVAL_Y_MAX", "plot_axis_ymax");
	//
	//	if ((axis_array[SECOND_X_AXIS].ticmode & TICS_MASK) != NO_TICS) {
	//	    MOUSE_PARAM("GPVAL_X2_MIN", "plot_axis_x2min");
	//	    MOUSE_PARAM("GPVAL_X2_MAX", "plot_axis_x2max");
	//	} else
	//	    fprintf(gpoutfile, "plot_axis_x2min = \"none\"\n");
	//	if ((axis_array[SECOND_Y_AXIS].ticmode & TICS_MASK) != NO_TICS) {
	//	    MOUSE_PARAM("GPVAL_Y2_MIN", "plot_axis_y2min");
	//	    MOUSE_PARAM("GPVAL_Y2_MAX", "plot_axis_y2max");
	//	} else
	//	    fprintf(gpoutfile, "plot_axis_y2min = \"none\"\n");
	///#undef MOUSE_PARAM
	//
	//	fprintf(gpoutfile, "plot_logaxis_x = %d;\n",
	//		axis_array[FIRST_X_AXIS].log ? 1: 0);
	//	fprintf(gpoutfile, "plot_logaxis_y = %d;\n",
	//		axis_array[FIRST_Y_AXIS].log ? 1: 0);
	//
	//	fprintf(gpoutfile, "plot_axis_width = plot_axis_xmax - plot_axis_xmin;\n");
	//	fprintf(gpoutfile, "plot_axis_height = plot_axis_ymax - plot_axis_ymin;\n");
	//
	//    } // End of section writing out variables for mousing 
	//
	//    fprintf(gpoutfile, "}\n");
	//
	//    if (CANVAS_standalone) {
	//	fprintf(gpoutfile,
	//		"</script>\n"
	//		"<link text=\"text/css\" href=\"%sgnuplot_mouse.css\" rel=\"stylesheet\">\n"
	//		"</head>\n"
	//		"<body onload=\"gnuplot_canvas(); gnuplot_init();\" oncontextmenu=\"return false;\">\n\n"
	//		"<div class=\"gnuplot\">\n",
	//			CANVAS_scriptdir ? CANVAS_scriptdir : ""
	//	);
	//
	// /* The format of the plot box and in particular the mouse tracking box
	//  * are determined by the CSS specs in customizable file gnuplot_mouse.css
	//  * We could make this even more customizable by providing an external HTML
	//  * template, but in that case the user might as well just create a *.js
	//  * file and provide his own wrapping HTML document.
	//  */
	//	if (CANVAS_mouseable) {
	//	    fprintf(gpoutfile,
	//		"<table class=\"mbleft\"><tr><td class=\"mousebox\">\n"
	//
	//		"<table class=\"mousebox\" border=0>\n"
	//		"  <tr><td class=\"mousebox\">\n"
	//		"    <table class=\"mousebox\" id=\"gnuplot_mousebox\" border=0>\n"
	//		"    <tr><td class=\"mbh\"></td></tr>\n"
	//		"    <tr><td class=\"mbh\">\n"
	//		"      <table class=\"mousebox\">\n"
	//		"	<tr>\n"
	//		"	  <td class=\"icon\"></td>\n"
	//		"	  <td class=\"icon\" onclick=toggle_grid><img src=\"%sgrid.png\" id=\"gnuplot_grid_icon\" align=right alt=\"#\" title=\"toggle grid\"></td>\n"
	//		"	  <td class=\"icon\" onclick=unzoom><img src=\"%spreviouszoom.png\" id=\"gnuplot_unzoom_icon\" align=right alt=\"unzoom\" title=\"unzoom\"></td>\n"
	//		"	  <td class=\"icon\" onclick=rezoom><img src=\"%snextzoom.png\" id=\"gnuplot_rezoom_icon\" align=right alt=\"rezoom\" title=\"rezoom\"></td>\n"
	//		"	  <td class=\"icon\" onclick=toggle_zoom_text><img src=\"%stextzoom.png\" id=\"gnuplot_textzoom_icon\" align=right alt=\"zoom text\" title=\"zoom text with plot\"></td>\n"
	//		"	  <td class=\"icon\"><img src=\"%shelp.png\" id=\"gnuplot_help_icon\" align=right alt=\"?\" title=\"help\"></td>\n"
	//		"	</tr>\n"
	//		"      </table>\n"
	//		"  </td></tr>\n"
	//		"</table></td></tr><tr><td class=\"mousebox\">\n",
	//		CANVAS_scriptdir ? CANVAS_scriptdir : "", CANVAS_scriptdir ? CANVAS_scriptdir : "",
	//		CANVAS_scriptdir ? CANVAS_scriptdir : "", CANVAS_scriptdir ? CANVAS_scriptdir : "",
	//		CANVAS_scriptdir ? CANVAS_scriptdir : ""
	//	    );
	//
	//	    fprintf(gpoutfile,
	//		"<table class=\"mousebox\" id=\"gnuplot_mousebox\" border=1>\n"
	//		"<tr> <td class=\"mb0\">x&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_x\">&nbsp;</span></td> </tr>\n"
	//		"<tr> <td class=\"mb0\">y&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_y\">&nbsp;</span></td> </tr>\n"
	//	    );
	//
	//	    if ((axis_array[SECOND_X_AXIS].ticmode & TICS_MASK) != NO_TICS)
	//	      fprintf(gpoutfile,
	//		"<tr> <td class=\"mb0\">x2&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_x2\">&nbsp;</span></td> </tr>\n");
	//	    if ((axis_array[SECOND_Y_AXIS].ticmode & TICS_MASK) != NO_TICS)
	//	      fprintf(gpoutfile,
	//		"<tr> <td class=\"mb0\">y2&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_y2\">&nbsp;</span></td> </tr>\n");
	//
	//	    fprintf(gpoutfile,
	//		"</table></td></tr>\n"
	//		"</table>\n"
	//	    );
	//
	//	    fprintf(gpoutfile,
	//	        "</td><td>\n"
	//	    );
	//	} // End if (CANVAS_mouseable) 
	//
	//
	//	fprintf(gpoutfile,
	//		"<table class=\"plot\">\n"
	//		"<tr><td>\n"
	//		"    <canvas id=\"gnuplot_canvas\" width=\"%d\" height=\"%d\" tabindex=\"0\">\n"
	//		"	Sorry, your browser seems not to support the HTML 5 canvas element\n"
	//		"    </canvas>\n"
	//		"</td></tr>\n"
	//		"</table>\n",
	//			(int)(term->xmax/CANVAS_OVERSAMPLE), (int)(term->ymax/CANVAS_OVERSAMPLE)
	//        );
	//
	//	if (CANVAS_mouseable) {
	//	    fprintf(gpoutfile,
	//		"</td></tr></table>\n"
	//	    );
	//	}
	//
	//	fprintf(gpoutfile,
	//		"</div>\n\n"
	//		"</body>\n"
	//		"</html>\n"
	//        );
	//    }
	//
	//    fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_reset()
	//{
	//    ;
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_linetype(int linetype)
	//{
	// /* NB: These values are manipulated as numbers; */
	// /* it does not work to give only the color name */
	//    static const char * pen_type[17] = {
	//	"rgb(255,255,255)", // should be background 
	//	"rgb(000,000,000)", // black 
	//	"rgb(160,160,160)", // grey 
	//	"rgb(255,000,000)", // red 
	//	"rgb(000,171,000)", // green 
	//	"rgb(000,000,225)", // blue 
	//        "rgb(190,000,190)", // purple  
	//	"rgb(000,255,255)", // cyan 
	//	"rgb(021,117,069)", // pine green
	//	"rgb(000,000,148)", // navy 
	//	"rgb(255,153,000)", // orange 
	//	"rgb(000,153,161)", // green blue
	//	"rgb(214,214,069)", // olive
	//	"rgb(163,145,255)", // cornflower
	//	"rgb(255,204,000)", // gold
	//	"rgb(214,000,120)", // mulberry
	//	"rgb(171,214,000)", // green yellow
	//    };
	//    if (linetype == canvas_line_type)
	//	return;
	//    canvas_line_type = linetype;
	//    CANVAS_finish();
	//
	//    if (linetype >= 14)
	//	linetype %= 14;
	//    if (linetype <= LT_BACKGROUND) // LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED 
	//	linetype = -3;
	//    strcpy(canvas_state.color,pen_type[linetype + 3]);
	//    if (strcmp(canvas_state.color, canvas_state.previous_color)) {
	//	fprintf(gpoutfile, "ctx.strokeStyle = \"%s\";\n", canvas_state.color);
	//	strcpy(canvas_state.previous_color, canvas_state.color);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_move(unsigned int arg_x, unsigned int arg_y)
	//{
	//    if (canvas_in_a_path && (canvas_x == arg_x) && (canvas_y == arg_y)) {
	//        return;
	//    }
	//    CANVAS_start();
	//    fprintf(gpoutfile,
	//	    "M(%u,%u);\n",
	//            arg_x, canvas_ymax - arg_y);
	//    canvas_x = arg_x;
	//    canvas_y = arg_y;
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_vector(unsigned int arg_x, unsigned int arg_y)
	//{
	//    if ((canvas_x == arg_x) && (canvas_y == arg_y))
	//        return;
	//
	//    if (!canvas_in_a_path) {
	// /* Force a new path */
	//	CANVAS_move(canvas_x, canvas_y);
	//    }
	//
	//    fprintf(gpoutfile,
	//	    "L(%u,%u);\n",
	//            arg_x, canvas_ymax - arg_y
	//           );
	//    canvas_x = arg_x;
	//    canvas_y = arg_y;
	//}
	//
	//
	//TERM_PUBLIC int
	//CANVAS_justify_text(enum JUSTIFY mode)
	//{
	//    switch (mode) {
	//    case (CENTRE):
	//	canvas_justify = "Center";
	//	break;
	//    case (RIGHT):
	//	canvas_justify = "Right";
	//	break;
	//    default:
	//    case (LEFT):
	//        canvas_justify = "";
	//	break;
	//    }
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_point(unsigned int x, unsigned int y, int number)
	//{
	//    double width  = CANVAS_ps * 0.6 * CANVASHTIC / CANVAS_OVERSAMPLE;
	//    int pt = number % 9;
	//
	//    CANVAS_finish();
	//
	//    switch (pt) {
	//    default:
	//	fprintf(gpoutfile, "Dot(%.1f,%.1f);\n",
	//		x/CANVAS_OVERSAMPLE, (canvas_ymax-y)/CANVAS_OVERSAMPLE);
	//	break;
	//    case 4:
	//    case 6:
	//    case 8:
	//	if (strcmp(canvas_state.previous_fill, canvas_state.color)) {
	//	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", canvas_state.color);
	//	    strcpy(canvas_state.previous_fill, canvas_state.color);
	//	}
	// /* Fall through */
	//    case 0:
	//    case 1:
	//    case 2:
	//    case 3:
	//    case 5:
	//    case 7:
	//	fprintf(gpoutfile, "Pt(%d,%.1f,%.1f,%.1f);\n", pt,
	//		x/CANVAS_OVERSAMPLE, (canvas_ymax-y)/CANVAS_OVERSAMPLE, width);
	//	break;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_pointsize(double ptsize)
	//{
	//    if (ptsize < 0)
	//	CANVAS_ps = 1;
	//    else
	//	CANVAS_ps = ptsize;
	//}
	//
	//
	//TERM_PUBLIC int
	//CANVAS_text_angle(int ang)
	//{
	//    canvas_text_angle = -1 * ang;
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    if (!str || !(*str))
	//	return;
	//
	//    CANVAS_finish();
	//    if (0 != canvas_text_angle) {
	//	fprintf(gpoutfile,
	//		"TR(%d,%d,%d,%.1f,\"%s\",\"",
	//		    x, (int)(canvas_ymax + 5*CANVAS_OVERSAMPLE - y),
	//		    canvas_text_angle, canvas_font_size, canvas_justify);
	//    } else {
	//	fprintf(gpoutfile, "T(%d,%d,%.1f,\"%s\",\"",
	//		x, (int)(canvas_ymax + 5*CANVAS_OVERSAMPLE - y), canvas_font_size,
	//		canvas_justify);
	//    }
	//
	// /* Sanitize string by escaping quote characters */
	//    do {
	//	if (*str == '"' || *str == '\\')
	//	    fputc('\\', gpoutfile);
	//	fputc(*str++, gpoutfile);
	//    } while (*str);
	//
	//    fprintf(gpoutfile, "\");\n");
	//}
	//
	//
	//TERM_PUBLIC void
	//CANVAS_linewidth(double linewidth)
	//{
	//    CANVAS_finish();
	//    if (canvas_state.previous_linewidth != linewidth) {
	//	fprintf(gpoutfile, "ctx.lineWidth = %g;\n", linewidth * canvas_linewidth);
	//	canvas_state.previous_linewidth = linewidth;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_set_color(t_colorspec *colorspec)
	//{
	//    rgb255_color rgb255;
	//
	//    if (colorspec->type == TC_LT) {
	//	CANVAS_linetype(colorspec->lt);
	//	return;
	//    } else if (colorspec->type == TC_RGB) {
	//	rgb255.r = colorspec->lt >> 16;
	//	rgb255.g = (colorspec->lt >> 8) & 0xff;
	//	rgb255.b = colorspec->lt & 0xff;
	//    } else if (colorspec->type == TC_FRAC) {
	//	rgb255maxcolors_from_gray(colorspec->value, &rgb255);
	//    } else
	// /* Other color types not yet supported */
	//	return;
	//
	//    CANVAS_finish();
	//
	//    sprintf(canvas_state.color,"rgb(%03d,%03d,%03d)", rgb255.r, rgb255.g, rgb255.b);
	//    if (strcmp(canvas_state.color, canvas_state.previous_color)) {
	//	fprintf(gpoutfile, "ctx.strokeStyle = \"%s\";\n", canvas_state.color);
	//	strcpy(canvas_state.previous_color, canvas_state.color);
	//    }
	//    canvas_line_type = LT_UNDEFINED;
	//}
	//
	//TERM_PUBLIC int
	//CANVAS_make_palette(t_sm_palette *palette)
	//{
	// /* We can do full RGB color */
	//    return 0;
	//}
	//
	//static char *
	//CANVAS_fillstyle(int style)
	//{
	//    float density = (float)(style >> 4) / 100.;
	//    static char fillcolor[24];
	//
	//    switch (style & 0xf) {
	//	case FS_TRANSPARENT_SOLID:
	//		sprintf(fillcolor,"rgba(%11.11s,%4.2f)%c",
	//			&canvas_state.color[4], density, '\0');
	//		break;
	//	case FS_EMPTY:
	//		strcpy(fillcolor,"rgba(255,255,255,0.00)");
	//		break;
	//	case FS_PATTERN:
	//	case FS_TRANSPARENT_PATTERN:
	// /* Patterns are possible, but not yet implemented */
	//		switch ((style >> 4) % 5) {
	//			case 0: density = 0.00; break;
	//			case 1: density = 1.00; break;
	//			case 2: density = 0.25; break;
	//			case 3: density = 0.75; break;
	//			case 4: density = 0.50; break;
	//		}	// fall through 
	//	case FS_SOLID:
	//		if (density == 1) {
	//		    strcpy(fillcolor,canvas_state.color);
	//		} else {
	//		    int r = atoi(&canvas_state.color[4]);
	//		    int g = atoi(&canvas_state.color[8]);
	//		    int b = atoi(&canvas_state.color[12]);
	//		    r = (float)r*density + 255.*(1.-density);
	//		    g = (float)g*density + 255.*(1.-density);
	//		    b = (float)b*density + 255.*(1.-density);
	//		    sprintf(fillcolor,"rgb(%3d,%3d,%3d)%c", r, g, b, '\0');
	//		}
	//		break;
	//	default:
	// /* Use current color, wherever it came from */
	//		sprintf(fillcolor,"%s%c",canvas_state.color,'\0');
	//    }
	//
	//    return fillcolor;
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int		i;
	//
	//    CANVAS_finish();
	//
	//    if (corners->style != FS_OPAQUE && corners->style != FS_DEFAULT) {
	//	char *fillcolor = CANVAS_fillstyle(corners->style);
	//	if (strcmp(canvas_state.previous_fill, fillcolor)) {
	//	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", fillcolor);
	//	    strcpy(canvas_state.previous_fill, fillcolor);
	//	}
	//    }
	//
	//    fprintf(gpoutfile,
	//	    "bp(%d, %d);\n"
	//            , corners[0].x, canvas_ymax - corners[0].y);
	//
	//    for (i = 1; i < points; i++) {
	//	fprintf(gpoutfile,
	//		"L(%d, %d);\n"
	//                , corners[i].x, canvas_ymax - corners[i].y);
	//    }
	//
	//    if (corners->style != FS_OPAQUE && corners->style != FS_DEFAULT)
	// /* Fill with separate fillStyle color */
	//	fprintf(gpoutfile, "cfp();\n");
	//    else
	// /* Fill with stroke color */
	//	fprintf(gpoutfile, "cfsp();\n");
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
	//{
	//    char *fillcolor = CANVAS_fillstyle(style);
	//
	// /* Since filled-rectangle is a primitive operation for the canvas element */
	// /* it's worth making this a special case rather than using filled_polygon */
	//	if (strcmp(canvas_state.previous_fill, fillcolor)) {
	//	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", fillcolor);
	//	    strcpy(canvas_state.previous_fill, fillcolor);
	//	}
	//
	//	fprintf(gpoutfile, "R(%d,%d,%d,%d);\n",
	//		x1, canvas_ymax - (y1+height), width, height);
	//}
	//
	//TERM_PUBLIC void 
	//CANVAS_layer(t_termlayer layer)
	//{
	//	if (layer == TERM_LAYER_BEGIN_GRID) {
	//	    fprintf(gpoutfile, "if (grid_lines) {\n"
	//			"var saveWidth = ctx.lineWidth;\n"
	//			"ctx.lineWidth = ctx.lineWidth * 0.5;\n");
	//	} else if (layer == TERM_LAYER_END_GRID) {
	//	    fprintf(gpoutfile,
	//			"ctx.lineWidth = saveWidth;\n"
	//			"} // grid_lines\n");
	//	}
	//}
	//
	//TERM_PUBLIC void
	//CANVAS_path(int p)
	//{
	//    switch (p) {
	//	case 1: // Close path 
	//		fprintf(gpoutfile, "ctx.closePath();\n");
	//		already_closed = TRUE;
	//		break;
	//	case 0:
	//		break;
	//    }
	//}
	//
	// /* Enhanced text mode support starts here */
	//
	//static double ENHCANVAS_base = 0.0;
	//static double ENHCANVAS_fontsize = 0;
	//static TBOOLEAN ENHCANVAS_opened_string = FALSE;
	//static TBOOLEAN ENHCANVAS_show = TRUE;
	//static TBOOLEAN ENHCANVAS_sizeonly = FALSE;
	//static TBOOLEAN ENHCANVAS_widthflag = TRUE;
	//static TBOOLEAN ENHCANVAS_overprint = FALSE;
	//
	//TERM_PUBLIC void
	//ENHCANVAS_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	//    static int save_x, save_y;
	// /* overprint = 1 means print the base text (leave position in center)
	//  * overprint = 2 means print the overlying text
	//  * overprint = 3 means save current position
	//  * overprint = 4 means restore saved position
	//  */
	//    if (overprint == 3) {
	//	save_x = canvas_x;
	//	save_y = canvas_y;
	//	return;
	//    }
	//    if (overprint == 4) {
	//	canvas_x = save_x;
	//	canvas_y = save_y;
	//	return;
	//    }
	//
	//    if (!ENHCANVAS_opened_string) {
	//	ENHCANVAS_opened_string = TRUE;
	//	enhanced_cur_text = &enhanced_text[0];
	//	ENHCANVAS_fontsize = fontsize;
	//	ENHCANVAS_base = base * CANVAS_OVERSAMPLE;
	//	ENHCANVAS_show = showflag;
	//	ENHCANVAS_widthflag = widthflag;
	//	ENHCANVAS_overprint = overprint;
	//    }
	//}
	//
	// /*
	//  * Since we only have the one font, and the character widths are known,
	//  * we can go to the trouble of actually counting character widths.
	//  * As it happens, the averages width of ascii characters is 20.
	//  */
	//static int utf8strlen(char *s)
	//{
	//    int width = 0;
	//    char *end = s + strlen(s);
	//
	//    while (*s) {
	//	if ((*s & 0x80) == 0) {
	//		if      (strchr("iIl|", *s)) width += 8;
	//		else if (strchr("j`',;:!.", *s)) width += 10;
	//		else if (strchr("ftr", *s)) width += 12;
	//		else if (strchr("()[]{}\\", *s)) width += 14;
	//		else if (strchr(" JTv^_\"*ykLsxz", *s)) width += 16;
	//		else if (strchr("AceFV?abdEghnopqu", *s)) width += 18;
	//		else if (strchr("M~<>%W=&@", *s)) width += 24;
	//		else if (strchr("m", *s)) width += 30;
	//		else width += 20;
	//		s++;
	//		continue;
	//	}
	//	else if (encoding != S_ENC_UTF8) s++;
	//	else if ((*s & 0xE0) == 0xC0) s += 2;
	//	else if ((*s & 0xF0) == 0xE0) s += 3;
	//	else s += 4; 
	//	width += 18;	// Assumed average width for UTF8 characters 
	//	if (s > end) break;
	//    }
	//    return (width);
	//}
	//
	//TERM_PUBLIC void
	//ENHCANVAS_FLUSH()
	//{
	//    double save_fontsize;
	//    int x,y;
	//    double w;
	//
	//    if (ENHCANVAS_opened_string) {
	//	ENHCANVAS_opened_string = FALSE;
	//	*enhanced_cur_text = '\0';
	//
	//	save_fontsize = canvas_font_size;
	//	x = canvas_x;
	//	y = canvas_y;
	//	w = utf8strlen(enhanced_text) * CANVAS_OVERSAMPLE * ENHCANVAS_fontsize/25.;
	//
	//	canvas_font_size = ENHCANVAS_fontsize;
	//	x -= sin((double)canvas_text_angle * M_PI_2/90.) * ENHCANVAS_base;
	//	y += cos((double)canvas_text_angle * M_PI_2/90.) * ENHCANVAS_base;
	//	if (ENHCANVAS_show && !ENHCANVAS_sizeonly)
	//		CANVAS_put_text(x, y, enhanced_text);
	//
	//	if (ENHCANVAS_overprint == 1) {
	//	    canvas_x += w * cos((double)canvas_text_angle * M_PI_2/90.)/2;
	//	    canvas_y -= w * sin((double)canvas_text_angle * M_PI_2/90.)/2;
	//	} else if (ENHCANVAS_widthflag) {
	//	    canvas_x += w * cos((double)canvas_text_angle * M_PI_2/90.);
	//	    canvas_y -= w * sin((double)canvas_text_angle * M_PI_2/90.);
	//	}
	//	canvas_font_size = save_fontsize;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHCANVAS_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char *original_string = (char *)str;
	//
	// /* Save starting font properties */
	//    double fontsize = canvas_font_size;
	//    char *fontname = "";
	//
	//    if (!strlen(str))
	//	return;
	//
	//    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
	//	CANVAS_put_text(x, y, str);
	//	return;
	//    }
	//
	//    CANVAS_move(x,y);
	//
	// /* Set up global variables needed by enhanced_recursion() */
	//    enhanced_fontscale = 1.0;
	//    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
	//    ENHCANVAS_opened_string = FALSE;
	//    ENHCANVAS_fontsize = canvas_font_size;
	//    if (!strcmp(canvas_justify,"Right") || !strcmp(canvas_justify,"Center"))
	//	ENHCANVAS_sizeonly = TRUE;
	//
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//			fontname, fontsize, 0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//	enh_err_check(str);
	//	if (!*++str)
	//	    break; // end of string 
	//    }
	//
	// /* We can do text justification by running the entire top level string */
	// /* through 2 times, with the ENHgd_sizeonly flag set the first time.   */
	// /* After seeing where the final position is, we then offset the start  */
	// /* point accordingly and run it again without the flag set.            */
	//    if (!strcmp(canvas_justify,"Right") || !strcmp(canvas_justify,"Center")) {
	//	char *justification = canvas_justify;
	//	int x_offset = canvas_x - x;
	//	int y_offset = (canvas_text_angle == 0) ? 0 : canvas_y - y;
	//
	//	canvas_justify = "";
	//	ENHCANVAS_sizeonly = FALSE;
	//
	//	if (!strcmp(justification,"Right")) {
	//	    ENHCANVAS_put_text(x - x_offset, y - y_offset, original_string);
	//	} else if (!strcmp(justification,"Center")) {
	//	    ENHCANVAS_put_text(x - x_offset/2, y - y_offset/2, original_string);
	//	}
	//	canvas_justify = justification;
	//    }
	//
	// /* Make sure we leave with the same font properties as on entry */
	//	canvas_font_size = fontsize;
	//	ENHCANVAS_base = 0;
	//
	//    return;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(canvas_driver)
	//    "canvas", "HTML Canvas object",
	//    CANVAS_XMAX, CANVAS_YMAX, CANVASVCHAR, CANVASHCHAR,
	//    CANVASVTIC, CANVASHTIC, CANVAS_options, CANVAS_init, CANVAS_reset,
	//    CANVAS_text, null_scale, CANVAS_graphics, CANVAS_move, CANVAS_vector,
	//    CANVAS_linetype, CANVAS_put_text, CANVAS_text_angle,
	//    CANVAS_justify_text, CANVAS_point, do_arrow, 
	//    set_font_null,
	//    CANVAS_pointsize,
	//    TERM_CAN_MULTIPLOT|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
	//    NULL, NULL, CANVAS_fillbox, CANVAS_linewidth
	///#ifdef USE_MOUSE
	//    , NULL, NULL, NULL, NULL, NULL
	///#endif
	//    , CANVAS_make_palette, NULL, CANVAS_set_color
	//    , CANVAS_filled_polygon
	//    , NULL // image 
	//    , ENHCANVAS_OPEN, ENHCANVAS_FLUSH, do_enh_writec
	//    , CANVAS_layer
	//    , CANVAS_path		// path 
	//TERM_TABLE_END(canvas_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM canvas_driver
	//
	///#endif // TERM_TABLE 

	///#ifdef TERM_HELP
	//START_HELP(canvas)
	//"1 canvas",
	//"?commands set terminal canvas",
	//"?set terminal canvas",
	//"?set term canvas",
	//"?terminal canvas",
	//"?term canvas",
	//"",
	//" Syntax:",
	//"       set terminal canvas {size <xsize>, <ysize>} {fsize <fontsize>}",
	//"                           {{no}enhanced} {linewidth <lw>}",
	//"                           {standalone {mousing} | name '<funcname>'}",
	//"                           {jsdir 'URL/for/javascripts'}",
	//"                           {title '<some string>'}",
	//"",
	//" where <xsize> and <ysize> set the size of the plot area in pixels.",
	//" The default size in standalone mode is 600 by 400 pixels.",
	//" The default font size is 10.  NB: Only one font is available, the ascii",
	//" portion of Hershey simplex Roman provided in the file canvastext.js.",
	//" You can replace this with the file canvasmath.js, which contains also",
	//" UTF-8 encoded Hershey simplex Greek and math symbols.",
	//"",
	//" The default `standalone` mode creates an html page containing javascript",
	//" code that renders the plot using the HTML 5 canvas element.  The html page",
	//" links to two required javascript files 'canvastext.js' and 'gnuplot_common.js'.",
	//" By default these point to local files, on unix-like systems usually in",
	//" directory /usr/local/share/gnuplot/<version>/js.  See installation notes for",
	//" other platforms. You can change this by using the `jsdir` option to specify",
	//" either a different local directory or a general URL.  The latter is usually",
	//" appropriate if the plot is exported for viewing on remote client machines.",
	//"",
	//" All plots produced by the canvas terminal are mouseable.  The additional",
	//" keyword `mousing` causes the `standalone` mode to add a mouse-tracking box",
	//" underneath the plot. It also adds a link to a javascript file",
	//" 'gnuplot_mouse.js' and to a stylesheet for the mouse box 'gnuplot_mouse.css'",
	//" in the same local or URL directory as 'canvastext.js'.",
	//"",
	//" The `name` option creates a file containing only javascript. Both the",
	//" javascript function it contains and the id of the canvas element that it",
	//" draws onto are taken from the following string parameter.  The commands",
	//"       set term canvas name 'fishplot'",
	//"       set output 'fishplot.js'",
	//" will create a file containing a javascript function fishplot() that will",
	//" draw onto a canvas with id=fishplot.  An html page that invokes this",
	//" javascript function must also load the canvastext.js function as described",
	//" above.  A minimal html file to wrap the fishplot created above might be:",
	//"",
	//"       <html>",
	//"       <head>",
	//"           <script src=\"canvastext.js\"></script>",
	//"           <script src=\"gnuplot_common.js\"></script>",
	//"       </head>",
	//"       <body onload=\"fishplot();\">",
	//"           <script src=\"fishplot.js\"></script>",
	//"           <canvas id=\"fishplot\" width=600 height=400>",
	//"               <div id=\"err_msg\">No support for HTML 5 canvas element</div>",
	//"           </canvas>",
	//"       </body>",
	//"       </html>",
	//""
	//END_HELP(canvas)
	///#endif // TERM_HELP 


	/* Computer Graphics Metafile (eg ms office) */
	/* Hey Emacs this is -*- C -*-
	 * $Id: cgm.trm,v 1.91.2.3 2010/02/24 20:16:57 sfeam Exp $
	 */

	/* GNUPLOT - cgm.trm */

	/*[
	 * Copyright 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c and ../docs/termdoc.c.
	 *
	 * This terminal driver supports:
	 *   Computer Graphics Metafile
	 *
	 * TODO
	 *   better control over plot size (never cutting off labels, correct font
	 *   sizes)
	
	 * REFERENCES
	 *
	 *   ISO 8632-1:1992 Computer Graphics Metafile (CGM), Part 1,
	 *   Functional Specification.
	 *
	 *   ISO 8632-1:1992 Computer Graphics Metafile (CGM), Part 3,
	 *   Binary Encoding.
	 *
	 *   FIPS PUB 128 - Computer Graphics Metafile (CGM).
	 *
	 *   MIL-STD-2301A Computer Graphics Metafile (CGM) Implementation
	 *   Standard for the National Imagery Transmission Format Standard, 5
	 *   June 1998, http://164.214.2.51/ntb/baseline/docs/2301a/.  Only a
	 *   subset of CGM version 1, but does include the binary format for
	 *   that subset.
	 *
	 *   MIL-D-28003A "Digital Representation for Communication of
	 *   Illustration Data: CGM Application Profile", 15 November 1991,
	 *   http://www-cals.itsi.disa.mil/core/standards/28003aa1.pdf.
	 *
	 *   "The computer graphics metafile", Lofton R. Henderson and Anne
	 *   M. Mumford, Butterworths, London, 1990, ISBN 0-408-02680-4.
	 *
	 * AUTHOR
	 *   Jim Van Zandt <jrvz@comcast.net>
	 *
	 * send your comments or suggestions to the author or
	 * gnuplot-info@lists.sourceforge.net.
	*/


	///#ifdef TERM_REGISTER
	//register_term(cgm)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void CGM_options __PROTO((void));
	//TERM_PUBLIC void CGM_init __PROTO((void));
	//TERM_PUBLIC void CGM_reset __PROTO((void));
	//TERM_PUBLIC void CGM_text __PROTO((void));
	//TERM_PUBLIC void CGM_graphics __PROTO((void));
	//TERM_PUBLIC void CGM_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void CGM_dashed_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void CGM_solid_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void CGM_linetype __PROTO((int linetype));
	//TERM_PUBLIC void CGM_linecolor __PROTO((int color));
	//TERM_PUBLIC void CGM_dashtype __PROTO((int dashtype));
	//TERM_PUBLIC void CGM_linewidth __PROTO((double width));
	//TERM_PUBLIC void CGM_put_text __PROTO((unsigned int x, unsigned int y,
	//				       const char *str));
	//TERM_PUBLIC int CGM_text_angle __PROTO((int ang));
	//TERM_PUBLIC int CGM_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int CGM_set_font __PROTO((const char *font));
	//TERM_PUBLIC void CGM_point __PROTO((unsigned int x, unsigned int y,
	//				    int number));
	//TERM_PUBLIC void CGM_fillbox __PROTO((int style, unsigned int x1, unsigned int y1,
	//				unsigned int width, unsigned int height));
	//TERM_PUBLIC int CGM_make_palette __PROTO((t_sm_palette *palette));
	//TERM_PUBLIC void CGM_set_color __PROTO((t_colorspec *));
	//
	//TERM_PUBLIC void CGM_filled_polygon __PROTO((int points, gpiPoint *corner));
	//
	//TERM_PUBLIC void CGM_set_pointsize __PROTO((double size));
	//
	///#define FATAL(msg) { fprintf(stderr, "%s\nFile %s line %d\n", msg, __FILE__, __LINE__); exit(EXIT_FAILURE); }
	//
	///#define CGM_LARGE 32767
	///#define CGM_SMALL 32767/18*13	// aspect ratio 1:.7222 
	///#define CGM_MARGIN (CGM_LARGE/180)
	// /* convert from plot units to pt */
	///#define CGM_PT ((term->xmax + CGM_MARGIN)/cgm_plotwidth)
	///#define CGM_LINE_TYPES 9	// number of line types we support 
	///#define CGM_COLORS 96		// must not exceed size of pm3d_color_names_tbl[] 
	///#define CGM_POINTS 13		// number of markers we support 
	///#define CGM_MAX_SEGMENTS 16382	// maximum # polyline coordinates 
	///#define CGM_VCHAR (CGM_SMALL/360*12)
	///#define CGM_HCHAR (CGM_SMALL/360*12*5/9)
	///#define CGM_VTIC (CGM_LARGE/80)
	///#define CGM_HTIC (CGM_LARGE/80)
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static int CGM_find_font __PROTO((const char *name, int len, double *relwidth));
	//static int CGM_find_nearest_color __PROTO((t_colorspec *colorspec));
	// /*
	//  * on NeXTstep, id is an identifier (in ObjC) and causes a parse error
	//  * since some asserts below are mistaken as casts. datum is a type
	//  * defined in ndbm.h which also causes a parse error (ndbm.h is
	//  * included as part of appkit.h, I think).  Strangely enough, both
	//  * errors only happen with cpp-precomp -smart, not with the regular
	//  * cpp. (AL)
	//  */
	//
	///#ifdef NEXT
	///#define id id_
	///#define datum datum_
	///#endif
	//
	///#include <ctype.h>		// for isspace() 
	//
	///#ifndef assert
	///#define assert(x) 0		// defeat assertions 
	///#endif
	//
	// /* uncomment the following to enable assertions for this module only,
	//    regardless of compiler switches
	// #ifdef NDEBUG
	// #define DEFEAT_ASSERTIONS
	// #endif
	// #undef NDEBUG
	// #include <assert.h>
	//  */
	//
	///#define CGM_ADJ (sizeof(int)/sizeof(short))
	//
	//static unsigned int cgm_posx;
	//static unsigned int cgm_posy;
	//static unsigned int cgm_linetype = 1;
	//static unsigned int cgm_linetypes = CGM_LINE_TYPES + 3;
	//static unsigned int cgm_dashtype = 0;
	//static unsigned int cgm_color = 0;
	//static int *cgm_polyline; // stored polyline coordinates 
	//static int cgm_coords = 0;	// # polyline coordinates saved 
	//static int cgm_doing_polygon = 0; /* nonzero if creating polygon, else
	// 				   * creating polyline */
	// /* static enum JUSTIFY cgm_justify = LEFT; //Tangible continue code after comment*/
	// /* unused */
	//static int cgm_step_sizes[8]; /* array of currently used dash
	// 				   lengths in plot units */
	//static int cgm_step_index = 0;	// index into cgm_step_sizes[] 
	//static int cgm_step = 0; /* amount of current dash not yet
	// 				   drawn, in plot units */
	//static int cgm_tic, cgm_tic707, cgm_tic866, cgm_tic500, cgm_tic1241, cgm_tic1077, cgm_tic621;	// marker dimensions 
	//struct cgm_properties {
	//  double angle; /* angle of text baseline (radians
	//                                    counter-clockwise from horizontal) */
	//  int font_index;		// font index 
	//  int char_height;		// character height in picture units 
	//  enum JUSTIFY justify_mode;	// how text is justified 
	//
	//  int edge_visibility;		// nonzero if edge is visible 
	//  int edge_color;
	//  int fill_color;
	//  int interior_style;
	//  int hatch_index;
	//};
	//
	//static struct cgm_properties
	//    cgm_current={-1,-1,-1,(enum JUSTIFY)-1,-1,-1,-1,-1,-1}, // written to file 
	//    cgm_next={0,-2,-2,LEFT,-2,-2,-2,-1,-1}, // needed for next text string/marker 
	//    cgm_reset={-1,-1,-1,(enum JUSTIFY)-1,-1,-1,-1,-1,-1}; // invalid entries 
	//
	//static int cgm_user_color_count = 0;
	//static int cgm_user_color_max = 0;
	//static int cgm_smooth_colors = 0;
	//static int GPFAR *cgm_user_color_table = (int GPFAR*)0;
	//static int cgm_maximum_color_index = 255;	// Size of color table we will write 
	//
	//struct fontdata {
	//  char *name;			// the name of the font 
	//  double width; /* the width of the font, relative to
	//                                    Times Bold Italic.  The width
	//                                    adjustment can only be approximate.
	//                                    Of the standard fonts, only the
	//                                    four versions of "Courier" are
	//                                    monospaced. Also, metrics of the
	//                                    same font from different foundaries
	//                                    are sometimes different.  */
	//};
	//
	//static struct fontdata cgm_basic_font_data[]={
	// /* these are WebCGM recommended fonts */
	//    {"Helvetica",1.039},
	//    {"Helvetica Oblique",1.099},
	//    {"Helvetica Bold",1.083},
	//    {"Helvetica Bold Oblique",1.011},
	//    {"Times Roman",.981},
	//    {"Times Bold",.985},
	//    {"Times Italic",.959},
	//    {"Times Bold Italic",1.0},
	//    {"Courier",1.327},
	//    {"Courier Bold",1.327},
	//    {"Courier Oblique",1.218},
	//    {"Courier Bold Oblique",1.341},
	//    {"Symbol",.897},
	//
	// /* These are basic public domain fonts required by MIL-D-28003A */
	//    {"Hershey/Cartographic_Roman",1.2404},
	//    {"Hershey/Cartographic_Greek",.9094},
	//    {"Hershey/Simplex_Roman",1.2369},
	//    {"Hershey/Simplex_Greek",.9129},
	//    {"Hershey/Simplex_Script",1.4181},
	//    {"Hershey/Complex_Roman",1.1150},
	//    {"Hershey/Complex_Greek",.9059},
	//    {"Hershey/Complex_Script",1.3868},
	//    {"Hershey/Complex_Italic",1.4146},
	//    {"Hershey/Complex_Cyrillic",1.2056},
	//    {"Hershey/Duplex_Roman",1.1707},
	//    {"Hershey/Triplex_Roman",1.3240},
	//    {"Hershey/Triplex_Italic",1.3310},
	//    {"Hershey/Gothic_German",1.2056},
	//    {"Hershey/Gothic_English",1.2021},
	//    {"Hershey/Gothic_Italian",1.2021},
	//    {"Hershey/Symbol_Set_1",.9059},
	//    {"Hershey/Symbol_Set_2",.9059},
	//    {"Hershey/Symbol_Math",.9059},
	//
	// /* These are available in the Microsoft Office import filter.  By
	//    default, the script font can apparently be accessed only via
	//    the name "15".  */
	//    {"ZapfDingbats",1.583},
	//    {"Script",1.139},
	//    {"15",1.139},
	//
	// /* in the Microsoft Office and Corel Draw import filters, these
	//    are pseudonyms for some of the above */
	//    {"Helvetica Italic",1.099},
	//    {"Helvetica Bold Italic",1.011},
	//    {"Courier Italic",1.218},
	//    {"Courier Bold Italic",1.341},
	//    {"Times Oblique",.959},
	//    {"Times Bold Oblique",1.0},
	//
	//    {0,0}
	//};
	//
	//static struct fontdata *cgm_font_data = cgm_basic_font_data;
	//
	///#define DEFAULT_CGMFONT "Helvetica Bold"
	//static char CGM_default_font[MAX_ID_LEN+1] = {'\0'};
	//
	// /* variables to record the options */
	//static char cgm_font[32] = DEFAULT_CGMFONT;
	//static unsigned int cgm_fontsize = 12;
	//static unsigned cgm_linewidth;	// line width in plot units 
	//static unsigned cgm_linewidth_pt = 1;	// line width in pt 
	//static TBOOLEAN cgm_monochrome = FALSE;		// colors enabled? 
	//static int cgm_plotwidth = 432;	// assumed width of plot in pt. 
	//static TBOOLEAN cgm_portrait = FALSE;	// portrait orientation? 
	//static TBOOLEAN cgm_rotate = TRUE;	// text rotation enabled? 
	//static TBOOLEAN cgm_dashed = TRUE;	// dashed linestyles enabled? 
	//static TBOOLEAN cgm_nofontlist_mode = FALSE;	// omit font list? 
	//
	// /* prototypes for static functions */
	//static void CGM_local_reset __PROTO((void));
	//static void CGM_flush_polyline __PROTO((void));
	//static void CGM_flush_polygon __PROTO((void));
	//static void CGM_write_char_record __PROTO((int class, int cgm_id, int length,
	//					   char *data));
	//static void CGM_write_code __PROTO((int class, int cgm_id, int length));
	//static void CGM_write_int __PROTO((int value));
	//static void CGM_write_int_record __PROTO((int class, int cgm_id, int length,
	//					  int *data));
	//static void CGM_write_mixed_record __PROTO((int class, int cgm_id,
	//					    int numint, int *int_data,
	//					    int numchar, const char *char_data));
	//static void CGM_write_byte_record __PROTO((int class, int cgm_id, int length,
	//					   char *data));
	//
	//enum CGM_id {
	// /* cgm mode */
	//    CGM_PORTRAIT, CGM_LANDSCAPE, CGM_DEFAULT,
	// /* color */
	//    CGM_MONOCHROME, CGM_COLOR,
	// /* rotation */
	//    CGM_ROTATE, CGM_NOROTATE,
	//    CGM_DASHED, CGM_SOLID,
	//    CGM_LINEWIDTH, CGM_WIDTH, CGM_NOFONTLIST, CGM_OTHER
	//};
	//
	//static struct gen_table CGM_opts[] =
	//{
	//    { "p$ortrait", CGM_PORTRAIT },
	//    { "la$ndscape", CGM_LANDSCAPE },
	//    { "de$fault", CGM_DEFAULT },
	//    { "nof$ontlist", CGM_NOFONTLIST },
	//    { "win$word6", CGM_NOFONTLIST }, // deprecated 
	//    { "m$onochrome", CGM_MONOCHROME },
	//    { "c$olor", CGM_COLOR },
	//    { "c$olour", CGM_COLOR },
	//    { "r$otate", CGM_ROTATE },
	//    { "nor$otate", CGM_NOROTATE },
	//    { "da$shed", CGM_DASHED },
	//    { "s$olid", CGM_SOLID },
	//    { "li$newidth", CGM_LINEWIDTH },
	//    { "lw", CGM_LINEWIDTH },
	//    { "wid$th", CGM_WIDTH },
	//    { NULL, CGM_OTHER }
	//};
	//
	//
	//TERM_PUBLIC void
	//CGM_options()
	//{
	//    char *string;
	//
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we have already initialized the terminal.                  */
	//    if (c_token != 2)
	//	CGM_local_reset();
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&CGM_opts[0],c_token)) {
	//	case CGM_PORTRAIT:
	//	    cgm_portrait = TRUE;
	//	    c_token++;
	//	    break;
	//	case CGM_LANDSCAPE:
	//	    cgm_portrait = FALSE;
	//	    c_token++;
	//	    break;
	//	case CGM_DEFAULT:
	//	    CGM_local_reset();
	//	    c_token++;
	//	    break;
	//	case CGM_NOFONTLIST:
	//	    cgm_nofontlist_mode = TRUE;
	//	    c_token++;
	//	    break;
	//	case CGM_MONOCHROME:
	//	    cgm_monochrome = TRUE;
	//	    term->flags |= TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case CGM_COLOR:
	//	    cgm_monochrome = FALSE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case CGM_ROTATE:
	//	    cgm_rotate = TRUE;
	//	    c_token++;
	//	    break;
	//	case CGM_NOROTATE:
	//	    cgm_rotate = FALSE;
	//	    c_token++;
	//	    break;
	//	case CGM_DASHED:
	//	    cgm_dashed = TRUE;
	//	    c_token++;
	//	    break;
	//	case CGM_SOLID:
	//	    cgm_dashed = FALSE;
	//	    c_token++;
	//	    break;
	//	case CGM_LINEWIDTH:
	//	    c_token++;
	//	    if (!END_OF_COMMAND) {
	//		cgm_linewidth_pt = int_expression();
	//		if (cgm_linewidth_pt == 0 || cgm_linewidth_pt > 10000) {
	//		    int_warn(c_token,"linewidth out of range");
	//		    cgm_linewidth_pt = 1;
	//		}
	//	    }
	//	    break;
	//	case CGM_WIDTH:
	//	    c_token++;
	//	    if (!END_OF_COMMAND) {
	//		cgm_plotwidth = int_expression();
	//		if (cgm_plotwidth < 0 || cgm_plotwidth > 10000) {
	//		    int_warn(c_token,"width out of range");
	//		    cgm_plotwidth = 6 * 72;
	//		}
	//	    }
	//	    break;
	//	case CGM_OTHER:
	//	default:
	//	    string = gp_input_line + token[c_token].start_index;
	//
	//	    if (string[0] == 'x') { // set color 
	//	        unsigned short red, green, blue;
	//
	//		if (sscanf(string, "x%2hx%2hx%2hx", &red, &green, &blue ) != 3)
	//		     int_error(c_token, "invalid color spec, must be xRRGGBB");
	//		if (cgm_user_color_count >= cgm_user_color_max) {
	//		     cgm_user_color_max = cgm_user_color_max*2 + 4;
	//		     cgm_user_color_table =
	//			  gp_realloc(cgm_user_color_table,
	//				     (cgm_user_color_max*3+1)*sizeof(int),
	//				     "CGM color table");
	// /* 1st table entry is the minimum color index value */
	//		     cgm_user_color_table[0] = 0;
	//		}
	//		cgm_user_color_table[1 + 3*cgm_user_color_count] = red;
	//		cgm_user_color_table[2 + 3*cgm_user_color_count] = green;
	//		cgm_user_color_table[3 + 3*cgm_user_color_count] = blue;
	//		cgm_user_color_count++;
	//		++c_token;
	//	    } else {
	//		if (equals(c_token,"font"))
	//		    c_token++;
	//		if (isstringvalue(c_token)) {
	//		    double relwidth;
	//		    int font_index;
	//		    char *s = try_to_get_string();
	//		    char *comma = strchr(s,',');
	//		    if (comma && (1 == sscanf(comma+1,"%d",&cgm_fontsize)))
	//			   *comma = '\0';
	//		    if (*s)
	//		      	   font_index = CGM_find_font(s, strlen(s), &relwidth);
	//		    else
	//			   font_index = CGM_find_font(cgm_font, strlen(cgm_font), &relwidth);
	//		    if (font_index == 0) {
	// /* insert the font in the font table */
	//			struct fontdata *new_font_data;
	//			int i, n;
	//			for (n=0; cgm_font_data[n].name; n++)
	//				;
	//			new_font_data = gp_alloc((n + 2)*sizeof(struct fontdata), "CGM font list");
	//			new_font_data->name = s;
	// /* punt, since we don't know the real font width */
	//			new_font_data->width = 1.0;
	//			for (i = 0; i <= n; i++)
	//			     new_font_data[i+1] = cgm_font_data[i];
	//			cgm_font_data = new_font_data;
	//			font_index = 1;
	//		    } else
	//			free(s);
	//		    strncpy(cgm_font, cgm_font_data[font_index-1].name, sizeof(cgm_font));
	//
	//		} else {
	// /* the user is specifying the font size */
	//		      cgm_fontsize = int_expression();
	//		}
	//		 break;
	//	    }
	//	}
	//    }
	//
	//    if (cgm_portrait) {
	//	term->xmax = CGM_SMALL - CGM_MARGIN;
	//	term->ymax = CGM_LARGE - CGM_MARGIN;
	//    } else {
	//	term->xmax = CGM_LARGE - CGM_MARGIN;
	//	term->ymax = CGM_SMALL - CGM_MARGIN;
	//    }
	//
	//    {   // cgm_font, cgm_fontsize, and/or term->v_char may have changed 
	//        double w;
	//	CGM_find_font(cgm_font, strlen(cgm_font), &w);
	//	term->v_char = (unsigned int) (cgm_fontsize*CGM_PT);
	//	term->h_char = (unsigned int) (cgm_fontsize*CGM_PT*.527*w);
	//    }
	//
	//    sprintf(CGM_default_font, "%s,%d", cgm_font, cgm_fontsize);
	// /* CGM_default_font holds the font and size set at 'set term' */
	//    sprintf(term_options, "%s %s %s %s %s width %d linewidth %d \"%s\" %d",
	//	    cgm_portrait ? "portrait" : "landscape",
	//	    cgm_monochrome ? "monochrome" : "color",
	//	    cgm_rotate ? "rotate" : "norotate",
	//	    cgm_dashed ? "dashed" : "solid",
	//	    cgm_nofontlist_mode ? "nofontlist" : "",
	//	    cgm_plotwidth,
	//	    cgm_linewidth_pt,
	//	    cgm_font, cgm_fontsize);
	//
	//    if (cgm_user_color_count) {
	//	 int i, red, green, blue;
	//	 for (i = 0; i < cgm_user_color_count &&
	//		   (strlen(term_options) + 9 < MAX_LINE_LEN); i++) {
	//	      red = cgm_user_color_table[1 + 3*i];
	//	      green = cgm_user_color_table[2 + 3*i];
	//	      blue = cgm_user_color_table[3 + 3*i];
	//	      sprintf(term_options + strlen(term_options),
	//		      " x%02x%02x%02x", red, green, blue);
	//	 }
	//    }
	//
	//    if (cgm_user_color_count < CGM_COLORS) {
	//	int i, j;
	//
	// /* fill in colors not set by the user with the default colors */
	//
	// /* 1st table entry is the minimum color index value */
	//	cgm_user_color_table = gp_realloc(cgm_user_color_table,
	//		(CGM_COLORS * 3 + 1) * sizeof (int), "CGM color table");
	//	cgm_user_color_table[0] = 0;
	//
	//	for (i = cgm_user_color_count, j = cgm_user_color_count * 3;
	//		     i < CGM_COLORS; i++, j+=3) {
	//		cgm_user_color_table[j+1] = (pm3d_color_names_tbl[i].value >> 16) & 0xff;
	//		cgm_user_color_table[j+2] = (pm3d_color_names_tbl[i].value >>  8) & 0xff;
	//		cgm_user_color_table[j+3] = (pm3d_color_names_tbl[i].value      ) & 0xff;
	//	}
	//
	//	cgm_user_color_count = CGM_COLORS;
	//    }
	//
	//}
	//
	//static void
	//CGM_local_reset()
	//{
	//    double w;
	//    strcpy(cgm_font, DEFAULT_CGMFONT);
	//    CGM_find_font(cgm_font, strlen(cgm_font), &w);
	//    cgm_fontsize = 12;
	//    term->v_char = (unsigned int) (cgm_fontsize * CGM_PT);
	//    term->h_char = (unsigned int) (cgm_fontsize * CGM_PT * .527 * w);
	//    cgm_linewidth_pt = 1;
	//    cgm_monochrome = FALSE;
	//    cgm_plotwidth = 6 * 72;
	//    cgm_portrait = FALSE;
	//    cgm_rotate = TRUE;
	//    cgm_dashed = TRUE;
	//    cgm_nofontlist_mode = FALSE;
	//    cgm_current = cgm_reset;
	//    cgm_user_color_count = 0;
	//}
	//
	//TERM_PUBLIC void
	//CGM_init()
	//{
	//    cgm_posx = cgm_posy = 0;
	//    cgm_linetype = 0;
	//    cgm_next.angle = 0;
	//    cgm_next.interior_style = 1;
	//    cgm_next.hatch_index = 1;
	//    cgm_polyline = gp_alloc(CGM_MAX_SEGMENTS*sizeof(int),"cgm polylines");
	//}
	//
	//TERM_PUBLIC void
	//CGM_graphics()
	//{
	//    register struct termentry *t = term;
	//    static int version_data[] = { 1 };
	//    static int vdc_type_data[] = { 0 };
	//    static int integer_precision_data[] = { 16 };
	//    static int real_precision_data[] = { 1, 16, 16 };
	//    static int index_precision_data[] = { 16 };
	//    static int color_precision_data[] = { 16 };
	//    static int color_index_precision_data[] = { 16 };
	//    static int scaling_mode_data[] = { 0, 0, 0 };
	//    static int color_value_extent_data[] = { 0, 0, 0, 255, 255, 255 };
	//    static int color_selection_mode_data[] = { 0 };
	//    static int linewidth_specification_mode_data[] = { 0 };
	//    static int edge_width_specification_mode_data[] = { 0 };
	//    static int marker_size_specification_mode_data[] = { 0 };
	//    static int vdc_extent_data[] = { 0, 0, 0, 0 };
	//    static int line_type_data[] = { 1 };
	//    static int interior_style_data[] = { 1 }; /* 0=hollow 1=filled
	// 					       * 2=pattern 3=hatch
	// 					       * 4=empty */
	//    static int hatch_index_data[] = { 1 }; /* 1=horizontal 2=vertical
	// 					    * 3=positive slope
	// 					    * 4=negative slope
	// 					    * 5=horizontal/vertical
	// 					    * crosshatch
	// 					    * 6=positive/negative
	// 					    * slope crosshatch */
	//
	//    static int GPFAR elements_list_data[] =
	//    {
	//	0,			// will be set to # elements in this list 
	//	0, 1,			// Begin Metafile 
	//	0, 2,			// End Metafile 
	//	0, 3,			// Begin Picture 
	//	0, 4,			// Begin Picture Body 
	//	0, 5,			// End Picture 
	//	1, 1,			// Metafile Version 
	//	1, 2,			// Metafile Description 
	//	1, 3,			// VDC Type 
	//	1, 4,			// Integer Precision 
	//	1, 5,			// Real Precision 
	//	1, 6,			// Index Precision 
	//	1, 7,			// Color Precision 
	//	1, 8,			// Color Index Precision 
	//	1, 9,			// Maximum Color Index 
	//	1, 10,			// Color Value Extent 
	//	1, 13,			// Font List 
	//	2, 1,			// Scaling Mode 
	//	2, 2,			// Color Selection Mode 
	//	2, 3,			// Line Width Specification Mode 
	//	2, 4,			// Marker Size Specification Mode 
	//	2, 5,			// Edge Width Specification Mode 
	//	2, 6,			// VDC Extent 
	///#ifdef NEVER
	// /* disabled due to complaints from CGM import filters */
	//	3, 1,			// VDC Integer Precision 
	//	3, 4,			// Transparency 
	//	3, 6,			// Clip Indicator 
	///#endif
	//	4, 1,			// Polyline 
	//	4, 3,			// Polymarker 
	//	4, 4,			// Text 
	//	4, 7,			// Polygon 
	//	4, 11,			// Rectangle 
	//	4, 12,			// Circle 
	//	4, 15,			// Circular Arc Center 
	//	4, 16,			// Circular Arc Center Close 
	//	4, 17,			// Ellipse 
	//	4, 18,			// Elliptical Arc 
	//	4, 19,			// Elliptical Arc Close 
	//	5, 2,			// Line Type 
	//	5, 3,			// Line Width 
	//	5, 4,			// Line Color 
	//	5, 6,			// Marker Type 
	//	5, 7,			// Marker Size 
	//	5, 8,			// Marker Color 
	//	5, 10,			// Text Font Index 
	//	5, 14,			// Text Color 
	//	5, 15,			// Character Height 
	//	5, 16,			// Character Orientation 
	//	5, 18,			// Text Alignment 
	//	5, 22,			// Interior Style 
	//	5, 23,			// Fill Color 
	//	5, 24,			// Hatch Index 
	//	5, 27,			// Edge Type 
	//	5, 28,			// Edge Width 
	//	5, 29,			// Edge Color 
	//	5, 30,			// Edge Visibility 
	//	5, 34,			// Color Table 
	//	6, 1,			// Escape 
	//	7, 2			// Application Data 
	//    };
	//
	// /* metafile description (class 1), including filename if available */
	//    if (!outstr)
	//	CGM_write_char_record(0, 1, 1, outstr);
	//    else
	//	CGM_write_char_record(0, 1, strlen(outstr) + 1, outstr);
	//    CGM_write_int_record(1, 1, 2, version_data);
	//    {
	//      char description_data[256];
	//      sprintf(description_data, "
	//Gnuplot version %s patchlevel %s,
	// Computer Graphics Metafile version 1 per MIL-D-28003A/BASIC-1.%d",
	//	      gnuplot_version, gnuplot_patchlevel, cgm_monochrome?0:2);
	//	CGM_write_char_record(1, 2, strlen(description_data),
	//			      description_data);
	//    }
	//    elements_list_data[0] = (sizeof(elements_list_data) / CGM_ADJ - 2) / 4;
	//    CGM_write_int_record(1, 11, sizeof(elements_list_data) / CGM_ADJ,
	//			 elements_list_data);
	//    CGM_write_int_record(1, 3, 2, vdc_type_data);
	//    CGM_write_int_record(1, 4, 2, integer_precision_data);
	//    CGM_write_int_record(1, 5, 6, real_precision_data);
	//    CGM_write_int_record(1, 6, 2, index_precision_data);
	//    CGM_write_int_record(1, 7, 2, color_precision_data);
	//    CGM_write_int_record(1, 8, 2, color_index_precision_data);
	//    CGM_write_int_record(1, 9, 2, &cgm_maximum_color_index);
	//    CGM_write_int_record(1, 10, sizeof(color_value_extent_data) / CGM_ADJ,
	//			 color_value_extent_data);
	//    if (cgm_nofontlist_mode == FALSE)
	//      {
	//	char *buf, *s;
	//	int i, lgh = 0;
	//	for (i = 0; cgm_font_data[i].name; i++)
	//	  lgh += strlen(cgm_font_data[i].name) + 1;
	//	buf = gp_alloc(lgh + 1, "CGM font list");
	//	for (s = buf, i = 0; cgm_font_data[i].name; i++)
	//	  {
	//	    int lgh = strlen(cgm_font_data[i].name);
	//	    *s++ = (char)lgh;
	//	    strcpy(s, cgm_font_data[i].name);
	//	    s += lgh;
	//	  }
	//	CGM_write_byte_record(1, 13, lgh, buf);
	//	free(buf);
	//      }
	//
	// /* picture description (classes 2 and 3) */
	//    CGM_write_char_record(0, 3, 8, "PICTURE1");
	//    CGM_write_int_record(2, 1, 6, scaling_mode_data);
	//    CGM_write_int_record(2, 2, 2, color_selection_mode_data);
	//    CGM_write_int_record(2, 3, 2, linewidth_specification_mode_data);
	//    CGM_write_int_record(2, 4, 2, marker_size_specification_mode_data);
	//    CGM_write_int_record(2, 5, 2, edge_width_specification_mode_data);
	//    vdc_extent_data[2] = t->xmax + CGM_MARGIN;
	//    vdc_extent_data[3] = t->ymax + CGM_MARGIN;
	//    CGM_write_int_record(2, 6, 8, vdc_extent_data);
	//
	// /* picture body (classes 4 and 5) */
	//    CGM_write_int_record(0, 4, 0, NULL);
	//
	///#ifdef NEVER		// no need for these, since we accept the defaults 
	//    {
	//      static int vdc_integer_precision_data[] = { 16 };
	//      CGM_write_int_record(3, 1, 2, vdc_integer_precision_data);
	//    }
	//    {
	//      static int transparency_data[] = { 1 }; /* text background:
	// 						 0=auxiliary color
	// 						 1=transparent */
	//      CGM_write_int_record(3, 4, sizeof(transparency_data) / CGM_ADJ,
	//			   transparency_data);
	//    }
	//    {
	//      static int clip_indicator_data[] = { 0 };
	//      CGM_write_int_record(3, 6, sizeof(clip_indicator_data) / CGM_ADJ,
	//			   clip_indicator_data);
	//    }
	///#endif
	//    if (!cgm_monochrome)
	//	CGM_write_int_record(5, 34, (cgm_user_color_count*3+1)*
	//			     sizeof(cgm_user_color_table[0])/CGM_ADJ,
	//			     cgm_user_color_table);
	//    CGM_write_int_record(5, 2, sizeof(line_type_data) / CGM_ADJ,
	//			 line_type_data); // line type 1=SOLID 
	//    cgm_linewidth = cgm_linewidth_pt * CGM_PT;
	//    CGM_write_int_record(5, 3, sizeof(cgm_linewidth) / CGM_ADJ,
	//			 (int *) &cgm_linewidth); // line width 
	//    CGM_write_int_record(5, 28, sizeof(cgm_linewidth) / CGM_ADJ,
	//			 (int *) &cgm_linewidth); // edge width 
	//    CGM_write_int_record(5, 27,  sizeof(line_type_data) / CGM_ADJ,
	//			 line_type_data); // edge type 1=SOLID 
	//    CGM_linecolor(0);
	//
	//    cgm_current = cgm_reset;
	//    cgm_next.char_height = t->v_char;
	//
	//    CGM_write_int_record(5, 22, 2, interior_style_data);
	//    CGM_write_int_record(5, 24, 2, hatch_index_data);
	//    {
	//	char buf[45];
	//	sprintf(buf, "%.31s,%d", cgm_font, cgm_fontsize);
	//	CGM_set_font(buf);
	//    }
	//    CGM_set_pointsize(pointsize);
	//
	// /* Fill with background color if user has specified one */
	//    if (!cgm_monochrome && cgm_user_color_count > 0) {
	//	CGM_linecolor(LT_BACKGROUND);
	//	CGM_fillbox(FS_SOLID, 0, 0, t->xmax, t->ymax);
	//    }
	//
	//}
	//
	// /* Return the index for the font with the name `name'.  The index for
	//    the first font is 1.  Set relwidth to the width of the font,
	//    relative to Times Bold Italic.  If the font is not in the table,
	//    set *relwidth to 1.0 and return 0. */
	//static int
	//CGM_find_font(const char *name, int numchar, double *relwidth)
	//{
	//    int i;
	//    *relwidth = 1.;
	//    for (i=0; cgm_font_data[i].name; i++)
	// /* strncasecmp is not standard, but defined by stdfn.c if not available */
	//      if (strlen(cgm_font_data[i].name) == numchar &&
	//	  strncasecmp(name, cgm_font_data[i].name, numchar) == 0)
	//	{
	//	  *relwidth = cgm_font_data[i].width;
	//	  return i+1;
	//	}
	//
	//    return 0;
	//}
	//
	//TERM_PUBLIC int
	//CGM_set_font(const char *font)
	//{
	//    register struct termentry *t = term;
	//    int size, font_index;
	//    char *comma = strchr(font, ',');
	//    int len;
	//    double width;
	//
	// /* Allow null string to indicaute default font */
	//    if (!font || !(*font))
	//	font = CGM_default_font;
	//
	// /* find font in font table, or use 1st font */
	//    if (comma)
	//	len = comma - font;
	//    else
	//	len = strlen(font);
	//
	//    font_index = CGM_find_font(font, len, &width);
	//    if (font_index == 0)
	//	font_index = 1;
	//    cgm_next.font_index = font_index;
	//
	//    {
	//      char *s = cgm_font_data[font_index-1].name;
	//
	//      len = strlen(s);
	//      if (len > 31)
	//	len = 31;
	//      strncpy(cgm_font, s, len);
	//      cgm_font[len] = NUL;
	//    }
	//
	// /* set font size */
	//    size = cgm_fontsize;
	//    if (comma)
	//	sscanf(comma + 1, "%d", &size);
	//    t->v_char = size * CGM_PT;
	//    t->h_char = size * CGM_PT * .527 * width;
	//
	//    cgm_next.char_height = t->v_char;
	//
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//CGM_text()
	//{
	//    CGM_flush_polyline();
	//    CGM_write_int_record(0, 5, 0, NULL);	// end picture 
	//    CGM_write_int_record(0, 2, 0, NULL);	// end metafile 
	//}
	//
	//TERM_PUBLIC void
	//CGM_linetype(int linetype)
	//{
	//    if (linetype < LT_NODRAW)
	//	linetype = LT_NODRAW;
	//
	//    if (linetype == cgm_linetype)
	//	return;
	//    cgm_linetype = linetype;
	//
	//    CGM_linecolor(linetype);
	//    if (cgm_dashed) {
	//	CGM_dashtype(linetype);	// DBT 10-8-98    use dashes 
	//    } else {
	// /* dashes for gridlines, solid for everything else */
	//	CGM_dashtype(linetype == -1 ? 2 : 0);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//CGM_linecolor(int linecolor)
	//{
	//    if (linecolor >= 0) {
	// /* subtract 2 due to linetypes -2 / -1 */
	//	if (cgm_linetypes > 3)
	//	    linecolor %= (cgm_linetypes - 3);
	//	else
	//	    linecolor = 0;
	//    } else if (linecolor == LT_BACKGROUND && !cgm_monochrome) {
	//	linecolor = -3;
	//    } else if (linecolor <= LT_NODRAW)
	//	return;
	//
	//    linecolor += 3;
	//    if (cgm_monochrome)
	//	cgm_color = linecolor = 1;
	//    if (linecolor == cgm_color)
	//	return;
	//    cgm_color = linecolor;
	//    cgm_next.fill_color = linecolor;
	//
	//    CGM_flush_polyline();
	//    CGM_write_int_record(5,  4, 2, (int *) &cgm_color);  // line color 
	//    CGM_write_int_record(5, 14, 2, (int *) &cgm_color); // text color 
	//}
	//
	//TERM_PUBLIC void
	//CGM_fillbox(
	//     int style,
	//     unsigned int x1, unsigned int y1,
	//     unsigned int width, unsigned int height)
	//{
	//    gpiPoint corner[5];
	//
	//    corner[0].x = x1;        corner[0].y = y1;
	//    corner[1].x = x1+width;  corner[1].y = y1;
	//    corner[2].x = x1+width;  corner[2].y = y1+height;
	//    corner[3].x = x1;        corner[3].y = y1+height;
	//    corner[4].x = x1;        corner[4].y = y1;
	//
	//    corner->style = style;
	//    CGM_filled_polygon(5, corner);
	//}
	//
	//
	//TERM_PUBLIC void
	//CGM_linewidth(double width)
	//{
	//    int new_linewidth;
	//
	//    if (width <= 0)
	//	width = 0.5;
	//
	//    new_linewidth = width * cgm_linewidth_pt * CGM_PT;
	//    if (new_linewidth == cgm_linewidth)
	//	return;
	//
	//    CGM_flush_polyline();
	//
	//    cgm_linewidth = new_linewidth;
	//    CGM_write_int_record(5, 3, sizeof(cgm_linewidth) / CGM_ADJ,
	//			 (int *) &cgm_linewidth);
	//    CGM_dashtype(cgm_dashtype);	// have dash lengths recalculated 
	//}
	//
	//TERM_PUBLIC void
	//CGM_dashtype(int dashtype)
	//{
	//    int i, j;
	// /* Each group of 8 entries in dot_length[] defines a dash
	//    pattern.  Entries in each group are alternately length of
	//    whitespace and length of line, in units of 2/3 of the
	//    linewidth. */
	//    static int dot_length[CGM_LINE_TYPES * 8] =
	//    {				// 0 - solid             
	//	5, 8, 5, 8, 5, 8, 5, 8,	// 1 - dashes            
	//	5, 3, 5, 3, 5, 3, 5, 3,	// 2 - short dashes      
	//	4, 1, 4, 1, 4, 1, 4, 1,	// 3 - dotted            
	//	4, 8, 4, 1, 4, 8, 4, 1,	// 4 - dash-dot          
	//	4, 9, 4, 1, 4, 1, 0, 0,	// 5 - dash-dot-dot      
	//	4, 10, 4, 1, 4, 1, 4, 1,	// 6 - dash-dot-dot-dot  
	//	4, 10, 4, 10, 4, 1, 0, 0,	// 7 - dash-dash-dot     
	//	4, 10, 4, 10, 4, 1, 4, 1};	// 8 - dash-dash-dot-dot 
	//
	//
	//    if (dashtype == cgm_dashtype)
	//	return;
	//    cgm_dashtype = dashtype;
	//
	//    CGM_flush_polyline();
	//
	//    if (dashtype >= CGM_LINE_TYPES)
	//	dashtype = dashtype % CGM_LINE_TYPES;
	//    if (dashtype < 1) {
	//	term->vector = CGM_solid_vector;
	//	return;
	//    }
	//    term->vector = CGM_dashed_vector;
	//
	// /* set up dash dimensions */
	//    j = (dashtype - 1) * 8;
	//    for (i = 0; i < 8; i++, j++) {
	//	if (dot_length[j])
	//	    cgm_step_sizes[i] = (dot_length[j] * cgm_linewidth) * 2 / 3;
	//	else
	//	    cgm_step_sizes[i] = 0;
	//    }
	// /* first thing drawn will be a line */
	//    cgm_step = cgm_step_sizes[1];
	//    cgm_step_index = 1;
	//}
	//
	//TERM_PUBLIC void
	//CGM_move(unsigned int x, unsigned int y)
	//{
	//    if (x >= term->xmax)
	//	x = term->xmax;
	//    if (y >= term->ymax)
	//	y = term->ymax;
	//
	//    if (x == cgm_posx && y == cgm_posy)
	//	return;
	//    CGM_flush_polyline();
	//    cgm_posx = x;
	//    cgm_posy = y;
	//}
	//
	//TERM_PUBLIC int
	//CGM_make_palette(t_sm_palette *palette)
	//{
	//    if (palette) {
	//	 int i, k;
	//
	//	 cgm_smooth_colors = palette->colors;
	//	 if (CGM_COLORS + cgm_smooth_colors > cgm_user_color_max) {
	//	      cgm_user_color_max = CGM_COLORS + cgm_smooth_colors;
	//	      cgm_user_color_table =
	//		   gp_realloc(cgm_user_color_table,
	//			      (cgm_user_color_max*3+1)*sizeof(int),
	//			      "CGM color table");
	//	 }
	//	 k = 1 + (CGM_COLORS)*3;
	//	 for (i = 0; i < cgm_smooth_colors; i++) {
	//	      cgm_user_color_table[k++] = palette->color[i].r*255.9;
	//	      cgm_user_color_table[k++] = palette->color[i].g*255.9;
	//	      cgm_user_color_table[k++] = palette->color[i].b*255.9;
	//	 }
	//	 cgm_user_color_count = CGM_COLORS + cgm_smooth_colors;
	//	 CGM_write_int_record(5, 34, (cgm_user_color_count*3+1)*
	//			      sizeof(cgm_user_color_table[0])/CGM_ADJ,
	//			      cgm_user_color_table);
	//	 return 0;
	//    } else {
	//      return (cgm_maximum_color_index - CGM_COLORS);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//CGM_set_color(t_colorspec *colorspec)
	//{
	//    if (colorspec->type == TC_LT) {
	//	 CGM_linecolor(colorspec->lt);
	//	 cgm_linetype = colorspec->lt;
	//	 return;
	//
	//    } else if (colorspec->type == TC_FRAC) {
	//	 double gray = colorspec->value;
	// /* map [0...1] to interval [0...cgm_smooth_colors-1], then add
	//    offset to get past the default colors */
	//	 cgm_next.fill_color = (gray <= 0) ? 0 : (int)(gray * cgm_smooth_colors);
	//	 if (cgm_next.fill_color >= cgm_smooth_colors)
	//	     cgm_next.fill_color = cgm_smooth_colors - 1;
	//	 cgm_next.fill_color += CGM_COLORS;
	//
	//    } else if (colorspec->type == TC_RGB) {
	// /* To truly support RGB we would have to write a new color table to the */
	// /* output file every time the RGB matched no previous color. That seems */
	// /* prohibitive, so instead we just look for the closest match.          */
	//	 cgm_next.fill_color = CGM_find_nearest_color(colorspec);
	//
	//    } else
	// /* Should not happen! */
	//	return;
	//
	// /* EAM - force color immediately so that lines and text can use it */
	//     if (cgm_color != cgm_next.fill_color) {
	//	    cgm_color = cgm_next.fill_color;
	//	    cgm_linetype = cgm_color;
	//	    CGM_flush_polyline();
	//	    CGM_write_int_record(5,  4, 2, (int *) &cgm_color); // line color 
	//	    CGM_write_int_record(5, 14, 2, (int *) &cgm_color); // text color 
	//     }
	//}
	//
	//TERM_PUBLIC void
	//CGM_filled_polygon(int points, gpiPoint *corner)
	//{
	// /* Note: This implementation cannot handle polygons with more than
	//  * about 8190 edges.  The best fix is to implement continuation
	//  * blocks.  If the high order bit of the "length" field of a block
	//  * is set, then it is followed by another block with more data.
	//  * This allows an arbitrary amount of data in a record.  However,
	//  * we implement a big enough block that problems should be rare.
	//  */
	//
	// /* We will use solid fill for patterns 0 and 3 */
	//    int hatch_index[]={0, 6, 5, 0, 4, 3};
	//    int style = corner->style;
	//    int pattern = (style >> 4) % 6;
	//    int i;
	//
	//    switch( style & 0xf ) {
	//
	//    case FS_SOLID:
	//    case FS_TRANSPARENT_SOLID:
	//	cgm_next.interior_style = 1;
	//        break;
	//
	//    case FS_PATTERN:
	//    case FS_TRANSPARENT_PATTERN:
	//	if (pattern == 0) {
	// /* FIXME - for unknown reasons, solid fill messes up the subsequent */
	// /* color state.  Just leave it empty and let the background show */
	//	    cgm_next.interior_style = 0; // empty 
	//	    break;
	//	}
	//	if (pattern == 3) {
	// /* Fill with solid color */
	//	    cgm_next.interior_style = 1;
	//	    break;
	//	}
	//
	// /* The rest of the patterns are hatch-filled */
	//	cgm_next.interior_style = 3; // hatched 
	//	cgm_next.hatch_index = hatch_index[pattern];
	//        break;
	//
	//    default: // style == 0 or unknown --> fill with background color 
	//	cgm_next.fill_color = 0;
	//	cgm_next.interior_style = 1; // solid 
	//        break;
	//    }
	//
	//    if (cgm_current.interior_style != cgm_next.interior_style){
	//      cgm_current.interior_style = cgm_next.interior_style;
	//      CGM_write_int_record(5, 22, 2, &cgm_next.interior_style);
	//    }
	//
	//    if (cgm_current.fill_color != cgm_next.fill_color){
	//      cgm_current.fill_color = cgm_next.fill_color;
	//      CGM_write_int_record(5, 23, 2, &cgm_next.fill_color);  // fill color 
	//    }
	//
	//    if (cgm_current.hatch_index != cgm_next.hatch_index &&
	//	cgm_next.interior_style == 3){
	//      cgm_current.hatch_index = cgm_next.hatch_index;
	//      CGM_write_int_record(5, 24, 2, &cgm_next.hatch_index);
	//    }
	//
	//    cgm_next.edge_visibility = 0;	// We draw the borders elsewhere 
	//    if (cgm_current.edge_visibility != cgm_next.edge_visibility){
	//      cgm_current.edge_visibility = cgm_next.edge_visibility;
	//      CGM_write_int_record(5, 30, 2, &cgm_current.edge_visibility);
	//    }
	//
	//    CGM_move(corner[0].x, corner[0].y);
	//    cgm_doing_polygon = 1;
	//    for (i = 1; i < points; i++)
	//	 CGM_solid_vector(corner[i].x, corner[i].y);
	//    CGM_flush_polygon();
	//    cgm_doing_polygon = 0;
	//}
	//
	//static void
	//CGM_flush_polyline()
	//{
	//    if (cgm_coords == 0)
	//	return;
	//    CGM_write_int_record(4, 1, cgm_coords * 2, cgm_polyline);
	//    cgm_coords = 0;
	//}
	//
	//static void
	//CGM_write_char_record(int class, int cgm_id, int numbytes, char *data)
	//{
	//    int i, pad, length;
	//    static unsigned char flag = 0xff;
	//    static unsigned char paddata = 0;
	//    char short_len;
	//
	//    pad = 0;
	//    length = numbytes + 1;
	//    if (numbytes >= 255)
	//	length += 2;	// long string 
	//    if (length & 1)
	//	pad = 1;	// needs pad 
	//    CGM_write_code(class, cgm_id, length);
	//    if (numbytes < 255)
	//    {
	//        short_len = (char)numbytes;
	//	fwrite(&short_len, 1, 1, gpoutfile);	// write true length 
	//    } else {
	//        fwrite(&flag, 1, 1, gpoutfile);
	//	CGM_write_int(numbytes);
	//    }
	//
	//    if (data)
	//        fwrite(data, 1, numbytes, gpoutfile);		// write string 
	//    else
	//	for (i=0; i<numbytes+pad; i++)
	//	    fputc('\0', gpoutfile);			// write null bytes 
	//
	//    if(pad)
	//      fwrite(&paddata, 1, 1, gpoutfile);
	//}
	//
	//static void
	//CGM_write_byte_record(int class, int cgm_id, int numbytes, char *data)
	//{
	//    int pad;
	//    static unsigned char paddata = 0;
	//
	//    pad = numbytes & 1;
	//    CGM_write_code(class, cgm_id, numbytes);
	//    fwrite(data, 1, numbytes, gpoutfile);		// write string 
	//    if(pad)
	//      fwrite(&paddata, 1, 1, gpoutfile);
	//}
	//
	//static void
	//CGM_write_int_record(int class, int cgm_id, int numbytes, int *data)
	//{
	//    int i;
	//    assert((numbytes & 1) == 0);
	//    CGM_write_code(class, cgm_id, numbytes);
	//    numbytes >>= 1;
	//    for (i = 0; i < numbytes; i++)
	//	CGM_write_int(data[i]);
	//}
	//
	//static void
	//CGM_write_mixed_record(
	//     int class, int cgm_id,
	//     int numint, int *int_data,
	//     int numchar, const char *char_data)
	//{
	//    int i, pad, length;
	//    static unsigned char paddata = 0;
	//    static unsigned char flag = 0xff;
	//    char short_len;
	//
	//    pad = 0;
	//    length = numchar + 1;
	//    if (numchar >= 255)
	//	length += 2;	// long string 
	//    if (length & 1)
	//	pad = 1;	// needs pad 
	//
	//    CGM_write_code(class, cgm_id, numint * 2 + length);
	//
	//    for (i = 0; i < numint; i++)
	//	CGM_write_int(int_data[i]);	// write integers 
	//
	//    if (numchar < 255) {
	//        short_len = (char)numchar;
	//	fwrite(&short_len, 1, 1, gpoutfile);	// write string length 
	//    } else {
	//	fwrite(&flag, 1, 1, gpoutfile);
	//	CGM_write_int(numchar);
	//    }
	//    fwrite(char_data, 1, numchar, gpoutfile);	// write string 
	//    if(pad)
	//      fwrite(&paddata, 1, 1, gpoutfile);
	//}
	//
	// /*
	//    Write the code word that starts a CGM record.
	//    bits in code word are as follows...
	//    cccciiiiiiilllll
	//    where
	//    cccc is a 4-bit class number
	//    iiiiiii is a 7-bit ID number
	//    lllll is a 5-bit length (# bytes following the code word, or
	//             31 followed by a word with the actual number)
	//    */
	//static void
	//CGM_write_code(int class, int cgm_id, int length)
	//{
	//    unsigned int code;
	//
	//    assert((0 <= class) &&(class <16));
	//    assert((0 <= cgm_id) && (cgm_id < 128));
	//    assert(0 <= length);
	//    if (length < 31) {
	//	code = ((class &0x0f) <<12) |
	//	    ((cgm_id & 0x7f) << 5) |
	//	    ((length & 0x1f));
	//	CGM_write_int(code);
	//    } else {
	//	code = ((class &0x0f) <<12) |
	//	    ((cgm_id & 0x7f) << 5) |
	//	    0x1f;
	//	CGM_write_int(code);
	//	CGM_write_int(length);
	//    }
	//}
	//
	//static void
	//CGM_write_int(int value)
	//{
	//    union {
	//	short s;
	//	char c[2];
	//    } u;
	//
	///#if !defined(DOS16) && !defined(WIN16)
	//    assert( -32768 <= value );
	//    assert( value <= 32767 );
	///#endif
	//
	//    u.c[0] = (value >> 8) & 255;	// convert to network order 
	//    u.c[1] = value & 255;
	//
	//    fwrite(&u.s, 1, 2, gpoutfile);
	//}
	//
	// /* Draw a dashed line to (ux,uy).  CGM has linestyles, but they are
	//  * not usable -- at least with the Word for Windows 6.0 filter, where
	//  * lines of significant width (even 1 pt) always come out solid.
	//  * Therefore, we implement dashed lines here instead. */
	//TERM_PUBLIC void
	//CGM_dashed_vector(unsigned int ux, unsigned int uy)
	//{
	//    int xa, ya;
	//    int dx, dy, adx, ady;
	//    int dist; /* approximate distance in plot units
	// 				   from starting point to specified end
	// 				   point. */
	//    long remain; /* approximate distance in plot units
	// 				   remaining to specified end point. */
	//
	//    if (ux >= term->xmax)
	//	ux = term->xmax;
	//    if (uy >= term->ymax)
	//	uy = term->ymax;
	//
	//    dx = (ux - cgm_posx);
	//    dy = (uy - cgm_posy);
	//    adx = abs(dx);
	//    ady = abs(dy * 10);
	//
	// /* using the approximation
	//    sqrt(x**2 + y**2)  ~  x + (5*x*x)/(12*y)   when x > y.
	//    Note ordering of calculations to avoid overflow on 16 bit
	//    architectures */
	//    if (10 * adx < ady)
	//	dist = (ady / 2 + 25 * adx / ady * adx / 6 * 5) / 5;
	//    else {
	//	if (adx == 0)
	//	    return;
	//	dist = (adx * 10 + (ady / 24) * (ady / adx)) / 10;
	//    }
	//    remain = dist;
	//    xa = cgm_posx;
	//    ya = cgm_posy;
	//    while (remain > cgm_step) {
	//	remain -= cgm_step;
	//	if (cgm_step_index & 1)
	//	    CGM_solid_vector((int) (ux - (remain * dx) / dist),
	//			     (int) (uy - (remain * dy) / dist));
	//	else {
	//	    xa = (int) (ux - (remain * dx) / dist);
	//	    ya = (int) (uy - (remain * dy) / dist);
	//	    CGM_move(xa, ya);
	//	}
	//	if (++cgm_step_index >= 8)
	//	    cgm_step_index = 0;
	//	cgm_step = cgm_step_sizes[cgm_step_index];
	//    }
	//    if (cgm_step_index & 1)
	//	CGM_solid_vector(ux, uy);
	//    else
	//	CGM_move(ux, uy);
	//    cgm_step -= (int) remain;
	//}
	//
	//TERM_PUBLIC void
	//CGM_solid_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (ux >= term->xmax)
	//	ux = term->xmax;
	//    if (uy >= term->ymax)
	//	uy = term->ymax;
	//
	//    if (ux == cgm_posx && uy == cgm_posy)
	//	return;
	//    if (cgm_coords > CGM_MAX_SEGMENTS - 2) {
	//	if (cgm_doing_polygon)
	//	      CGM_flush_polygon();
	//	else
	//	      CGM_flush_polyline();
	//	cgm_polyline[cgm_coords++] = cgm_posx;
	//	cgm_polyline[cgm_coords++] = cgm_posy + CGM_MARGIN;
	//    } else if (cgm_coords == 0) {
	//	cgm_polyline[cgm_coords++] = cgm_posx;
	//	cgm_polyline[cgm_coords++] = cgm_posy + CGM_MARGIN;
	//    }
	//    cgm_polyline[cgm_coords++] = ux;
	//    cgm_polyline[cgm_coords++] = uy + CGM_MARGIN;
	//    cgm_posx = ux;
	//    cgm_posy = uy;
	//}
	//
	//TERM_PUBLIC void
	//CGM_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    static int where[3] = { 0, 0, 1 }; /* the final "1" signals that
	// 					  this is the last text in the
	// 					  string */
	//    const char *s = str;
	//
	// /* sanity check - labels are not clipped */
	//    if ((x > 32767) || (y > 32767))
	//      return;
	//
	//    while (*s)
	//	if (!isspace((unsigned char) *s++))
	//	    goto showit;
	//    return;
	//
	//  showit:
	//
	//    CGM_flush_polyline();
	//
	// /* update the text characteristics if they have changed since the
	//    last text string was output */
	//    if (cgm_current.font_index != cgm_next.font_index) {
	//      cgm_current.font_index = cgm_next.font_index;
	//      CGM_write_int_record(5, 10, 2, &cgm_next.font_index);
	//    }
	//    if (cgm_current.justify_mode != cgm_next.justify_mode) {
	//      static int data[6] = { 1, 3, 0, 0, 0, 0 };
	//      cgm_current.justify_mode = cgm_next.justify_mode;
	//
	//      switch (cgm_current.justify_mode) {
	//      case LEFT:
	//	data[0] = 1;
	//	break;
	//      case CENTRE:
	//	data[0] = 2;
	//	break;
	//      case RIGHT:
	//	data[0] = 3;
	//	break;
	//      default:
	//	assert(0);
	//      }
	//      CGM_write_int_record(5, 18, 12, data);
	//    }
	//
	//    if (cgm_current.char_height != cgm_next.char_height) {
	//      int h = cgm_next.char_height;
	//      cgm_current.char_height = h;
	//      h = h*2/3; /* gnuplot measures fonts by the
	//                                    baseline-to-baseline distance,
	//                                    while the CGM file needs the actual
	//                                    height of the upper case
	//                                    characters. */
	//      CGM_write_int_record(5, 15, 2, &h);
	//    }
	//
	// /* "angle" is the angle of the text baseline (counter-clockwise in
	//    radians from horizontal).  This is a bit more general than
	//    gnuplot needs right now. */
	//    if (cgm_current.angle != cgm_next.angle) {
	// /* The first two elements of orient are components of a vector
	// "upward" with respect to the text.  The next two elements are
	// components of a vector along the baseline of the text. The
	// lengths of both vectors are equal to the baseline-to-baseline
	// distance in plot units. */
	//      static int orient[4];
	//      cgm_current.angle = cgm_next.angle;
	//
	//      orient[0] = (int)cgm_next.char_height*cos(cgm_next.angle+M_PI_2);
	//      orient[1] = (int)cgm_next.char_height*sin(cgm_next.angle+M_PI_2);
	//      orient[2] = (int)cgm_next.char_height*cos(cgm_next.angle);
	//      orient[3] = (int)cgm_next.char_height*sin(cgm_next.angle);
	//      CGM_write_int_record(5, 16, 8, orient);
	//    }
	//
	//    where[0] = x;
	//    where[1] = y + CGM_MARGIN;
	//    CGM_write_mixed_record(4, 4, 3, where, strlen(str), str);
	//
	//    cgm_posx = cgm_posy = -2000;
	//}
	//
	//TERM_PUBLIC int
	//CGM_text_angle(int ang)
	//{
	//    if (cgm_rotate) {
	//	cgm_next.angle = ang * M_PI_2 / 90.;
	//	return TRUE;
	//    }
	//    return ang ? FALSE : TRUE;
	//}
	//
	//TERM_PUBLIC int
	//CGM_justify_text(enum JUSTIFY mode)
	//{
	//  cgm_next.justify_mode = mode;
	//  return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//CGM_reset()
	//{
	//    cgm_posx = cgm_posy = 0;
	//    free(cgm_polyline);
	//}
	//
	//TERM_PUBLIC void
	//CGM_point(unsigned int x, unsigned int y, int number)
	//{
	//    int old_dashtype;
	//
	//    if (number < 0) {		// draw dot 
	//	CGM_move(x, y);
	//	CGM_solid_vector(x + 1, y);
	//	return;
	//    }
	//    number %= CGM_POINTS;
	//
	//    CGM_flush_polyline();
	//    old_dashtype = cgm_dashtype;
	//    CGM_dashtype(0);
	//    if (number >= 3)		// using a polygon 
	//      cgm_next.interior_style = 1; // solid 
	//    if (number == 4 || number == 6 || number == 8
	//	    || number == 10 || number == 12) {
	// /* filled */
	//      cgm_next.edge_visibility = 0;
	//      cgm_next.fill_color = cgm_color;
	//    } else {
	// /* NOT filled */
	//      cgm_next.edge_visibility = 1;
	//      cgm_next.interior_style = 0; // empty 
	//      cgm_next.edge_color = cgm_color;
	//    }
	//
	//    if (cgm_current.interior_style != cgm_next.interior_style){
	//      cgm_current.interior_style = cgm_next.interior_style;
	//      CGM_write_int_record(5, 22, 2, &cgm_next.interior_style);
	//    }
	//    if (cgm_current.fill_color != cgm_next.fill_color){
	//      cgm_current.fill_color = cgm_next.fill_color;
	//      CGM_write_int_record(5, 23, 2, &cgm_next.fill_color);
	//    }
	//    if (cgm_current.edge_visibility != cgm_next.edge_visibility){
	//      cgm_current.edge_visibility = cgm_next.edge_visibility;
	//      CGM_write_int_record(5, 30, 2, &cgm_current.edge_visibility);
	//    }
	//    if (cgm_current.edge_visibility &&
	//	cgm_current.edge_color != cgm_next.edge_color){
	//      cgm_current.edge_color = cgm_next.edge_color;
	//      CGM_write_int_record(5, 29, 2, &cgm_current.edge_color);
	//    }
	//
	//    switch (number) {
	//    case 0:			// draw plus 
	//	CGM_move(x - cgm_tic, y);
	//	CGM_solid_vector(x + cgm_tic, y);
	//	CGM_move(x, y - cgm_tic);
	//	CGM_solid_vector(x, y + cgm_tic);
	//	break;
	//    case 1:			// draw X 
	//	CGM_move(x - cgm_tic707, y - cgm_tic707);
	//	CGM_solid_vector(x + cgm_tic707, y + cgm_tic707);
	//	CGM_move(x - cgm_tic707, y + cgm_tic707);
	//	CGM_solid_vector(x + cgm_tic707, y - cgm_tic707);
	//	break;
	//    case 2:			// draw star (asterisk) 
	//	CGM_move(x, y - cgm_tic);
	//	CGM_solid_vector(x, y + cgm_tic);
	//	CGM_move(x + cgm_tic866, y - cgm_tic500);
	//	CGM_solid_vector(x - cgm_tic866, y + cgm_tic500);
	//	CGM_move(x + cgm_tic866, y + cgm_tic500);
	//	CGM_solid_vector(x - cgm_tic866, y - cgm_tic500);
	//	break;
	//    case 3:			// draw box 
	//    case 4:
	//	CGM_move(x - cgm_tic707, y - cgm_tic707);
	//	CGM_solid_vector(x + cgm_tic707, y - cgm_tic707);
	//	CGM_solid_vector(x + cgm_tic707, y + cgm_tic707);
	//	CGM_solid_vector(x - cgm_tic707, y + cgm_tic707);
	//	CGM_flush_polygon();
	//	break;
	//    case 5:
	//    case 6: /* draw circle (actually, dodecagon)
	// 				   (WinWord 6 accepts the CGM "circle"
	// 				   element, but the resulting circle
	// 				   is not correctly centered!) */
	//	CGM_move(x, y - cgm_tic);
	//	CGM_solid_vector(x + cgm_tic500, y - cgm_tic866);
	//	CGM_solid_vector(x + cgm_tic866, y - cgm_tic500);
	//	CGM_solid_vector(x + cgm_tic, y);
	//	CGM_solid_vector(x + cgm_tic866, y + cgm_tic500);
	//	CGM_solid_vector(x + cgm_tic500, y + cgm_tic866);
	//	CGM_solid_vector(x, y + cgm_tic);
	//	CGM_solid_vector(x - cgm_tic500, y + cgm_tic866);
	//	CGM_solid_vector(x - cgm_tic866, y + cgm_tic500);
	//	CGM_solid_vector(x - cgm_tic, y);
	//	CGM_solid_vector(x - cgm_tic866, y - cgm_tic500);
	//	CGM_solid_vector(x - cgm_tic500, y - cgm_tic866);
	//	CGM_flush_polygon();
	//	break;
	//    case 7:			// draw triangle (point up) 
	//    case 8:
	//	CGM_move(x, y + cgm_tic1241);
	//	CGM_solid_vector(x - cgm_tic1077, y - cgm_tic621);
	//	CGM_solid_vector(x + cgm_tic1077, y - cgm_tic621);
	//	CGM_flush_polygon();
	//	break;
	//    case 9:			// draw triangle (point down) 
	//    case 10:
	//	CGM_move(x, y - cgm_tic1241);
	//	CGM_solid_vector(x - cgm_tic1077, y + cgm_tic621);
	//	CGM_solid_vector(x + cgm_tic1077, y + cgm_tic621);
	//	CGM_flush_polygon();
	//	break;
	//    case 11:			// draw diamond 
	//    case 12:
	//	CGM_move(x - cgm_tic, y);
	//	CGM_solid_vector(x, y - cgm_tic);
	//	CGM_solid_vector(x + cgm_tic, y);
	//	CGM_solid_vector(x, y + cgm_tic);
	//	CGM_flush_polygon();
	//	break;
	//    }
	//    CGM_dashtype(old_dashtype);
	//}
	//
	//
	//TERM_PUBLIC void
	//CGM_set_pointsize(double size)
	//{
	// /* Markers were chosen to have approximately equal
	//    areas.  Dimensions are as follows, in units of
	//    cgm_tic:
	//
	//    plus, diamond: half height = 1
	//
	//    square, cross: half height = sqrt(1/2) ~ 12/17
	//
	//    triangle: half width = sqrt(sqrt(4/3)) ~ 14/13,
	//    height = sqrt(3*sqrt(4/3)) ~ 54/29
	//
	//    star: half height = 1, half width = sqrt(3/4) ~ 13/15
	//
	//    dodecagon: coordinates of vertices are 0,
	//    sin(30) = 1/2, cos(30) = sqrt(3/4) ~ 13/15, or 1
	//
	//    The fractions are approximates of the equivalent
	//    continued fractions. */
	//    if (size < 0)
	//	size = 1;
	//    cgm_tic = (size * term->h_tic / 2);
	//    cgm_tic707 = cgm_tic * 12 / 17;
	//    cgm_tic866 = cgm_tic * 13 / 15;
	//    cgm_tic500 = cgm_tic / 2;
	//    cgm_tic1241 = cgm_tic * 36 / 29;
	//    cgm_tic1077 = cgm_tic * 14 / 13;
	//    cgm_tic621 = cgm_tic * 18 / 29;
	//}
	//
	//static void
	//CGM_flush_polygon()
	//{
	//    if (cgm_coords == 0)
	//	return;
	//    CGM_write_int_record(4, 7, cgm_coords * 2, cgm_polyline);
	//    cgm_coords = 0;
	//}
	//
	// /*
	//  * This terminal driver does not support true RGB color,
	//  * but we can at least try to find some reasonable approximation.
	//  */
	///#define CLOSE_ENOUGH 32		// 0 would require a perfect match 
	//static int
	//CGM_find_nearest_color(t_colorspec *colorspec)
	//{
	//    int red   = (colorspec->lt >> 16) & 0xff;
	//    int green = (colorspec->lt >> 8) & 0xff;
	//    int blue  = colorspec->lt & 0xff;
	//    int closest = 0;
	//    int howclose = 1<<16;
	//    int i = 0;
	//    int k;
	//    int dr, dg, db, distance;
	//
	//    for (k=0; k<cgm_user_color_count; k++) {
	//	dr = cgm_user_color_table[++i] - red;
	//	dg = cgm_user_color_table[++i] - green;
	//	db = cgm_user_color_table[++i] - blue;
	//	distance = (dr*dr + dg*dg + db*db);
	//	if (distance < howclose) {
	//	    closest = k;
	//	    howclose = distance;
	//	}
	//	if (distance < CLOSE_ENOUGH)
	//	    break;
	//    }
	//
	//    FPRINTF((stderr,"CGM_find_nearest_color:  asked for %d %d %d\n",red,green,blue));
	//    FPRINTF((stderr,"         got index %3d             %d %d %d\n", closest,
	//	    cgm_user_color_table[closest*3], cgm_user_color_table[closest*3+1],
	//	    cgm_user_color_table[closest*3+2]));
	//
	//    return closest;
	//}
	///#undef CLOSE_ENOUGH
	//
	///#ifdef DEFEAT_ASSERTIONS
	///#define NDEBUG
	///#include <assert.h>
	///#undef DEFEAT_ASSERTIONS
	///#endif // DEFEAT_ASSERTIONS 
	//
	///#ifdef NEXT
	///#undef id
	///#undef datum
	///#endif
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(cgm_driver)
	//    "cgm", "Computer Graphics Metafile",
	//    CGM_LARGE - CGM_MARGIN, CGM_SMALL - CGM_MARGIN, CGM_VCHAR, CGM_HCHAR,
	//    CGM_VTIC, CGM_HTIC, CGM_options, CGM_init, CGM_reset,
	//    CGM_text, null_scale, CGM_graphics, CGM_move, CGM_solid_vector,
	//    CGM_linetype, CGM_put_text, CGM_text_angle,
	//    CGM_justify_text, CGM_point, do_arrow, CGM_set_font,
	//    CGM_set_pointsize,
	//    TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,	// various flags 
	//    NULL,			// after one plot of multiplot 
	//    NULL,			// before subsequent plot of multiplot 
	//    CGM_fillbox,
	//    CGM_linewidth
	///#ifdef USE_MOUSE
	//    , NULL, NULL, NULL, NULL, NULL
	// /*  , waitforinput, put_tmptext, set_ruler, set_cursor, set_clipboard */
	///#endif
	//    , CGM_make_palette,
	//    NULL // _previous_palette 
	//,
	//    CGM_set_color,
	//    CGM_filled_polygon
	//TERM_TABLE_END(cgm_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM cgm_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(cgm)
	//"1 cgm",
	//"?commands set terminal cgm",
	//"?set terminal cgm",
	//"?set term cgm",
	//"?terminal cgm",
	//"?term cgm",
	//"?cgm",
	//" The `cgm` terminal generates a Computer Graphics Metafile, Version 1. ",
	//" This file format is a subset of the ANSI X3.122-1986 standard entitled",
	//" \"Computer Graphics - Metafile for the Storage and Transfer of Picture",
	//" Description Information\".",
	//"",
	//" Syntax:",
	//"       set terminal cgm {color | monochrome} {solid | dashed} {{no}rotate}",
	//"                        {<mode>} {width <plot_width>} {linewidth <line_width>}",
	//"                        {font \"<fontname>,<fontsize>\"}",
	//"                        {<color0> <color1> <color2> ...}",
	//"",
	//" `solid` draws all curves with solid lines, overriding any dashed patterns;",
	//" <mode> is `landscape`, `portrait`, or `default`;",
	//" <plot_width> is the assumed width of the plot in points; ",
	//" <line_width> is the line width in points (default 1); ",
	//" <fontname> is the name of a font (see list of fonts below)",
	//" <fontsize> is the size of the font in points (default 12).",
	//"",
	//" The first six options can be in any order.  Selecting `default` sets all",
	//" options to their default values.",
	//"",
	//" Each color must be of the form 'xrrggbb', where x is the literal",
	//" character 'x' and 'rrggbb' are the red, green and blue components in",
	//" hex.  For example, 'x00ff00' is green.  The background color is set",
	//" first, then the plotting colors.",
	//"",
	//" Examples:",
	//"       set terminal cgm landscape color rotate dashed width 432 \\",
	//"                      linewidth 1  'Helvetica Bold' 12       # defaults",
	//"       set terminal cgm linewidth 2  14  # wider lines & larger font",
	//"       set terminal cgm portrait \"Times Italic\" 12",
	//"       set terminal cgm color solid      # no pesky dashes!",
	//
	//"2 cgm font",
	//"?commands set terminal cgm font",
	//"?set terminal cgm font",
	//"?set term cgm font",
	//"?cgm font",
	//" The first part of a Computer Graphics Metafile, the metafile description,",
	//" includes a font table.  In the picture body, a font is designated by an",
	//" index into this table.  By default, this terminal generates a table with",
	//" the following 35 fonts, plus six more with `italic` replaced by",
	//" `oblique`, or vice-versa (since at least the Microsoft Office and Corel",
	//" Draw CGM import filters treat `italic` and `oblique` as equivalent):",
	//"@start table - first is interactive cleartext form",
	//"       Helvetica",
	//"       Helvetica Bold",
	//"       Helvetica Oblique",
	//"       Helvetica Bold Oblique",
	//"       Times Roman",
	//"       Times Bold",
	//"       Times Italic",
	//"       Times Bold Italic",
	//"       Courier",
	//"       Courier Bold",
	//"       Courier Oblique",
	//"       Courier Bold Oblique",
	//"       Symbol",
	//"       Hershey/Cartographic_Roman",
	//"       Hershey/Cartographic_Greek",
	//"       Hershey/Simplex_Roman",
	//"       Hershey/Simplex_Greek",
	//"       Hershey/Simplex_Script",
	//"       Hershey/Complex_Roman",
	//"       Hershey/Complex_Greek",
	//"       Hershey/Complex_Script",
	//"       Hershey/Complex_Italic",
	//"       Hershey/Complex_Cyrillic",
	//"       Hershey/Duplex_Roman",
	//"       Hershey/Triplex_Roman",
	//"       Hershey/Triplex_Italic",
	//"       Hershey/Gothic_German",
	//"       Hershey/Gothic_English",
	//"       Hershey/Gothic_Italian",
	//"       Hershey/Symbol_Set_1",
	//"       Hershey/Symbol_Set_2",
	//"       Hershey/Symbol_Math",
	//"       ZapfDingbats",
	//"       Script",
	//"       15",
	//"#\\begin{tabular}{|ccl|} \\hline",
	//"#\\multicolumn{3}{|c|}{CGM fonts}\\\\",
	//"#&Helvetica&\\\\",
	//"#&Helvetica Bold&\\\\",
	//"#&Helvetica Oblique&\\\\",
	//"#&Helvetica Bold Oblique&\\\\",
	//"#&Times Roman&\\\\",
	//"#&Times Bold&\\\\",
	//"#&Times Italic&\\\\",
	//"#&Times Bold Italic&\\\\",
	//"#&Courier&\\\\",
	//"#&Courier Bold&\\\\",
	//"#&Courier Oblique&\\\\",
	//"#&Courier Bold Oblique&\\\\",
	//"#&Symbol&\\\\",
	//"#&Hershey/Cartographic\\_Roman&\\\\",
	//"#&Hershey/Cartographic\\_Greek&\\\\",
	//"#&Hershey/Simplex\\_Roman&\\\\",
	//"#&Hershey/Simplex\\_Greek&\\\\",
	//"#&Hershey/Simplex\\_Script&\\\\",
	//"#&Hershey/Complex\\_Roman&\\\\",
	//"#&Hershey/Complex\\_Greek&\\\\",
	//"#&Hershey/Complex\\_Script&\\\\",
	//"#&Hershey/Complex\\_Italic&\\\\",
	//"#&Hershey/Complex\\_Cyrillic&\\\\",
	//"#&Hershey/Duplex\\_Roman&\\\\",
	//"#&Hershey/Triplex\\_Roman&\\\\",
	//"#&Hershey/Triplex\\_Italic&\\\\",
	//"#&Hershey/Gothic\\_German&\\\\",
	//"#&Hershey/Gothic\\_English&\\\\",
	//"#&Hershey/Gothic\\_Italian&\\\\",
	//"#&Hershey/Symbol\\_Set\\_1&\\\\",
	//"#&Hershey/Symbol\\_Set\\_2&\\\\",
	//"#&Hershey/Symbol\\_Math&\\\\",
	//"#&ZapfDingbats&\\\\",
	//"#&Script&\\\\",
	//"#&15&\\\\",
	//"%c c l .",
	//"%@@CGM fonts",
	//"%_",
	//"%@@Helvetica",
	//"%@@Helvetica Bold",
	//"%@@Helvetica Oblique",
	//"%@@Helvetica Bold Oblique",
	//"%@@Times Roman",
	//"%@@Times Bold",
	//"%@@Times Italic",
	//"%@@Times Bold Italic",
	//"%@@Courier",
	//"%@@Courier Bold",
	//"%@@Courier Oblique",
	//"%@@Courier Bold Oblique",
	//"%@@Symbol",
	//"%@@Hershey/Cartographic_Roman",
	//"%@@Hershey/Cartographic_Greek",
	//"%@@Hershey/Simplex_Roman",
	//"%@@Hershey/Simplex_Greek",
	//"%@@Hershey/Simplex_Script",
	//"%@@Hershey/Complex_Roman",
	//"%@@Hershey/Complex_Greek",
	//"%@@Hershey/Complex_Script",
	//"%@@Hershey/Complex_Italic",
	//"%@@Hershey/Complex_Cyrillic",
	//"%@@Hershey/Duplex_Roman",
	//"%@@Hershey/Triplex_Roman",
	//"%@@Hershey/Triplex_Italic",
	//"%@@Hershey/Gothic_German",
	//"%@@Hershey/Gothic_English",
	//"%@@Hershey/Gothic_Italian",
	//"%@@Hershey/Symbol_Set_1",
	//"%@@Hershey/Symbol_Set_2",
	//"%@@Hershey/Symbol_Math",
	//"%@@ZapfDingbats",
	//"%@@Script",
	//"%@@15",
	//"@end table",
	//
	//" The first thirteen of these fonts are required for WebCGM.  The",
	//" Microsoft Office CGM import filter implements the 13 standard fonts",
	//" listed above, and also 'ZapfDingbats' and 'Script'.  However, the",
	//" script font may only be accessed under the name '15'.  For more on",
	//" Microsoft import filter font substitutions, check its help file which",
	//" you may find here:",
	//"   C:\\Program Files\\Microsoft Office\\Office\\Cgmimp32.hlp",
	//" and/or its configuration file, which you may find here:",
	//"   C:\\Program Files\\Common Files\\Microsoft Shared\\Grphflt\\Cgmimp32.cfg",
	//"",
	//" In the `set term` command, you may specify a font name which does not",
	//" appear in the default font table.  In that case, a new font table is",
	//" constructed with the specified font as its first entry. You must ensure",
	//" that the spelling, capitalization, and spacing of the name are",
	//" appropriate for the application that will read the CGM file.  (Gnuplot",
	//" and any MIL-D-28003A compliant application ignore case in font names.)",
	//" If you need to add several new fonts, use several `set term` commands.",
	//"",
	//" Example:",
	//"       set terminal cgm 'Old English'",
	//"       set terminal cgm 'Tengwar'",
	//"       set terminal cgm 'Arabic'",
	//"       set output 'myfile.cgm'",
	//"       plot ...",
	//"       set output",
	//"",
	//" You cannot introduce a new font in a `set label` command.",
	//
	//"2 cgm fontsize",
	//"?commands set terminal cgm fontsize",
	//"?set terminal cgm fontsize",
	//"?set term cgm fontsize",
	//"?cgm fontsize",
	//" Fonts are scaled assuming the page is 6 inches wide.  If the `size`",
	//" command is used to change the aspect ratio of the page or the CGM file",
	//" is converted to a different width, the resulting font sizes will be",
	//" scaled up or down accordingly.  To change the assumed width, use the",
	//" `width` option.",
	//
	//"2 cgm linewidth",
	//"?commands set terminal cgm linewidth",
	//"?set terminal cgm linewidth",
	//"?set term cgm linewidth",
	//"?cgm linewidth",
	//" The `linewidth` option sets the width of lines in pt.  The default width",
	//" is 1 pt.  Scaling is affected by the actual width of the page, as",
	//" discussed under the `fontsize` and `width` options.",
	//
	//"2 cgm rotate",
	//"?commands set terminal cgm rotate",
	//"?set terminal cgm rotate",
	//"?set term cgm rotate",
	//"?cgm rotate",
	//" The `norotate` option may be used to disable text rotation.  For",
	//" example, the CGM input filter for Word for Windows 6.0c can accept",
	//" rotated text, but the DRAW editor within Word cannot.  If you edit a",
	//" graph (for example, to label a curve), all rotated text is restored to",
	//" horizontal.  The Y axis label will then extend beyond the clip boundary.",
	//" With `norotate`, the Y axis label starts in a less attractive location,",
	//" but the page can be edited without damage.  The `rotate` option confirms",
	//" the default behavior.",
	//
	//"2 cgm solid",
	//"?set terminal cgm solid",
	//"?set term cgm solid",
	//"?cgm solid",
	//" The `solid` option may be used to disable dashed line styles in the",
	//" plots.  This is useful when color is enabled and the dashing of the",
	//" lines detracts from the appearance of the plot. The `dashed` option",
	//" confirms the default behavior, which gives a different dash pattern to",
	//" each line type.",
	//
	//"2 cgm size",
	//"?commands set terminal cgm size",
	//"?set terminal cgm size",
	//"?set term cgm size",
	//"?cgm size",
	//" Default size of a CGM plot is 32599 units wide and 23457 units high for",
	//" landscape, or 23457 units wide by 32599 units high for portrait.",
	//
	//"2 cgm width",
	//"?commands set terminal cgm width",
	//"?set terminal cgm width",
	//"?set term cgm width",
	//"?cgm width",
	//" All distances in the CGM file are in abstract units.  The application",
	//" that reads the file determines the size of the final plot.  By default,",
	//" the width of the final plot is assumed to be 6 inches (15.24 cm).  This",
	//" distance is used to calculate the correct font size, and may be changed",
	//" with the `width` option.  The keyword should be followed by the width in",
	//" points.  (Here, a point is 1/72 inch, as in PostScript.  This unit is",
	//" known as a \"big point\" in TeX.)  Gnuplot `expressions` can be used to",
	//" convert from other units.",
	//"",
	//" Example:",
	//"       set terminal cgm width 432            # default",
	//"       set terminal cgm width 6*72           # same as above",
	//"       set terminal cgm width 10/2.54*72     # 10 cm wide",
	//
	//"2 cgm nofontlist",
	//"?commands set terminal cgm nofontlist",
	//"?set terminal cgm nofontlist",
	//"?set term cgm nofontlist",
	//"?cgm nofontlist",
	//"?set terminal cgm winword6",
	//"?set term cgm winword6",
	//"?cgm winword6",
	//" The default font table includes the fonts recommended for WebCGM, which",
	//" are compatible with the Computer Graphics Metafile input filter for",
	//" Microsoft Office and Corel Draw.  Another application might use",
	//" different fonts and/or different font names, which may not be",
	//" documented.  The `nofontlist` (synonym `winword6`) option deletes the font",
	//" table from the CGM file.  In this case, the reading application should",
	//" use a default table.  Gnuplot will still use its own default font table",
	//" to select font indices.  Thus, 'Helvetica' will give you an index of 1,",
	//" which should get you the first entry in your application's default font",
	//" table. 'Helvetica Bold' will give you its second entry, etc.",
	//""
	//
	//END_HELP(cgm)
	///#endif // TERM_HELP 


	/*
	 * Local Variables:
	 * mode:C
	 * eval: (c-set-style "k&r")
	 * End:
	 */


	/* CorelDraw! eps format */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: corel.trm,v 1.17 2006/07/21 02:35:45 sfeam Exp $
	 */

	/*
	   corel.trm
	
	   A modified ai.trm for CorelDraw import filters
	   by Chris Parks, parks@physics.purdue.edu
	   Import from CorelDraw with the CorelTrace filter
	
	   syntax: set terminal default
	           set terminal mode "fontname" fontsize,xsize,ysize,linewidth
	
	           mode= color or monochrome             (default=mono)
	           "fontname"= postscript font name      (default="SwitzerlandLight")
	           fontsize  = size of font in points    (default=22pt)
	           xsize     = width of page in inches   (default=8.2in)
	           ysize     = height of page in inches  (default=10in)
	           linewidth = width of lines in points  (default=1.2pt)
	
	*/

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(corel)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void COREL_options __PROTO((void));
	//TERM_PUBLIC void COREL_init __PROTO((void));
	//TERM_PUBLIC void COREL_graphics __PROTO((void));
	//TERM_PUBLIC void COREL_text __PROTO((void));
	//TERM_PUBLIC void COREL_reset __PROTO((void));
	//TERM_PUBLIC void COREL_linetype __PROTO((int linetype));
	//TERM_PUBLIC void COREL_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void COREL_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void COREL_put_text __PROTO((unsigned int x, unsigned int y,
	//					 const char *str));
	//TERM_PUBLIC int COREL_text_angle __PROTO((int ang));
	//TERM_PUBLIC int COREL_justify_text __PROTO((enum JUSTIFY mode));
	///#define CORELD_XMAX  5960	// 8.2 inches wide 
	///#define CORELD_YMAX  7200	// 10 inches high  
	///#define CORELD_VTIC  (CORELD_YMAX/80)
	///#define CORELD_HTIC  (CORELD_YMAX/80)
	///#define CORELD_VCHAR (22*COREL_SC)	// default is 22 point characters 
	///#define CORELD_HCHAR (22*COREL_SC*6/10)
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#define DEFAULT_CORELFONT "SwitzerlandLight"
	//
	// /* plots for publication should be sans-serif (don't use TimesRoman) */
	//static char corel_font[MAX_ID_LEN + 1] = DEFAULT_CORELFONT;	// name of font 
	//static int corel_fontsize = 22;	// size of font in pts 
	//static TBOOLEAN corel_color = FALSE;
	//static TBOOLEAN corel_stroke = FALSE;
	//static int corel_path_count = 0;	// count of lines in path 
	//static int corel_ang = 0;		// text angle 
	//static enum JUSTIFY corel_justify = LEFT;	// text is flush left 
	//
	//
	// /* default mode constants */
	///#define CORELD_XOFF  0		// page offset in pts 
	///#define CORELD_YOFF  0
	///#define COREL_SC     (10.0)	// scale is 1pt = 10 units 
	///#define CORELD_LW    (1.2*COREL_SC)	// linewidth = 1.2 pts 
	//
	//static unsigned int corel_xmax = CORELD_XMAX;
	//static unsigned int corel_ymax = CORELD_YMAX;
	//static float corel_lw = CORELD_LW;
	//
	//enum COREL_id {COREL_DEFAULT, COREL_MONOCHROME, COREL_COLOR, COREL_OTHER };
	//
	//static struct gen_table COREL_opts[] =
	//{
	//    { "def$ault", COREL_DEFAULT},
	//    { "mono$chrome", COREL_MONOCHROME },
	//    { "color$", COREL_COLOR },
	//    { "colour$", COREL_COLOR },
	//    { NULL, COREL_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//COREL_options()
	//{
	//    struct value a;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&COREL_opts[0],c_token)) {
	//	case COREL_DEFAULT:
	//	    corel_color = FALSE;
	//	    strcpy(corel_font, DEFAULT_CORELFONT);
	//	    corel_fontsize = 22;
	//	    corel_lw = CORELD_LW;
	//	    corel_xmax = CORELD_XMAX;
	//	    corel_ymax = CORELD_YMAX;
	//	    c_token++;
	//	    break;
	//	case COREL_MONOCHROME:
	//	    corel_color = FALSE;
	//	    c_token++;
	//	    break;
	//	case COREL_COLOR:
	//	    corel_color = TRUE;
	//	    c_token++;
	//	    break;
	//	case COREL_OTHER:
	//	default:
	// /* font name */
	//	    if (isstring(c_token)) {
	//		quote_str(corel_font, c_token, MAX_ID_LEN);
	//		c_token++;
	//	    } else {
	// /* We have font size specified */
	//		corel_fontsize = (int) real(const_express(&a));
	//		c_token++;
	//		term->v_char = (unsigned int) (corel_fontsize * COREL_SC);
	//		term->h_char = (unsigned int) (corel_fontsize * COREL_SC * 6 / 10);
	//	    }
	//	    break;
	//	}
	//    }
	//
	// /* FIXME - argh. Stupid syntax alert here */
	//    if (!END_OF_COMMAND) {
	//	corel_xmax = (unsigned int) (real(const_express(&a)) * 720);
	//	c_token++;
	//	if (!END_OF_COMMAND) {
	//	    corel_ymax = (unsigned int) (real(const_express(&a)) * 720);
	//	    c_token++;
	//	}
	//	term->xmax = corel_xmax;
	//	term->ymax = corel_ymax;
	//	term->v_tic = corel_ymax / 80;
	//	term->h_tic = corel_ymax / 80;
	//    }
	//    if (!END_OF_COMMAND) {
	//	corel_lw = real(const_express(&a)) * COREL_SC;
	//	c_token++;
	//    }
	//    sprintf(term_options, "%s \"%s\" %d,%0.1f,%0.1f,%0.1f",
	//	    corel_color ? "color" : "monochrome", corel_font,
	//	    corel_fontsize, corel_xmax / 720.0, corel_ymax / 720.0,
	//	    corel_lw / COREL_SC);
	//}
	//
	//TERM_PUBLIC void
	//COREL_init()
	//{
	//    fprintf(gpoutfile, "
	//%%!PS-Adobe-2.0 EPSF-1.2\n
	//%%%%BoundingBox: %d %d %d %d\n
	//%%%%TemplateBox: %d %d %d %d\n
	//%%%%EndComments\n
	//%%%%EndProlog\n
	//%%%%BeginSetup\n%%%%EndSetup\n",
	//	    CORELD_XOFF, CORELD_YOFF,
	//	    (int) ((corel_xmax) / COREL_SC + 0.5 + CORELD_XOFF),
	//	    (int) ((corel_ymax) / COREL_SC + 0.5 + CORELD_YOFF),
	//	    CORELD_XOFF, CORELD_YOFF,
	//	    (int) ((corel_xmax) / COREL_SC + 0.5 + CORELD_XOFF),
	//	    (int) ((corel_ymax) / COREL_SC + 0.5 + CORELD_YOFF));
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_graphics()
	//{
	//    corel_path_count = 0;
	//    corel_stroke = FALSE;
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_text()
	//{
	//    if (corel_stroke) {
	//	fputs("S\n", gpoutfile);
	//	corel_stroke = FALSE;
	//    }
	//    corel_path_count = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_reset()
	//{
	//    fputs("%%Trailer\n", gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_linetype(int linetype)
	//{
	//    if (corel_stroke) {
	//	fputs("S\n", gpoutfile);
	//	corel_stroke = FALSE;
	//    }
	//    switch (linetype) {
	//    case LT_BLACK:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 0 0 1 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[] 0 d\n
	//0 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case LT_AXIS:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 0 0 1 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[1 2] 0 d\n
	//0 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 0:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("1 0 1 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 1:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("1 1 0 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[4 2] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 2:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 1 1 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[2 3] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 3:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 1 0 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[1 1.5] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 4:
	//	fprintf(gpoutfile, "%f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("1 0 0 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[5 2 1 2] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 5:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 0 1 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[4 3 1 3] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 6:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 0 0 1 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[2 2 2 4] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 7:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0 0.7 1 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[2 2 2 2 2 4] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//
	//    case 8:
	//	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
	//	if (corel_color) {
	//	    fputs("0.5 0.5 0.5 0 K\n", gpoutfile);
	//	} else {
	//	    fputs("
	//[2 2 2 2 2 2 2 4] 0 d\n
	//2 j\n0 G\n", gpoutfile);
	//	}
	//	break;
	//    }
	//    corel_path_count = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_move(unsigned int x, unsigned int y)
	//{
	//    if (corel_stroke)
	//	fputs("S\n", gpoutfile);
	//    fprintf(gpoutfile, "%0.2f %0.2f m\n", x / COREL_SC, y / COREL_SC);
	//    corel_path_count += 1;
	//    corel_stroke = TRUE;
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_vector(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "%.2f %.2f l\n", x / COREL_SC, y / COREL_SC);
	//    corel_path_count += 1;
	//    corel_stroke = TRUE;
	//    if (corel_path_count >= 400) {
	//	fprintf(gpoutfile, "S\n%.2f %.2f m\n", x / COREL_SC, y / COREL_SC);
	//	corel_path_count = 0;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//COREL_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char ch;
	//    if (corel_stroke) {
	//	fputs("S\n", gpoutfile);
	//	corel_stroke = FALSE;
	//    }
	//    switch (corel_justify) {
	//    case LEFT:
	//	fprintf(gpoutfile, "/_%s %d %d 0 0 z\n",
	//		corel_font, corel_fontsize, corel_fontsize);
	//	break;
	//    case CENTRE:
	//	fprintf(gpoutfile, "/_%s %d %d 0 1 z\n",
	//		corel_font, corel_fontsize, corel_fontsize);
	//	break;
	//    case RIGHT:
	//	fprintf(gpoutfile, "/_%s %d %d 0 2 z\n",
	//		corel_font, corel_fontsize, corel_fontsize);
	//	break;
	//    }
	//    if (corel_ang == 0) {
	//	fprintf(gpoutfile, "[1 0 0 1 %.2f %.2f]e\n0 g\n",
	//		x / COREL_SC, y / COREL_SC - corel_fontsize / 3.0);
	//    } else {
	//	fprintf(gpoutfile, "[0 1 -1 0 %.2f %.2f]e\n0 g\n",
	//		x / COREL_SC - corel_fontsize / 3.0, y / COREL_SC);
	//    }
	//
	//    putc('(', gpoutfile);
	//    ch = *str++;
	//    while (ch != NUL) {
	//	if ((ch == '(') || (ch == ')') || (ch == '\\'))
	//	    putc('\\', gpoutfile);
	//	putc(ch, gpoutfile);
	//	ch = *str++;
	//    }
	//    fputs(")t\nT\n", gpoutfile);
	//    corel_path_count = 0;
	//}
	//
	//TERM_PUBLIC int
	//COREL_text_angle(int ang)
	//{
	//    corel_ang = ang;
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int
	//COREL_justify_text(enum JUSTIFY mode)
	//{
	//    corel_justify = mode;
	//    return TRUE;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(corel_driver)
	//    "corel", "EPS format for CorelDRAW",
	//    CORELD_XMAX, CORELD_YMAX, CORELD_VCHAR, CORELD_HCHAR,
	//    CORELD_VTIC, CORELD_HTIC, COREL_options, COREL_init, COREL_reset,
	//    COREL_text, null_scale, COREL_graphics, COREL_move, COREL_vector,
	//    COREL_linetype, COREL_put_text, COREL_text_angle,
	//    COREL_justify_text, do_point, do_arrow, set_font_null
	//TERM_TABLE_END(corel_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM corel_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(corel)
	//"1 corel",
	//"?commands set terminal corel",
	//"?set terminal corel",
	//"?set term corel",
	//"?terminal corel",
	//"?term corel",
	//"?corel",
	//" The `corel` terminal driver supports CorelDraw.",
	//"",
	//" Syntax:",
	//"       set terminal corel {  default",
	//"                           | {monochrome | color",
	//"                                {\"<font>\" {<fontsize> ",
	//"                                   {<xsize> <ysize> {<linewidth> }}}}}",
	//"",
	//" where the fontsize and linewidth are specified in points and the sizes in",
	//" inches.  The defaults are monochrome, \"SwitzerlandLight\", 22, 8.2, 10 and 1.2."
	//END_HELP(corel)
	///#endif // TERM_HELP 


	/* debugging terminal */
	///#ifdef DEBUG
	///#include "debug.trm"
	///#endif

	/* dumb terminal */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: dumb.trm,v 1.30 2009/03/26 00:49:19 sfeam Exp $
	 *
	 */

	/* GNUPLOT - dumb.trm */

	/*[
	 * Copyright 1991 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   DUMB terminals
	 *
	 * AUTHORS
	 *   Francois Pinard, 91-04-03
	 *           INTERNET: pinard@iro.umontreal.ca
	 *
	 *   Ethan A Merritt Nov 2003
	 *	Added support for enhanced text mode.
	 *	Yes, this is frivolous, but it serves as an example for
	 *	adding enhanced text to other terminals.  You can disable
	 *	it by adding a line
	 *	#define NO_DUMB_ENHANCED_SUPPORT
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	///#ifdef TERM_REGISTER
	//register_term(dumb_driver)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void DUMB_options __PROTO((void));
	//TERM_PUBLIC void DUMB_init __PROTO((void));
	//TERM_PUBLIC void DUMB_graphics __PROTO((void));
	//TERM_PUBLIC void DUMB_text __PROTO((void));
	//TERM_PUBLIC void DUMB_reset __PROTO((void));
	//TERM_PUBLIC void DUMB_linetype __PROTO((int linetype));
	//TERM_PUBLIC void DUMB_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void DUMB_point __PROTO((unsigned int x, unsigned int y,
	//				     int point));
	//TERM_PUBLIC void DUMB_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void DUMB_put_text __PROTO((unsigned int x, unsigned int y,
	//					const char *str));
	//TERM_PUBLIC void DUMB_arrow __PROTO((unsigned int sx, unsigned int sy,
	//				     unsigned int ex, unsigned int ey,
	//				     int head));
	//
	///#ifndef NO_DUMB_ENHANCED_SUPPORT
	// /* To support "set term dumb enhanced" (don't ask why!) */
	//TERM_PUBLIC void ENHdumb_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void ENHdumb_OPEN __PROTO((char * fontname, double fontsize,
	//	                            double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//				    int overprint));
	//TERM_PUBLIC void ENHdumb_FLUSH __PROTO((void));
	///#else
	///#define ENHdumb_put_text NULL
	///#endif
	//
	//
	///#define DUMB_XMAX 79
	///#define DUMB_YMAX 24
	//
	///#endif // TERM_PROTO 

	///#ifdef TERM_BODY
	//
	///#define DUMB_AXIS_CONST '\1'
	///#define DUMB_BORDER_CONST '\2'
	//
	// /* matrix of characters */
	//static char *dumb_matrix = NULL;
	// /* matrix of priority at each position */
	//static char *dumb_priority = NULL;
	// /* current character used to draw */
	//static char dumb_pen;
	// /* current X position */
	//static int dumb_x;
	// /* current Y position */
	//static int dumb_y;
	//static int dumb_xmax = DUMB_XMAX;
	//static int dumb_ymax = DUMB_YMAX;
	//static int dumb_feed = 1;
	//
	///#define DUMB_PIXEL(x,y) dumb_matrix[dumb_xmax*(y)+(x)]
	//
	//static void dumb_set_pixel __PROTO((int x, int y, int v, int p));
	//
	//enum DUMB_id { DUMB_FEED, DUMB_NOFEED, DUMB_ENH, DUMB_NOENH, DUMB_SIZE, DUMB_OTHER };
	//
	//static struct gen_table DUMB_opts[] =
	//{
	//    { "f$eed", DUMB_FEED },
	//    { "nof$eed", DUMB_NOFEED },
	//    { "enh$anced", DUMB_ENH },
	//    { "noe$nhanced", DUMB_NOENH },
	//    { "size", DUMB_SIZE },
	//    { NULL, DUMB_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//DUMB_options()
	//{
	//    int x, y;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&DUMB_opts[0],c_token)) {
	//	case DUMB_FEED:
	//	    c_token++;
	//	    dumb_feed = 1;
	//	    break;
	//	case DUMB_NOFEED:
	//	    c_token++;
	//	    dumb_feed = 0;
	//	    break;
	///#ifndef NO_DUMB_ENHANCED_SUPPORT
	//	case DUMB_ENH:
	//	    c_token++;
	//	    term->put_text = ENHdumb_put_text;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    break;
	//	case DUMB_NOENH:
	//	    c_token++;
	//	    term->put_text = DUMB_put_text;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    break;
	///#endif
	//	case DUMB_SIZE:
	//	    c_token++;
	// /* Fall through */
	//
	//	case DUMB_OTHER:
	//	default:
	//	    x = int_expression();
	//	    if (!END_OF_COMMAND) {
	//		if (equals(c_token,","))
	//		    c_token++;
	//		y = int_expression();
	//		dumb_xmax = term->xmax = x;
	//		dumb_ymax = term->ymax = y;
	//	    }
	// 	    break;
	//	}
	//    }
	//
	//    sprintf(term_options, "%sfeed %s size %d, %d",
	//	    dumb_feed ? "" : "no",
	//	    term->put_text == ENHdumb_put_text ? "enhanced" : "",
	//	    dumb_xmax, dumb_ymax);
	//}
	//
	//
	//static void
	//dumb_set_pixel(int x, int y, int v, int p)
	//{
	//    if ((unsigned int) x <= dumb_xmax &&	// ie x>=0 && x<=dumb_xmax 
	//	(unsigned int) y <= dumb_ymax &&
	//	p > dumb_priority[dumb_xmax * y + x]) {
	//	dumb_matrix[dumb_xmax * y + x] = v;
	//	dumb_priority[dumb_xmax * y + x] = p;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_init()
	//{
	//    if (dumb_matrix)
	//	free(dumb_matrix);
	//
	//    dumb_matrix = gp_alloc((dumb_xmax+1) * (dumb_ymax+1) * 2, "dumb terminal");
	//
	//    dumb_priority = dumb_matrix + dumb_xmax * dumb_ymax;
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_graphics()
	//{
	//    int i;
	//    char *pm = dumb_matrix, *pp = dumb_priority;
	//
	//    for (i = dumb_xmax * dumb_ymax; i > 0; i--) {
	//	*pm++ = ' ';
	//	*pp++ = 0;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_text()
	//{
	//    int x, y, l;
	//
	//    putc('\f', gpoutfile);
	//    for (y = dumb_ymax - 1; y >= 0; y--) {
	//	for (l = dumb_xmax; l > 0 && DUMB_PIXEL(l - 1, y) == ' '; l--);
	//	for (x = 0; x < l; x++)
	//	    putc(DUMB_PIXEL(x, y), gpoutfile);
	//	if (dumb_feed || y > 0)
	//	    putc('\n', gpoutfile);
	//    }
	//    fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_reset()
	//{
	//    if (dumb_matrix)
	//	free(dumb_matrix);
	//    dumb_matrix = NULL;
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_linetype(int linetype)
	//{
	//    static char pen_type[7] = { '*', '#', '$', '%', '@', '&', '=' };
	//
	//    if (linetype == LT_BLACK)
	//	dumb_pen = DUMB_BORDER_CONST;
	//    else if (linetype == LT_AXIS)
	//	dumb_pen = DUMB_AXIS_CONST;
	//    else if (linetype <= LT_NODRAW)
	//	dumb_pen = ' ';
	//    else {
	//	linetype = linetype % 7;
	//	dumb_pen = pen_type[linetype];
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_move(unsigned int x, unsigned int y)
	//{
	//    dumb_x = x;
	//    dumb_y = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_point(unsigned int x, unsigned int y, int point)
	//{
	//    dumb_set_pixel(x, y, point == -1 ? '.' : point % 26 + 'A', 4);
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_vector(unsigned int arg_x, unsigned int arg_y)
	//{
	//    int x = arg_x; /* we need signed int, since
	// 				 * unsigned-signed=unsigned and */
	//    int y = arg_y;		// abs and cast to double wouldn't work 
	//    char pen, pen1;
	//    int priority;
	//    int delta;
	//
	//    if (ABS(y - dumb_y) > ABS(x - dumb_x)) {
	//	switch (dumb_pen) {
	//	case DUMB_AXIS_CONST:
	//	    pen = ':';
	//	    pen1 = '+';
	//	    priority = 1;
	//	    break;
	//
	//	case DUMB_BORDER_CONST:
	//	    pen = '|';
	//	    pen1 = '+';
	//	    priority = 2;
	//	    break;
	//
	//	default:
	//	    pen = dumb_pen;
	//	    pen1 = dumb_pen;
	//	    priority = 3;
	//	    break;
	//	}
	//	dumb_set_pixel(dumb_x, dumb_y, pen1, priority);
	//	for (delta = 1; delta < ABS(y - dumb_y); delta++) {
	//	    dumb_set_pixel(dumb_x  + (int) ((double) (x - dumb_x) *
	//					    delta / ABS(y - dumb_y) + 0.5),
	//			   dumb_y + delta * sign(y - dumb_y), pen, priority);
	//	}
	//	dumb_set_pixel(x, y, pen1, priority);
	//    } else if (ABS(x - dumb_x) > ABS(y - dumb_y)) {
	//	switch (dumb_pen) {
	//	case DUMB_AXIS_CONST:
	//	    pen = '.';
	//	    pen1 = '+';
	//	    priority = 1;
	//	    break;
	//
	//	case DUMB_BORDER_CONST:
	//	    pen = '-';
	//	    pen1 = '+';
	//	    priority = 2;
	//	    break;
	//
	//	default:
	//	    pen = dumb_pen;
	//	    pen1 = dumb_pen;
	//	    priority = 3;
	//	    break;
	//	}
	//	dumb_set_pixel(dumb_x, dumb_y, pen1, priority);
	//	for (delta = 1; delta < ABS(x - dumb_x); delta++)
	//	    dumb_set_pixel(dumb_x + delta * sign(x - dumb_x),
	//			   dumb_y +
	//			   (int) ((double) (y - dumb_y) * delta / ABS(x - dumb_x)
	//				  + 0.5),
	//			   pen, priority);
	//	dumb_set_pixel(x, y, pen1, priority);
	//    } else {
	//	switch (dumb_pen) {
	//	case DUMB_AXIS_CONST:	// zero length axis 
	//	    pen = '+';
	//	    priority = 1;
	//	    break;
	//
	//	case DUMB_BORDER_CONST:	// zero length border 
	//	    pen = '+';
	//	    priority = 2;
	//	    break;
	//
	//	default:
	//	    pen = dumb_pen;
	//	    priority = 3;
	//	    break;
	//	}
	//	for (delta = 0; delta <= ABS(x - dumb_x); delta++)
	//	    dumb_set_pixel(dumb_x + delta * sign(x - dumb_x),
	//			   dumb_y + delta * sign(y - dumb_y),
	//			   pen, priority);
	//    }
	//    dumb_x = x;
	//    dumb_y = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    int length;
	//
	//    length = strlen(str);
	//    if (x + length > dumb_xmax)
	//	x = GPMAX(0, dumb_xmax - length);
	//
	//    for (; x < dumb_xmax && *str; x++, str++)
	//	dumb_set_pixel(x, y, *str, 5);
	//}
	//
	//
	//TERM_PUBLIC void
	//DUMB_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)		// ignored 
	//{
	//    char saved_pen;
	//    char saved_x;
	//    char saved_y;
	//
	//    (void) head;		// dummy usage avoid compiler warnings 
	//    saved_pen = dumb_pen;
	//    saved_x = dumb_x;
	//    saved_y = dumb_y;
	//
	//    dumb_pen = '>';
	//    dumb_x = sx;
	//    dumb_y = sy;
	//    DUMB_vector(ex, ey);
	//
	//    dumb_pen = saved_pen;
	//    dumb_x = saved_x;
	//    dumb_y = saved_y;
	//}
	//
	//
	///#ifndef NO_DUMB_ENHANCED_SUPPORT
	// /*
	//  * The code from here on serves as an example of how to
	//  * add enhanced text mode support to even a dumb driver.
	//  */
	//
	//static TBOOLEAN ENHdumb_opened_string;
	//static TBOOLEAN ENHdumb_show = TRUE;
	//static int ENHdumb_overprint = 0;
	//static TBOOLEAN ENHdumb_widthflag = TRUE;
	//static unsigned int ENHdumb_xsave, ENHdumb_ysave;
	///#define ENHdumb_fontsize 1
	///#define ENHdumb_font ""
	//static double ENHdumb_base;
	//
	//TERM_PUBLIC void
	//ENHdumb_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* There are two special cases:
	//  * overprint = 3 means save current position
	//  * overprint = 4 means restore saved position
	//  */
	//    if (overprint == 3) {
	//	ENHdumb_xsave = dumb_x;
	//	ENHdumb_ysave = dumb_y;
	//	return;
	//    } else if (overprint == 4) {
	//	DUMB_move(ENHdumb_xsave, ENHdumb_ysave);
	//	return;
	//    }
	//
	//
	//    if (!ENHdumb_opened_string) {
	//	ENHdumb_opened_string = TRUE;
	// /* Start new text fragment */
	//	    enhanced_cur_text = &enhanced_text[0];
	// /* Scale fractional font height to vertical units of display */
	//	    ENHdumb_base = base * 2;
	// /* Keep track of whether we are supposed to show this string */
	//	    ENHdumb_show = showflag;
	// /* 0/1/2  no overprint / 1st pass / 2nd pass */
	//	    ENHdumb_overprint = overprint;
	// /* widthflag FALSE means do not update text position after printing */
	//	    ENHdumb_widthflag = widthflag;
	// /* Many drivers will need to do something about font selection here */
	// /* but dumb is dumb */
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHdumb_FLUSH()
	//{
	//    char *str = enhanced_text;	// The fragment to print 
	//    int x = dumb_x;		// The current position  
	//    int len;
	//
	//    if (ENHdumb_opened_string) {
	//	*enhanced_cur_text = '\0';
	//	len = strlen(str);
	//
	// /* print the string fragment, perhaps invisibly */
	// /* NB: base expresses offset from current y pos */
	//	for (; x < dumb_xmax && *str; x++, str++)
	//	    if (ENHdumb_show)
	//        	dumb_set_pixel(x, dumb_y+ENHdumb_base, *str, 5);
	//
	//	if (!ENHdumb_widthflag)
	// /* don't update position */
	//	    ;
	//	else if (ENHdumb_overprint == 1)
	// /* First pass of overprint, leave position in center of fragment */
	//	    dumb_x += len / 2;
	//	else
	// /* Normal case is to update position to end of fragment */
	//	    dumb_x += len;
	//
	//	ENHdumb_opened_string = FALSE;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHdumb_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	// /* If no enhanced text processing is needed, we can use the plain  */
	// /* vanilla put_text() routine instead of this fancy recursive one. */
	//    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
	//	DUMB_put_text(x,y,str);
	//	return;
	//    }
	//
	// /* Set up global variables needed by enhanced_recursion() */
	//    enhanced_fontscale = 1.0;
	//    ENHdumb_opened_string = FALSE;
	//    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
	//
	//    DUMB_move(x,y);
	//
	// /* Set the recursion going. We say to keep going until a
	//  * closing brace, but we don't really expect to find one.
	//  * If the return value is not the nul-terminator of the
	//  * string, that can only mean that we did find an unmatched
	//  * closing brace in the string. We increment past it (else
	//  * we get stuck in an infinite loop) and try again.
	//  */
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//    			ENHdumb_font, ENHdumb_fontsize,
	//			0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//
	// /* I think we can only get here if *str == '}' */
	//	    enh_err_check(str);
	//
	//	if (!*++str)
	//	    break; // end of string 
	//
	// /* else carry on and process the rest of the string */
	//    }
	//}
	///#endif // NO_DUMB_ENHANCED_SUPPORT 
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(dumb_driver)
	//    "dumb", "ascii art for anything that prints text",
	//    DUMB_XMAX, DUMB_YMAX, 1, 1,
	//    1, 1, DUMB_options, DUMB_init, DUMB_reset,
	//    DUMB_text, null_scale, DUMB_graphics, DUMB_move, DUMB_vector,
	//    DUMB_linetype, DUMB_put_text, null_text_angle,
	//    null_justify_text, DUMB_point, DUMB_arrow, set_font_null,
	//    0,				// pointsize 
	//    TERM_CAN_MULTIPLOT,
	//    NULL, NULL, NULL, NULL
	///#ifdef USE_MOUSE
	//    , NULL, NULL, NULL, NULL, NULL
	///#endif
	//    , NULL, NULL, NULL, NULL
	//    , NULL // image 
	///#ifndef NO_DUMB_ENHANCED_SUPPORT
	//    , ENHdumb_OPEN, ENHdumb_FLUSH, do_enh_writec
	///#endif // NO_DUMB_ENHANCED_SUPPORT 
	//TERM_TABLE_END(dumb_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM dumb_driver
	//
	///#endif // TERM_TABLE 

	///#ifdef TERM_HELP
	//START_HELP(dumb)
	//"1 dumb",
	//"?commands set terminal dumb",
	//"?set terminal dumb",
	//"?set term dumb",
	//"?terminal dumb",
	//"?term dumb",
	//"?dumb",
	//" The `dumb` terminal driver has an optional size specification and trailing",
	//" linefeed control.",
	//"",
	//" Syntax:",
	//"       set terminal dumb {[no]feed} {<xsize> <ysize>}",
	///#ifndef NO_DUMB_ENHANCED_SUPPORT
	//"                         {[no]enhanced}",
	///#endif
	//"",
	//" where <xsize> and <ysize> set the size of the dumb terminals. Default is",
	//" 79 by 24. The last newline is printed only if `feed` is enabled.",
	//"",
	//" Examples:",
	//"       set term dumb nofeed",
	//"       set term dumb 79 49 # VGA screen---why would anyone do that?"
	//END_HELP(dumb)
	///#endif // TERM_HELP 


	/* DXF format for use with AutoCad (Release 10.x) */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: dxf.trm,v 1.16 2006/07/21 02:35:45 sfeam Exp $
	 *
	 */

	/* GNUPLOT - dxf.trm */

	/*[
	 * Copyright 1991 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   AutoCad (Release 10.x) dxf file format (import with AutoCad dxfin command)
	 *
	 *
	 * AUTHOR
	 *   Florian Hiss  (fhis1231@w204zrz.zrz.tu-berlin.de)
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	*/

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(dxf)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void DXF_init __PROTO((void));
	//TERM_PUBLIC void DXF_graphics __PROTO((void));
	//TERM_PUBLIC void DXF_text __PROTO((void));
	//TERM_PUBLIC void DXF_linetype __PROTO((int linetype));
	//TERM_PUBLIC void DXF_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void DXF_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void DXF_put_text __PROTO((unsigned int x, unsigned int y,
	//				       const char str[]));
	//TERM_PUBLIC int DXF_text_angle __PROTO((int ang));
	//TERM_PUBLIC int DXF_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void DXF_reset __PROTO((void));
	//
	///#define DXF_XMAX (120.0 * DXF_UNIT)
	///#define DXF_YMAX (80.0 * DXF_UNIT)
	///#if 0 // HBB 20030626: old version 
	///#define DXF_HTIC (0.01 * DXF_XMAX)	// 1.0 percent 
	///#define DXF_VTIC (0.01 * DXF_YMAX)	// 1.0 percent 
	///#else
	// /* HBB 20030626: make them have the same length in DXF_UNITs ! */
	///#define DXF_HTIC (2.0 * DXF_UNIT)
	///#define DXF_VTIC (2.0 * DXF_UNIT)
	///#endif
	///#define DXF_HCHAR (0.014 * DXF_XMAX)	// 1.4 percent 
	///#define DXF_VCHAR (0.026 * DXF_YMAX)	// 2.6 percent 
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#define DXF_UNIT 60.0
	///#define LINEWIDTH 0.0351	// default line width is 1 pt 
	//
	// /* 120 (autocad units) wide by 80 (autocad units) high (default)
	//  * use the GNUPLOT 'set size' command to change the defaults */
	// /* actual text height */
	///#define DXF_TEXTHEIGHT (0.7 * DXF_VCHAR)
	//
	// /* actual text width, only a guess, we don't know the width of
	//  * a character of given height of the AutoCad STANDARD text font,
	//  * so change it if you like */
	///#define DXF_TEXTWIDTH (0.7 * DXF_HCHAR)
	//
	// /* number of line types we support. see below  */
	///#define DXF_LINE_TYPES 7
	//
	// /* number of layers used for the drawing. see below */
	///#define MAX_LAYER 7
	//
	// /* line type scaling */
	///#define LT_SCALE 1
	//
	//static unsigned int DXF_posx;
	//static unsigned int DXF_posy;
	// /* linetype is mapped to a layer. see below. */
	//static unsigned int dxf_linetype;
	//static enum JUSTIFY dxf_justify = LEFT;
	//static float dxf_angle = 0.0;	// 0 is horizontal, 90.0 is vertical 
	//
	// /* text style used in the entire drawing */
	//static const char *text_style = "STANDARD";
	//
	// /* text always resides on layer 0 */
	///#define TEXT_LAYER 0
	//
	// /* each linetype resides on its own layer. each layer has its own color.
	//  * this avoids difficulties that AutoCad has with proper scaling of
	//  * the linetypes.
	//  * change the colors according to your needs */
	//static const char *layer_name[] ={ "0", "1", "2", "3", "4", "5", "6" };
	//
	// /* the colours are white, red, yellow, green, cyan, blue, magenta.
	//  * change them according to your needs.
	//  * when using a black and white plotting device the colours map to different
	//  * line thicknesses. see description of AutoCad print / plot command */
	//static const char *layer_colour[] = { "7", "1", "2", "3", "4", "5", "6" };
	//
	// /* support line types AutoCad has to offer by default. */
	//static const char *layer_lines[] = {
	//    "CONTINUOUS", "DASHED", "HIDDEN", "CENTER", "PHANTOM", "DOT", "DASHDOT"
	//};
	//
	//static TBOOLEAN vector_was_last = FALSE;
	//
	//TERM_PUBLIC void
	//DXF_init()
	//{
	//    DXF_posx = DXF_posy = 0;
	//    dxf_linetype = 0;
	//    dxf_angle = 0.0;
	//    vector_was_last = FALSE;
	//}
	//
	//TERM_PUBLIC void
	//DXF_graphics()
	//{
	//    register struct termentry *t = term;
	//    int i;
	//    static char GPFAR dxfi1[] = "
	//999\n
	//%% GNUPLOT: dxf file for AutoCad\n
	//  0\nSECTION\n  2\nHEADER\n
	//  9\n$EXTMIN\n
	// 10\n0.000\n 20\n0.000\n
	//  9\n$EXTMAX\n
	// 10\n%-6.3f\n 20\n%-6.3f\n
	//  9\n$LIMMIN\n
	// 10\n0.000\n 20\n0.000\n
	//  9\n$LIMMAX\n
	// 10\n%-6.3f\n 20\n%-6.3f\n
	//  9\n$TEXTSTYLE\n  7\n%s\n
	//  9\n$TEXTSIZE\n 40\n%-6.3f\n
	//  9\n$PLINEWID\n 40\n%-6.4f\n
	//  9\n$LTSCALE\n  40\n%-6.3f\n
	//  9\n$COORDS\n 70\n  1\n
	//  9\n$CELTYPE\n 6\nBYLAYER\n
	//  9\n$CLAYER\n  8\n0\n
	//  9\n$CECOLOR\n 62\n   %s\n
	//  9\n$MENU\n  1\nacad\n
	//  0\nENDSEC\n
	//  0\nSECTION\n  2\nTABLES\n";
	//    static char GPFAR dxfi2[] = "
	//0\nTABLE\n  2\nLTYPE\n 70\n    %d\n
	//0\nLTYPE\n  2\nCONTINUOUS\n 70\n    64\n
	//  3\nSolid line\n 72\n    65\n 73\n      0\n 40\n0.0\n
	//  0\nLTYPE\n  2\nDASHED\n 70\n    64\n
	//  3\n__ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n
	// 72\n    65\n 73\n     2\n 40\n0.75\n 49\n0.5\n 49\n-0.25\n
	//  0\nLTYPE\n  2\nHIDDEN\n 70\n    64\n
	//  3\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n
	// 72\n    65\n 73\n     2\n 40\n0.375\n 49\n0.25\n 49\n-0.125\n
	//  0\nLTYPE\n  2\nCENTER\n 70\n    64\n
	//  3\n____ _ ____ _ ____ _ ____ _ ____ _ ____ _ ____\n
	// 72\n    65\n 73\n     4\n 40\n2.0\n 49\n1.25\n 49\n-0.25\n
	// 49\n0.25\n 49\n-0.25\n
	//  0\nLTYPE\n  2\nPHANTOM\n 70\n    64\n
	//  3\n_____ _ _ _____ _ _ _____ _ _ _____ _ _ ____\n
	// 72\n    65\n 73\n     6\n 40\n2.5\n 49\n1.25\n
	// 49\n-0.25\n 49\n0.25\n 49\n-0.25\n 49\n0.25\n 49\n-0.25\n
	//  0\nLTYPE\n  2\nDOT\n 70\n    64\n
	//  3\n...............................................\n
	// 72\n    65\n 73\n     2\n 40\n0.25\n 49\n0.0\n 49\n-0.25\n
	//  0\nLTYPE\n  2\nDASHDOT\n 70\n    64\n
	//  3\n__ . __ . __ . __ . __ . __ . __ . __ . __ . __\n
	// 72\n    65\n 73\n     4\n 40\n1.0\n 49\n0.5\n 49\n-0.25\n
	// 49\n0.0\n 49\n-0.25\n
	//  0\nENDTAB\n";
	//
	//    fprintf(gpoutfile, dxfi1,
	//	    t->xmax / DXF_UNIT, t->ymax / DXF_UNIT,
	//	    t->xmax / DXF_UNIT, t->ymax / DXF_UNIT,
	//	    text_style,
	//	    DXF_TEXTHEIGHT / DXF_UNIT,
	//	    LINEWIDTH,
	//	    (double) LT_SCALE,
	//	    layer_colour[0]);
	// /* the linetype table */
	//    fprintf(gpoutfile, dxfi2, DXF_LINE_TYPES);
	// /* the layer table */
	//    fprintf(gpoutfile, "  0\nTABLE\n  2\nLAYER\n 70\n   %-d\n", MAX_LAYER);
	//    for (i = 1; i <= MAX_LAYER; i++)
	//	fprintf(gpoutfile, "  0\nLAYER\n  2\n%s\n 70\n   64\n62\n   %s\n  6\n%s\n", layer_name[i - 1], layer_colour[i - 1], layer_lines[i - 1]);
	//
	// /* no blocks for insertion */
	// /* start the entity section */
	//    fputs("  0\nENDTAB\n0\nENDSEC\n
	//  0\nSECTION\n  2\nBLOCKS\n  0\nENDSEC\n
	//  0\nSECTION\n
	//  2\nENTITIES\n",
	//	  gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//DXF_text()
	//{
	//    if (vector_was_last)
	//	fputs("  0\nSEQEND\n", gpoutfile);
	//    fputs("  0\nENDSEC\n  0\nEOF\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//DXF_linetype(int linetype)
	//{
	//    linetype = ABS(linetype);
	//    linetype = linetype % DXF_LINE_TYPES;
	//    dxf_linetype = linetype;
	//}
	//
	//TERM_PUBLIC void
	//DXF_move(unsigned int x, unsigned int y)
	//{
	//    DXF_posx = x;
	//    DXF_posy = y;
	//    if (vector_was_last)
	//	fputs("  0\nSEQEND\n", gpoutfile);
	//    vector_was_last = FALSE;
	//    fprintf(gpoutfile, "
	//  0\nPOLYLINE\n  8\n%s\n 66\n   1\n
	//  6\n%s\n
	//  0\nVERTEX\n  8\n%s\n
	//  6\n%s\n
	// 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n",
	//	    layer_name[dxf_linetype],
	//	    layer_lines[dxf_linetype],
	//	    layer_name[dxf_linetype],
	//	    layer_lines[dxf_linetype],
	//	    DXF_posx / DXF_UNIT, DXF_posy / DXF_UNIT);
	//
	//}
	//
	//TERM_PUBLIC void
	//DXF_vector(unsigned int ux, unsigned int uy)
	//{
	//    DXF_posx = ux;
	//    DXF_posy = uy;
	//    vector_was_last = TRUE;
	//
	//    fprintf(gpoutfile, "
	//  0\nVERTEX\n  8\n%s\n
	//  6\n%s\n
	//  10\n%-6.3f\n  20\n%-6.3f\n  30\n0.000\n",
	//	    layer_name[dxf_linetype],
	//	    layer_lines[dxf_linetype],
	//	    DXF_posx / DXF_UNIT, DXF_posy / DXF_UNIT);
	//}
	//
	//TERM_PUBLIC void
	//DXF_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    int stl;
	//    float xleftpos, yleftpos, xrightpos, yrightpos;
	//
	// /* shut up gcc warnings  - SB */
	//    xleftpos = yleftpos = xrightpos = yrightpos = 1.0;	// dummy 
	// /* ignore empty strings */
	//    if (str[0] == NUL)
	//	return;
	//
	//    stl = 0;
	//    while (str[stl] != NUL)
	//	++stl;			// get string length 
	//
	//    if (vector_was_last)
	//	fputs("  0\nSEQEND\n", gpoutfile);
	//    vector_was_last = FALSE;
	//    fprintf(gpoutfile, "  0\nTEXT\n  8\n%s\n", layer_name[TEXT_LAYER]);
	//    if (dxf_angle != 90.0) {
	//	switch (dxf_justify) {
	//	case LEFT:
	//	    xleftpos = (float) x;
	//	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
	//	    xrightpos = (float) (x + stl * DXF_TEXTWIDTH);
	//	    yrightpos = yleftpos;
	//	    break;
	//	case RIGHT:
	//	    xleftpos = (float) (x - stl * DXF_TEXTWIDTH);
	//	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
	//	    xrightpos = (float) x;
	//	    yrightpos = yleftpos;
	//	    break;
	//	case CENTRE:
	//	    xleftpos = (float) (x - stl * DXF_TEXTWIDTH / 2.0);
	//	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
	//	    xrightpos = (float) x;	// center point 
	//	    yrightpos = yleftpos;
	//	    break;
	//	}
	//    } else {
	//	switch (dxf_justify) {
	//	case LEFT:
	//	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
	//	    yleftpos = (float) y;
	//	    xrightpos = xleftpos;
	//	    yrightpos = (float) (y + stl * DXF_TEXTWIDTH);
	//	    break;
	//	case RIGHT:
	//	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
	//	    yleftpos = (float) (y - stl * DXF_HCHAR);
	//	    xrightpos = xleftpos;
	//	    yrightpos = (float) y;
	//	    break;
	//	case CENTRE:
	//	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
	//	    yleftpos = (float) (y - stl * DXF_TEXTWIDTH / 2.0);
	//	    xrightpos = xleftpos;
	//	    yrightpos = (float) y;	// center point 
	//	    break;
	//	}
	//    }
	//
	//    fprintf(gpoutfile, "
	// 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n
	// 40\n%-6.3f\n  1\n%s\n 50\n%-6.3f\n
	//  7\n%s\n",
	//	    xleftpos / DXF_UNIT, yleftpos / DXF_UNIT,
	//	    DXF_TEXTHEIGHT / DXF_UNIT, str, dxf_angle,
	//	    text_style);
	//
	//    if (dxf_justify != LEFT) {
	//	fprintf(gpoutfile, " 72\n%d\n
	// 11\n%-6.3f\n 21\n%-6.3f\n 31\n0.000\n",
	//		dxf_justify,
	//		xrightpos / DXF_UNIT, yrightpos / DXF_UNIT);
	//    }
	//}
	//
	//TERM_PUBLIC int
	//DXF_text_angle(int ang)
	//{
	//    dxf_angle = (ang ? 90.0 : 0.0);
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//DXF_justify_text(enum JUSTIFY mode)
	//{
	//    dxf_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//DXF_reset()
	//{
	//    DXF_posx = DXF_posy = 0;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(dxf_driver)
	//  "dxf", "dxf-file for AutoCad (default size 120x80)",
	//    DXF_XMAX, DXF_YMAX, DXF_VCHAR, DXF_HCHAR,
	//    DXF_VTIC, DXF_HTIC, options_null, DXF_init, DXF_reset,
	//    DXF_text, null_scale, DXF_graphics, DXF_move, DXF_vector,
	//    DXF_linetype, DXF_put_text, DXF_text_angle,
	//    DXF_justify_text, do_point, do_arrow, set_font_null
	//TERM_TABLE_END(dxf_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM dxf_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(dxf)
	//"1 dxf",
	//"?commands set terminal dxf",
	//"?set terminal dxf",
	//"?set term dxf",
	//"?terminal dxf",
	//"?term dxf",
	//"?dxf",
	//" The `dxf` terminal driver creates pictures that can be imported into AutoCad",
	//" (Release 10.x).  It has no options of its own, but some features of its plots",
	//" may be modified by other means.  The default size is 120x80 AutoCad units,",
	//" which can be changed by `set size`.  `dxf` uses seven colors (white, red,",
	//" yellow, green, cyan, blue and magenta), which can be changed only by",
	//" modifying the source file.  If a black-and-white plotting device is used, the",
	//" colors are mapped to differing line thicknesses.  See the description of the",
	//" AutoCad print/plot command."
	//END_HELP(dxf)
	///#endif // TERM_HELP 


	/* Enhanced Metafile Format driver */
	/* Hey Emacs this is -*- C -*-
	 * $Id: emf.trm,v 1.59.2.5 2010/02/28 04:33:36 sfeam Exp $
	 */

	/* GNUPLOT - emf.trm */

	/*[
	 * Copyright 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c and ../docs/termdoc.c.
	 *
	 * This terminal driver supports:
	 *   Enhanced Metafile Format
	 *
	 * TODO
	 *
	 * HISTORY
	 *
	 * 4.3.1 12-Sep-2008 Ethan A Merritt
	 * - enhanced text mode
	 * - Two variants are here. One uses the TA_UPDATECP mode to track character position.
	 *   This works great horizontally, but I could not find a way to introduce a vertical
	 *   offset to handle subscripts and superscripts.
	 * - The second variant tracks both x and y by estimating the character width/height.
	 *   This causes visible imperfections in the character spacing.
	 * - Rotated enhanced text not yet supported
	 *
	 * 1.0.11 06-Dec-2004 Ethan A Merritt
	 * - implement term->set_color(), term->filled_polygon(), and term->fillbox()
	 *   RGB colors supported, but not yet PM3D palettes
	 * 1.0.10 08-Jul-2004 Hans-Bernhard Broeker
	 * - cleaned up to match gnuplot CodeStyle conventions (one line per statement,
	 *   even in macro bodies, no meddling with assert()).
	 * - purged K&R definitions
	 * 1.0.9 03-Jun-2004 Stephane Barbaray <stephane.barbaray@compodata.com>, Ethan Merritt <merritt@u.washington.edu>
	 * - fixed linewidth bug
	 * - all is now really assumed as 1024x768@96dpi,
	 *   before it was a mix between 1600x1200@120dpi and 1024x768@96dpi,
	 *   so font may now render differently than before...
	 * - pointsize rework (size twice also now)
	 * - HCHAR and VCHAR are more efficiently computed
	 * 1.0.8 06-May-2004 Stephane Barbaray <stephane.barbaray@compodata.com> 
	 * - fixed to work with MS security patch (kb835732) applied, because MS introduced bugs!!!
	 * - EMR_EXTTEXTOUTW (84) is now EMR_EXTTEXTOUTA (83)
	 * 1.0.7 3-Feb-2003 Ethan A Merritt 
	 * - modify text and point color handling to match other terminal types
	 * - FIXME! alignment of rotated text is not correct.
	 * 1.0.6 25-Jul-2002 Ethan A Merritt <merritt@u.washington.edu> 
	 * - generalized text rotation and justification
	 * 1.0.5 2000/07/20
	 * - Handles were not freed at all, resulting to resource leaks when viewing on Windows 9x (not on NT4/W2000!!!)
	 * 1.0.4 2000/06/28
	 * - Emulated dashed vectors are now looking better
	 * - 15 colors * 8 pointstyles = 120 pointtypes
	 * 1.0.3 2000/03/29
	 * - default font is now Arial 12
	 * - implemented options (color/mono,dashed/solid,font)
	 * - 15 colors * 5 dashtypes = 75 linetypes
	 * 1.0.2 2000/03/22
	 * - Polygon and Polyline structures are not working for Windows 9X, I
	 *   really don't know why, replaced with lineto/moveto couples...
	 * - Texts are now displayed in GM_Compatible mode because GM_Advanced is
	 *   displaying correctly but it does not print correctly with Word97!
	 * - Text centering now works best according to escapement/orientation
	 * - Now there is 8 colors * 5 dashtypes = 40 linetypes
	 * - Successfully Working on Linux Suse 6.1 (x86)
	 *
	 * 1.0.1 2000/03/16
	 * - Unicode text have be to long aligned in EMF files (exttextoutw)
	 * - Problems with text transparence (SetBkMode was not called)
	 * - Null brush created for *not* filling polygon
	 *
	 * 1.0.0 2000/03/15
	 * - Only tested on x86 Win32
	 *
	 * AUTHOR
	 *   Stephane Barbaray <stephane.barbaray@compodata.com>
	 *   Some code based on cgm.trm
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 */


	///#ifdef TERM_REGISTER
	//register_term(emf)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void EMF_options __PROTO((void));
	//TERM_PUBLIC void EMF_init __PROTO((void));
	//TERM_PUBLIC void EMF_reset __PROTO((void));
	//TERM_PUBLIC void EMF_text __PROTO((void));
	//TERM_PUBLIC void EMF_graphics __PROTO((void));
	//TERM_PUBLIC void EMF_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void EMF_dashed_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void EMF_solid_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void EMF_linetype __PROTO((int linetype));
	//TERM_PUBLIC void EMF_linecolor __PROTO((int color));
	//TERM_PUBLIC void EMF_dashtype __PROTO((int dashtype));
	//TERM_PUBLIC void EMF_linewidth __PROTO((double width));
	//TERM_PUBLIC void EMF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int EMF_text_angle __PROTO((int ang));
	//TERM_PUBLIC int EMF_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void EMF_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void EMF_set_pointsize __PROTO((double size));
	//TERM_PUBLIC int EMF_set_font __PROTO((const char *));
	//TERM_PUBLIC int EMF_make_palette __PROTO((t_sm_palette *palette));
	//TERM_PUBLIC void EMF_previous_palette __PROTO((void));
	//TERM_PUBLIC void EMF_set_color __PROTO((t_colorspec *colorspec));
	//TERM_PUBLIC void EMF_filled_polygon __PROTO((int, gpiPoint *));
	//TERM_PUBLIC void EMF_fillbox __PROTO((int, unsigned int, unsigned int, unsigned int, unsigned int));
	//
	// /* Enhanced text support */
	//TERM_PUBLIC void ENHemf_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void ENHemf_OPEN __PROTO((char * fontname, double fontsize,
	//                        double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//			int overprint));
	//TERM_PUBLIC void ENHemf_FLUSH __PROTO((void));
	//
	///#undef RGB
	///#define RGB(r,g,b) ((long)							    (((unsigned char)(r)					      | ((short) ((unsigned char) (g)) << 8))			     | (((long) (unsigned char) (b)) << 16)))
	//ignore
	//ignore
	//ignore
	//
	///#ifndef GPMIN
	///#define GPMIN(a,b) (a < b ? a : b)
	///#endif
	//
	///#ifndef GPMAX
	///#define GPMAX(a,b) (a > b ? a : b)
	///#endif
	//
	///#define EMF_PX2HM 26.37
	///#define EMF_PT2HM 35.28
	///#define EMF_10THDEG2RAD (3.14159265359/1800)
	///#define EMF_XMAX (1024 * EMF_PX2HM)
	///#define EMF_YMAX (768 * EMF_PX2HM)
	///#define EMF_HTIC (EMF_XMAX / 160)
	///#define EMF_VTIC EMF_HTIC
	///#define EMF_FONTNAME "Arial"
	///#define EMF_FONTSIZE 12
	///#define EMF_HCHAR ((EMF_FONTSIZE * EMF_PT2HM) * 0.6)
	///#define EMF_VCHAR ((EMF_FONTSIZE * EMF_PT2HM) * 1.3)
	///#define EMF_LINE_TYPES 5	// number of line types we support 
	///#define EMF_COLORS 15		// number of colors we support 
	///#define EMF_POINTS 13		// number of markers we support 
	///#define EMF_MAX_SEGMENTS 104	// maximum # polyline coordinates 
	//
	///#define EMF_HANDLE_PEN		1
	///#define EMF_HANDLE_FONT		2
	///#define EMF_HANDLE_BRUSH	3
	///#define EMF_HANDLE_MAX		4
	//
	///#define EMF_STOCK_OBJECT_FLAG	((unsigned long)0x1 << 31)
	///#define EMF_STOCK_OBJECT_WHITE_BRUSH 	(EMF_STOCK_OBJECT_FLAG + 0x00)
	///#define EMF_STOCK_OBJECT_BLACK_PEN   	(EMF_STOCK_OBJECT_FLAG + 0x07)
	///#define EMF_STOCK_OBJECT_DEFAULT_FONT	(EMF_STOCK_OBJECT_FLAG + 0x0A)
	//
	///#define EMF_write_emr(type, size) {		    EMF_write_long(type);			    EMF_write_long(size);			    emf_record_count++;				}
	//ignore
	//ignore
	//ignore
	//ignore
	///#define EMF_write_sizel(width, height) {	    EMF_write_long(width);			    EMF_write_long(height);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_write_points(x, y) {		    EMF_write_short(x);				    EMF_write_short(y);				}
	//ignore
	//ignore
	//ignore
	///#define EMF_write_pointl(x, y) {		    EMF_write_long(x);				    EMF_write_long(y);				}
	//ignore
	//ignore
	//ignore
	///#define EMF_write_rectl(left, top, right, bottom) {	    EMF_write_long(left);				    EMF_write_long(top);				    EMF_write_long(right);				    EMF_write_long(bottom);				}
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	///#define EMF_EOF() {				    EMF_write_emr(14, 20);			    EMF_write_long(0);				    EMF_write_long(0x10);			    EMF_write_long(20);				}
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	///#define EMF_SetMapMode(mode) {			    EMF_write_emr(17, 0x0C);			    EMF_write_long(mode);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetWindowExtEx(width, height) {	    EMF_write_emr(9, 0x10);			    EMF_write_sizel(width, height);		}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetWindowOrgEx(width, height) {	    EMF_write_emr(10, 0x10);			    EMF_write_sizel(width, height);		}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetViewportExtEx(width, height) {	    EMF_write_emr(11, 0x10);			    EMF_write_sizel(width, height);		}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetViewportOrgEx(width, height) {	    EMF_write_emr(12, 0x10);			    EMF_write_sizel(width, height);		}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetTextColor(color) {		    EMF_write_emr(24, 0x0C);			    EMF_write_long(color);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_MoveToEx(x,y) {			    EMF_write_emr(27, 0x10);			    EMF_write_pointl(x, y);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_LineTo(x,y) {			    EMF_write_emr(54, 0x10);			    EMF_write_pointl(x, y);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_CreatePen(handle, type, width, color) {	    EMF_write_emr(38, 0x1C);				    EMF_write_long(handle);				    EMF_write_long(type);				    EMF_write_long(width);				    EMF_write_long(0);					    EMF_write_long(color);				}
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	///#define EMF_CreateBrush(handle, type, color, hatch) {	    EMF_write_emr(39, 0x18);				    EMF_write_long(handle);				    EMF_write_long(type);				    EMF_write_long(color);				    EMF_write_long(hatch);				}
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	///#define EMF_SelectObject(handle) {		    EMF_write_emr(37, 0x0C);			    EMF_write_long(handle);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_DeleteObject(handle) {		    EMF_write_emr(40, 0x0C);			    EMF_write_long(handle);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetTextAlign(align) {		    EMF_write_emr(22, 0x0C);			    EMF_write_long(align);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_SetBkMode(mode) {			    EMF_write_emr(18, 0x0C);			    EMF_write_long(mode);			}
	//ignore
	//ignore
	//ignore
	///#define EMF_SaveDC() {				    EMF_write_emr(33, 0x0C);			    EMF_write_long(0);				}
	//ignore
	//ignore
	//ignore
	///#define EMF_RestoreDC() {			    EMF_write_emr(34, 0x0C);			    EMF_write_long(1);				}
	//ignore
	//ignore
	//ignore
	///#define EMF_CreatePolygon(nvert) {		    EMF_write_emr(3, (7+2*nvert)*4);		    EMF_write_rectl(0,0,0,0);  	    EMF_write_long(nvert);			} 
	//ignore
	//ignore
	//ignore
	//ignore
	//
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#include <ctype.h>		// for isspace() 
	//
	//static unsigned int emf_posx;
	//static unsigned int emf_posy;
	//static unsigned int emf_record_count = 0;
	//static unsigned int emf_linetype = 1;
	//static unsigned int emf_dashtype = 0;
	//static unsigned long emf_color = 0L;
	//static unsigned long emf_textcolor = LT_UNDEFINED;
	//static unsigned int emf_colors = EMF_COLORS;
	//static unsigned int emf_polyline[EMF_MAX_SEGMENTS];	// stored polyline coordinates 
	//static unsigned int emf_graphics = FALSE;
	//static unsigned int emf_dashed = TRUE;
	//static unsigned int emf_monochrome = FALSE;
	//static double emf_linewidth;	// line width in plot units 
	//static double emf_linewidth_factor = 1.0;
	//static double emf_dashlength = 1.0;
	//static int emf_coords = 0;	// # polyline coordinates saved 
	//static char emf_fontname[255] = EMF_FONTNAME;
	//static float emf_fontsize = EMF_FONTSIZE;
	//static enum JUSTIFY emf_justify = LEFT;
	//static char emf_defaultfontname[255] = EMF_FONTNAME;
	//static float emf_defaultfontsize = EMF_FONTSIZE;
	//static int emf_vert_text = 0;	// text orientation -- nonzero for vertical 
	//static int emf_step_sizes[8];	// array of currently used dash lengths in plot units 
	//static int emf_step_index = 0;	// index into emf_step_sizes[] 
	//static int emf_step = 0;	// amount of current dash not yet drawn, in plot units 
	//static int emf_tic, emf_tic707, emf_tic866, emf_tic500, emf_tic1241, emf_tic1077, emf_tic621;	// marker dimensions 
	//
	//static TBOOLEAN emf_tweak = TRUE;	// Empirical hack to adjust character widths 
	//
	//static void EMF_flush_polyline __PROTO((void));
	//static void EMF_flush_polygon __PROTO((void));
	//static void EMF_write_byte __PROTO((int)); 
	//static void EMF_write_short __PROTO((int)); 
	//static void EMF_write_long __PROTO((unsigned long));
	//static void EMF_write_float __PROTO((double)); 
	//static void EMF_setfont __PROTO((void));
	//
	///#define ANSI_CHARSET         0
	///#define DEFAULT_CHARSET      1
	///#define GREEK_CHARSET      161
	///#define TURKISH_CHARSET    162
	///#define BALTIC_CHARSET     186
	///#define RUSSIAN_CHARSET    204
	///#define EASTEUROPE_CHARSET 238
	///#define KOI8_CHARSET       242
	//
	// /* Text alignment */
	///#define GP_TA_NOUPDATECP       0x00
	///#define GP_TA_UPDATECP         0x01
	///#define GP_TA_LEFT             0x00
	///#define GP_TA_RIGHT            0x02
	///#define GP_TA_CENTER           0x06
	///#define GP_TA_TOP              0x00
	///#define GP_TA_BOTTOM           0x08
	///#define GP_TA_BASELINE         0x18
	//
	// /* ExtTextOut options */
	///#define ETO_NO_RECT	   0x100
	///#define ETO_PDY		  0x2000
	//
	//static void 
	//EMF_setfont()
	//{
	//    int i, count;
	//    int bold = 400;
	//    char italic = 0, underline = 0, strikeout = 0;
	//    char font[32];
	//    char *sub;
	//
	//    if (!emf_graphics)
	//	return;
	//
	//    count = GPMIN (strlen(emf_fontname), 31);
	//    if (((sub = strstr(emf_fontname, " bold")) != NULL)
	//	|| ((sub = strstr(emf_fontname, " Bold")) != NULL)) {
	//	bold = 700;
	//	count = GPMIN(sub - emf_fontname, count);
	//    }
	//    if (((sub = strstr(emf_fontname, " italic")) != NULL)
	//	|| ((sub = strstr(emf_fontname, " Italic")) != NULL)) {
	//	italic = 1;
	//	count = GPMIN(sub - emf_fontname, count);
	//    }
	//    if (((sub = strstr(emf_fontname, " underline")) != NULL)
	//	|| ((sub = strstr(emf_fontname, " Underline")) != NULL)) {
	//	underline = 1;
	//	count = GPMIN(sub - emf_fontname, count);
	//    }
	//    if (((sub = strstr(emf_fontname, " strikeout")) != NULL)
	//	|| ((sub = strstr(emf_fontname, " Strikeout")) != NULL)
	//	|| ((sub = strstr(emf_fontname, " StrikeOut")) != NULL)
	//	) {
	//	strikeout = 1;
	//	count = GPMIN(sub - emf_fontname, count);
	//    }
	//
	//    safe_strncpy(font, emf_fontname, count + 1);
	//
	//    EMF_SelectObject(EMF_STOCK_OBJECT_DEFAULT_FONT);
	//    EMF_DeleteObject(EMF_HANDLE_FONT);
	//
	// /* SB 20040506: was not complete size was 104, now it is 332 */
	//    EMF_write_emr(82, 332); 
	//    EMF_write_long(EMF_HANDLE_FONT);
	//    EMF_write_long((long) (-emf_fontsize * EMF_PT2HM));	// height 
	//    EMF_write_long(0);		        // width 
	//    EMF_write_long(emf_vert_text);	// escapement 
	//    EMF_write_long(emf_vert_text);	// orientation 
	//    EMF_write_long(bold);	        // weight 
	//    EMF_write_byte(italic);	        // italic 
	//    EMF_write_byte(underline);	        // underline 
	//    EMF_write_byte(strikeout);	        // strikeout 
	//
	// /* charset: could be extended? */
	//    switch (encoding) {
	//    case S_ENC_CP1250:
	//    case S_ENC_ISO8859_2:
	//	EMF_write_byte(EASTEUROPE_CHARSET);
	//	break;
	//    case S_ENC_KOI8_R:
	//    case S_ENC_KOI8_U:
	//	EMF_write_byte(KOI8_CHARSET);
	//	break;
	//    case S_ENC_CP1254:
	//    case S_ENC_ISO8859_9:
	//	EMF_write_byte(TURKISH_CHARSET);
	//	break;
	//    default:
	//	EMF_write_byte(DEFAULT_CHARSET);
	//    }
	//
	//    EMF_write_byte(0);		        // out precision 
	//    EMF_write_byte(0);		        // clip precision 
	//    EMF_write_byte(0);		        // quality 
	//    EMF_write_byte(0);		        // pitch and family 
	//    for (i = 0; i < 32; i++) {
	// /* face name (max 32) */
	//	EMF_write_byte((char) (i < strlen(font) ? font[i] : 0));
	//	EMF_write_byte(0);
	//    }
	//    
	// /* SB 20040506: modification following */
	//    for (i = 0; i < 64; i++) {
	// /* FULL face name (max 64) */
	//	EMF_write_byte((char) (i < strlen(font) ? font[i] : 0));
	//	EMF_write_byte(0);
	//    }
	//    for (i = 0; i < 32; i++) {
	// /* style name (max 32) */
	//	EMF_write_byte(0);
	//	EMF_write_byte(0);
	//    }
	//    EMF_write_long(0);		// version 
	//    EMF_write_long(0);		// Style size 
	//    EMF_write_long(0);		// Match 
	//    EMF_write_long(0);		// reserved 
	//    EMF_write_long(0);		// VendorId 
	//    EMF_write_long(0);		// Culture 
	//    for (i = 0; i < 10; i++)
	//	EMF_write_byte(0); // Panose (ignored) 
	//    EMF_write_byte(0);		// pad (long aligned) 
	//    EMF_write_byte(0);		// pad (long aligned) 
	// /* SB 20040506: End of modification */
	//
	//    EMF_SelectObject(EMF_HANDLE_FONT);
	//}
	//
	//static void 
	//EMF_flush_polygon()
	//{
	//    int i = 0;
	//
	//    if (emf_coords == 0)
	//	return;
	//
	//    EMF_MoveToEx(emf_polyline[i++], term->ymax - emf_polyline[i++]);
	//    while (i < emf_coords * 2)
	//	EMF_LineTo(emf_polyline[i++], term->ymax - emf_polyline[i++]);
	//    EMF_LineTo(emf_polyline[0], term->ymax - emf_polyline[1]);
	//
	//    emf_coords = 0;
	//}
	//
	//static void 
	//EMF_flush_polyline()
	//{
	//    if (emf_coords == 0)
	//	return;
	//    
	//    if (emf_coords <= 2) {
	//	EMF_MoveToEx(emf_polyline[0], term->ymax - emf_polyline[1]);
	//	EMF_LineTo(emf_polyline[2], term->ymax - emf_polyline[3]);
	//    } else {
	//	int i = 0;
	//	EMF_MoveToEx(emf_polyline[i++], term->ymax - emf_polyline[i++]);
	//	while (i < emf_coords * 2)
	//	    EMF_LineTo(emf_polyline[i++], term->ymax - emf_polyline[i++]);
	//    }
	//    emf_coords = 0;
	//}
	//
	// /* HBB 20040708: the following keep K&R argument types for now */
	//static void 
	//EMF_write_byte(int value)
	//{
	//    char c = value;
	//    fwrite(&c, 1, 1, gpoutfile);
	//}
	//
	//static void 
	//EMF_write_short(int value)
	//{
	//    short actual_value = value;
	//    char c[2];
	//
	//    c[1] = (actual_value >> 8) & 255;	// convert to x86 order 
	//    c[0] = actual_value & 255;
	//
	//    fwrite(c, 1, 2, gpoutfile);
	//}
	//
	//static void 
	//EMF_write_long(unsigned long value)
	//{
	//    char c[4];
	//
	//    c[3] = (value >> 24) & 0xFFL;	// convert to x86 order 
	//    c[2] = (value >> 16) & 0xFFL;
	//    c[1] = (value >> 8) & 0xFFL;
	//    c[0] = value & 0xFFL;
	//
	//    fwrite(c, 1, 4, gpoutfile);
	//}
	//
	// /* FIXME HBB 20001103: this only works as given iff 'float' is the
	//  * same format as on x86's, i.e. IEEE 4-byte floating point format */
	//static void 
	//EMF_write_float(double value)
	//{
	//    char c[4];
	//
	//    union {
	//	long l;
	//	float f;
	//    } u;
	//
	//    u.f = value;
	//
	//    c[3] = (u.l >> 24) & 0xFFL;	// convert to x86 order 
	//    c[2] = (u.l >> 16) & 0xFFL;
	//    c[1] = (u.l >> 8) & 0xFFL;
	//    c[0] = u.l & 0xFFL;
	//
	//    fwrite(c, 1, 4, gpoutfile);
	//}
	//
	//TERM_PUBLIC void 
	//EMF_options()
	//{
	//    char *s;
	//
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we have already initialized the terminal.                  */
	//    if (c_token != 2) {
	//	term->xmax = EMF_XMAX;
	//	term->ymax = EMF_YMAX;
	//	emf_dashed = TRUE;
	//	emf_monochrome = FALSE;
	//	emf_tweak = TRUE;
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	if (almost_equals(c_token, "de$fault")) {
	//	    strcpy(emf_defaultfontname, EMF_FONTNAME);
	//	    emf_defaultfontsize = EMF_FONTSIZE;
	//	    emf_monochrome = FALSE;
	//	    emf_dashed = TRUE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    continue;
	//	}
	//	if (almost_equals(c_token, "m$onochrome")) {
	//	    emf_monochrome = TRUE;
	//	    term->flags |= TERM_MONOCHROME;
	//	    c_token++;
	//	    continue;
	//	}
	//	if (almost_equals(c_token, "c$olor") || almost_equals(c_token, "c$olour")) {
	//	    emf_monochrome = FALSE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    continue;
	//	}
	//	if (almost_equals(c_token, "da$shed")) {
	//	    emf_dashed = TRUE;
	//	    c_token++;
	//	    continue;
	//	}
	//	if (equals(c_token, "dl") || almost_equals(c_token, "dashl$ength")) {
	//	    c_token++;
	//	    emf_dashlength = real_expression();
	//	    if (emf_dashlength < 0.5)
	//		emf_dashlength = 1.0;
	//	    continue;
	//	}
	//	if (almost_equals(c_token, "s$olid")) {
	//	    emf_dashed = FALSE;
	//	    c_token++;
	//	    continue;
	//	}
	//	if (equals(c_token, "lw") || almost_equals(c_token, "linew$idth")) {
	//	    c_token++;
	//	    emf_linewidth_factor = real_expression();
	//	    if (emf_linewidth_factor < 0.1)
	//		emf_linewidth_factor = 1.0;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token,"enh$anced")) {
	//	    c_token++;
	//	    term->put_text = ENHemf_put_text;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    continue;
	//	} else if (almost_equals(c_token,"noenh$anced")) {
	//	    c_token++;
	//	    term->put_text = EMF_put_text;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	}
	//
	//	if (almost_equals(c_token,"nopro$portional")) {
	//	    c_token++;
	//	    emf_tweak = FALSE;
	//	}
	//
	//	if (almost_equals(c_token, "si$ze")) {
	//	    int tempxmax = 1024;
	//	    int tempymax = 768;
	//	    c_token++;
	//	    if (!END_OF_COMMAND) {
	//		tempxmax = real_expression();
	//		if (equals(c_token, ",")) {
	//		    c_token++;
	//		    tempymax = real_expression();
	//		}
	//	    }
	//	    if (tempxmax > 0)
	//		term->xmax = tempxmax * EMF_PX2HM;
	//	    if (tempymax > 0)
	//		term->ymax = tempymax * EMF_PX2HM;
	//	    term->h_tic = term->xmax / 160;
	//	    term->v_tic = term->h_tic;
	//	    continue;
	//	}
	//	if (equals(c_token, "font"))
	//	    c_token++;
	// /* Fall through to old-style bare font name */
	//	if ((s = try_to_get_string())) {
	//	    char *comma = strrchr(s,',');
	//	    if (comma && (1 == sscanf(comma+1,"%g",&emf_defaultfontsize))) {
	//		*comma = '\0';
	//	    }
	//	    if (*s)
	//		strncpy(emf_defaultfontname, s, sizeof(emf_defaultfontname));
	//	    free(s);
	//	    if (isanumber(c_token)) {
	//		emf_defaultfontsize = int_expression();
	//	    }
	//	    continue;
	//	}
	//	break;
	//    } // while(!end of command) 
	//
	//    if (!END_OF_COMMAND) {
	// /* We have old-style bare font size specified */
	//	emf_defaultfontsize = int_expression();
	//    }
	//    EMF_set_font(NULL);		// set default font 
	//    
	//    emf_colors = emf_monochrome ? 1 : EMF_COLORS;
	//
	//    sprintf(term_options, "%s %s \"%s\" %g",
	//	    emf_monochrome ? "monochrome" : "color",
	//	    emf_dashed ? "dashed" : "solid",
	//	    emf_defaultfontname, emf_defaultfontsize);
	//
	//    if (term->flags & TERM_ENHANCED_TEXT)
	//	strcat(term_options, " enhanced ");
	//    if (term->xmax != (int)EMF_XMAX || term->ymax != (int)EMF_YMAX)
	//	sprintf(&(term_options[strlen(term_options)]), " size %d,%d ",
	//	    (int)(0.5+term->xmax/EMF_PX2HM), (int)(0.5+term->ymax/EMF_PX2HM));
	//    if (emf_linewidth_factor != 1.0)
	//	sprintf(&(term_options[strlen(term_options)]), " lw %.1f",
	//		emf_linewidth_factor);
	//    if (emf_dashlength != 1.0)
	//	sprintf(&(term_options[strlen(term_options)]), " dashlength %.1f",
	//		emf_dashlength);
	//}
	//
	//TERM_PUBLIC void 
	//EMF_init()
	//{
	//    emf_posx = emf_posy = 0;
	//    emf_linetype = 0;
	//    emf_vert_text = 0;
	//    emf_graphics = FALSE;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_graphics()
	//{
	//    int width = 0.5 + term->xmax/EMF_PX2HM;
	//    int height = 0.5 + term->ymax/EMF_PX2HM;
	//    int mmwidth = 0.5 + (term->xmax/EMF_PX2HM) * (270./1024.);
	//    int mmheight = 0.5 + (term->ymax/EMF_PX2HM) * (200./768.);
	//
	// /* header start */
	//    emf_record_count = 0;
	//    EMF_write_emr(1, 100);
	//    EMF_write_long(0);		// rclBounds 
	//    EMF_write_long(0);
	//    EMF_write_long(term->xmax / EMF_PX2HM);
	//    EMF_write_long(term->ymax / EMF_PX2HM);
	//    EMF_write_long(0);		// rclFrame 
	//    EMF_write_long(0);
	//    EMF_write_long(term->xmax);
	//    EMF_write_long(term->ymax);
	//    EMF_write_long(0x464D4520);	// signature 
	//    EMF_write_long(0x00010000);	// version 
	//    EMF_write_long(0);		// nBytes 
	//    EMF_write_long(0);		// nRecords 
	//    EMF_write_short(EMF_HANDLE_MAX);	// nHandles, MUST NOT BE 0 
	//    EMF_write_short(0);		// reserved 
	//    EMF_write_long(0);		// descSize 
	//    EMF_write_long(0);		// descOff 
	//    EMF_write_long(0);		// nPalEntries 
	//    EMF_write_long(width);	// ref dev pixwidth, default 1024 
	//    EMF_write_long(height);	// ref dev pixheight, default 768 
	//    EMF_write_long(mmwidth);	// ref dev mwidth, default 270 
	//    EMF_write_long(mmheight);	// ref dev mheight, default 200 
	//    EMF_write_long(0);		// cbPixelFormat  
	//    EMF_write_long(0);		// offPixelFormat  
	//    EMF_write_long(0);		// bOpenGL 
	//    emf_graphics = TRUE;
	// /* header end */
	//
	//    EMF_SetMapMode(8);		// forcing anisotropic mode 
	//    EMF_SetWindowExtEx(term->xmax, term->ymax);		// setting logical (himetric) size      
	//    EMF_SetViewportExtEx(term->xmax / EMF_PX2HM, term->ymax / EMF_PX2HM);	// setting device (pixel) size 
	//    EMF_CreatePen(EMF_HANDLE_PEN, 0, 1, 0x000000);	// init default pen 
	//    EMF_SelectObject(EMF_HANDLE_PEN);
	//    EMF_SetBkMode(1);		// transparent background for text 
	//    EMF_CreateBrush(EMF_HANDLE_BRUSH, 1, 0, 0);		// transparent brush for polygons 
	//    EMF_SelectObject(EMF_HANDLE_BRUSH);
	//    EMF_set_font(NULL);		// init default font 
	//}
	//
	//TERM_PUBLIC int 
	//EMF_set_font(const char *font)
	//{
	//    static float last_fontsize = -1;
	//    static char last_fontname[256] = {'\0'};
	//
	//    if (font && *font) {
	//	float tempsize;
	//	int sep = strcspn(font,",");
	//	if (sep > 0)
	//	    safe_strncpy(emf_fontname, font, GPMIN(sep + 1, 32));
	//	if (sep < strlen(font) && sscanf(font+sep+1, "%f", &tempsize))
	//	    emf_fontsize = tempsize;
	//    } else {
	//	strcpy(emf_fontname, emf_defaultfontname);
	//	emf_fontsize = emf_defaultfontsize;
	//    }
	//
	// /* Optimization only */
	//    if (!strcmp(last_fontname,emf_fontname) && last_fontsize == emf_fontsize) {
	//	return TRUE;
	//    }
	//
	//    term->h_char = (emf_fontsize * EMF_PT2HM)*0.6;
	//    term->v_char = (emf_fontsize * EMF_PT2HM)*1.3;
	//    EMF_setfont();
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_text()
	//{
	//    long pos;
	//    EMF_flush_polyline();
	//
	// /* writing end of metafile */
	//    EMF_SelectObject(EMF_STOCK_OBJECT_DEFAULT_FONT);
	//    EMF_DeleteObject(EMF_HANDLE_FONT);
	//    EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
	//    EMF_DeleteObject(EMF_HANDLE_PEN);
	//    EMF_SelectObject(EMF_STOCK_OBJECT_WHITE_BRUSH);
	//    EMF_DeleteObject(EMF_HANDLE_BRUSH);
	//    EMF_EOF();
	//
	// /* updating header */
	//    pos = ftell(gpoutfile);
	//    fseek(gpoutfile, 48, SEEK_SET);
	//    EMF_write_long(pos);
	//    EMF_write_long(emf_record_count);
	// /* HBB 20010228: have to make known that we're no longer in graphics
	//  * status. */
	//    emf_graphics = FALSE;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_linetype(int linetype)
	//{
	// /* Note : separating linetype and color would have not been futile, but anyway... */
	//
	///#if (0)  // Not safe because linetype/color/pen are intermixed 
	//    if (linetype == emf_linetype)
	//	return;
	///#endif
	//
	//    if (linetype == LT_NODRAW)
	//	linetype = LT_BACKGROUND;
	//	
	//    emf_linetype = linetype;
	//
	//    EMF_linecolor(linetype);
	//    EMF_dashtype(linetype);
	//}
	//
	//TERM_PUBLIC void 
	//EMF_linecolor(int linecolor)
	//{
	//    static long GPFAR color_table_data[] =
	//    {
	//	RGB(255, 0, 0),		// red 
	//	RGB(0, 255, 0),		// green 
	//	RGB(0, 0, 255),		// blue 
	//	RGB(255, 0, 255),	// magenta 
	//	RGB(0, 0, 128),		// dark blue 
	//	RGB(128, 0, 0),		// dark red 
	//	RGB(0, 128, 128),	// dark cyan 
	//	RGB(0, 0, 0),		// black 
	//	RGB(128, 128, 128),	// grey 
	//	RGB(0, 128, 64),	// very dark cyan 
	//	RGB(128, 128, 0),	// dark yellow 
	//	RGB(128, 0, 128),	// dark magenta 
	//	RGB(192, 192, 192),	// light grey 
	//	RGB(0, 255, 255),	// cyan 
	//	RGB(255, 255, 0)	// yellow 
	//    };
	//
	//    if (linecolor == LT_BACKGROUND)
	//	emf_color = RGB(255, 255, 255);	// white (background) 
	//    else {
	//	linecolor = (linecolor < 0 || emf_monochrome) ? 7 : (linecolor % EMF_COLORS);
	//	emf_color = color_table_data[linecolor];
	//    }
	//
	//    EMF_flush_polyline();
	//}
	//
	//TERM_PUBLIC int EMF_make_palette(t_sm_palette *palette)
	//{
	//    return 0; // can do continous colors 
	//}
	//
	//TERM_PUBLIC void EMF_previous_palette()
	//{
	// /* do nothing */
	//}
	//
	//TERM_PUBLIC void
	//EMF_set_color(t_colorspec *colorspec)
	//{
	//    rgb255_color rgb255;
	//
	//    if (colorspec->type == TC_LT) {
	//	EMF_linecolor(colorspec->lt);
	//    } else if (colorspec->type == TC_FRAC) {
	//	rgb255maxcolors_from_gray(colorspec->value, &rgb255);
	//	emf_color = RGB(rgb255.r, rgb255.g, rgb255.b);
	//    } else if (colorspec->type == TC_RGB) {
	//	emf_color = RGB( colorspec->lt >> 16 & 0xff,
	//			 colorspec->lt >> 8 & 0xff,
	//			 colorspec->lt & 0xff );
	//    }
	//
	// /*
	// else {
	// fprintf(stderr, "unhandled colorspec type %d\n", colorspec->type);
	// }
	// */
	//
	// /* Force reevaluation of dash type */
	//    emf_dashtype = LT_UNDEFINED;
	//    EMF_dashtype(emf_linetype);
	//}
	//
	//TERM_PUBLIC void
	//EMF_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int i;
	//    unsigned long color = emf_color;
	//    int fillpar = corners->style >> 4;
	//    int style = corners->style & 0xf;
	//
	//    switch (style) {
	//	case FS_EMPTY: // fill with background color 
	//		color = RGB(255,255,255);
	//		break;
	//	case FS_PATTERN: // pattern fill implemented as partial density 
	//		fillpar *= 12;
	//	case FS_SOLID: // solid fill 
	//		if (fillpar >= 0 && fillpar < 100) {
	//		    double density = (double)fillpar / 100.;
	//		    color = ((int)((double)((emf_color>>16)&0xff)*density) << 16)
	//			  + ((int)((double)((emf_color>>8)&0xff)*density) << 8)
	//			  + ((int)((double)(emf_color&0xff)*density));
	//		    color += ((int)(255.*(1.-density)) << 16)
	//		           + ((int)(255.*(1.-density)) << 8)
	//			   + ((int)(255.*(1.-density)));
	//		}
	//		break;
	//	default:
	//		break;
	//    }
	//
	// /* Sequence of operations cribbed from Windows example */
	//	EMF_CreateBrush(EMF_HANDLE_BRUSH, 0, color, 0);
	//	EMF_SelectObject(EMF_HANDLE_BRUSH);
	//
	//	EMF_CreatePolygon(points);
	//	for (i=0; i<points; i++)
	//	    EMF_write_pointl(corners[i].x, term->ymax - corners[i].y);
	//
	//	EMF_DeleteObject(EMF_HANDLE_BRUSH);
	//
	// /* Force re-evaluation of linetype next time we draw a line */
	//    emf_linetype = LT_UNDEFINED;
	//    emf_dashtype = LT_UNDEFINED;
	//}
	//
	//TERM_PUBLIC void
	//EMF_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
	//{
	//    gpiPoint corner[4];
	//
	//	corner[0].x = x1;        corner[0].y = y1;
	//	corner[1].x = x1+width;  corner[1].y = y1;
	//	corner[2].x = x1+width;  corner[2].y = y1+height;
	//	corner[3].x = x1;        corner[3].y = y1+height;
	//	corner->style = style;
	//
	//	EMF_filled_polygon(4, corner);
	//}
	//
	//TERM_PUBLIC void 
	//EMF_linewidth(double width)
	//{
	//	int current_dashtype = emf_dashtype;
	//    
	//    width *= emf_linewidth_factor;
	//    if (width == emf_linewidth)
	//	return;
	//    emf_linewidth = width;
	//
	//	emf_dashtype = LT_UNDEFINED;      // Invalidate current dash type     
	//	EMF_dashtype(current_dashtype);    // Force re-evaluation of dash type 
	//}
	//
	// /*
	//  * Resets _both_ line color and dash type!
	//  */
	//TERM_PUBLIC void 
	//EMF_dashtype(int dashtype)
	//{
	//    int i, j;
	// /* Each group of 8 entries in dot_length[] defines a dash
	//    pattern.  Entries in each group are alternately length of
	//    whitespace and length of line, in units of 2/3 of the
	//    linewidth. */
	//    static int dot_length[EMF_LINE_TYPES * 8] =
	//    {				// 0 - solid             
	//	5, 8, 5, 8, 5, 8, 5, 8,	// 1 - dashes            
	//	4, 2, 4, 2, 4, 2, 4, 2,	// 2 - dotted            
	//	4, 8, 4, 2, 4, 8, 4, 2,	// 3 - dash-dot          
	//	4, 9, 4, 2, 4, 2, 0, 0,	// 4 - dash-dot-dot      
	//    };
	//
	//    emf_dashtype = dashtype;
	//
	//    EMF_flush_polyline();
	//
	//    if (dashtype >= 0)
	//	dashtype = (dashtype / emf_colors) % EMF_LINE_TYPES;
	//
	//    if (dashtype == LT_AXIS)
	//	dashtype = 2;
	//
	//    if (dashtype < 1 || !emf_dashed) {	// solid mode 
	//	EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
	//	EMF_DeleteObject(EMF_HANDLE_PEN);
	//	EMF_CreatePen(EMF_HANDLE_PEN, 0, emf_linewidth * EMF_PX2HM, emf_color);
	//	EMF_SelectObject(EMF_HANDLE_PEN);
	//
	//	term->vector = EMF_solid_vector;
	//    } else {			// Since win32 dashed lines works only with 1 pixel linewith we must emulate 
	//	EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
	//	EMF_DeleteObject(EMF_HANDLE_PEN);
	//	EMF_CreatePen(EMF_HANDLE_PEN, 0, emf_linewidth * EMF_PX2HM, emf_color);
	//	EMF_SelectObject(EMF_HANDLE_PEN);
	//
	//	term->vector = EMF_dashed_vector;
	//
	// /* set up dash dimensions */
	//	j = (dashtype - 1) * 8;
	//	for (i = 0; i < 8; i++, j++) {
	//	    emf_step_sizes[i] = dot_length[j] * emf_dashlength * EMF_PX2HM;
	//	}
	// /* first thing drawn will be a line */
	//	emf_step = emf_step_sizes[1];
	//	emf_step_index = 1;
	//    }
	//}
	//
	//TERM_PUBLIC void 
	//EMF_move(unsigned int x, unsigned int y)
	//{
	//    if (x >= term->xmax || y >= term->ymax) {
	//	int_warn(NO_CARET, "emf_move: (%d,%d) out of range",x,y);
	//	x = GPMIN(x, term->xmax); y = GPMIN(y, term->ymax);
	//    }
	//    if (x == emf_posx && y == emf_posy)
	//	return;
	//    EMF_flush_polyline();
	//    emf_posx = x;
	//    emf_posy = y;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_dashed_vector(unsigned int ux, unsigned int uy)
	//{
	//    int xa, ya;
	//    int dx, dy, adx, ady;
	//    int dist;			// approximate distance in plot units from starting point to specified end point. 
	//    long remain;		// approximate distance in plot units remaining to specified end point. 
	//
	//    if (ux >= term->xmax || uy >= term->ymax)
	//	int_warn(NO_CARET, "emf_dashed_vector: (%d,%d) out of range",ux,uy);
	//
	//    dx = (ux - emf_posx);
	//    dy = (uy - emf_posy);
	//    adx = abs(dx);
	//    ady = abs(dy * 10);
	//
	// /* using the approximation sqrt(x**2 + y**2)  ~  x + (5*x*x)/(12*y)   when x > y.  
	//    Note ordering of calculations to avoid overflow on 16 bit architectures */
	//    if (10 * adx < ady)
	//	dist = (ady / 2 + 25 * adx / ady * adx / 6 * 5) / 5;
	//    else {
	//	if (adx == 0)
	//	    return;
	//	dist = (adx * 10 + (ady / 24) * (ady / adx)) / 10;
	//    }
	//    remain = dist;
	//    xa = emf_posx;
	//    ya = emf_posy;
	//    while (remain > emf_step) {
	//	remain -= emf_step;
	//	if (emf_step_index & 1)
	//	    EMF_solid_vector((int) (ux - (remain * dx) / dist),
	//			     (int) (uy - (remain * dy) / dist));
	//	else {
	//	    xa = (int) (ux - (remain * dx) / dist);
	//	    ya = (int) (uy - (remain * dy) / dist);
	//	    EMF_move(xa, ya);
	//	}
	//	if (++emf_step_index >= 8)
	//	    emf_step_index = 0;
	//	emf_step = emf_step_sizes[emf_step_index];
	//    }
	//    if (emf_step_index & 1)
	//	EMF_solid_vector(ux, uy);
	//    else
	//	EMF_move(ux, uy);
	//    emf_step -= (int) remain;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_solid_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (ux >= term->xmax || uy >= term->ymax)
	//	int_warn(NO_CARET, "emf_solid_vector: (%d,%d) out of range",ux,uy);
	//    if (ux == emf_posx && uy == emf_posy)
	//	return;
	//    if (emf_coords * 2 > EMF_MAX_SEGMENTS - 2)
	//	EMF_flush_polyline();
	//    if (emf_coords == 0) {
	//	emf_polyline[0] = emf_posx;
	//	emf_polyline[1] = emf_posy;
	//	emf_coords++;
	//    }
	//    emf_posx = emf_polyline[emf_coords * 2] = ux;
	//    emf_posy = emf_polyline[emf_coords * 2 + 1] = uy;
	//    emf_coords++;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    int i, len = strlen(str);
	//
	//    EMF_flush_polyline();
	//    if (emf_textcolor != emf_color) {
	//	EMF_SetTextColor(emf_color);	// since text doesn't use pens, we must initialize with this 
	//	emf_textcolor = emf_color;
	//    }
	//
	// /* SB 20040506: offset array now included since it won't work with MS Security patch (kb835732) */
	// /* SB 20040506: also changed function from unicode to ansi version */
	//    if (len % 4)
	//	len += 4 - (len % 4); // Structure must be long aligned! 
	//    EMF_write_emr(83, 76 + len + strlen(str)*4);// ExtTextOutA, ANSI char version! 
	//    EMF_write_rectl(0, 0, 0, 0); // bounding, never used 
	//    EMF_write_long(1);		// GM_Compatible mode for advanced scaling 
	//    EMF_write_float(EMF_PX2HM);	// x scale 
	//    EMF_write_float(EMF_PX2HM);	// y scale 
	// /* positioning... y is recentered from bottom reference set in
	//  * text align */
	//    EMF_write_pointl(
	//	x + (long) ((EMF_VCHAR / 2) * sin(emf_vert_text * EMF_10THDEG2RAD)),
	//	term->ymax - y + (long) (EMF_VCHAR / 2
	//				 * cos(emf_vert_text * EMF_10THDEG2RAD)));
	//    EMF_write_long(strlen(str)); // real char size 
	//    EMF_write_long(76);		// offset to text 
	//    EMF_write_long(0);		// options, none 
	//    EMF_write_rectl(0, 0, 0, 0); // rectangle clipping not used 
	//    EMF_write_long(0);		// offset to intercharacter spacing array, can't be used since really we don't know anything about the face properties used 
	//    for (i = 0; i < len; i++) 
	//	EMF_write_byte(i<strlen(str)?str[i]:0);	// writing text 
	//    for (i = 0; i < strlen(str); i++)
	// /* writing intercharacter spacing array (but we don't use it) */
	//	EMF_write_long(300); 
	// /* SB 20040506: end of modification */
	//
	//    emf_posx = emf_posy = -2000;
	//}
	//
	//TERM_PUBLIC int 
	//EMF_text_angle(int ang)
	//{
	// /* Win GDI rotation is scaled in tenth of degrees, so... */
	//    switch (ang) {
	//    case 0:			// left right 
	//	if (emf_vert_text != 0) {
	//	    emf_vert_text = 0;
	//	    EMF_setfont();
	//	}
	//	break;
	//    case TEXT_VERTICAL:		// bottom up 
	//	if (emf_vert_text != 900) {
	//	    emf_vert_text = 900;
	//	    EMF_setfont();
	//	}
	//	break;
	//    default:			// the general case 
	//    	emf_vert_text = 10 * ang;
	//	EMF_setfont();
	//	break;
	//    }
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int 
	//EMF_justify_text(enum JUSTIFY mode)
	//{
	//    int align = GP_TA_BOTTOM;
	//
	//    emf_justify = mode;
	//
	//    switch (mode) {
	//    case LEFT:
	//	align |= GP_TA_LEFT;
	//	break;
	//    case RIGHT:
	//	align |= GP_TA_RIGHT;
	//	break;
	//    case CENTRE:
	//	align |= GP_TA_CENTER;
	//	break;
	//    }
	//    EMF_SetTextAlign(align);
	//
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void 
	//EMF_reset()
	//{
	//    emf_posx = emf_posy = 0;
	//    emf_graphics = FALSE;
	//}
	//
	//TERM_PUBLIC void 
	//EMF_point(unsigned int x, unsigned int y, int number)
	//{
	//    int old_dashtype;
	//    gpiPoint corners[12];
	//    corners->style = FS_OPAQUE;
	//
	//    EMF_flush_polyline();
	//    old_dashtype = emf_dashtype;
	//    EMF_dashtype(0);
	//
	// /* if (number < 0)*/
	//    {
	// /* draw dot */
	//	EMF_move(x, y);
	//	EMF_solid_vector(x + 1, y);
	// /* goto end_points;*/
	//    }
	//    number = number % EMF_POINTS;
	//
	//    switch (number) {
	//    case 0:			// draw plus 
	//	EMF_move(x - emf_tic, y);
	//	EMF_solid_vector(x + emf_tic, y);
	//	EMF_move(x, y - emf_tic);
	//	EMF_solid_vector(x, y + emf_tic);
	//	break;
	//    case 1:			// draw X 
	//	EMF_move(x - emf_tic707, y - emf_tic707);
	//	EMF_solid_vector(x + emf_tic707, y + emf_tic707);
	//	EMF_move(x - emf_tic707, y + emf_tic707);
	//	EMF_solid_vector(x + emf_tic707, y - emf_tic707);
	//	break;
	//    case 2:			// draw star (asterisk) 
	//	EMF_move(x, y - emf_tic);
	//	EMF_solid_vector(x, y + emf_tic);
	//	EMF_move(x + emf_tic866, y - emf_tic500);
	//	EMF_solid_vector(x - emf_tic866, y + emf_tic500);
	//	EMF_move(x + emf_tic866, y + emf_tic500);
	//	EMF_solid_vector(x - emf_tic866, y - emf_tic500);
	//	break;
	//    case 3:			// draw box 
	//	EMF_move(x - emf_tic707, y - emf_tic707);
	//	EMF_solid_vector(x + emf_tic707, y - emf_tic707);
	//	EMF_solid_vector(x + emf_tic707, y + emf_tic707);
	//	EMF_solid_vector(x - emf_tic707, y + emf_tic707);
	//	EMF_flush_polygon();
	//	break;
	//    case 4:			// draw filled box 
	//	corners[0].x = x - emf_tic707; corners[0].y = y - emf_tic707;
	//	corners[1].x = x + emf_tic707; corners[1].y = y - emf_tic707;
	//	corners[2].x = x + emf_tic707; corners[2].y = y + emf_tic707;
	//	corners[3].x = x - emf_tic707; corners[3].y = y + emf_tic707;
	//	EMF_filled_polygon(4, corners);
	//	break;
	//    case 5:
	// /* draw circle (actually, dodecagon) (WinWord 6 accepts the
	//  * CGM "circle" element, but the resulting circle is not
	//  * correctly centered!) */
	//	EMF_move(x, y - emf_tic);
	//	EMF_solid_vector(x + emf_tic500, y - emf_tic866);
	//	EMF_solid_vector(x + emf_tic866, y - emf_tic500);
	//	EMF_solid_vector(x + emf_tic, y);
	//	EMF_solid_vector(x + emf_tic866, y + emf_tic500);
	//	EMF_solid_vector(x + emf_tic500, y + emf_tic866);
	//	EMF_solid_vector(x, y + emf_tic);
	//	EMF_solid_vector(x - emf_tic500, y + emf_tic866);
	//	EMF_solid_vector(x - emf_tic866, y + emf_tic500);
	//	EMF_solid_vector(x - emf_tic, y);
	//	EMF_solid_vector(x - emf_tic866, y - emf_tic500);
	//	EMF_solid_vector(x - emf_tic500, y - emf_tic866);
	//	EMF_flush_polygon();
	//	break;
	//    case 6: // filled circle 
	//	corners [0].x = x             ; corners [0].y = y - emf_tic;
	//	corners [1].x = x + emf_tic500; corners [1].y = y - emf_tic866;
	//	corners [2].x = x + emf_tic866; corners [2].y = y - emf_tic500;
	//	corners [3].x = x + emf_tic   ; corners [3].y = y;
	//	corners [4].x = x + emf_tic866; corners [4].y = y + emf_tic500;
	//	corners [5].x = x + emf_tic500; corners [5].y = y + emf_tic866;
	//	corners [6].x = x             ; corners [6].y = y + emf_tic;
	//	corners [7].x = x - emf_tic500; corners [7].y = y + emf_tic866;
	//	corners [8].x = x - emf_tic866; corners [8].y = y + emf_tic500;
	//	corners [9].x = x - emf_tic   ; corners [9].y = y;
	//	corners[10].x = x - emf_tic866; corners[10].y = y - emf_tic500;
	//	corners[11].x = x - emf_tic500; corners[11].y = y - emf_tic866;
	//	EMF_filled_polygon(12, corners);
	//	break;
	//    case 7:			// draw triangle (point up) 
	//	EMF_move(x, y + emf_tic1241);
	//	EMF_solid_vector(x - emf_tic1077, y - emf_tic621);
	//	EMF_solid_vector(x + emf_tic1077, y - emf_tic621);
	//	EMF_flush_polygon();
	//	break;
	//    case 8: // filled triangle point up 
	//	corners[0].x = x               ; corners[0].y = y + emf_tic1241;
	//	corners[1].x = x - emf_tic1077 ; corners[1].y = y - emf_tic621;
	//	corners[2].x = x + emf_tic1077 ; corners[2].y = y - emf_tic621;
	//	EMF_filled_polygon(3, corners);
	//	break;
	//    case 9:			// draw triangle (point down) 
	//	EMF_move(x, y - emf_tic1241);
	//	EMF_solid_vector(x - emf_tic1077, y + emf_tic621);
	//	EMF_solid_vector(x + emf_tic1077, y + emf_tic621);
	//	EMF_flush_polygon();
	//	break;
	//    case 10: // filled triangle point down 
	//	corners[0].x = x               ; corners[0].y = y - emf_tic1241;
	//	corners[1].x = x - emf_tic1077 ; corners[1].y = y + emf_tic621;
	//	corners[2].x = x + emf_tic1077 ; corners[2].y = y + emf_tic621;
	//	EMF_filled_polygon(3, corners);
	//	break;
	//    case 11:			// draw diamond 
	//	EMF_move(x - emf_tic, y);
	//	EMF_solid_vector(x, y - emf_tic);
	//	EMF_solid_vector(x + emf_tic, y);
	//	EMF_solid_vector(x, y + emf_tic);
	//	EMF_flush_polygon();
	//	break;
	//    case 12: // filled diamond 
	//	corners[0].x = x - emf_tic ; corners[0].y = y;
	//	corners[1].x = x           ; corners[1].y = y - emf_tic;
	//	corners[2].x = x + emf_tic ; corners[2].y = y;
	//	corners[3].x = x           ; corners[3].y = y + emf_tic;
	//	EMF_filled_polygon(4, corners);
	//	break;
	//    }
	// /* end_points: */
	//    EMF_dashtype(old_dashtype);
	//}
	//
	//
	//TERM_PUBLIC void 
	//EMF_set_pointsize(double size)
	//{
	//    if (size < 0)
	//	size = 1;
	//    emf_tic = (size * term->h_tic);
	//    emf_tic707 = emf_tic * 12 / 17;
	//    emf_tic866 = emf_tic * 13 / 15;
	//    emf_tic500 = emf_tic / 2;
	//    emf_tic1241 = emf_tic * 36 / 29;
	//    emf_tic1077 = emf_tic * 14 / 13;
	//    emf_tic621 = emf_tic * 18 / 29;
	//}
	//
	// /*
	//  * Ethan A Merritt September 2008
	//  *	- Support for enhanced text mode
	//  * PROBLEMS:
	//  *	- Rotated enhanced text is not handled
	//  *	- The proportional spacing hack is really ugly
	//  *	  ETO_PDY is supposed to handle this, but pre-Vista Windows
	//  *	  doesn't support the flag so it's of no real use.
	//  */
	//
	//static TBOOLEAN ENHemf_opened_string;
	//
	// /* used in determining height of processed text */
	//static float ENHemf_base;
	//
	// /* use these so that we don't over-write the current font settings */
	//static float ENHemf_fontsize;
	//static char   *ENHemf_font;
	//
	//static TBOOLEAN ENHemf_show = TRUE;
	//static int ENHemf_overprint = 0;
	//
	//TERM_PUBLIC void
	//ENHemf_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag,
	//    TBOOLEAN showflag,
	//    int overprint)
	//{
	//
	// /* If the overprint code requests a save or restore, that's all we do */
	///#define EMF_AVG_WID 0.8
	///#undef TA_UPDATECP_MODE
	///#ifdef TA_UPDATECP_MODE
	//    if (overprint == 3) {
	//	EMF_SaveDC();
	//	return;
	//    } else if (overprint == 4) {
	//	EMF_RestoreDC();
	//	return;
	//    }
	///#else
	//    static int save_x, save_y;
	//    if (overprint == 3) {
	//	save_x = emf_posx;
	//	save_y = emf_posy;
	//	return;
	//    } else if (overprint == 4) {
	//	emf_posx = save_x;
	//	emf_posy = save_y;
	//	return;
	//    }
	///#endif
	//
	//    if (!ENHemf_opened_string) {
	//	ENHemf_opened_string = TRUE;
	//	enhanced_cur_text = &enhanced_text[0];
	//	ENHemf_font = fontname;
	//	ENHemf_fontsize = fontsize;
	//	ENHemf_base = base;
	//	ENHemf_show = showflag;
	//	ENHemf_overprint = overprint;
	//    }
	//}
	//
	// /* Write a string fragment and update the current position */
	//TERM_PUBLIC void
	//ENHemf_FLUSH()
	//{
	//    unsigned int x, y;
	//    char *str;
	//    int i;
	//    int incr_x;
	//    double strl;
	//
	//	if (ENHemf_opened_string) {
	//	    *enhanced_cur_text = '\0';
	//	    ENHemf_opened_string = FALSE;
	//	    x = emf_posx;
	//	    y = emf_posy;
	//
	//	    FPRINTF((stderr,"ENHemf_FLUSH: Write string \"%s\" len %d at %g with font %s,%g\n",
	//		    enhanced_text,strlen(enhanced_text),
	//		    (double)x/EMF_PX2HM,ENHemf_font,ENHemf_fontsize));
	//
	//	    if (1) {
	//		char save_font[256];
	//		float save_fontsize = emf_fontsize;
	//		strcpy(save_font,emf_fontname);
	//		emf_fontsize = ENHemf_fontsize;
	//
	//		EMF_set_font(ENHemf_font);
	//		
	//		emf_fontsize = save_fontsize;
	//		strcpy(emf_fontname,save_font);
	//	    }
	//
	// /* Don't know how to do a pure move; instead write in white */
	//	    if (!ENHemf_show) {
	//		EMF_SetTextColor(0xffffff);
	//		emf_textcolor = 0xffffff;
	//	    } else if (ENHemf_show && emf_textcolor != emf_color) {
	//		EMF_SetTextColor(emf_color);
	//		emf_textcolor = emf_color;
	//	    }
	//
	//	    str = enhanced_text;
	//
	///#ifndef GP_TA_UPDATEPC_MODE
	// /* We are especially bad at guessing the width of whitespace. */
	// /* Best is to pile up all our errors on top of leading space. */
	//	    i = strspn(enhanced_text," ");
	//	    if (i > 0) {
	//		x += i * term->h_char 
	//		   * EMF_AVG_WID * ENHemf_fontsize/emf_defaultfontsize;
	//		emf_posx = x;
	//		str += i;
	//	    }
	///#endif
	//
	// /* Copied from put_text(). Is all this really necessary? */
	//	    {
	//	    int record_length;
	//	    int len = strlen(str);
	//	    if (len % 4)
	//		len += 4 - (len % 4);		// Structure must be long aligned! 
	//	    record_length = 76 + len + strlen(str)*4;
	//
	//	    EMF_write_emr(83, record_length);// ExtTextOutA, ANSI char version! 
	//	    EMF_write_rectl(0, 0, 0, 0);	// bounding, never used 
	//	    EMF_write_long(1);			// GM_Compatible mode for advanced scaling 
	//	    EMF_write_float(EMF_PX2HM);		// x scale 
	//	    EMF_write_float(EMF_PX2HM);		// y scale 
	//	    if (emf_vert_text == 0) {		// x,y position (ignored if GP_TA_UPDATECP) 
	//		float yo = 1.3 * EMF_PX2HM * ENHemf_base;
	//		EMF_write_pointl(
	//			x, term->ymax - (y + yo));
	//	    } else {
	//		float a = emf_vert_text * EMF_10THDEG2RAD;
	//		float yo = 1.3 * EMF_PX2HM * ENHemf_base;
	//		EMF_write_pointl(
	//			x - (long) (yo * sin(a)),
	//			term->ymax - (long) (y + (yo * cos(a))) );
	//	    }
	//	    EMF_write_long(strlen(str)); 	// true number of characters 
	//	    EMF_write_long(76);			// offset to text 
	//	    EMF_write_long(0);			// ExtTextOut options 
	//	    EMF_write_rectl(0, 0, 0, 0);	// bounding, never used 
	//	    EMF_write_long(0);			// offset to intercharacter spacing array 
	//	    for (i = 0; i < len; i++) 
	//		EMF_write_byte(i<strlen(str)?str[i]:0);	// character string 
	//	    for (i = 0; i < strlen(str); i++)
	//		EMF_write_long(300); 		// intercharacter spacing array (not used) 
	//	    }
	//
	// /* Empirical hack */
	//	    strl = strlen(str);
	//	    if (emf_vert_text != 0)
	//		strl += 1.0;
	//
	//	    if (emf_tweak) {
	// /* Tweak estimated length of rendered string by counting "thin" characters */
	// /* In principle EMF will accept an array of char widths. But in practice   */
	// /* none of the EMF viewers implement this option (ETO_PDY).                */
	//		{
	//		int thin = 0, wide = 0;
	//		for (i=0; i<strlen(str); i++) {
	//		    if (strchr(" ijl.,;:|!()[]I-'",str[i]))
	//			thin++;
	//		    if (('A' <= str[i] && str[i] <= 'Z') || strchr("mw<>",str[i]))
	//			wide++;
	//		    if (strchr(" i.,;:|!'",str[i]))  // really thin 
	//			thin++;
	//		}
	//		incr_x = (strl * EMF_AVG_WID 
	//			+ (double)(wide) * 0.3
	//			+ (double)(-thin) * 0.2)
	//			* term->h_char;
	//		}
	//	    } else {
	//		incr_x = strl * EMF_AVG_WID * term->h_char;
	//	    }
	//
	// /* Attempt to handle slanted text. Not entirely successful */
	//	    emf_posx += incr_x * cos(emf_vert_text * EMF_10THDEG2RAD);
	//	    emf_posy += incr_x * sin(emf_vert_text * EMF_10THDEG2RAD);
	//
	//	    if (ENHemf_overprint == 1)
	//		emf_posx -= strlen(str) * term->h_char 
	//	    		  * (0.5) * EMF_AVG_WID * ENHemf_fontsize/emf_defaultfontsize;
	//
	//	}
	//}
	//
	//TERM_PUBLIC void
	//ENHemf_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    int tmp_justify = emf_justify;
	//    int len;
	//
	//    if (ignore_enhanced_text) {
	//	EMF_put_text(x,y,str);
	//	return;
	//    }
	//
	//    if (!strlen(str))
	//	return;
	//    len = estimate_strlen((char *)str);
	//
	// /* if there are no magic characters, we should just be able
	//  * punt the string to EMF_put_text()
	//  */
	//    if (!strpbrk(str, "{}^_@&~")) {
	// /* FIXME: do something to ensure default font is selected */
	//	EMF_put_text(x,y,str);
	//	return;
	//    }
	//
	//    if (emf_textcolor != emf_color) {
	//	EMF_SetTextColor(emf_color);
	//	emf_textcolor = emf_color;
	//    }
	//
	// /* set up the global variables needed by enhanced_recursion() */
	//    enhanced_fontscale = 1.0;
	//    strncpy(enhanced_escape_format,"&#x%2.2x;",sizeof(enhanced_escape_format));
	//
	//    ENHemf_opened_string = FALSE;
	//    ENHemf_show = TRUE;
	//    ENHemf_overprint = 0;
	//    ENHemf_font = emf_fontname;
	//    ENHemf_fontsize = emf_fontsize;
	//
	// /* EAM -FIXME
	//  * To do proper justification requires some way to track the current position
	//  * after writing a text fragment.  I don't know how to do that in emf.
	//  * So I punt by just estimating the total length.
	//  */
	//    if (emf_justify == RIGHT) {
	//		x -= term->h_char * len * cos(emf_vert_text * EMF_10THDEG2RAD);
	//		y -= term->h_char * len * sin(emf_vert_text * EMF_10THDEG2RAD);
	//    } else if (emf_justify == CENTRE) {
	//		x -= term->h_char * len/2. * cos(emf_vert_text * EMF_10THDEG2RAD);
	//		y -= term->h_char * len/2. * sin(emf_vert_text * EMF_10THDEG2RAD);
	//    }
	//    x += term->v_char/3. * sin(emf_vert_text * EMF_10THDEG2RAD);
	//    y -= term->v_char/3. * cos(emf_vert_text * EMF_10THDEG2RAD);
	//    EMF_move(x,y);
	//
	//    emf_justify = LEFT;
	///#ifdef UPDATECP_MODE
	//    EMF_SetTextAlign(GP_TA_BASELINE|GP_TA_LEFT|GP_TA_UPDATECP);
	///#else
	//    EMF_SetTextAlign(GP_TA_BASELINE|GP_TA_LEFT|GP_TA_NOUPDATECP);
	///#endif
	//
	// /* Set the recursion going. We say to keep going until a
	//  * closing brace, but we don't really expect to find one.
	//  * If the return value is not the nul-terminator of the
	//  * string, that can only mean that we did find an unmatched
	//  * closing brace in the string. We increment past it (else
	//  * we get stuck in an infinite loop) and try again.
	//  */
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//			ENHemf_font, ENHemf_fontsize,
	//			0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//
	// /* I think we can only get here if *str == '}' */
	//	    enh_err_check(str);
	//
	//	if (!*++str)
	//	    break; // end of string 
	//
	// /* else carry on and process the rest of the string */
	//    }
	//
	// /* Restore everything we messed with */
	//    emf_justify = tmp_justify;
	//    EMF_setfont(); // Necessary? 
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(emf_driver)
	//    "emf", "Enhanced Metafile format",
	//    EMF_XMAX, EMF_YMAX, EMF_VCHAR, EMF_HCHAR,
	//    EMF_VTIC, EMF_HTIC, EMF_options, EMF_init, EMF_reset,
	//    EMF_text, null_scale, EMF_graphics, EMF_move, EMF_solid_vector,
	//    EMF_linetype, EMF_put_text, EMF_text_angle,
	//    EMF_justify_text, EMF_point, do_arrow, EMF_set_font,
	//    EMF_set_pointsize,
	//    TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,		// various flags 
	//    NULL,				// suspend 
	//    NULL,				// resume  
	//    EMF_fillbox,
	//    EMF_linewidth
	///#ifdef USE_MOUSE
	//   , 0, 0, 0, 0, 0 // no mouse support for emf 
	///#endif
	//   , EMF_make_palette,
	//   EMF_previous_palette,
	//   EMF_set_color,
	//   EMF_filled_polygon
	//    , NULL // image 
	//    , ENHemf_OPEN, ENHemf_FLUSH, do_enh_writec
	//TERM_TABLE_END(emf_driver)
	///#undef LAST_TERM
	///#define LAST_TERM emf_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(emf)
	//"1 emf",
	//"?commands set terminal emf",
	//"?set terminal emf",
	//"?set term emf",
	//"?terminal emf",
	//"?term emf",
	//"?emf",
	//" The `emf` terminal generates an Enhanced Metafile Format file.",
	//" This file format is recognized by many Windows applications.",
	//"",
	//" Syntax:",
	//"       set terminal emf {color | monochrome} {solid | dashed}",
	//"                        {enhanced {noproportional}}",
	//"                        {linewidth <LW>} {dashlength <DL>} {size XX,YY}",
	//"                        {\"<fontname>\"} {<fontsize>}    #old syntax",
	//"                        {font \"<fontname>,<fontsize>\"} #new syntax",
	//"",
	//" In `monochrome` mode successive line types cycle through dash patterns.",
	//" In `color` mode successive line types use successive colors, and only after",
	//" all 8 default colors are exhausted is the dash pattern incremented.",
	//" `solid` draws all curves with solid lines, overriding any dashed patterns;",
	//" `linewidth <factor>` multiplies all line widths by this factor.",
	//" `dashlength <factor>` is useful for thick lines.",
	//" <fontname> is the name of a font; and ",
	//" `<fontsize>` is the size of the font in points.",
	//"",
	//" The nominal size of the output image defaults to 1024x768 in arbitrary",
	//" units. You may specify a different nominal size using the `size` option.",
	//"",
	//" Enhanced text mode tries to approximate proportional character spacing.",
	//" If you are using a monospaced font, or don't like the approximation, you",
	//" can turn off this correction using the `noproportional` option.",
	//"",
	//" The default settings are `color dashed font \"Arial,12\" size 1024,768`",
	//" Selecting `default` sets all options to their default values.",
	//"",
	//" Examples:",
	//"       set terminal emf 'Times Roman Italic' 12",
	//"       set terminal emf color solid    # no pesky dashes!"
	//END_HELP(emf)
	///#endif // TERM_HELP 


	/* Roland DXY800A plotter */
	/* #include "dxy.trm" */
	/* QMS/EXCL laserprinter (Talaris 1590 and others) */
	/* #include "excl.trm" */

	/* fig graphics */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: fig.trm,v 1.67 2009/03/26 00:49:20 sfeam Exp $
	 */

	/* GNUPLOT - fig.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  Fig graphics language
	 *
	 * AUTHORS
	 *  Micah Beck, David Kotz
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * Original for Fig code output by Micah Beck, 1989
	 * Department of Computer Science, Cornell University
	 * Updated by David Kotz for gnuplot 2.0
	 * More efficient output by Ian Dall
	 * Updated to FIG 2.1 (with color) format by Vivek Khera
	 * Updated to FIG 3.1 (higher resolution) format by Ian MacPhedran, Jan 1995
	 * Updated to conform to newterm format Ian MacPhedran, Apr 1995
	 * Point-count option joachim.selinger@ins.uni-stuttgart.de (JFS) Feb  9 1996
	 * More options (portrait/landscape, metric/inches, size, fontsize, thickness)
	 * plus symbols and depth/thickness by bernlohr@eu1.mpi-hd.mpg.de (KB) Aug 15 1996
	 * Added PM3D functionality Ian MacPhedran, April 15 1999
	 * Take into account 'set palette maxcolors' Petr Mikulik, June 11 2002
	 * Don't reset options when 'set term fig <new options>', Petr Mikulik, Aug 24 2002
	 * Ethan A Merritt - May 2008:
	 *   Bring into line with other terminals for point types, size syntax, font spec
	 */


	///#ifdef TERM_REGISTER
	//register_term(fig)
	///#endif // TERM_REGISTER 

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void FIG_options __PROTO((void));
	//TERM_PUBLIC void FIG_init __PROTO((void));
	//TERM_PUBLIC void FIG_graphics __PROTO((void));
	//TERM_PUBLIC void FIG_text __PROTO((void));
	//TERM_PUBLIC void FIG_linetype __PROTO((int linetype));
	//TERM_PUBLIC void FIG_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void FIG_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void FIG_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
	//TERM_PUBLIC void FIG_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int FIG_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int FIG_text_angle __PROTO((int ang));
	//TERM_PUBLIC void FIG_pointsize __PROTO((double arg_pointsize));
	//TERM_PUBLIC void FIG_linewidth __PROTO((double linewidth));
	//TERM_PUBLIC void FIG_reset __PROTO((void));
	//TERM_PUBLIC void FIG_lpoint __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void FIG_boxfill __PROTO((int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h));
	//TERM_PUBLIC int FIG_make_palette (t_sm_palette *);
	// /* TERM_PUBLIC void FIG_previous_palette (void); */
	//TERM_PUBLIC void FIG_set_color (t_colorspec *);
	//TERM_PUBLIC void FIG_filled_polygon (int, gpiPoint *);
	//TERM_PUBLIC void FIG_layer __PROTO((t_termlayer syncpoint));
	//
	///#define GOT_FIG_PROTO
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#include "object.h"		// modified from the XFig distribution 
	///#define FIG_DEFAULT DEFAULT
	///#define FIG_ROMAN_FONT (0)	// actually, the default font 
	//
	///#if METRIC
	///#define INCH FALSE
	///#else
	///#define INCH TRUE
	///#endif
	//
	// /* These should not be defined elsewhere - ACZ */
	// /* This is now 1200 per inch */
	///#define FIG_IRES        (1200)
	// /* This is now 450 per cm */
	///#define FIG_MRES        (450)
	//
	///#define FIG_COORD_SYS   2
	///#define FIG_ORIENT (FIG_portrait?"Portrait":"Landscape")
	// /* Could be "Portrait" */
	///#define FIG_JUST        "Center"
	// /* Could be "Flush Left" */
	///#define FIG_UNIT (FIG_inches?"Inches":"Metric")
	// /* Could be "Inches" */
	///#define FIG_PAPER       (FIG_inches ? "Letter" : "A4")
	///#define FIG_MAGNIFICATION  100.0
	///#define FIG_MULTIPAGE   "Single"
	// /* Could be "Multiple" */
	///#define FIG_TRANSCOLOR  -2
	// /* none: -2; background: -1; 0..31: foreground colors */
	// /* This could probably be dropped with the support of GIFs. */
	///#define FIG_TRUERES (FIG_inches ? FIG_IRES : FIG_MRES) // ACZ 
	///#define FIG_DEFAULTVERSION "3.2"
	//
	///#define FIG_HTIC(inch)  ((inch) ? (5*FIG_IRES)/80 : (15*FIG_MRES)/100)
	///#define FIG_VTIC(inch)  ((inch) ? (5*FIG_IRES)/80 : (15*FIG_MRES)/100)
	///#define FIG_FONT_S      (10)	// size in points 
	///#define FIG_MAX_POINTS  99999L	// almost infinite ;-) 
	//
	// /* height of font in pixels: */
	///#define FIG_to_pixel_v(inch,s) (((inch) ? (s)*FIG_IRES : (s)*FIG_MRES*2.54) / 72 * 3/4)
	// /* This is fudged to enlarge the drawing area, but gives fairly good results */
	// /* this is a guess at the width: */
	///#define FIG_to_pixel_h(inch,s) (FIG_to_pixel_v(inch,s)*6/10)
	//
	///#define FIG_VCHAR       FIG_to_pixel_v(INCH,FIG_FONT_S)	// just for default, 
	///#define FIG_HCHAR       FIG_to_pixel_h(INCH,FIG_FONT_S)	// not really used   
	//
	// /* Text flags (ULIG) */
	//enum FIG_TEXT_STYLEBITS {
	//    FIG_TEXT_RIGID      = 1<<0,
	//    FIG_TEXT_SPECIAL    = 1<<1,
	//    FIG_TEXT_POSTSCRIPT = 1<<2,
	//    FIG_TEXT_HIDDEN     = 1<<3
	//};
	///#define FIG_TEXT_NORMAL      FIG_TEXT_POSTSCRIPT
	//
	//enum FIG_poly_stat {
	//    FIG_poly_new, FIG_poly_part
	//};
	//
	//static int FIG_posx;
	//static int FIG_posy;
	//static long FIG_poly_vec_cnt;
	//static int FIG_depth = 10;
	//static int FIG_linedepth = 10;
	//static int FIG_thickness = 1;
	//static int FIG_default_thickness = 1;
	//static double FIG_current_pointsize = 1.;
	//static double FIG_current_linewidth = 1.;
	//
	// /* Maximum number of points per POLYLINE.
	//    Default 1000 (hardcoded in help section as well) */
	//static int FIG_poly_vec_max = 999;	// JFS 
	//
	//static enum FIG_poly_stat FIG_polyvec_stat;
	//
	// /* 5 inches wide by 3 inches high */
	///#define FIG_XMAX(inch) ((inch) ? 5*FIG_IRES : 12*FIG_MRES)
	///#define FIG_YMAX(inch) ((inch) ? 3*FIG_IRES :  8*FIG_MRES)
	//
	///#define FIG_XOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
	///#define FIG_YOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
	//
	//
	///#define BFIG_HTIC(inch) ((inch) ? (7*FIG_IRES)/80 : (20*FIG_MRES)/100)
	///#define BFIG_VTIC(inch) ((inch) ? (7*FIG_IRES)/80 : (20*FIG_MRES)/100)
	///#define BFIG_FONT_S     (16)	// size in points 
	///#define BFIG_VCHAR      FIG_to_pixel_v(INCH,BFIG_FONT_S)  // height in pixels of font 
	///#define BFIG_HCHAR      FIG_to_pixel_h(INCH,BFIG_FONT_S)  // this is a guess at the width 
	//
	//static F_point *FIG_points = NULL; /* Array for the collection of points for
	// 					   POLYLINE, allocated on demand. */
	//static F_line FIG_line;
	//
	// /* 8 inches wide by 5 inches high */
	///#define BFIG_XMAX(inch) ((inch) ? 8*FIG_IRES : 20*FIG_MRES)
	///#define BFIG_YMAX(inch) ((inch) ? 5*FIG_IRES : 15*FIG_MRES)
	//
	///#define BFIG_XOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
	///#define BFIG_YOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
	//
	//
	//static int FIG_type;		// negative types use real lines 
	//static float FIG_spacing;	// length of dash or dot spacing 
	//static int FIG_justify;		// Fig justification T_*_JUSTIFIED 
	//static float FIG_angle;		// Fig text angle (in radians) 
	//static int FIG_use_color = FALSE;	// do we use color or not? 
	//static int FIG_is_big = FALSE;	// big plot ? 
	//static int FIG_color = DEFAULT;	// which color to use 
	//static int FIG_xoff = FIG_XOFF(INCH);
	//static int FIG_yoff = FIG_YOFF(INCH);
	//static int FIG_font_id = FIG_ROMAN_FONT;
	//static int FIG_font_s = FIG_FONT_S;
	//static int FIG_portrait = FALSE;
	//static int FIG_inches = INCH;
	//static int FIG_text_flags = FIG_TEXT_NORMAL;    // whether text is special or hidden etc. 
	//static char FIG_version[MAX_ID_LEN+1] = FIG_DEFAULTVERSION;  // file format version 
	//static int FIG_solid = FALSE;                   // dashed lines or not 
	//static int FIG_palette_set = FALSE;	// PM3D Palette Set ? 
	//static int FIG_palette_size = 128;	// Number of colours in palette 
	//static int FIG_palette_offst = 32;	// Offset from zero for user colours 
	//static int FIG_fill_style = 20;		// Full saturation 
	//
	//static void FIG_poly_clean __PROTO((enum FIG_poly_stat fig_stat));
	//
	//enum FIG_id {
	//    FIG_MONOCHROME, FIG_COLOR,
	//    FIG_SMALL, FIG_BIG,
	//    FIG_INCHES, FIG_METRIC,
	//    FIG_PORTRAIT, FIG_LANDSCAPE,
	//    FIG_SIZE, FIG_FONT, FIG_FONTSIZE,
	//    FIG_THICKNESS, FIG_DEPTH, FIG_POINTSMAX,
	//    FIG_SOLID, FIG_DASHED,
	//    FIG_NORMALTEXT, FIG_SPECIALTEXT, FIG_HIDDENTEXT, FIG_RIGIDTEXT,
	//    FIG_VERSION, FIG_OTHER
	//};
	//
	//static struct gen_table FIG_opts[] =
	//{
	//    { "b$ig", FIG_BIG },
	//    { "c$olor", FIG_COLOR },
	//    { "c$olour", FIG_COLOR },
	//    { "da$shed", FIG_DASHED },
	//    { "de$pth", FIG_DEPTH },
	//    { "font", FIG_FONT },
	//    { "f$ontsize", FIG_FONTSIZE },
	//    { "in$ches", FIG_INCHES },
	//    { "l$andscape", FIG_LANDSCAPE },
	//    { "me$tric", FIG_METRIC },
	//    { "mo$nochrome", FIG_MONOCHROME },
	//    { "poi$ntsmax", FIG_POINTSMAX },
	//    { "por$trait", FIG_PORTRAIT },
	//    { "si$ze", FIG_SIZE },
	//    { "sm$all", FIG_SMALL },
	//    { "so$lid", FIG_SOLID },
	//    { "linew$idth", FIG_THICKNESS },
	//    { "t$hickness", FIG_THICKNESS },
	//    { "texth$idden", FIG_HIDDENTEXT },
	//    { "textn$ormal", FIG_NORMALTEXT },
	//    { "textr$igid", FIG_RIGIDTEXT },
	//    { "texts$pecial", FIG_SPECIALTEXT },
	//    { "v$ersion", FIG_VERSION },
	//    { NULL, FIG_OTHER }
	//};
	//
	//const struct gen_table FIG_fonts[] =
	//{
	//    { "Times Roman",  0 },
	//    { "Times Italic",  1 },
	//    { "Times Bold",  2 },
	//    { "Times Bold Italic",  3 },
	//    { "AvantGarde Book",  4 },
	//    { "AvantGarde Book Oblique",  5 },
	//    { "AvantGarde Demi",  6 },
	//    { "AvantGarde Demi Oblique",  7 },
	//    { "Bookman Light",  8 },
	//    { "Bookman Light Italic",  9 },
	//    { "Bookman Demi", 10 },
	//    { "Bookman Demi Italic", 11 },
	//    { "Courier", 12 },
	//    { "Courier Oblique", 13 },
	//    { "Courier Bold", 14 },
	//    { "Courier Bold Oblique", 15 },
	//    { "Helvetica", 16 },
	//    { "Helvetica Oblique", 17 },
	//    { "Helvetica Bold", 18 },
	//    { "Helvetica Bold Oblique", 19 },
	//    { "Helvetica Narrow", 20 },
	//    { "Helvetica Narrow Oblique", 21 },
	//    { "Helvetica Narrow Bold", 22 },
	//    { "Helvetica Narrow Bold Oblique", 23 },
	//    { "New Century Schoolbook Roman", 24 },
	//    { "New Century Schoolbook Italic", 25 },
	//    { "New Century Schoolbook Bold", 26 },
	//    { "New Century Schoolbook Bold Italic", 27 },
	//    { "Palatino Roman", 28 },
	//    { "Palatino Italic", 29 },
	//    { "Palatino Bold", 30 },
	//    { "Palatino Bold Italic", 31 },
	//    { "Symbol", 32 },
	//    { "Zapf Chancery Medium Italic", 33 },
	//    { "Zapf Dingbats", 34 },
	//    { NULL, -1}
	//};
	//
	//TERM_PUBLIC void
	//FIG_options()
	//{
	//    int parse_error = FALSE;
	//    long temp_max;
	//    unsigned int tmax_t;
	//    double xsize_t = 0, ysize_t = 0;
	//    char text_flags[256]; // for description only 
	//
	///#if 0
	// /* Terminals should not reset options to defaults. */
	//    FIG_use_color = FALSE;	// default 
	//    FIG_is_big = FALSE;		// default 
	//    FIG_portrait = FALSE;
	//    FIG_font_id = FIG_ROMAN_FONT;
	//    FIG_font_s = 0;
	//    FIG_default_thickness = 1;
	//    xsize_t = ysize_t = 0.;
	//    FIG_inches = INCH;
	//    FIG_text_flags = FIG_TEXT_NORMAL;
	//    FIG_solid = FALSE;
	//    strcpy( FIG_version, FIG_DEFAULTVERSION );
	///#endif
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&FIG_opts[0],c_token)) {
	//	case FIG_MONOCHROME:
	//	    FIG_use_color = FALSE;
	//	    c_token++;
	//	    break;
	//	case FIG_COLOR:
	//	    FIG_use_color = TRUE;
	//	    c_token++;
	//	    break;
	//	case FIG_SMALL:
	//	    FIG_is_big = FALSE;
	//	    c_token++;
	//	    break;
	//	case FIG_BIG:
	//	    FIG_is_big = TRUE;
	//	    c_token++;
	//	    break;
	//	case FIG_INCHES:
	//	    FIG_inches = TRUE;
	//	    c_token++;
	//	    break;
	//	case FIG_METRIC:
	//	    FIG_inches = FALSE;
	//	    c_token++;
	//	    break;
	//	case FIG_SOLID:
	//	    FIG_solid = TRUE;
	//	    c_token++;
	//	    break;
	//	case FIG_DASHED:
	//	    FIG_solid = FALSE;
	//	    c_token++;
	//	    break;
	//	case FIG_NORMALTEXT:
	//	    FIG_text_flags = FIG_TEXT_NORMAL;
	//	    c_token++;
	//	    break;
	//	case FIG_SPECIALTEXT:
	//	    FIG_text_flags |= FIG_TEXT_SPECIAL;
	//            FIG_text_flags &= ~FIG_TEXT_POSTSCRIPT;
	//	    FIG_font_id = 0;
	//	    c_token++;
	//	    break;
	//	case FIG_HIDDENTEXT:
	//	    FIG_text_flags |= FIG_TEXT_HIDDEN;
	//	    c_token++;
	//	    break;
	//	case FIG_RIGIDTEXT:
	//	    FIG_text_flags |= FIG_TEXT_RIGID;
	//	    c_token++;
	//	    break;
	//	case FIG_PORTRAIT:
	//	    FIG_portrait = TRUE;
	//	    c_token++;
	//	    break;
	//	case FIG_LANDSCAPE:
	//	    FIG_portrait = FALSE;
	//	    c_token++;
	//	    break;
	//	case FIG_SIZE:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "size: 2 numbers expected");
	//	    } else {
	//		xsize_t = real_expression();
	//		if (equals(c_token,","))
	//		    c_token++;
	//		if (END_OF_COMMAND) {
	//		    int_error(c_token, "size: 2 numbers expected");
	//		    xsize_t = 0.;
	//		} else {
	//		    ysize_t = real_expression();
	//		}
	//		if (xsize_t < 2. || ysize_t < 2. || xsize_t > 99. || ysize_t > 99.) {
	//		    if (xsize_t != 0. || ysize_t != 0.)
	//			int_error(c_token, "size: out of range");
	//		    xsize_t = ysize_t = 0.;
	//		}
	//	    }
	//	    break;
	//	case FIG_FONT:
	//	    {
	//	    char *fontname;
	//	    int sep;
	//	    c_token++;
	//	    if (END_OF_COMMAND || !((fontname = try_to_get_string())))
	//		int_error(c_token, "expecting font name");
	//	    sep = strcspn(fontname,",");
	//	    sscanf (&(fontname[sep+1]),"%d",&FIG_font_s);
	//	    fontname[sep] = '\0';
	//	    FIG_font_id = lookup_table_entry(FIG_fonts, fontname);
	//	    if (FIG_font_id < 0)
	//		FIG_font_id = FIG_ROMAN_FONT;
	//	    free(fontname);
	//	    break;
	//	    }
	//	case FIG_FONTSIZE:
	//	    c_token++;
	//	    FIG_font_s = int_expression();
	//	    break;
	//	case FIG_THICKNESS:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "thickness: number expected");
	//	    } else {
	//		FIG_default_thickness = int_expression();
	//		if (FIG_default_thickness < 1 || FIG_default_thickness > 10) {
	//		    int_error(c_token - 1, "thickness out of range");
	//		    FIG_default_thickness = 1;
	//		}
	//	    }
	//	    break;
	//	case FIG_DEPTH:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "depth: number expected");
	//	    } else {
	//		FIG_depth = int_expression();
	//		if (FIG_depth < 0 || FIG_depth > 99) {
	//		    int_error(c_token - 1, "depth out of range");
	//		    FIG_depth = 10;
	//		}
	//		FIG_linedepth = FIG_depth;
	//	    }
	//	    break;
	//	case FIG_POINTSMAX:
	// /* Skip the word and then expect the number ! */
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token,
	//			  "max. points per polyline: number expected");
	//	    } else {
	//		temp_max = (long) real_expression();
	// /* Now check the range for the number */
	//		if ((temp_max > 1) && (temp_max < (FIG_MAX_POINTS + 2))) {
	// /* OK. subtract one to the right number! See other numbers... */
	//		    FIG_poly_vec_max = temp_max - 1;
	//		} else {
	//		    int_error(c_token,
	//			      "pointsmax: number out of range (2,%ld)",
	//			      (FIG_MAX_POINTS + 1));
	//		}
	//	    }
	//	    break;
	//	case FIG_VERSION:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "version: 3.1 or 3.2 expected");
	//	    } else {
	//                copy_str( FIG_version, c_token, MAX_ID_LEN );
	//                c_token++;
	//                if( strcmp( FIG_version, "3.1" ) != 0 &&
	//                    strcmp( FIG_version, "3.2" ) != 0 ) {
	//                    int_error(c_token, "wrong version number, must be 3.1 or 3.2");
	//                }
	//	    }
	//	    break;
	//	case FIG_OTHER:
	//	default:
	//	    parse_error = TRUE;
	//	    int_error(c_token, "unrecognized option");
	//	    break;
	//	}
	//    }
	//
	//    if( FIG_text_flags == FIG_TEXT_NORMAL ) {
	//        strcpy( text_flags, " textnormal" );
	//    } else {
	//        sprintf( text_flags, "%s%s%s",
	//                 (FIG_text_flags & FIG_TEXT_SPECIAL) ? " textspecial" : "",
	//                 (FIG_text_flags & FIG_TEXT_HIDDEN) ? " texthidden" : "",
	//                 (FIG_text_flags & FIG_TEXT_RIGID) ? " textrigid" : ""
	//               );
	//    }
	//
	//    sprintf(term_options, "%s %s %s %d %s %s %s%s %s \"%s\" %s %d %s %d %s %d %s %s",
	//	    FIG_use_color ? "color" : "monochrome",
	//	    FIG_is_big ? "big" : "small",
	//	    "pointsmax",
	//	    FIG_poly_vec_max + 1,
	//	    FIG_portrait ? "portrait" : "landscape",
	//	    FIG_inches ? "inches" : "metric",
	//            FIG_solid ? "solid" : "dashed",
	//	    text_flags,
	//	    "font", FIG_fonts[FIG_font_id].key,
	//	    "fontsize", (FIG_font_s > 0 ? FIG_font_s :
	//			 (FIG_is_big ? BFIG_FONT_S : FIG_FONT_S)),
	//	    "linewidth", FIG_default_thickness, "depth", FIG_depth,
	//            "version", FIG_version );	// JFS, KB, ULIG 
	//    if (xsize_t > 0. && ysize_t > 0.) {
	//	if (xsize_t - (int) xsize_t == 0. && ysize_t - (int) ysize_t == 0.)
	//	    sprintf(term_options + strlen(term_options),
	//		    " size %d %d", (int) xsize_t, (int) ysize_t);
	//	else
	//	    sprintf(term_options + strlen(term_options),
	//		    " size %f %f", xsize_t, ysize_t);
	//    }
	//    if (!FIG_is_big) {
	//	if (FIG_font_s <= 0)	// KB 
	//	    FIG_font_s = FIG_FONT_S;
	//	term->xmax = FIG_XMAX(FIG_inches);
	//	term->ymax = FIG_YMAX(FIG_inches);
	//	term->v_tic = FIG_VTIC(FIG_inches);
	//	term->h_tic = FIG_HTIC(FIG_inches);
	//	FIG_xoff = FIG_XOFF(FIG_inches);
	//	FIG_yoff = FIG_YOFF(FIG_inches);
	//    } else {
	//	if (FIG_font_s <= 0)	// KB 
	//	    FIG_font_s = BFIG_FONT_S;
	//	term->xmax = BFIG_XMAX(FIG_inches);
	//	term->ymax = BFIG_YMAX(FIG_inches);
	//	term->v_tic = BFIG_VTIC(FIG_inches);
	//	term->h_tic = BFIG_HTIC(FIG_inches);
	//	FIG_xoff = BFIG_XOFF(FIG_inches);
	//	FIG_yoff = BFIG_YOFF(FIG_inches);
	//    }
	//    if (FIG_portrait) {		// KB 
	//	tmax_t = term->xmax;
	//	term->xmax = term->ymax;
	//	term->ymax = tmax_t;
	//    }
	//    if (xsize_t > 0. && ysize_t > 0.) {
	//	term->xmax = (unsigned int) (xsize_t * FIG_TRUERES);
	//	term->ymax = (unsigned int) (ysize_t * FIG_TRUERES);
	//    }
	//    term->v_char = FIG_to_pixel_v(FIG_inches, FIG_font_s);
	//    term->h_char = FIG_to_pixel_h(FIG_inches, FIG_font_s);
	//    FIG_thickness = FIG_default_thickness;
	//    if (parse_error) {		// JFS, KB 
	//	int_error(c_token, "unrecognized option");
	//    }
	//}
	//
	//
	//static void
	//FIG_poly_clean(enum FIG_poly_stat fig_stat)
	//{
	//    int i, j;
	//    int cap_style;
	//
	//    if (fig_stat == FIG_poly_part) {
	//	cap_style = (FIG_line.style==DOTTED_LINE)
	//	    ? CAP_ROUND : FIG_line.cap_style;
	//	fprintf(gpoutfile,
	//		"%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %ld\n\t",
	//		O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
	//		FIG_line.pen_color, FIG_line.fill_color, FIG_line.depth,
	//		FIG_line.pen_style, FIG_line.fill_style, FIG_line.style_val,
	//		FIG_line.join_style, cap_style, FIG_line.radius,
	//		0, 0, FIG_poly_vec_cnt);
	//
	//	j = 0;
	//	for (i = 0; i < FIG_poly_vec_cnt; i++) {
	//	    fprintf(gpoutfile, " %d %d", FIG_points[i].x, FIG_points[i].y);
	//	    if (j++ > 4 && i != FIG_poly_vec_cnt - 1) {
	//		fputs("\n\t", gpoutfile);
	//		j = 0;		// JFS 
	//	    }
	//	}
	//	if (j != 0) {
	//	    putc('\n', gpoutfile);
	//	}
	// /* Give the memory back to the system because we are done with this
	//  * polyline. Make sure FIG_points contains NULL afterwards!
	//  */
	//	free(FIG_points);
	//	FIG_points = NULL;
	//    }
	//    FIG_polyvec_stat = FIG_poly_new;
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_init()
	//{
	//    FIG_posx = FIG_posy = 0;
	//    FIG_polyvec_stat = FIG_poly_new;
	//    FIG_linetype(-1);
	//    FIG_justify_text(LEFT);
	//    FIG_text_angle(0);
	//
	//    FIG_palette_set = FALSE;    // PM3D Palette Set ? 
	//    FIG_line.tagged = FIG_DEFAULT;
	//    FIG_line.distrib = FIG_DEFAULT;
	//    FIG_line.type = T_POLYLINE;
	//    FIG_line.style = 0;
	//    FIG_line.thickness = FIG_thickness;
	//    FIG_line.fill_style = -1;
	//    FIG_line.depth = FIG_linedepth;
	//    FIG_line.pen_style = 0;
	//    FIG_line.for_arrow = NULL;
	//    FIG_line.back_arrow = NULL;
	//    FIG_line.cap_style = 0;
	//    FIG_line.join_style = 0;
	//    FIG_line.style_val = 0.0;
	//    FIG_line.radius = 0;
	//    FIG_line.pic = NULL;
	//    FIG_line.next = NULL;
	//
	// /* Add further versions headers below (ULIG). There is probably more work to be done */
	// /* than only changing the header in future xfig versions */
	//
	//    if( strcmp(FIG_version, "3.1") == 0 ) {
	//        fprintf( gpoutfile,
	//                 "#FIG 3.1\n%s\n%s\n%s\n%d %d\n",
	//                 FIG_ORIENT,
	//                 FIG_JUST,
	//                 FIG_UNIT,
	//                 FIG_IRES, FIG_COORD_SYS
	//               );
	//    } else if( strcmp(FIG_version, "3.2") == 0 ) {
	//        fprintf( gpoutfile,
	//                 "#FIG 3.2\n%s\n%s\n%s\n%s\n%6.2f\n%s\n%d\n%d %d\n",
	//                 FIG_ORIENT,
	//                 FIG_JUST,
	//                 FIG_UNIT,
	//                 FIG_PAPER,
	//                 FIG_MAGNIFICATION,
	//                 FIG_MULTIPAGE,
	//                 FIG_TRANSCOLOR,
	//                 FIG_IRES, FIG_COORD_SYS
	//               );
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_graphics()
	//{
	//    FIG_posx = FIG_posy = 0;
	//    FIG_polyvec_stat = FIG_poly_new;
	// /* there is no way to have separate pictures in a FIG file */
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_text()
	//{
	// /* there is no way to have separate pictures in a FIG file */
	//    FIG_poly_clean(FIG_polyvec_stat);
	//    FIG_posx = FIG_posy = 0;
	//    fflush(gpoutfile);
	//}
	//
	//
	// /* Line types for FIG work like this:
	//  *  for monochrome:
	//  *  -2 : solid (border)
	//  *  -1 : dotted 4 (axes)
	//  *   0 : solid (first curve)
	//  *   1 : dotted 3
	//  *   2 : dashed 3
	//  *   3 : dotted 6
	//  *   4 : dashed 6
	//  *   ... ...
	//  *  for color, cycle through colors. once colors are used up, repeat colors
	//  *   but start using dashed lines of different dash length. don't use white
	//  *   as a color.
	//  */
	//
	//TERM_PUBLIC void
	//FIG_linetype(int linetype)		// expect linetype >= -2 
	//{
	//    int last_FIG_type = FIG_type;
	//    int last_FIG_spacing = FIG_spacing;
	//    int last_FIG_color = FIG_color;
	//    int last_FIG_depth = FIG_linedepth;
	//    int last_FIG_thickness = FIG_thickness;
	//
	// /* mapping of fig color codes to color sequence as in the postscript terminal */
	///#define npscolors 9
	//    int fig2pscolors[npscolors] = {
	//	4 //red
	//, 2 //green
	//, 1 //blue
	//,
	//	5 //magenta
	//, 3 //cyan
	//, 6 //yellow
	//,
	//	0 //black
	//, 26 //brown
	//,
	//	11 //use LtBlue instead of light gray
	// /* note: black=1, white=8 */
	//    };
	//
	//    FIG_linedepth = FIG_depth;
	//    FIG_thickness = FIG_current_linewidth * FIG_default_thickness;
	//    if (FIG_thickness < 1)
	//	FIG_thickness = 1;
	//    FIG_color = DEFAULT;
	//
	//    if (linetype <= LT_NODRAW)
	//	linetype = LT_BLACK;
	//
	//    switch (linetype) {
	//    case 0:
	//    case LT_BLACK:{
	//	    FIG_type = SOLID_LINE;
	//	    FIG_spacing = 0.0;
	//	    if (FIG_use_color)
	///#if 0 // fig's old color sequence 
	//		FIG_color = BLACK;
	///#else // color sequence compatible to the postscript terminal 
	//		if (linetype==0) FIG_color = fig2pscolors[0]; // red 
	///#endif
	//	    break;
	//	}
	//    case LT_AXIS:{
	//	    FIG_type = DOTTED_LINE;
	//            if( FIG_solid )
	//                FIG_type = SOLID_LINE;
	//	    FIG_spacing = 4.0;	// gap 
	//	    if (FIG_use_color)
	//		FIG_color = BLACK;
	//	    break;
	//	}
	//    default:{
	// /* now linetype >= 1 --- shouldn't be negative anyway */
	//	    FIG_linedepth = FIG_depth + linetype / 1000;
	//	    linetype %= 1000;
	// /* Thickness of lines is either included in the linetype */
	// /* (in Fig units) or the default is scaled with the */
	// /* current 'linewidth'. */
	//	    if ((FIG_thickness = linetype / 100) == 0)
	//		FIG_thickness = FIG_current_linewidth * FIG_default_thickness;
	//	    if (FIG_thickness < 1)	// Less than 1 would be invisible 
	//		FIG_thickness = 1;
	//	    linetype %= 100;
	//	    if (FIG_use_color) {
	///#if 0 // fig's old color sequence 
	//		FIG_type = (linetype >= WHITE);		// dashed line 
	//		FIG_color = linetype % WHITE;
	//		FIG_spacing = (linetype / WHITE) * 3;
	///#else // color sequence compatible to the postscript terminal 
	//		FIG_type = (linetype >= npscolors);		// dashed line 
	//		FIG_color = fig2pscolors[linetype % npscolors];
	//		FIG_spacing = (linetype / npscolors) * 3;
	///#endif
	//	    } else {		// monochrome 
	//		FIG_type = (linetype)? linetype%2 + 1 : SOLID_LINE; // dotted, dashed, ... 
	//		FIG_spacing = (linetype + 1) / 2 * 3;
	//	    }
	//            if( FIG_solid )
	//                FIG_type = SOLID_LINE;
	//	    break;
	//	}
	//    }
	//    if (FIG_type != last_FIG_type || FIG_spacing != last_FIG_spacing ||
	//	FIG_color != last_FIG_color || FIG_linedepth != last_FIG_depth ||
	//	FIG_thickness != last_FIG_thickness)
	//	FIG_poly_clean(FIG_polyvec_stat);
	//}
	//
	//TERM_PUBLIC void
	//FIG_move(unsigned int x, unsigned int y)
	//{
	//    int last_FIG_posx = FIG_posx;
	//    int last_FIG_posy = FIG_posy;
	//
	//    FIG_posx = x;
	//    FIG_posy = y;
	//    if (FIG_posx != last_FIG_posx || FIG_posy != last_FIG_posy)
	//	FIG_poly_clean(FIG_polyvec_stat);
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_vector(unsigned int ux, unsigned int uy)
	//{
	//    int x = ux, y = uy;
	//
	//    if (FIG_polyvec_stat != FIG_poly_part) {
	//	FIG_line.pen_color = FIG_color;
	//	FIG_line.fill_color = FIG_color;
	//	FIG_line.style = FIG_type;
	//	FIG_line.style_val = FIG_spacing;
	//	FIG_line.depth = FIG_linedepth;
	//	FIG_line.thickness = FIG_thickness;
	//	FIG_poly_vec_cnt = 0;
	// /* allocate memory for the first point */
	//	FIG_points = (F_point *) gp_realloc(FIG_points, sizeof(F_point), "FIG_points");		// JFS 
	//	FIG_points[FIG_poly_vec_cnt].x = FIG_xoff + FIG_posx;
	//	FIG_points[FIG_poly_vec_cnt].y = term->ymax + FIG_yoff - FIG_posy;
	//
	//	FIG_poly_vec_cnt = 1;
	//	FIG_polyvec_stat = FIG_poly_part;
	//    }
	// /* allocate memory for the next point */
	//    FIG_points = (F_point *) gp_realloc(FIG_points, (FIG_poly_vec_cnt + 1) *
	//					sizeof(F_point), "FIG_points");		// JFS 
	//    FIG_points[FIG_poly_vec_cnt].x = FIG_xoff + x;
	//    FIG_points[FIG_poly_vec_cnt].y = term->ymax + FIG_yoff - y;
	//
	//    FIG_poly_vec_cnt++;
	//    if (FIG_poly_vec_cnt > FIG_poly_vec_max)
	//	FIG_poly_clean(FIG_polyvec_stat);
	//
	//    FIG_posx = x;
	//    FIG_posy = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_arrow(
	//    unsigned int sx, unsigned int sy, // start coord 
	//    unsigned int ex, unsigned int ey, // end coord 
	//    int head)
	//{
	//    int cap_style;
	//    double awidth, aheight;	// arrow head sizes 
	//
	//    FIG_poly_clean(FIG_polyvec_stat);
	//    cap_style = (FIG_line.style==DOTTED_LINE)? CAP_ROUND : FIG_line.cap_style;
	//    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %d\n",
	//	    O_POLYLINE, FIG_line.type, FIG_type, FIG_thickness,
	//	    FIG_color, FIG_color, FIG_linedepth,
	//	    FIG_line.pen_style, FIG_line.fill_style, FIG_spacing,
	//	    FIG_line.join_style, cap_style, FIG_line.radius,
	//	    head ? 1 : 0, head==2 ? 1 : 0, 2);
	//
	// /* arrow head(s) */
	//    if (head) {
	//	unsigned int headbackangleparameter = 0;
	//	unsigned int headfillparameter = 0;
	//
	// /* arrow head size */
	//	if (curr_arrow_headlength==0) {
	//	    awidth  = (double) (term->h_tic / 2 + 1);
	//	    aheight = (double) term->h_tic;
	//	} else {
	//	    awidth  = (double) curr_arrow_headlength * 2*sin(curr_arrow_headangle*M_PI/180);
	//	    aheight = (double) curr_arrow_headlength * cos(curr_arrow_headangle*M_PI/180);
	//	}
	//
	// /* arrow head geometry */
	//	if ( curr_arrow_headbackangle < 70 )
	//	    headbackangleparameter = 2;
	//	else if ( curr_arrow_headbackangle > 110 )
	//	    headbackangleparameter = 3;
	//	else
	//	    headbackangleparameter = 1;
	//
	//	if (curr_arrow_headfilled==2)
	//	    headfillparameter = 1;
	//	else
	//	    headfillparameter = 0;
	//
	// /* forward head */
	//	fprintf(gpoutfile, "%d %d %.3f %.3f %.3f\n",
	//		headbackangleparameter, headfillparameter,
	//		1.0, awidth, aheight);
	// /* backward head */
	//	if (head==2)
	//	    fprintf(gpoutfile, "%d %d %.3f %.3f %.3f\n",
	//		    headbackangleparameter,  headfillparameter,
	//		    1.0, awidth, aheight);
	//    }
	//
	// /* arrow line */
	//    fprintf(gpoutfile, "%d %d %d %d\n",
	//	    FIG_xoff + sx, FIG_yoff + term->ymax - sy,
	//	    FIG_yoff + ex, FIG_yoff + term->ymax - ey);
	//
	//    FIG_posx = ex;
	//    FIG_posy = ey;
	//}
	//
	//
	//TERM_PUBLIC void
	//FIG_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char *s1, *s2, *output_string;
	//
	//    if (strlen(str) == 0)
	//	return;
	//
	//    output_string = (char *) gp_alloc(2*strlen(str)+1, "FIG text");
	//    s1 = (char *)str;
	//    s2 = output_string;
	//    do {
	//	if (*s1 == '\\') *(s2++) = *s1;
	//	*(s2++) = *s1;
	//    } while ( *(s1++) );
	//    FIG_poly_clean(FIG_polyvec_stat);
	//    if (FIG_angle == 0.)
	//	y -= term->v_char / 2;	// assuming vertical center justified 
	//    else {
	//	x += (int)(term->v_char*sin(FIG_angle)/4.);
	//	y -= (int)(term->v_char*cos(FIG_angle)/4.);
	//    }
	//
	//    fprintf(gpoutfile, "%d %d %d %d %d %d %6.3f %6.3f %d %6.3f %6.3f %d %d %s\\001\n",
	//	    OBJ_TEXT, FIG_justify, FIG_color, 0, FIG_DEFAULT,
	//	    FIG_font_id, (float) FIG_font_s,
	//	    FIG_angle, FIG_text_flags, (float) term->v_char,
	//	    (float) term->h_char * strlen(str),
	//	    FIG_xoff + x, term->ymax + FIG_yoff - y, output_string);
	//
	//    free(output_string);
	//}
	//
	//TERM_PUBLIC int
	//FIG_justify_text(enum JUSTIFY mode)
	//{
	//    switch (mode) {
	//    case LEFT:
	//	FIG_justify = T_LEFT_JUSTIFIED;
	//	break;
	//    case CENTRE:
	//	FIG_justify = T_CENTER_JUSTIFIED;
	//	break;
	//    case RIGHT:
	//	FIG_justify = T_RIGHT_JUSTIFIED;
	//	break;
	// /* shouldn't happen */
	//    default:
	//	FIG_justify = T_LEFT_JUSTIFIED;
	//	return (FALSE);
	//	break;
	//    }
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//FIG_text_angle(int ang)
	//{
	//    FIG_angle = ang * M_PI_2 / 90. ;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//FIG_lpoint(unsigned int x, unsigned int y, int number)
	//{
	//    FIG_type = 0;		// Solid lines for marker outline 
	//    if (number % 100 >= 49 && number % 100 < 99) {	// circles, squares, triangles 
	//	int r, d, h, xpc, ypc;
	//	int line_color, fill_color, fill_style;
	//	int cnum, tnum, color, depth;
	//
	//	FIG_poly_clean(FIG_polyvec_stat);
	//	depth = FIG_linedepth - 1;	// Above error bars 
	//	if (number > 1000)
	//	    depth = FIG_depth + number / 1000 - 1;
	//	number %= 1000;
	//	if (depth < 0)
	//	    depth = 0;
	//	if (number < 100)
	//	    color = FIG_color;
	//	else if (FIG_use_color)
	//	    color = number / 100 - 1;
	//	else if (number / 100 >= WHITE)
	//	    color = WHITE;
	//	else
	//	    color = DEFAULT;
	//	number %= 100;
	//	cnum = (number + 1) % 10;
	//	tnum = (number - 49) / 10;
	//	if (cnum < 5)
	//	    line_color = (FIG_use_color ? BLACK : DEFAULT);
	//	else
	//	    line_color = FIG_color;
	//	fill_color = color;
	//	if (cnum == 0 || cnum == 5)
	//	    fill_style = -1;
	//	else
	//	    fill_style = (cnum % 5) * 5;
	//
	//	xpc = FIG_xoff + x;
	//	ypc = term->ymax + FIG_yoff - y;
	//
	//	if (tnum == 0) {	// circle 
	//	    r = FIG_current_pointsize * term->v_char / 4 + 1;
	//	    fprintf(gpoutfile,
	//		    "1 3 %d %d %d %d %d %d %d %6.3f 1 0.000 %d %d %d %d %d %d %d %d\n",
	//		    FIG_type, FIG_thickness, line_color,
	//		    fill_color, depth, 0, fill_style, FIG_spacing,
	//		    xpc, ypc, r, r, xpc, ypc, xpc, ypc - r);
	//	} else {
	//	    fprintf(gpoutfile, "2 3 %d %d %d %d %d %d %d %6.3f 0 0 0 0 0 ",
	//		    FIG_type, FIG_thickness, line_color,
	//		    fill_color, depth, 0, fill_style, FIG_spacing);
	//
	//	    if (tnum == 1) {	// square 
	//		d = FIG_current_pointsize * term->v_char / 4 + 1;
	//		fprintf(gpoutfile, "5\n\t%d %d %d %d %d %d %d %d %d %d\n",
	//			xpc - d, ypc - d, xpc - d, ypc + d, xpc + d, ypc + d, xpc + d, ypc - d,
	//			xpc - d, ypc - d);
	//	    } else if (tnum == 2) {	// diamond 
	//		d = FIG_current_pointsize * term->v_char / 3 + 1;
	//		fprintf(gpoutfile, "5\n\t%d %d %d %d %d %d %d %d %d %d\n",
	//			xpc - d, ypc, xpc, ypc + d, xpc + d, ypc, xpc, ypc - d, xpc - d, ypc);
	//	    } else if (tnum == 3) {	// triangle up 
	//		d = FIG_current_pointsize * term->v_char / 3 + 1;
	//		h = d * 4 / 7;	// About d times one 3rd of sqrt(3) 
	//		fprintf(gpoutfile, "4\n\t%d %d %d %d %d %d %d %d\n",
	//			xpc - d, ypc + h, xpc, ypc - 2 * h, xpc + d, ypc + h, xpc - d, ypc + h);
	//	    } else if (tnum == 4) {	// triangle down 
	//		d = FIG_current_pointsize * term->v_char / 3 + 1;
	//		h = d * 4 / 7;
	//		fprintf(gpoutfile, "4\n\t%d %d %d %d %d %d %d %d\n",
	//			xpc - d, ypc - h, xpc, ypc + 2 * h, xpc + d, ypc - h, xpc - d, ypc - h);
	//	    }
	//	}
	//    } else {
	//	int pt = number % 13;
	//	switch (pt) {
	//	default:	do_point(x, y, pt); break;
	//	case 3: 	FIG_lpoint(x, y, 64); break;
	//	case 4: 	FIG_lpoint(x, y, 68); break;
	//	case 5: 	FIG_lpoint(x, y, 54); break;
	//	case 6: 	FIG_lpoint(x, y, 58); break;
	//	case 7: 	FIG_lpoint(x, y, 84); break;
	//	case 8: 	FIG_lpoint(x, y, 88); break;
	//	case 9: 	FIG_lpoint(x, y, 94); break;
	//	case 10:	FIG_lpoint(x, y, 98); break;
	//	case 11: 	FIG_lpoint(x, y, 74); break;
	//	case 12:	FIG_lpoint(x, y, 78); break;
	//	}
	//    }
	//}
	//
	//TERM_PUBLIC void
	//FIG_pointsize(double arg_pointsize)
	//{
	//    FIG_current_pointsize = arg_pointsize < 0. ? 1. : arg_pointsize;
	// /* Bug-fix by hkeller@gwdg.de and K.B.: set pointsize for do_point() */
	//    do_pointsize(arg_pointsize * FIG_font_s / (double) FIG_FONT_S);
	//}
	//
	//TERM_PUBLIC void
	//FIG_linewidth(double linewidth)
	//{
	//    FIG_current_linewidth = linewidth;
	//}
	//
	//TERM_PUBLIC void
	//FIG_reset()
	//{
	//    FIG_poly_clean(FIG_polyvec_stat);
	//    FIG_posx = FIG_posy = 0;
	//    fflush(gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//FIG_boxfill(
	//    int style,
	//    unsigned int x, unsigned int y,
	//    unsigned int w, unsigned int h)
	//{
	//    int pen_color, fill_color, fill_style, fill_dens;
	//
	//    FIG_poly_clean(FIG_polyvec_stat);
	//
	//    FIG_line.pen_color = FIG_color;
	//
	//    switch( style & 0xf ) {
	//    case FS_SOLID:
	//    case FS_TRANSPARENT_SOLID:
	// /* style == 1 --> filled with intensity according to filldensity */
	//        pen_color = FIG_line.pen_color;
	//        fill_color = FIG_line.pen_color;
	//        fill_dens = style >> 4;
	//        if( fill_dens < 0 ) fill_dens = 0;
	//        if( fill_dens > 100 ) fill_dens = 100;
	//        if( FIG_color == -1 || FIG_color == 0 )
	// /* default color or black: solid 0%...100% -> 0...20 */
	//            fill_style = fill_dens / 5;
	//        else
	// /* all other colors: solid 0%...100% -> 40...20 */
	//            fill_style = 40 - fill_dens / 5;
	//        break;
	//    case FS_PATTERN:
	//    case FS_TRANSPARENT_PATTERN:
	// /* style == 2 --> filled with pattern according to fillpattern */
	//        pen_color = FIG_line.pen_color;
	//        fill_color = WHITE;
	//        fill_style = 41 + ( ( (style>>4) < 0 ) ? 0 : style>>4 );
	//        break;
	//    case FS_EMPTY:
	//    default:
	// /* style == 0 or unknown --> filled with background color */
	//        pen_color = FIG_line.pen_color;
	//        fill_color = WHITE;
	//        fill_style = 20;
	//    }
	//
	//    x = FIG_xoff + x;
	//    y = term->ymax + FIG_yoff - y;
	//
	//    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %6.3f %d %d %d %d %d %d\n"
	//            "  %d %d %d %d %d %d %d %d %d %d\n",
	//            O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
	//            pen_color, fill_color, FIG_line.depth, FIG_line.pen_style,
	//            fill_style, FIG_line.style_val, FIG_line.join_style,
	//            FIG_line.cap_style, FIG_line.radius, 0, 0, 5,
	//            x, y, x+w, y, x+w, y-h, x, y-h, x, y );
	//}
	//
	//TERM_PUBLIC int FIG_make_palette(t_sm_palette *palette)
	//{
	//    int i;
	//
	// /* Query to determine palette size */
	//    if (palette==NULL) {
	//	return FIG_palette_size; // How big is palette ? 
	//    }
	//
	//    FIG_poly_clean(FIG_polyvec_stat); // Clean up current data 
	//
	//    if (FIG_palette_set == FALSE) {
	// /* Create new palette */
	//	FIG_palette_set = TRUE;
	//	if (FIG_use_color == FALSE || sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) {
	// /* Gray palette */
	//	    if (FIG_use_color == FALSE && sm_palette.colorMode == SMPAL_COLOR_MODE_RGB)
	//		fprintf(stderr,	"Monochrome fig file: using gray palette instead of color\n");
	//	    for (i = 0; i < sm_palette.colors; i++) {
	//		int j = (int)(i * 255.0 / (sm_palette.colors-1) + 0.5);
	//		fprintf(gpoutfile, "%d %d #%2.2x%2.2x%2.2x\n",
	//		O_COLOR_DEF, (i + FIG_palette_offst), j, j, j);
	//	    }
	//	} else {
	// /* Create colour/normal palette */
	//	    for (i = 0; i < sm_palette.colors; i++) {
	//		fprintf(gpoutfile, "%d %d #%2.2x%2.2x%2.2x\n",
	//		O_COLOR_DEF, (i + FIG_palette_offst),
	//		(int)( palette->color[i].r * 255 + 0.5 ),
	//		(int)( palette->color[i].g * 255 + 0.5 ),
	//		(int)( palette->color[i].b * 255 + 0.5 ) );
	//	    }
	//	}
	//    } else {
	//	fprintf(stderr, "fig: Attempt to set palette twice\n");
	//    }
	//    return 0;
	//}
	//
	// /* This doesn't apply for FIG format files
	// TERM_PUBLIC void FIG_previous_palette()
	// {
	// }
	// */
	//
	//TERM_PUBLIC void FIG_set_color(t_colorspec *colorspec)
	//{
	//    double gray = colorspec->value;
	//    int new_color;
	//
	//    if (colorspec->type == TC_LT) {
	//    	FIG_linetype(colorspec->lt);
	//	return;
	//    }
	//
	//    if (colorspec->type != TC_FRAC)
	//	return;
	//
	//    new_color = (gray <= 0) ? 0 : (int)(gray * sm_palette.colors);
	//    if (new_color >= FIG_palette_size)
	//	new_color = FIG_palette_size - 1;
	//    if (FIG_palette_set == FALSE) {
	//	fprintf(stderr,"fig: Palette used before set\n"); // Error condition 
	//    }
	//    new_color += FIG_palette_offst;
	//    if (FIG_color != new_color) {
	//	FIG_poly_clean(FIG_polyvec_stat);
	//	FIG_color = new_color;
	//    }
	//}
	//
	//TERM_PUBLIC void FIG_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int i,j;
	//
	//    FIG_poly_clean(FIG_polyvec_stat); // Clean up current data 
	//
	//    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %ld\n\t",
	//	O_POLYLINE, T_POLYGON, FIG_line.style, 0,
	//	FIG_color, FIG_color, FIG_line.depth,
	//	FIG_line.pen_style, FIG_fill_style, FIG_line.style_val,
	//	FIG_line.join_style, FIG_line.cap_style, FIG_line.radius,
	//	0, 0, (long)(points+1));
	// /* set thickness (arg 4) to 0 */
	//
	//    j = 0;
	//    for (i = 0; i < points; i++) {
	//	fprintf(gpoutfile, " %d %d", FIG_xoff + corners[i].x,
	//	    term->ymax + FIG_yoff - corners[i].y);
	//	if (j++ > 4 && i != points - 1) {
	//		fputs("\n\t", gpoutfile);
	//		j = 0;		// JFS 
	//	}
	//    }
	//    fprintf(gpoutfile, " %d %d", FIG_xoff + corners[0].x,
	//	term->ymax + FIG_yoff - corners[0].y);
	//    j++;
	//    if (j != 0) {
	//	putc('\n', gpoutfile);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//FIG_layer(t_termlayer syncpoint)
	//{
	//    static int plotno = 0;
	//
	// /* We must ignore all syncpoints that we don't recognize */
	//    switch (syncpoint) {
	//
	//	default:
	//		break;
	//	
	//	case TERM_LAYER_BEFORE_PLOT:
	//		FIG_poly_clean(FIG_polyvec_stat);
	//		fputs("6", gpoutfile);
	// /* Bounding box?  Give it the entire plot area */
	//		fprintf(gpoutfile, " %d %d %d %d\n",
	//			FIG_xoff + plot_bounds.xleft, 
	//			term->ymax + FIG_yoff - plot_bounds.ytop,
	//			FIG_xoff + plot_bounds.xright, 
	//			term->ymax + FIG_yoff - plot_bounds.ybot);
	//		fprintf(gpoutfile, "# Begin plot #%d\n", ++plotno);
	//		break;
	//	
	//	case TERM_LAYER_AFTER_PLOT:
	//		FIG_poly_clean(FIG_polyvec_stat);
	//		fprintf(gpoutfile, "# End plot #%d\n", plotno);
	//		fputs("-6\n", gpoutfile);
	//		break;
	//	
	//	case TERM_LAYER_RESET:
	//		plotno = 0;
	//		break;
	//
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(fig_driver)
	//    "fig", "FIG graphics language for XFIG graphics editor",
	//    FIG_XMAX(INCH), FIG_YMAX(INCH), FIG_VCHAR, FIG_HCHAR,
	//    FIG_VTIC(INCH), FIG_HTIC(INCH), FIG_options, FIG_init, FIG_reset,
	//    FIG_text, null_scale, FIG_graphics, FIG_move, FIG_vector,
	//    FIG_linetype, FIG_put_text, FIG_text_angle, FIG_justify_text,
	//    FIG_lpoint, FIG_arrow, set_font_null, FIG_pointsize,
	//    TERM_BINARY|TERM_CAN_DASH //flags 
	// ,
	//    0 //suspend 
	// , 0 //resume 
	// ,
	//    FIG_boxfill, FIG_linewidth
	///#ifdef USE_MOUSE
	//    ,0, 0, 0, 0, 0 // no mouse support for the fig terminal 
	///#endif
	//    , FIG_make_palette, 0 //previous_palette
	//, FIG_set_color, FIG_filled_polygon
	//    , 0
	//    , 0, 0, 0	// no enhanced text support 
	//    , FIG_layer
	//TERM_TABLE_END(fig_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM fig_driver
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(fig)
	//"1 fig",
	//"?commands set terminal fig",
	//"?set terminal fig",
	//"?set term fig",
	//"?terminal fig",
	//"?term fig",
	//"?fig",
	//"?xfig",
	//" The `fig` terminal device generates output in the Fig graphics language.",
	//"",
	//" Syntax:",
	//"       set terminal fig {monochrome | color}",
	//"                        {landscape | portrait}",
	//"                        {small | big | size <xsize> <ysize>}",
	//"                        {metric | inches}",
	//"                        {pointsmax <max_points>}",
	//"                        {solid | dashed}",
	//"                        {font <fontname>} {fontsize <fsize>}",
	//"                        {textnormal | {textspecial texthidden textrigid}}",
	//"                        {{thickness|linewidth} <units>}",
	//"                        {depth <layer>}",
	//"                        {version <number>}",
	//"",
	//" `monochrome` and `color` determine whether the picture is black-and-white or",
	//" `color`.  `small` and `big` produce a 5x3 or 8x5 inch graph in the default",
	//" `landscape` mode and 3x5 or 5x8 inches in `portrait` mode.",
	//" `size` sets (overrides) the size of the drawing",
	//" area to <xsize>*<ysize> in units of inches or centimeters depending on the",
	//" `inches` or `metric` setting in effect.",
	//" The latter settings is also used as default units for editing with \"xfig\".",
	//"",
	//" `pointsmax <max_points>` sets the maximum number of points per polyline.",
	//"",
	//" `solid` inhibits automatic usage of `dash`ed lines when solid linestyles are",
	//" used up, which otherwise occurs.",
	//"",
	//" `fontsize` sets the size of the text font to <fsize> points.  `textnormal`",
	//" resets the text flags and selects postscript fonts, `textspecial` sets the",
	//" text flags for LaTeX specials, `texthidden` sets the hidden flag and",
	//" `textrigid` the rigid flag. ",
	//"",
	//" `depth` sets the default depth layer for all lines and text.  The default",
	//" depth is 10 to leave room for adding material with \"xfig\" on top of the",
	//" plot.",
	//"",
	//" `version` sets the format version of the generated fig output. Currently",
	//" only versions 3.1 and 3.2 are supported.",
	//"",
	//" `thickness` sets the default line thickness, which is 1 if not specified.",
	//" Overriding the thickness can be achieved by adding a multiple of 100 to the",
	//" `linetype` value for a `plot` command.  In a similar way the `depth`",
	//" of plot elements (with respect to the default depth) can be controlled by",
	//" adding a multiple of 1000 to <linetype>.  The depth is then <layer> +",
	//" <linetype>/1000 and the thickness is (<linetype>%1000)/100 or, if that is",
	//" zero, the default line thickness. `linewidth` is a synonym for `thickness`.",
	//"",
	//" Additional point-plot symbols are also available with the `fig` driver. The",
	//" symbols can be used through `pointtype` values % 100 above 50, with different",
	//" fill intensities controlled by <pointtype> % 5 and outlines in black (for",
	//" <pointtype> % 10 < 5) or in the current color.  Available symbols are",
	//"         50 - 59:  circles",
	//"         60 - 69:  squares",
	//"         70 - 79:  diamonds",
	//"         80 - 89:  upwards triangles",
	//"         90 - 99:  downwards triangles",
	//" The size of these symbols is linked to the font size.  The depth of symbols",
	//" is by default one less than the depth for lines to achieve nice error bars.",
	//" If <pointtype> is above 1000, the depth is <layer> + <pointtype>/1000-1.  If",
	//" <pointtype>%1000 is above 100, the fill color is (<pointtype>%1000)/100-1.",
	//"",
	//" Available fill colors are (from 1 to 9): black, blue, green, cyan, red,",
	//" magenta, yellow, white and dark blue (in monochrome mode: black for 1 to 6",
	//" and white for 7 to 9).",
	//"",
	//" See `plot with` for details of <linetype> and <pointtype>.",
	//"",
	//" The `big` option is a substitute for the `bfig` terminal in earlier versions,",
	//" which is no longer supported.",
	//"",
	//" Examples:",
	//"       set terminal fig monochrome small pointsmax 1000  # defaults",
	//"",
	//"       plot 'file.dat' with points linetype 102 pointtype 759",
	//" would produce circles with a blue outline of width 1 and yellow fill color.",
	//"",
	//"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 554",
	//" would produce errorbars with black lines and circles filled red.  These",
	//" circles are one layer above the lines (at depth 9 by default).",
	//"",
	//" To plot the error bars on top of the circles use",
	//"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 2554"
	//END_HELP(fig)
	///#endif // TERM_HELP 




	///#if 0
	////
	//// /* I hope this is enough to stop compilers looking in here
	////  * (I think that anything inside #if 0 is still strictly
	////  *  required to be valid C, rather than just any old junk
	////  *  like this.)
	////  */
	////
	//// /*
	////  * FIG : Facility for Interactive Generation of figures
	////  * Copyright (c) 1985 by Supoj Sutanthavibul
	////  * Parts Copyright (c) 1994 by Brian V. Smith
	////  * Parts Copyright (c) 1991 by Paul King
	////  *
	////  * The X Consortium, and any party obtaining a copy of these files from
	////  * the X Consortium, directly or indirectly, is granted, free of charge, a
	////  * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
	////  * nonexclusive right and license to deal in this software and
	////  * documentation files (the "Software"), including without limitation the
	////  * rights to use, copy, modify, merge, publish, distribute, sublicense,
	////  * and/or sell copies of the Software, and to permit persons who receive
	////  * copies from any such party to do so, with the only requirement being
	////  * that this copyright notice remain intact.  This license includes without
	////  * limitation a license to do the foregoing actions under any patents of
	////  * the party supplying this software to the X Consortium.
	////  */
	////
	//// /*
	//// The only difference from version 3.0 to version 3.1 is that the position
	//// of the "magnet" has been shifted by 14 Fig units.
	//// In the 2.1 and older versions of xfig the grid was in multiples of 5 Fig
	//// units, but they were on intervals 4, 9, 14, 19, etc.
	//// When version 3.0 was created, coordinates were simply multiplied by the
	//// ratio of the resolutions (1200/80 = 15) so values like 4 became 60 instead
	//// of 74 ((4+1)*15 - 1).
	////
	//// This means that figures converted from 2.1 and older files are offset by
	//// 14 Fig units but new objects entered with version 3.0 are correct.
	////
	//// In version 3.1 the magnet grid is at intervals 0, 75, 150, etc instead of
	//// -1, 74, 149, etc.
	//// Figures from 2.1 and older are correctly converted now and a warning is popped
	//// up when you read in a version 3.0 file that says you may have to offset the
	//// figure when you load it, using the x and y offsets in the file panel.
	////
	//// --------------------------------------------------------------------------------
	//// Description of the Fig Format Follows
	//// --------------------------------------------------------------------------------
	////
	////  (1) The very first line is a comment line containing the name and version:
	//// 	#FIG 3.1
	////
	////     The character # at the first column of a line indicates that the line
	////     is a comment line which will be ignored.
	////
	////  (2) The first non-comment line consists of two numbers and two strings:
	////
	//// 	int	fig_resolution		(Fig units/inch)
	//// 	string	orientation		("Landscape" or "Portrait")
	//// 	string	justification		("Center" or "Flush Left")
	//// 	string	units			("Metric" or "Inches")
	//// 	int	coordinate_system	(1: origin is the lower left corner (NOT USED)
	//// 					 2: upper left)
	////
	////     Fig_resolution is the resolution of the figure in the file.
	////     Xfig will always write the file with a resolution of 1200ppi so it
	////     will scale the figure upon reading it in if its resolution is different
	////     from 1200ppi.  Pixels are assumed to be square.
	////
	////     Xfig will read the orientation string and change the canvas to match
	////     either the Landscape or Portrait mode of the figure file.
	////
	////     The units specification is self-explanatory.
	////
	////     The coordinate_system variable is ignored - the origin is ALWAYS the
	////     upper-left corner.
	////
	////     ** Coordinates are given in "fig_resolution" units.
	////     ** Line thicknesses are given in 1/80 of an inch ("display units").  The
	////        minimum line thickness is 0 (no line is drawn) and the maximum is 500.
	////     ** dash-lengths/dot-gaps are given in 1/80 of an inch.
	////
	////
	////  (3) The rest of the file contains various objects.  An object can be one
	////     of six classes (or types).
	////
	//// 	0)	Color pseudo-object.
	//// 	1)	Arc.
	//// 	2)	Ellipse which is a generalization of circle.
	//// 	3)	Polyline which includes polygon and box.
	//// 	4)	Spline which includes closed/open control/interpolated spline.
	//// 	5)	Text.
	//// 	6)	Compound object which is composed of one or more objects.
	////
	////     In the following elaboration on object formats, every value of Fig
	////     output are separated by blank characters or new line ('\n').  The
	////     value of the unused parameters will be -1.
	////
	////     Some fields are described as "enumeration type" or "bit vector"; the
	////     values which these fields can take are defined in the header file object.h.
	////     The pen_style field is unused.
	////     These values may be defined in some future version of Fig.
	////
	////     The two color fields (pen and fill; pen only, for texts) are
	////     defined as follows:
	////
	//// 	    -1 = Default
	//// 	     0 = Black
	//// 	     1 = Blue
	//// 	     2 = Green
	//// 	     3 = Cyan
	//// 	     4 = Red
	//// 	     5 = Magenta
	//// 	     6 = Yellow
	//// 	     7 = White
	//// 	  8-11 = four shades of blue (dark to lighter)
	//// 	 12-14 = three shades of green (dark to lighter)
	//// 	 15-17 = three shades of cyan (dark to lighter)
	//// 	 18-20 = three shades of red (dark to lighter)
	//// 	 21-23 = three shades of magenta (dark to lighter)
	//// 	 24-26 = three shades of brown (dark to lighter)
	//// 	 27-30 = four shades of pink (dark to lighter)
	//// 	    31 = Gold
	////
	//// 	 values from 32 to 543 (512 total) are user colors and
	//// 	 are defined in color pseudo-objects (type 0)
	////
	////     For WHITE color, the area fill field is defined as follows:
	////
	//// 	-1 = not filled
	//// 	 0 = black
	//// 	...  values from 1 to 19 are shades of grey, from darker to lighter
	//// 	20 = white
	//// 	21-40 not used
	//// 	41-56 see patterns for colors, below
	////
	////     For BLACK or DEFAULT color, the area fill field is defined as follows:
	////
	//// 	-1 = not filled
	//// 	 0 = white
	//// 	...  values from 1 to 19 are shades of grey, from lighter to darker
	//// 	20 = black
	//// 	21-40 not used
	//// 	41-56 see patterns for colors, below
	////
	////     For all other colors, the area fill field is defined as follows:
	////
	//// 	-1 = not filled
	//// 	 0 = black
	//// 	...  values from 1 to 19 are "shades" of the color, from darker to lighter.
	//// 		A shade is defined as the color mixed with black
	//// 	20 = full saturation of the color
	//// 	...  values from 21 to 39 are "tints" of the color from the color to white.
	//// 		A tint is defined as the color mixed with white
	//// 	40 = white
	//// 	41 = 30 degree left diagonal pattern
	//// 	42 = 30 degree right diagonal pattern
	//// 	43 = 30 degree crosshatch
	//// 	44 = 45 degree left diagonal pattern
	//// 	45 = 45 degree right diagonal pattern
	//// 	46 = 45 degree crosshatch
	//// 	47 = bricks
	//// 	48 = circles
	//// 	49 = horizontal lines
	//// 	50 = vertical lines
	//// 	51 = crosshatch
	//// 	52 = fish scales
	//// 	53 = small fish scales
	//// 	54 = octagons
	//// 	55 = horizontal "tire treads"
	//// 	56 = vertical "tire treads"
	////
	////     The depth field is defined as follows:
	////
	//// 	 0 ... 999 where larger value means object is deeper than (under)
	//// 		   objects with smaller depth
	////
	////     The line_style field is defined as follows:
	////
	//// 	-1 = Default
	//// 	 0 = Solid
	//// 	 1 = Dashed
	//// 	 2 = Dotted
	////
	////     The style_val field is defined as the length, in 1/80 inches, of the on/off
	////     dashes for dashed lines, and the distance between the dots, in 1/80 inches,
	////     for dotted lines.
	////
	////     The join_style field is defined FOR LINES only as follows:
	////
	//// 	 0 = Miter (the default in xfig 2.1 and earlier)
	//// 	 1 = Bevel
	//// 	 2 = Round
	////
	////     The cap_style field is defined FOR LINES, OPEN SPLINES and ARCS only as follows:
	////
	//// 	 0 = Butt (the default in xfig 2.1 and earlier)
	//// 	 1 = Round
	//// 	 2 = Projecting
	////
	////     The arrow_type field is defined for LINES, ARCS and OPEN SPLINES
	////     only as follows:
	////
	//// 	 0 = Stick-type (the default in xfig 2.1 and earlier)
	//// 	 1 = Closed triangle:
	//// 		|
	//// 		|
	//// 		|
	//// 		|    /
	//// 		|  /
	//// 		|/
	//// 	 2 = Closed with "indented" butt:
	//// 		|
	//// 		
	//// 		
	//// 		
	//// 		  /    /
	//// 		 /   /
	//// 		/  /
	//// 		|/
	//// 	 3 = Closed with "pointed" butt:
	//// 		   |
	//// 		  /
	//// 		 /
	//// 		/
	//// 		\         /
	//// 		 \      /
	//// 		  \   /
	//// 		   |/
	////
	////     The arrow_style field is defined for LINES, ARCS and OPEN SPLINES
	////     only as follows:
	////
	//// 	 0 = Hollow (actually filled with white)
	//// 	 1 = Filled with pen_color
	////
	////  (3.0) OBJECT DEFINITION:
	////
	////     (3.1) Color Pseudo-objects (user-defined colors)
	//// 	  This is used to define arbitrary colors beyond the 32 standard colors.
	//// 	  The color objects must be defined before any other Fig objects.
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 0)
	//// 	int	color_number		(color number, from 32-543 (512 total))
	////      hex string	rgb values		(hexadecimal string describing red,
	//// 					 green and blue values (e.g. #330099) )
	////
	////     (3.2) ARC
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 5)
	//// 	int	sub_type		(0: pie-wedge (closed)
	//// 					 1: open ended arc)
	//// 	int	line_style		(enumeration type)
	//// 	int	line_thickness		(1/80 inch)
	//// 	int	pen_color		(enumeration type, pen color)
	//// 	int	fill_color		(enumeration type, fill color)
	//// 	int	depth			(enumeration type)
	//// 	int	pen_style		(pen style, not used)
	//// 	int	area_fill		(enumeration type, -1 = no fill)
	//// 	float	style_val		(1/80 inch)
	//// 	int	cap_style		(enumeration type)
	//// 	int	direction		(0: clockwise, 1: counterclockwise)
	//// 	int	forward_arrow		(0: no forward arrow, 1: on)
	//// 	int	backward_arrow		(0: no forward arrow, 1: on)
	//// 	float	center_x, center_y	(center of the arc)
	//// 	int	x1, y1			(Fig units, the 1st point the user entered)
	//// 	int	x2, y2			(Fig units, the 2nd point)
	//// 	int	x3, y3			(Fig units, the last point)
	////
	////     Forward arrow line (Optional; absent if forward_arrow is 0):
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	arrow_type		(enumeration type)
	//// 	int	arrow_style		(enumeration type)
	//// 	float	arrow_thickness		(1/80 inch)
	//// 	float 	arrow_width		(Fig units)
	//// 	float	arrow_height		(Fig units)
	////
	////     Backward arrow line (Optional; absent if backward_arrow is 0):
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	arrow_type		(enumeration type)
	//// 	int	arrow_style		(enumeration type)
	//// 	float	arrow_thickness		(1/80 inch)
	//// 	float	arrow_width		(Fig units)
	//// 	float	arrow_height		(Fig units)
	////
	////     (3.3) COMPOUND
	////
	////     A line with object code 6 signifies the start of a compound.
	////     There are four more numbers on this line which indicate the
	////     upper right corner and the lower left corner of the bounding
	////     box of this compound.  A line with object code -6 signifies
	////     the end of the compound.  Compound may be nested.
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 6)
	//// 	int	upperright_corner_x	(Fig units)
	//// 	int	upperright_corner_y	(Fig units)
	//// 	int	lowerleft_corner_x	(Fig units)
	//// 	int	lowerleft_corner_y	(Fig units)
	////
	////     Subsequent lines:
	//// 	objects
	//// 	.
	//// 	.
	////
	////     Last line:
	//// 	-6
	////
	////     (3.4) ELLIPSE
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 1)
	//// 	int	sub_type		(1: ellipse defined by radiuses
	//// 					 2: ellipse defined by diameters
	//// 					 3: circle defined by radius
	//// 					 4: circle defined by diameter)
	//// 	int	line_style		(enumeration type)
	//// 	int	thickness		(1/80 inch)
	//// 	int	pen_color		(enumeration type, pen color)
	//// 	int	fill_color		(enumeration type, fill color)
	//// 	int	depth			(enumeration type)
	//// 	int	pen_style		(pen style, not used)
	//// 	int	area_fill		(enumeration type, -1 = no fill)
	//// 	float	style_val		(1/80 inch)
	//// 	int	direction		(always 1)
	//// 	float	angle			(radians, the angle of the x-axis)
	//// 	int	center_x, center_y	(Fig units)
	//// 	int	radius_x, radius_y	(Fig units)
	//// 	int	start_x, start_y	(Fig units; the 1st point entered)
	//// 	int	end_x, end_y		(Fig units; the last point entered)
	////
	////     (3.5) POLYLINE
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 2)
	//// 	int	sub_type		(1: polyline
	//// 					 2: box
	//// 					 3: polygon
	//// 					 4: arc-box)
	//// 					 5: imported-picture bounding-box)
	//// 	int	line_style		(enumeration type)
	//// 	int	thickness		(1/80 inch)
	//// 	int	pen_color		(enumeration type, pen color)
	//// 	int	fill_color		(enumeration type, fill color)
	//// 	int	depth			(enumeration type)
	//// 	int	pen_style		(pen style, not used)
	//// 	int	area_fill		(enumeration type, -1 = no fill)
	//// 	float	style_val		(1/80 inch)
	//// 	int	join_style		(enumeration type)
	//// 	int	cap_style		(enumeration type, only used for POLYLINE)
	//// 	int	radius			(1/80 inch, radius of arc-boxes)
	//// 	int	forward_arrow		(0: off, 1: on)
	//// 	int	backward_arrow		(0: off, 1: on)
	//// 	int	npoints			(number of points in line)
	////
	////     Forward arrow line: same as ARC object
	////
	////     Backward arrow line: same as ARC object
	////
	////     Points line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	x1, y1			(Fig units)
	//// 	int	x2, y2			(Fig units)
	//// 	  .
	//// 	  .
	//// 	int	xnpoints ynpoints	(this will be the same as the 1st
	//// 					point for polygon and box)
	////
	////     PIC line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	boolean	flipped			orientation = normal (0) or flipped (1)
	//// 	char	file[]			name of picture file to import
	////
	////     (3.6) SPLINE
	////
	////     First line:
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object_code		(always 3)
	//// 	int	sub_type		(0: open spline
	//// 					 1: closed spline
	//// 					 2: open interpolated spline
	//// 					 3: closed interpolated spline)
	//// 	int	line_style		(See the end of this section)
	//// 	int	thickness		(1/80 inch)
	//// 	int	pen_color		(enumeration type, pen color)
	//// 	int	fill_color		(enumeration type, fill color)
	//// 	int	depth			(enumeration type)
	//// 	int	pen_style		(pen style, not used)
	//// 	int	area_fill		(enumeration type, -1 = no fill)
	//// 	float	style_val		(1/80 inch)
	//// 	int	cap_style		(enumeration type, only used for open splines)
	//// 	int	forward_arrow		(0: off, 1: on)
	//// 	int	backward_arrow		(0: off, 1: on)
	//// 	int	npoints			(number of control points in spline)
	////
	////     Forward arrow line: same as ARC object
	////
	////     Backward arrow line: same as ARC object
	////
	////     Points line: same as POLYLINE object
	////
	////     Control points line (absent if sub_type is 0 or 1):
	//// 	Control points of interpolated spline.  There are two control
	//// 	points for each knots.  A section i, of the spline is drawn
	//// 	using Bezier cubic with the following four points:
	//// 		(x ,y ), (rx ,ry ), (lx	  , ly   ), (x   , y   ).
	//// 		  i  i	    i	i      i+1    i+1     i+1   i+1
	//// 	For closed interpolated spline the last pair of control points,
	//// 	(lxnpoints,lynpoints) and (rxnpoints,rynpoints) (which can be ignored),
	//// 	are the same as (lx1,ly1) and (rx1,ry1) respectively.
	////
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	float	lx1, ly1		(Fig units)
	//// 	float	rx1, ry1		(Fig units)
	//// 	float	lx2, ly2		(Fig units)
	//// 	float	rx2, ry2		(Fig units)
	//// 	  .
	//// 	  .
	//// 	float	lxnpoints, lynpoints	(Fig units)
	//// 	float	rxnpoints, rynpoints	(Fig units)
	////
	////     (3.7) TEXT
	//// 	type	name			(brief description)
	//// 	----	----			-------------------
	//// 	int	object 			(always 4)
	//// 	int	sub_type		(0: Left justified
	//// 					 1: Center justified
	//// 					 2: Right justified)
	//// 	int	color			(enumeration type)
	//// 	int	depth			(enumeration type)
	//// 	int	pen_style		(enumeration , not used)
	//// 	int	font 			(enumeration type)
	//// 	float	font_size 		(font size in points)
	//// 	float	angle			(radians, the angle of the text)
	//// 	int	font_flags		(bit vector)
	//// 	float	height			(Fig units)
	//// 	float	length			(Fig units)
	//// 	int	x, y			(Fig units, coordinate of the origin
	//// 					 of the string.  If sub_type = 0, it is
	//// 					 the lower left corner of the string.
	//// 					 If sub_type = 1, it is the lower
	//// 					 center.  Otherwise it is the lower
	//// 					 right corner of the string.)
	//// 	char	string[]		(ASCII characters; starts after a blank
	//// 					 character following the last number and
	//// 					 ends before the sequence '\001'.  This
	//// 					 sequence is not part of the string.
	//// 					 Characters above octal 177 are
	//// 					 represented by \xxx where xxx is the
	//// 					 octal value.  This permits Fig files to
	//// 					 be edited with 7-bit editors and sent
	//// 					 by e-mail without data loss.
	//// 					 Note that the string may contain '\n'.)
	////
	////     The font_flags field is defined as follows:
	////
	//// 	 Bit	Description
	////
	//// 	  0	Rigid text (text doesn't scale when scaling compound objects)
	//// 	  1	Special text (for LaTeX)
	//// 	  2	PostScript font (otherwise LaTeX font is used)
	//// 	  3	Hidden text
	////
	////     The font field is defined as follows:
	////
	//// 	For font_flags bit 2 = 0 (LaTeX fonts):
	////
	//// 	 0	Default font
	//// 	 1	Roman
	//// 	 2	Bold
	//// 	 3	Italic
	//// 	 4	Sans Serif
	//// 	 5	Typewriter
	////
	//// 	For font_flags bit 3 = 1 (PostScript fonts):
	////
	//// 	-1	Default font
	//// 	 0	Times Roman
	//// 	 1	Times Italic
	//// 	 2	Times Bold
	//// 	 3	Times Bold Italic
	//// 	 4	AvantGarde Book
	//// 	 5	AvantGarde Book Oblique
	//// 	 6	AvantGarde Demi
	//// 	 7	AvantGarde Demi Oblique
	//// 	 8	Bookman Light
	//// 	 9	Bookman Light Italic
	//// 	10	Bookman Demi
	//// 	11	Bookman Demi Italic
	//// 	12	Courier
	//// 	13	Courier Oblique
	//// 	14	Courier Bold
	//// 	15	Courier Bold Oblique
	//// 	16	Helvetica
	//// 	17	Helvetica Oblique
	//// 	18	Helvetica Bold
	//// 	19	Helvetica Bold Oblique
	//// 	20	Helvetica Narrow
	//// 	21	Helvetica Narrow Oblique
	//// 	22	Helvetica Narrow Bold
	//// 	23	Helvetica Narrow Bold Oblique
	//// 	24	New Century Schoolbook Roman
	//// 	25	New Century Schoolbook Italic
	//// 	26	New Century Schoolbook Bold
	//// 	27	New Century Schoolbook Bold Italic
	//// 	28	Palatino Roman
	//// 	29	Palatino Italic
	//// 	30	Palatino Bold
	//// 	31	Palatino Bold Italic
	//// 	32	Symbol
	//// 	33	Zapf Chancery Medium Italic
	//// 	34	Zapf Dingbats
	//// */
	////
	///#endif


	/* geographical info system */
	/* #include "grass.trm" */

	/* HP2623A and probably others */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hp26.trm,v 1.19 2007/01/16 23:11:55 sfeam Exp $
	 */

	/* GNUPLOT - HP26.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  HP2623A
	 *
	 * AUTHORS
	 *   luecken@udel.edu (Bruce Lueckenhoff)
	 *   hplvlch!ch (Chuck Heller)
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(hp2623a)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HP26_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HP26_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HP26_init __PROTO((void));
	//TERM_PUBLIC void HP26_graphics __PROTO((void));
	//TERM_PUBLIC void HP26_text __PROTO((void));
	//TERM_PUBLIC void HP26_reset __PROTO((void));
	//TERM_PUBLIC int HP26_text_angle __PROTO((int ang));
	//TERM_PUBLIC void HP26_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void HP26_linetype __PROTO((int linetype));
	//TERM_PUBLIC void HP26_line_and_point __PROTO((unsigned int x, unsigned int y, int number));
	//
	///#define HP26_XMAX 512
	///#define HP26_YMAX 390
	//
	// /* Use a size 1 character, or a 7 x 10 grid. */
	///#define HP26_VCHAR	10
	///#define HP26_HCHAR	7
	///#define HP26_VTIC	5
	///#define HP26_HTIC	5
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#define HP26_XLAST (HP26_XMAX - 1)
	///#define HP26_YLAST (HP26_XMAX - 1)
	//
	//static void HP26_do_point __PROTO((unsigned int x, unsigned int y, int number));
	//static struct _HP26_Buffer_Node *BN_create __PROTO((int index, int size, int linetype));
	//static void BN_delete __PROTO((struct _HP26_Buffer_Node * the_node));
	//static int HP26_flush __PROTO((struct _HP26_Buffer_Node * the_buff));
	//static void HP26_handle_overflow __PROTO((void));
	//
	//typedef struct _HP26_Buffer_Node {
	//    int index;
	//    int size;
	//    int next;
	//    int linetype;
	//    int *x;
	//    int *y;
	//    TBOOLEAN *isa_move;
	//} HP26_Buffer_Node;
	//
	// /* constructor method */
	//static HP26_Buffer_Node *
	//BN_create(int index, int size, int linetype)
	//{
	//    HP26_Buffer_Node *the_node;
	//    the_node = (HP26_Buffer_Node *) gp_alloc(sizeof(HP26_Buffer_Node), "HP26");
	//    if (the_node) {
	//	the_node->index = index;
	//	the_node->linetype = linetype;
	//	the_node->size = size;
	//	the_node->next = 0;
	//	the_node->x = (int *) gp_alloc(size*sizeof(int), "HP26");
	//	the_node->y = (int *) gp_alloc(size*sizeof(int), "HP26");
	//	the_node->isa_move = (TBOOLEAN *) gp_alloc(size*sizeof(TBOOLEAN), "HP26");
	//	if (the_node->x == NULL || the_node->y == NULL || the_node->isa_move == NULL)
	//	    return (NULL);
	//    }
	//    memset(the_node->isa_move, 0, size*sizeof(TBOOLEAN));
	//    return (the_node);
	//}
	//
	// /* destructor method */
	//static void
	//BN_delete(HP26_Buffer_Node *the_node)
	//{
	//    free(the_node->x);
	//    free(the_node->y);
	//    free(the_node->isa_move);
	//    free(the_node);
	//}
	//
	// /* 2 for border and axes + 9 for plots + 1 for dots */
	///#define HP26_gnu_map_size 12
	//static HP26_Buffer_Node *HP26_gnu_map[HP26_gnu_map_size];
	//static HP26_Buffer_Node *HP26_buff;
	//static int HP26_pen_x;
	//static int HP26_pen_y;
	//static int HP26_angle;
	//static int HP26_cursor_x;
	//static int HP26_cursor_y;
	//static TBOOLEAN HP26_in_text;
	//static int HP26_linetype_current;
	//static int HP26_reduction_int;
	//static int HP26_reduction_slope;
	//static int HP26_overflows;
	//static int HP26_nop_move;
	//static int HP26_nop_vect;
	//static int HP26_nop_line;
	//
	// /* linetype stuff */
	///#define	SOLID	1
	///#define	USER	2
	///#define LINE3	3
	///#define LINE4	4
	///#define LINE5	5
	///#define LINE6	6
	///#define	DOTS	7
	///#define LINE8	8
	///#define LINE9	9
	///#define LINE10	10
	///#define POINT	11
	//
	//
	//
	///#define swap(a, b) a ^= b; b ^= a; a ^= b;
	//
	//static char HP26_bin_short_table[32] =
	//{
	//    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>',
	//    '?', ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-',
	//    '.', '/'
	//};
	// /* encodes an integer (assumed to be in range) into
	//    binary short incremental format (j)*/
	///#define short_encode(n) (HP26_bin_short_table[n+16])
	//
	// /* tells whether a given delta_x,delta_y pair can be expressed in
	//    binary short incremental format */
	///#define qualified(dx,dy) ((dx>-17)&&(dy>-17)&&(dx<16)&&(dy<16))
	//
	//
	//static char HP26_bin_table[32] =
	//{
	//    ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-',
	//    '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<',
	//    '=', '>', '?'
	//};
	// /* returns the high byte of integer n in binary absolute format (i) */
	///#define bin_encode_hi(n) (HP26_bin_table[n>>5])
	// /* returns the low byte of integer n in binary absolute format (i) */
	///#define bin_encode_lo(n) (HP26_bin_table[n & 31])
	//
	//
	//
	// /* the guts of the program
	// -- first checks if any work need be done and, failing that, returns
	// 	immediately
	// -- tries to compress the vector stream
	// -- goes through the buffer, using binary short incremental (2 bytes/point)
	// 	as much as possible, even if must output two pairs to express one vector
	// 	(it's no more expensive, and will hopefully damp any excessive switching
	// 	back and forth between the two formats)
	// 	if can't use binary short incremental, use binary
	// 	absolute(4 bytes/point)
	// -- finally, resets the HP26_next pointer to zero    */
	//static int
	//HP26_flush(HP26_Buffer_Node *the_buff)
	//{
	//    int i, delta_x, delta_y, half_dx, half_dy;
	//    int *buff_x, *buff_y;
	//    TBOOLEAN *isa_move;
	//    TBOOLEAN bin_short;
	//
	//    if (the_buff->next == 0)
	//	return (FALSE);
	// /* init pointers for easy access */
	//    buff_x = the_buff->x;
	//    buff_y = the_buff->y;
	//    isa_move = the_buff->isa_move;
	//    if (HP26_in_text) {
	//	fputs("\033*dT", gpoutfile);
	//	HP26_in_text = FALSE;
	//    }
	//    if (HP26_linetype_current != the_buff->linetype
	//	&& (the_buff->next > 1 || !isa_move[0])) {
	//	fprintf(gpoutfile, "\033*m%dB", the_buff->linetype);
	//	HP26_linetype_current = the_buff->linetype;
	//    }
	//
	// /* start escape sequence */
	//    fputs("\033*p", gpoutfile);
	// /* initialize the state:  binary short incremental or binary absolute */
	//    delta_x = buff_x[0] - HP26_pen_x;
	//    delta_y = buff_y[0] - HP26_pen_y;
	//    if (qualified(delta_x, delta_y)) {
	//	fputc('j', gpoutfile);
	//	bin_short = TRUE;
	//    } else {
	//	fputc('i', gpoutfile);
	//	bin_short = FALSE;
	//    }
	// /* now work through the list */
	//    for (i = 0; i < the_buff->next; i++) {
	//	if (i > 0) {
	//	    delta_x = buff_x[i] - buff_x[i - 1];
	//	    delta_y = buff_y[i] - buff_y[i - 1];
	//	}
	//	if ((delta_x == 0) && (delta_y == 0)) {
	//	    if (i > 0 && !isa_move[i - 1] && !isa_move[i]) {
	// /* allow null vectors only when drawing dots */
	//		HP26_nop_vect++;
	//		continue;
	//	    } else if (isa_move[i]) {
	// /* a null move */
	//		HP26_nop_move++;
	//		continue;
	//	    }
	//	} else if (i > 0
	//		   && i + 1 < the_buff->next
	//		   && isa_move[i]
	//		   && isa_move[i + 1]) {
	// /* consecutive moves are condensed into one */
	//	    HP26_nop_move++;
	//	    continue;
	//	} else if (!qualified(delta_x, delta_y)
	//		   && i > 0
	//		   && i + 2 < the_buff->next
	//		   && isa_move[i]
	//		   && !isa_move[i + 1]
	//		   && isa_move[i + 2]
	//		   && qualified(buff_x[i + 1] - buff_x[i - 1], buff_y[i + 1] - buff_y[i - 1])) {
	//	    swap(buff_x[i], buff_x[i + 1]);
	//	    swap(buff_y[i], buff_y[i + 1]);
	// /* set up new delta_x & delta_y */
	//	    delta_x = buff_x[i] - buff_x[i - 1];
	//	    delta_y = buff_y[i] - buff_y[i - 1];
	//	}
	//	if (qualified(delta_x, delta_y)) {
	//	    if (!bin_short) {
	//		fputc('j', gpoutfile);
	//		bin_short = TRUE;
	//	    }
	//	    if (isa_move[i])
	//		fputc('a', gpoutfile);
	//	    fputc(short_encode(delta_x), gpoutfile);
	//	    fputc(short_encode(delta_y), gpoutfile);
	//	} else {
	//	    half_dx = (delta_x + (delta_x > 0 ? 1 : -1)) / 2;
	//	    half_dy = (delta_y + (delta_y > 0 ? 1 : -1)) / 2;
	//	    if (bin_short && qualified(half_dx, half_dy)) {
	//		if (isa_move[i])
	//		    fputc('a', gpoutfile);
	//		fputc(short_encode(half_dx), gpoutfile);
	//		fputc(short_encode(half_dy), gpoutfile);
	//		if (isa_move[i])
	//		    fputc('a', gpoutfile);
	//		fputc(short_encode(delta_x - half_dx), gpoutfile);
	//		fputc(short_encode(delta_y - half_dy), gpoutfile);
	//	    } else {
	//		if (bin_short) {
	//		    bin_short = FALSE;
	//		    fputc('i', gpoutfile);
	//		}
	//		if (isa_move[i])
	//		    fputc('a', gpoutfile);
	//		fputc(bin_encode_hi(buff_x[i]), gpoutfile);
	//		fputc(bin_encode_lo(buff_x[i]), gpoutfile);
	//		fputc(bin_encode_hi(buff_y[i]), gpoutfile);
	//		fputc(bin_encode_lo(buff_y[i]), gpoutfile);
	//	    }
	//	}
	//    }				// end for.. 
	// /* the term doesn't seem to mind leaving this out */
	// /* finish the escape sequence */
	//    fputc('Z', gpoutfile);
	// /* set these for next time */
	//    HP26_pen_x = buff_x[the_buff->next - 1];
	//    HP26_pen_y = buff_y[the_buff->next - 1];
	//    the_buff->next = 0;
	//    return (TRUE);
	//}
	//
	//static void
	//HP26_handle_overflow()
	//{
	//    HP26_Buffer_Node *bigger, *old;
	//    int x, y;
	//    x = (HP26_buff->x)[HP26_buff->next - 1];
	//    y = (HP26_buff->y)[HP26_buff->next - 1];
	//    HP26_flush(HP26_buff);
	//    bigger = BN_create(HP26_buff->index, HP26_buff->size * 2,
	//		       HP26_buff->linetype);
	//    if (bigger != NULL) {
	//	old = HP26_buff;
	//	HP26_gnu_map[bigger->index] = bigger;
	// /* special case since DOTS entry is shared 3 ways */
	//	if (bigger->index == 0) {
	//	    HP26_gnu_map[1] = bigger;
	//	    HP26_gnu_map[3] = bigger;
	//	}
	//	HP26_buff = bigger;
	//	BN_delete(old);
	//    }
	//    (HP26_buff->x)[0] = x;
	//    (HP26_buff->y)[0] = y;
	//    (HP26_buff->isa_move)[0] = TRUE;
	//    HP26_buff->next = 1;
	//    HP26_overflows++;
	//}
	//
	// /* checks for NOP, overcapacity condition, and then adds vector to the list */
	//TERM_PUBLIC void
	//HP26_vector(unsigned int x, unsigned int y)
	//{
	//    if (HP26_buff->next > 2
	//	&& x == (HP26_buff->x)[HP26_buff->next - 1]
	//	&& y == (HP26_buff->y)[HP26_buff->next - 1]
	//	&& !(HP26_buff->isa_move)[HP26_buff->next - 1]) {
	//	HP26_nop_vect++;
	//	return;
	//    }
	//    if (HP26_buff->next == HP26_buff->size)
	//	HP26_handle_overflow();
	// /* otherwise add to the list */
	//    (HP26_buff->x)[HP26_buff->next] = x;
	//    (HP26_buff->y)[HP26_buff->next] = y;
	//    (HP26_buff->isa_move)[HP26_buff->next] = FALSE;
	//    HP26_buff->next++;
	//}
	//
	// /* checks for NOP, checks for overcapacity, puts self on list */
	//TERM_PUBLIC void
	//HP26_move(unsigned int x, unsigned int y)
	//{
	//    if (HP26_buff->next > 0) {
	//	if (((HP26_buff->x)[HP26_buff->next - 1] == x)
	//	    && ((HP26_buff->y)[HP26_buff->next - 1] == y)) {
	// /* null moves are NOP's */
	//	    HP26_nop_move++;
	//	    return;
	//	} else if ((HP26_buff->isa_move)[HP26_buff->next - 1]) {
	// /* consecutive moves are NOP's */
	//	    (HP26_buff->x)[HP26_buff->next - 1] = x;
	//	    (HP26_buff->y)[HP26_buff->next - 1] = y;
	//	    HP26_nop_move++;
	//	    return;
	//	}
	//    }
	//    if (HP26_buff->next == HP26_buff->size)
	//	HP26_handle_overflow();
	//    (HP26_buff->x)[HP26_buff->next] = x;
	//    (HP26_buff->y)[HP26_buff->next] = y;
	//    (HP26_buff->isa_move)[HP26_buff->next] = TRUE;
	//    HP26_buff->next++;
	//    return;
	//}
	//
	//TERM_PUBLIC void
	//HP26_init()
	//{
	//    HP26_gnu_map[-2 + 2] = BN_create(0, 2048, DOTS);	// border 
	//    HP26_gnu_map[-1 + 2] = HP26_gnu_map[-2 + 2];	// axes 
	//    HP26_gnu_map[0 + 2] = BN_create(2, 3072, SOLID);	// plot 0 
	//    HP26_gnu_map[1 + 2] = HP26_gnu_map[-2 + 2];		// plot 1 
	//    HP26_gnu_map[2 + 2] = BN_create(4, 1024, LINE5);	// plot 2 
	//    HP26_gnu_map[3 + 2] = BN_create(5, 256, LINE6);	// plot 3 
	//    HP26_gnu_map[4 + 2] = BN_create(6, 256, LINE8);	// plot 4 
	//    HP26_gnu_map[5 + 2] = BN_create(7, 128, LINE9);	// plot 5 
	//    HP26_gnu_map[6 + 2] = BN_create(8, 128, LINE10);	// plot 6 
	//    HP26_gnu_map[7 + 2] = BN_create(9, 64, LINE6);	// plot 7 
	//    HP26_gnu_map[8 + 2] = BN_create(10, 64, LINE4);	// plot 8 
	//    HP26_gnu_map[9 + 2] = BN_create(11, 512, POINT);	// point plot 
	//    HP26_buff = HP26_gnu_map[10];	// set to an unlikely linetype 
	//    HP26_linetype_current = 0;	// set to force a linetype change 
	//    HP26_angle = 1;		// left to right, default 
	//    fputs("\033*mp1m2a2Q", gpoutfile);
	// /*           1 2 3 4
	//    1.  make text upright
	//    2.  select text size 1
	//    3.  make SET the default drawing op
	//    4.  left justify text */
	//    fflush(gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//HP26_graphics()
	//{
	//    fputs("\033*daflsC", gpoutfile);
	// /*           12345
	//    1.  clear graphics display
	//    2.  shut off the alphanumeric display
	//    3.  graphics cursor off
	//    4.  into graphics text mode
	//    5.  enable graphics display */
	// /* set the pen & cursor positions to force an initial absolute move */
	//    HP26_pen_x = HP26_pen_y = -200;
	//    HP26_cursor_x = HP26_cursor_y = 800;
	//    HP26_in_text = TRUE;
	// /* initialize statistics */
	//    HP26_reduction_int = 0;
	//    HP26_reduction_slope = 0;
	//    HP26_nop_move = 0;
	//    HP26_nop_vect = 0;
	//    HP26_nop_line = 0;
	//    HP26_overflows = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//HP26_text()
	//{
	//    int i, j, curr;
	//
	// /* always flush the current line first */
	//    for (i = 0; i < HP26_gnu_map_size; i++)
	//	if ((HP26_gnu_map[i])->linetype == HP26_linetype_current)
	//	    HP26_flush(HP26_gnu_map[i]);
	// /* now flush the rest of the lines */
	//    for (i = 0; i < HP26_gnu_map_size; i++) {
	//	HP26_flush(HP26_gnu_map[i]);
	//	curr = HP26_gnu_map[i]->linetype;
	//	for (j = 0; j < HP26_gnu_map_size; j++)
	//	    if ((HP26_gnu_map[j])->linetype == curr)
	//		HP26_flush(HP26_gnu_map[j]);
	//    }
	//    fputs("\033*deT", gpoutfile);
	// /*           12
	//    1. turn on the alphanumeric display
	//    2. back to text mode */
	//    fflush(gpoutfile);
	// /* informational:  tells how many points compressed, how
	//    many NOP's of each type, and how many times a buffer
	//    overflowed during this plot */
	// /*
	//    if(HP26_reduction_int
	//    + HP26_reduction_slope
	//    + HP26_nop_move
	//    + HP26_nop_vect
	//    + HP26_overflows
	//    + HP26_nop_line > 0){
	//    if (HP26_reduction_int>0)
	//    printf("%d int-compress",HP26_reduction_int);
	//    if (HP26_reduction_slope>0)
	//    printf("%d slope-compress",HP26_reduction_slope);
	//    if (HP26_nop_move>0)
	//    printf("  %d nop_move",HP26_nop_move);
	//    if (HP26_nop_vect>0)
	//    printf("  %d nop_vect",HP26_nop_vect);
	//    if (HP26_nop_line>0)
	//    printf("  %d nop_line",HP26_nop_line);
	//    if (HP26_overflows>0)
	//    printf("  %d buffer overflows",HP26_overflows);
	//    printf("\n");
	//    }
	//  */
	//}
	//
	//TERM_PUBLIC void
	//HP26_reset()
	//{
	//    int i;
	//    for (i = 2; i < HP26_gnu_map_size; i++)
	//	BN_delete(HP26_gnu_map[i]);
	//}
	//
	//TERM_PUBLIC int
	//HP26_text_angle(int ang)
	//{
	//    HP26_angle = (ang ? 2 : 1);
	//    fprintf(gpoutfile, "\033*m%dN", HP26_angle);
	//    return (TRUE);
	//}
	//
	//
	//TERM_PUBLIC void
	//HP26_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char abs_str[10], rel_str[10];
	//
	//    if (!strlen(str))
	//	return;
	//    else {
	//	fputs("\033*d", gpoutfile);
	//	if (!HP26_in_text) {
	//	    fputc('s', gpoutfile);
	//	    HP26_in_text = TRUE;
	//	}
	//	sprintf(rel_str, "%d,%dP", x - HP26_cursor_x, y - HP26_cursor_y);
	//	sprintf(abs_str, "%d,%dO", x, y);
	//	if (strlen(rel_str) < strlen(abs_str))
	//	    fputs(rel_str, gpoutfile);
	//	else
	//	    fputs(abs_str, gpoutfile);
	//	fputs(str, gpoutfile);
	//	HP26_pen_x = HP26_cursor_x = x;
	//	HP26_pen_y = HP26_cursor_y = y;
	//    }
	// /*
	//    tmp = &(HP26_all_buffers[HP26_linetype_current]);
	//    tmp->x[tmp->next] = x;
	//    tmp->y[tmp->next] = y;
	//    tmp->isa_move[tmp->next] = TRUE;
	//    tmp->next++;
	//    HP26_flush(tmp);
	//    fprintf(gpoutfile,"\033*l%s\r",str);
	//  */
	//    return;
	//}
	//
	//
	// /* checks for NOP, sets HP26_buff to point to the right buffer */
	//TERM_PUBLIC void
	//HP26_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype > 8)
	//	linetype %= 9;
	//    linetype += 2;
	//    if (HP26_gnu_map[linetype] == HP26_buff) {
	//	HP26_nop_line++;
	//	return;			// gnuplot just sent us another NOP 
	//    }
	//    HP26_buff = HP26_gnu_map[linetype];
	//}
	//
	//
	//
	// /* switches to a solid linetype and calls do_point, then switches back */
	//TERM_PUBLIC void
	//HP26_line_and_point(unsigned int x, unsigned int y, int number)
	//{
	//    int line_save, not_solid;
	//
	// /* shut up warnings with dummy initializer  -SB */
	//    line_save = 0;
	//    not_solid = (HP26_buff->linetype != SOLID);
	//    if (not_solid) {
	//	line_save = HP26_buff->linetype;
	//	HP26_linetype(0);	//switch to a solid line 
	//    }
	//    HP26_do_point(x, y, number);
	//    if (not_solid)
	//	HP26_linetype(line_save);
	//}
	//
	//
	// /* provides 9 point types so they stay in sync with the linetypes
	// puts simpler point types first on the assumption they are more
	// frequently used */
	//static void
	//HP26_do_point(unsigned int x, unsigned int y, int number)
	//{
	//    int htic, vtic;
	//    HP26_Buffer_Node *tmp;
	//
	//    vtic = HP26_VTIC / 2;
	//    htic = HP26_HTIC / 2;
	//    if (number < 0) {
	// /* do a dot -- special case */
	//	tmp = HP26_buff;
	//	HP26_buff = HP26_gnu_map[11];	// point plot 
	//	HP26_vector(x, y);
	//	HP26_buff = tmp;
	//    }
	//    switch (number % 9) {
	//    case 0:
	// /* do triangle */
	//	HP26_move(x - htic, y - vtic);
	//	HP26_vector(x, y + vtic);
	//	HP26_vector(x + htic, y - vtic);
	//	HP26_vector(x - htic, y - vtic);
	//	break;
	//    case 1:
	// /* do nambla */
	//	HP26_move(x - htic, y + vtic);
	//	HP26_vector(x, y - vtic);
	//	HP26_vector(x + htic, y + vtic);
	//	HP26_vector(x - htic, y + vtic);
	//	break;
	//    case 2:
	// /* do left triangle */
	//	HP26_move(x - htic, y);
	//	HP26_vector(x + htic, y + vtic);
	//	HP26_vector(x + htic, y - vtic);
	//	HP26_vector(x - htic, y);
	//	break;
	//    case 3:
	// /* do right triangle */
	//	HP26_move(x + htic, y);
	//	HP26_vector(x - htic, y + vtic);
	//	HP26_vector(x - htic, y - vtic);
	//	HP26_vector(x + htic, y);
	//	break;
	//    case 4:
	// /* do box */
	//	HP26_move(x - htic, y - vtic);
	//	HP26_vector(x - htic, y + vtic);
	//	HP26_vector(x + htic, y + vtic);
	//	HP26_vector(x + htic, y - vtic);
	//	HP26_vector(x - htic, y - vtic);
	//	break;
	//    case 5:
	// /* do plus */
	//	HP26_move(x, y + vtic);
	//	HP26_vector(x, y - vtic);
	//	HP26_move(x - htic, y);
	//	HP26_vector(x + htic, y);
	//	break;
	//    case 6:
	// /* do X */
	//	HP26_move(x + htic, y + vtic);
	//	HP26_vector(x - htic, y - vtic);
	//	HP26_move(x - htic, y + vtic);
	//	HP26_vector(x + htic, y - vtic);
	//	break;
	//    default:
	// /* do diamond */
	//	HP26_move(x, y - vtic);
	//	HP26_vector(x - htic, y);
	//	HP26_vector(x, y + vtic);
	//	HP26_vector(x + htic, y);
	//	HP26_vector(x, y - vtic);
	//	break;
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(hp2623a_driver)
	//    "hp2623A", "HP2623A and maybe others",
	//    HP26_XMAX, HP26_YMAX, HP26_VCHAR, HP26_HCHAR,
	//    HP26_VTIC, HP26_HTIC, options_null, HP26_init, HP26_reset,
	//    HP26_text, null_scale, HP26_graphics, HP26_move, HP26_vector,
	//    HP26_linetype, HP26_put_text, HP26_text_angle,
	//    null_justify_text, HP26_line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(hp2623a_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hp2623a_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(hp2623a)
	//"1 hp2623a",
	//"?commands set terminal hp2623a",
	//"?set terminal hp2623a",
	//"?set term hp2623a",
	//"?terminal hp2623a",
	//"?term hp2623a",
	//"?hp2623a",
	//" The `hp2623a` terminal driver supports the Hewlett Packard HP2623A.  It has",
	//" no options."
	//END_HELP(hp2623a)
	///#endif


	/* HP2647 and 2648 */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hp2648.trm,v 1.13 2006/07/21 02:35:47 sfeam Exp $
	 *
	 */

	/* GNUPLOT -  hp2648.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  HP2648 and HP2647
	 *
	 * AUTHORS
	 *  Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(hp2648)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HP2648init __PROTO((void));
	//TERM_PUBLIC void HP2648graphics __PROTO((void));
	//TERM_PUBLIC void HP2648text __PROTO((void));
	//TERM_PUBLIC void HP2648linetype __PROTO((int linetype));
	//TERM_PUBLIC void HP2648move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HP2648vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HP2648put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int HP2648_text_angle __PROTO((int ang));
	//TERM_PUBLIC void HP2648reset __PROTO((void));
	//
	///#define HP2648XMAX 720
	///#define HP2648YMAX 360
	//
	///#define HP2648VCHAR		12
	///#define HP2648HCHAR		7
	///#define HP2648VTIC		8
	///#define HP2648HTIC		8
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	///#define HP2648XLAST (HP2648XMAX - 1)
	///#define HP2648YLAST (HP2648YMAX - 1)
	//
	//
	//TERM_PUBLIC void
	//HP2648init()
	//{
	//    fprintf(gpoutfile, "\033*m1m1n136,1cZ");
	// /*                   1     2 3     4
	// 	1. mode
	// 	2. textsize=1
	// 	3. textangle=1
	//         4. define line type 2 to be *   *   *   * etc.
	// */
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648graphics()
	//{
	//    fprintf(gpoutfile, "\033*dacZ");
	// /*                   1     23
	// 	1. mode
	// 	2. clear grahics screen
	// 	3. graphics video on
	// */
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648text()
	//{
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648linetype(int linetype)
	//{
	//    static int hpline[] = { 1, 7, 1, 4, 5, 6, 8, 9, 10, 7, 2 };
	//    fprintf(gpoutfile, "\033*m%dbZ", hpline[(linetype + 2) % 11]);
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648move(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "\033*paf%d,%dZ", x, y);
	// /*               1     23     4
	//    1        plot mode
	//    2        "pen up"
	//    3        goto absolute x,y
	//    4        end command
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648vector(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "\033*pbf%d,%dZ", x, y);
	// /*                     1
	//    1        "pen down"
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//HP2648put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    HP2648move(x, y - HP2648VCHAR / 2 + 1);
	//    fprintf(gpoutfile, "\033*l%s\n", str);
	//}
	//
	//
	//TERM_PUBLIC int
	//HP2648_text_angle(int ang)
	//{
	//int hp_ang = (ang ? 1 : 0);
	//
	//    fprintf(gpoutfile, "\033*m%dnZ\n", hp_ang+1);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//HP2648reset()
	//{
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(hp2648_driver)
	//    "hp2648", "HP2648 and HP2647",
	//    HP2648XMAX, HP2648YMAX, HP2648VCHAR, HP2648HCHAR,
	//    HP2648VTIC, HP2648HTIC, options_null, HP2648init, HP2648reset,
	//    HP2648text, null_scale, HP2648graphics, HP2648move, HP2648vector,
	//    HP2648linetype, HP2648put_text, HP2648_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(hp2648_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hp2648_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(hp2648)
	//"1 hp2648",
	//"?commands set terminal hp2648",
	//"?set terminal hp2648",
	//"?set term hp2648",
	//"?terminal hp2648",
	//"?term hp2648",
	//"?hp2648",
	//" The `hp2648` terminal driver supports the Hewlett Packard HP2647 and HP2648.",
	//" It has no options."
	//END_HELP(hp2648)
	///#endif


	/* HP DeskJet 500 C */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hp500c.trm,v 1.17 2006/07/21 02:35:47 sfeam Exp $
	 *
	 */

	/* GNUPLOT - hp500c.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  hpdj 500c
	 *
	 * AUTHORS
	 *  John Engels      --
	 *  Russell Lang     ----> HPLJII.trm
	 *  Maurice Castro   -- /
	 *  UdoHessenauer    ----> derived this version from the above one
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* The following HP Deskjet500c  driver uses generic bit mapped graphics
	   routines from bitmap.c to build up a bit map in memory.  The driver
	   interchanges colomns and lines in order to access entire lines
	   easily and returns the lines to get bits in the right order :
	   (x,y) -> (y,XMAX-1-x). */
	/* This interchange is done by calling b_makebitmap() with reversed
	   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
	   will then perform the interchange before each pixel is plotted */
	/* by John Engels JENGELS@BNANDP51.BITNET, inspired by the hpljet driver
	   of Jyrki Yli-Nokari */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(hp500c)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HP500C_options __PROTO((void));
	//TERM_PUBLIC void HP500C_init __PROTO((void));
	//TERM_PUBLIC void HP500C_reset __PROTO((void));
	//TERM_PUBLIC void HP500C_linetype __PROTO((int linetype));
	//TERM_PUBLIC void HP500C_graphics __PROTO((void));
	//TERM_PUBLIC void HP500C_text __PROTO((void));
	// /* default values for term_tbl */
	///#define HP500C_75PPI_XMAX (1920/4)
	///#define HP500C_75PPI_YMAX (1920/4)
	///#define HP500C_75PPI_HCHAR (1920/4/6)
	///#define HP500C_75PPI_VCHAR (1920/4/10)
	///#define HP500C_75PPI_VTIC 5
	///#define HP500C_75PPI_HTIC 5
	//
	///#define GOT_HP500C_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//
	// /* We define 4 different print qualities : 300ppi, 150ppi, 100ppi and
	//    75ppi.  (Pixel size = 1, 2, 3, 4 dots) */
	//
	///#define HP500C_DPP (hpdj_dpp)	// dots per pixel 
	///#define HP500C_PPI (300/HP500C_DPP)	// pixel per inch 
	// /* make XMAX and YMAX a multiple of 8 */
	///#define HP500C_XMAX (8*(unsigned int)(xsize*1920/HP500C_DPP/8.0+0.9))
	///#define HP500C_YMAX (8*(unsigned int)(ysize*1920/HP500C_DPP/8.0+0.9))
	//
	// /* Courier font with 6 lines per inch */
	///#define HP500C_VCHAR (HP500C_PPI/6)
	// /* Courier font with 10 caracters per inch */
	///#define HP500C_HCHAR (HP500C_PPI/10)
	//
	//
	// /* Save current cursor position */
	///#define HP500C_PUSH_CURSOR fputs("\033&f0S",gpoutfile)
	// /* Restore cursor position */
	///#define HP500C_POP_CURSOR fputs("\033&f1S",gpoutfile)
	//
	// /* be sure to use courier font with 6lpi and 10cpi */
	///#define HP500C_COURIER fputs("\033(0N\033(s0p10.0h12.0v0s0b3T\033&l6D",gpoutfile)
	//
	//
	//static int HP_compress __PROTO((unsigned char *op, unsigned char *oe,
	//			       unsigned char *cp));
	//static unsigned char HP_complement __PROTO((int c));
	//static int HP_compress_to_TIFF __PROTO((unsigned char *op, unsigned char *oe,
	//				       unsigned char *cp));
	//static int HP_nocompress __PROTO((unsigned char *op, unsigned char *oe,
	//				 unsigned char *cp));
	//
	//static int hpdj_dpp = 4;
	//static int HP_COMP_MODE = 0;
	//
	// /* bm_pattern not appropriate for 300ppi graphics */
	///#ifndef GOT_300_PATTERN
	///#define GOT_300_PATTERN
	//static unsigned int b_300ppi_pattern[] =
	//{
	//    0xffff, 0x1111,
	//    0xffff, 0x3333, 0x0f0f, 0x3f3f, 0x0fff, 0x00ff, 0x33ff
	//};
	///#endif
	//
	//
	//TERM_PUBLIC void
	//HP500C_options()
	//{
	//    char opt[6];
	//
	///#define HPDJCERROR "expecting dots per inch size 75, 100, 150 or 300 and/or compression method"
	//    while (!END_OF_COMMAND) {
	//	if (token[c_token].length > 4)
	//	    int_error(c_token, HPDJCERROR);
	//
	// /* almost_equals() won't accept numbers - use strcmp() instead */
	//	capture(opt, c_token, c_token, 6);
	//	if (!strcmp(opt, "75")) {
	//	    hpdj_dpp = 4;
	//	    HP_COMP_MODE = 0;
	//
	//	} else if (!strcmp(opt, "100")) {
	//	    hpdj_dpp = 3;
	//	    HP_COMP_MODE = 0;
	//	} else if (!strcmp(opt, "150")) {
	//	    hpdj_dpp = 2;
	//	    HP_COMP_MODE = 0;
	//	} else if (!strcmp(opt, "300")) {
	//	    hpdj_dpp = 1;
	//	    HP_COMP_MODE = 0;
	//	} else if (!strcmp(opt, "rle")) {
	//	    HP_COMP_MODE = 1;
	//	} else if (!strcmp(opt, "tiff")) {
	//	    HP_COMP_MODE = 2;
	//	}
	//	c_token++;
	//    }
	//
	//    term->xmax = HP500C_XMAX;
	//    term->ymax = HP500C_YMAX;
	//    switch (hpdj_dpp) {
	//    case 1:
	//	strcpy(term_options, "300");
	//	term->v_tic = 15;
	//	term->h_tic = 15;
	//	break;
	//    case 2:
	//	strcpy(term_options, "150");
	//	term->v_tic = 8;
	//	term->h_tic = 8;
	//	break;
	//    case 3:
	//	strcpy(term_options, "100");
	//	term->v_tic = 6;
	//	term->h_tic = 6;
	//	break;
	//    case 4:
	//	strcpy(term_options, "75");
	//	term->v_tic = 5;
	//	term->h_tic = 5;
	//	break;
	//    }
	//    switch (HP_COMP_MODE) {
	//    case 0:
	//	strcat(term_options, " no comp");
	//	break;
	//    case 1:
	//	strcat(term_options, " RLE");
	//	break;
	//    case 2:
	//	strcat(term_options, " TIFF");
	//	break;
	//    case 3:			// not implemented yet 
	//	strcat(term_options, " Delta Row");
	//	break;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HP500C_init()
	//{
	// /* HBB 980226: all changes to term-> fields *must* happen here, not
	//  * in graphics() !*/
	//    switch (hpdj_dpp) {
	//    case 1:
	//	b_charsize(FNT13X25);
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	break;
	//    case 2:
	//	b_charsize(FNT13X25);
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	break;
	//    case 3:
	//	b_charsize(FNT9X17);
	//	term->v_char = FNT9X17_VCHAR;
	//	term->h_char = FNT9X17_HCHAR;
	//	break;
	//    case 4:
	//	b_charsize(FNT5X9);
	//	term->v_char = FNT5X9_VCHAR;
	//	term->h_char = FNT5X9_HCHAR;
	//	break;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HP500C_reset()
	//{
	///#ifdef VMS
	//    fflush_binary();
	///#endif
	//}
	//
	//
	//
	// /* HP DeskJet 500c routines */
	//
	//TERM_PUBLIC void
	//HP500C_linetype(int linetype)
	//{
	//    if (linetype < 0)
	//	linetype = 7;
	//    else if (linetype >= 8) {
	//	linetype %= 8;
	//    }
	//    switch (linetype) {
	//    case 0:
	//	linetype = 6;
	//	break;
	//    case 1:
	//	linetype = 5;
	//	break;
	//    case 2:
	//	linetype = 3;
	//	break;
	//    case 3:
	//	linetype = 2;
	//	break;
	//    case 4:
	//	linetype = 1;
	//	break;
	//    case 5:
	//	linetype = 4;
	//	break;
	//    case 6:
	//	linetype = 7;
	//    }
	//    b_setvalue(linetype);
	//
	//}
	//
	///#if 0
	//void
	//HP500C_point(unsigned int x, unsigned int y, int value)
	//{
	//    HP500C_linetype(value);
	//    do_point(x,y,value);
	//}
	///#endif
	//
	//TERM_PUBLIC void
	//HP500C_graphics()
	//{
	// /* HBB 980226: moved block of code from here to init() */
	// /* rotate plot -90 degrees by reversing XMAX and YMAX and by
	//    setting b_rastermode to TRUE */
	//    b_makebitmap(HP500C_YMAX, HP500C_XMAX, 3);
	//    b_rastermode = TRUE;
	//}
	//
	// /*
	//  * Run-length encoding for the DeskJet. We have pairs of <count>
	//  * <what>, where count goes from 0 (meaning one count) to 255
	//  * this might double the size of the image.
	//  */
	//
	//static int
	//HP_compress(unsigned char *op, unsigned char *oe, unsigned char *cp)
	//{
	//    unsigned char *ce = cp;
	//
	//    while (op < oe) {
	//	unsigned char prevchar;
	//	unsigned char count;
	//
	//	prevchar = *op;		// remember char 
	//	count = 1;		// its read the first time 
	//
	//	while (++op < oe && *op == prevchar && count < 255) {
	// /* set op to the next char */
	//	    count++;		// and count it  
	//	}
	//	*ce++ = --count;	// were ready, so correct the count 
	//	*ce++ = prevchar;	// and store <what> 
	//    }
	//    *ce = 0;			// just to be safe   
	//    return ce - cp;		// length of  cbufs 
	//}
	//
	//static unsigned char
	//HP_complement(int c)
	//{
	//    return (unsigned char) (256 - c);
	//}
	//
	//
	//static int
	//HP_compress_to_TIFF(
	//    unsigned char *op,		// original pointer 
	//    unsigned char *oe,		// end of orig string 
	//    unsigned char *cp)		// pointer for compressed data 
	//{
	//    unsigned char *countposition;
	//    unsigned char *ce = cp;
	//
	//    while (op < oe) {
	//	unsigned char prevchar;
	//	unsigned char count;
	//
	//	prevchar = *op;		// gelesenes Zeichen aufbewaren 
	//	count = 1;		// bisher wurde es einmal gelesen 
	//
	//	while (++op < oe && *op == prevchar && count < 128) {
	//	    count++;
	//	}
	//	*ce = HP_complement(count - 1);
	// /* remember count for building blocks of literal bytes */
	//	countposition = ce++;
	//	*ce++ = prevchar;
	//
	//	if (count < 2) {
	//	    while (op < oe && (prevchar != *op || *op != *(op + 1))) {
	// /* only use rle for at leat 3 equal bytes */
	//		*ce++ = *op;
	//		count++;
	//		prevchar = *op++;
	//		if (op > oe)
	//		    puts("FATAL op> oe!!\n");
	//	    }
	//	    if (op < oe && prevchar == *op) {
	//		op--;
	//		count--;
	//		ce--;
	//	    }
	//	    *countposition = count - 1;
	//	}
	//    }
	//    return ce - cp;
	//
	//}
	//
	//static int
	//HP_nocompress(
	//    unsigned char *op,
	//    unsigned char *oe,
	//    unsigned char *cp)
	//{
	//    unsigned char *ce = cp;
	//
	//    while (op < oe)
	//	*ce++ = *op++;
	//    return ce - cp;
	//}
	//
	// /* 0 compression raster bitmap dump. Compatible with HP DeskJet 500
	//    hopefully compatible with other HP Deskjet printers */
	//
	//TERM_PUBLIC void
	//HP500C_text()
	//{
	//    register int x, j, row, count = 0;
	//    unsigned char *obuf, *oe, *cbuf, *ce;
	//
	//    if ((obuf = (unsigned char *) malloc(100 * b_psize)) == 0)
	//	puts("FATAL!-- couldn't get enough memory for obuf");
	//    if ((cbuf = (unsigned char *) malloc(400 * b_psize)) == 0)
	//	puts("FATAL!-- couldn't get enough memory for cbuf");
	//
	//    oe = obuf;
	//
	//    fprintf(gpoutfile, "
	//\033*t%dR
	//\033*r1A
	//\033*b%1dM
	//\033*r%dS
	//\033*r-3U",
	//	    HP500C_PPI,
	//	    HP_COMP_MODE,
	//	    b_ysize);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	for (j = row; j >= 0; j--) {
	//	    *oe++ = (char) (*((*b_p)[j] + x));
	//	}
	//	switch (HP_COMP_MODE) {
	//	case 2:
	//	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
	//	    break;
	//	case 1:
	//	    count = HP_compress(obuf, oe, cbuf);
	//	    break;
	//	case 0:
	//	    count = HP_nocompress(obuf, oe, cbuf);
	//	    break;
	//	}
	//	fprintf(gpoutfile, "\033*b%dV", count);
	//	ce = cbuf;
	//	while (count--)
	//	    fputc(*ce++, gpoutfile);
	//	oe = obuf;
	//
	//	for (j = row; j >= 0; j--) {
	//	    *oe++ = (char) (*((*b_p)[j + b_psize] + x));
	//	}
	//	switch (HP_COMP_MODE) {
	//	case 2:
	//	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
	//	    break;
	//	case 1:
	//	    count = HP_compress(obuf, oe, cbuf);
	//	    break;
	//	case 0:
	//	    count = HP_nocompress(obuf, oe, cbuf);
	//	    break;
	//
	//	}
	//
	//	fprintf(gpoutfile, "\033*b%dV", count);
	//	ce = cbuf;
	//	while (count--)
	//	    fputc(*ce++, gpoutfile);
	//	oe = obuf;
	//
	//	for (j = row; j >= 0; j--) {
	//	    *oe++ = (char) (*((*b_p)[j + (2 * b_psize)] + x));
	//	}
	//	switch (HP_COMP_MODE) {
	//	case 2:
	//	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
	//	    break;
	//	case 1:
	//	    count = HP_compress(obuf, oe, cbuf);
	//	    break;
	//	case 0:
	//	    count = HP_nocompress(obuf, oe, cbuf);
	//	    break;
	//	}
	//	fprintf(gpoutfile, "\033*b%dW", count);
	//	ce = cbuf;
	//	while (count--)
	//	    fputc(*ce++, gpoutfile);
	//	oe = obuf;
	//
	//    }
	//    fputs("\033*rbC", gpoutfile);
	//    free(cbuf);
	//    free(obuf);
	//    b_freebitmap();
	//
	///#ifndef VMS
	// /* most vms spoolers add a formfeed character */
	//    putc('\f', gpoutfile);
	///#endif // !VMS 
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(hp500c_driver)
	//    "hp500c", "HP DeskJet 500c, [75 100 150 300] [rle tiff]",
	//    HP500C_75PPI_XMAX, HP500C_75PPI_YMAX, HP500C_75PPI_VCHAR,
	//    HP500C_75PPI_HCHAR, HP500C_75PPI_VTIC, HP500C_75PPI_HTIC, HP500C_options,
	//    HP500C_init, HP500C_reset, HP500C_text, null_scale,
	//    HP500C_graphics, b_move, b_vector, HP500C_linetype,
	//    b_put_text, b_text_angle, null_justify_text, do_point,
	//    do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(hp500c_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hp500c_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(hp500c)
	//"1 hp500c",
	//"?commands set terminal hp500c",
	//"?set terminal hp500c",
	//"?set term hp500c",
	//"?terminal hp500c",
	//"?term hp500c",
	//"?hp500c",
	//" The `hp500c` terminal driver supports the Hewlett Packard HP DeskJet 500c.",
	//" It has options for resolution and compression.",
	//"",
	//" Syntax:",
	//"       set terminal hp500c {<res>} {<comp>}",
	//"",
	//" where `res` can be 75, 100, 150 or 300 dots per inch and `comp` can be \"rle\",",
	//" or \"tiff\".  Any other inputs are replaced by the defaults, which are 75 dpi",
	//" and no compression.  Rasterization at the higher resolutions may require a",
	//" large amount of memory."
	//END_HELP(hp500c)
	///#endif // TERM_HELP 


	/* HP7475, HP7220 plotters, and (hopefully) lots of others */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hpgl.trm,v 1.23 2009/03/02 23:55:26 sfeam Exp $
	 */

	/* GNUPLOT - hpgl.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.h.
	 *
	 * This terminal driver supports:
	 *  hpgl, hp7550, hp7580b, HP Laserjet III
	 *  hp7550 has been replaced by  "hpgl 8 eject"
	 *  hp7580b has been replaced by "hpgl 4"
	 *
	 * AUTHORS
	 *  Colin Kelley, Thomas Williams, Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 *
	 * MODIFIED for expanded HPGL/2 and PCL utilites
	 *  Tom Swiler (tom@silica.mse.ufl.edu)
	 * Modified June 1995 Ian MacPhedran to support newterm format
	 * Modified October 1995 Ian MacPhedran to simplify HPGL terminals
	 * Modified January 96 by David Denholm and Emmanuel Bigler for cp850
	 *                               and iso international character sets
	 * Modified February 99 by Jeremy Brenes to give PCL5 terminal optional
	 * multi-pen support (6 pen default), a default 34" plotting width for
	 * use with large color plotters such as the HP Designjet 750C,
	 * various alternative plot sizes, and variable fontsizes;
	 * Also decreased the HPGL terminal's fixed fontsize to make it more
	 * reasonable when plots get scaled to 34"
	 * Modified July 99 by Jeremy Brenes to make extended plot area smaller;
	 * added solid/dashed lines option, additional font types, mixed fonts
	 * Modified November 99 by Jeremy Brenes to add a postscript pointtypes
	 * option, special purpose negative pointtypes, and a pointsize function
	 *
	 */
	///#define HPGL
	///#define PCL


	///#ifdef TERM_REGISTER
	//register_term(hpgl)
	//register_term(pcl5)
	///#endif // TERM_REGISTER 

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HPGL_options __PROTO((void));
	//TERM_PUBLIC void HPGL2_options __PROTO((void));
	//TERM_PUBLIC void PCL_options __PROTO((void));
	//TERM_PUBLIC void HPGL_init __PROTO((void));
	// /* TERM_PUBLIC void HPGL2_init __PROTO((void)); */
	//TERM_PUBLIC void PCL_init __PROTO((void));
	//TERM_PUBLIC void HPGL_graphics __PROTO((void));
	//TERM_PUBLIC void HPGL2_graphics __PROTO((void));
	//TERM_PUBLIC void PCL_graphics __PROTO((void));
	//TERM_PUBLIC void HPGL_text __PROTO((void));
	// /* TERM_PUBLIC void HPGL2_text __PROTO((void)); */
	//TERM_PUBLIC void PCL_text __PROTO((void));
	//TERM_PUBLIC void HPGL_linetype __PROTO((int linetype));
	//TERM_PUBLIC void HPGL2_linetype __PROTO((int linetype));
	//TERM_PUBLIC void HPGL_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void HPGL2_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void HPGL_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HPGL_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HPGL2_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HPGL2_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void HPGL2_encode __PROTO((int d));
	//TERM_PUBLIC int HPGL_text_angle __PROTO((int ang));
	//TERM_PUBLIC int HPGL2_text_angle __PROTO((int ang));
	//TERM_PUBLIC void HPGL_reset __PROTO((void));
	// /* TERM_PUBLIC void HPGL2_reset __PROTO((void)); */
	//TERM_PUBLIC void PCL_reset __PROTO((void));
	//TERM_PUBLIC int HPGL2_justify_text __PROTO((enum JUSTIFY just));
	//TERM_PUBLIC int HPGL2_set_font __PROTO((const char *font));
	//TERM_PUBLIC void HPGL2_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void HPGL2_neg_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void HPGL2_pointsize __PROTO((double size));
	///#define GOT_HPGL_PROTO
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	// /*
	//  * The maximum plot size, in plotter units.
	//  * Note that the actual size of larger plots may be limited by
	//  * available printer memory.
	//  */
	//
	///#define HPGL_PUPI	1016	// Plotter units per inch 
	//
	///#define HPGL_XMAX_A	10000
	///#define HPGL_YMAX_A	7500
	//
	///#define HPGL_XMAX_B	13000
	///#define HPGL_YMAX_B	7500
	//
	///#define HPGL_XMAX_C	45333
	///#define HPGL_YMAX_C	34000
	//
	///#define HPGL_XMAX_D	52000
	///#define HPGL_YMAX_D	34000
	//
	///#define HPGL_XMAX	HPGL_XMAX_A
	///#define HPGL_YMAX	HPGL_YMAX_A
	//
	///#define PCL_XMAX	HPGL_XMAX_C
	///#define PCL_YMAX	(HPGL_YMAX_C-60)
	//
	// /*
	//  * Tic sizes
	//  */
	//
	///#define HPGL_VTIC	(HPGL_YMAX/70)
	///#define HPGL_HTIC	(HPGL_YMAX/70)
	//
	///#define PCL_VTIC	((HPGL_YMAX_C-60)/320)
	///#define PCL_HTIC	((HPGL_YMAX_C-60)/320)
	//
	// /*
	//  * Font size for HPGL
	//  */
	//
	///#define HPGL_VCHAR	(HPGL_YMAX/100*8/10)	// 0.8% 
	///#define HPGL_HCHAR	(HPGL_XMAX/100*3/10)	// 0.3% 
	//
	// /*
	//  * Font size for HPGL/2
	//  */
	//
	///#define HPGL2_DEF_POINT	12	// Height of font 
	//
	///#define HPGL2_DEF_PITCH	(3 * 72 / (HPGL2_DEF_POINT * 2))
	///#define HPGL2_VCHAR	((int) HPGL_PUPI * HPGL2_DEF_POINT / 72)
	///#define HPGL2_HCHAR	(HPGL2_VCHAR * 2 / 3)
	//
	// /*
	//  * Point size for HPGL/2
	//  */
	//
	//static double HPGL2_psize = 1.0;	// Default point size 
	//
	// /*
	//  * Number of available pointtypes for HPGL/2
	//  */
	//
	///#define  HPGL2_NUM_NOPSPOINTS 6;	// for nopspoints option 
	///#define  HPGL2_NUM_PSPOINTS 75;	// for pspoints option 
	//
	// /*
	//  * Control constants
	//  */
	//
	///#define DOWN		0	// Pen is down 
	///#define UP 		1	// Pen is up 
	///#define UNKNOWN		-10	// Unknown status for lots of things 
	//
	// /*
	//  * For Polyline Encoded, either use base 64 or base 32.
	//  * Save space with base 64, but get 8-bit characters.
	//  */
	//
	///#define HPGL2_BASE64 1
	//
	///#if HPGL2_BASE64
	///#define HPGL2_BITS 6
	///#define HPGL2_LOW_OFFS 63
	///#define HPGL2_HIGH_OFFS 191
	///#define HPGL2_MASK 63
	///#else
	///#define HPGL2_BITS 5
	///#define HPGL2_LOW_OFFS 63
	///#define HPGL2_HIGH_OFFS 95
	///#define HPGL2_MASK 31
	///#endif
	//
	// /*
	//  * Data structures for options
	//  */
	//
	//struct HPGL2_font_str {
	//    const char *compare, *name;
	//    int symbol_set, spacing;
	//    double pitch, height;
	//    int posture, stroke_weight, typeface;
	//};
	//
	//struct PCL_mode_str {
	//    const char *compare, *name, *command;
	//    unsigned int xmax, ymax;
	//};
	//
	// /*
	//  * The default font goes first.  Although it is the ugliest,  the
	//  * stick font is probably supported by the most devices.
	//  */
	//
	//static struct HPGL2_font_str GPFAR HPGL2_font_table[] = {
	//    {"u$nivers", "univers", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4148},
	//    {"s$tick", "stick", 277, 0, HPGL2_DEF_PITCH, 0.0, 0, 0, 48},
	//    {"cg_t$imes", "cg_times", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4101},
	//    {"z$apf_dingbats", "zapf_dingbats", 364, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4141},
	//    {"an$tique_olive", "antique_olive", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4168},
	//    {"ar$ial", "arial", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16602},
	//    {"cou$rier", "courier", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4099},
	//    {"g$aramond_antigua", "garamond_antigua", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4197},
	//    {"l$etter_gothic", "letter_gothic", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4102},
	//    {"cg_o$mega", "cg_omega", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4113},
	//    {"al$bertus", "albertus", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 1, 4362},
	//    {"ti$mes_new_roman", "times_new_roman", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16901},
	//    {"cl$arendon", "clarendon", 277, 1, 0.0, HPGL2_DEF_POINT, 4, 3, 4140},
	//    {"cor$onet", "coronet", 277, 1, 0.0, HPGL2_DEF_POINT, 1, 0, 4116},
	//    {"m$arigold", "marigold", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4297},
	//    {"tr$uetype_symbols", "truetype_symbols", 621, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16686},
	//    {"w$ingdings", "wingdings", 18540, 1, 0.0, HPGL2_DEF_POINT, 1, 0, 31402}
	//};
	//
	///#define HPGL2_FONTS (sizeof(HPGL2_font_table) / sizeof (struct HPGL2_font_str))
	//static struct HPGL2_font_str *HPGL2_font = &HPGL2_font_table[0];
	//
	// /*
	//  * The default mode goes first.  Landscape style plots are probably the
	//  * most compatable with other HPGL devices.
	//  */
	//
	//static struct PCL_mode_str GPFAR PCL_mode_table[] = {
	//    {"l$andscape", "landscape", "\033&l1O", PCL_XMAX, PCL_YMAX},
	//    {"p$ortrait", "portrait", "\033&l0O", PCL_YMAX, PCL_XMAX}
	//};
	//
	///#define PCL_MODES (sizeof(PCL_mode_table) / sizeof (struct PCL_mode_str))
	//static struct PCL_mode_str *PCL_mode = &PCL_mode_table[0];
	//
	// /*
	//  * Various line types and widths to distinguish data sets in monochrome
	//  */
	//
	//static const char *HPGL2_lt[] = { "", ",2", ",2", ",2", ",2", ",2", ",2", ",2" },
	//		  *HPGL2_pw[] = { ".24", ".16", ".08"};
	//
	///#define HPGL2_LINETYPES (sizeof(HPGL2_lt) / sizeof(char *))
	///#define HPGL2_PENWIDTHS (sizeof(HPGL2_pw) / sizeof(char *))
	//
	// /* encoding vector for cp850 , characters 128 (0200) -> 255 (0377) */
	//
	//static char hpgl_cp_850[128][4] = {
	//
	// /* 0200 //Tangible continue code after comment*/
	// "\0164\017",
	// /* 0201 //Tangible continue code after comment*/
	// "\016O\017",
	// /* 0202 //Tangible continue code after comment*/
	// "\016E\017",
	// /* 0203 //Tangible continue code after comment*/
	// "\016@\017",
	// /* 0204 //Tangible continue code after comment*/
	// "\016L\017",
	// /* 0205 //Tangible continue code after comment*/
	// "\016H\017",
	// /* 0206 //Tangible continue code after comment*/
	// "\016T\017",
	// /* 0207 //Tangible continue code after comment*/
	// "\0165\017",
	//
	// /* 0210 //Tangible continue code after comment*/
	// "\016A\017",
	// /* 0211 //Tangible continue code after comment*/
	// "\016M\017",
	// /* 0212 //Tangible continue code after comment*/
	// "\016I\017",
	// /* 0213 //Tangible continue code after comment*/
	// "\016]\017",
	// /* 0214 //Tangible continue code after comment*/
	// "\016Q\017",
	// /* 0215 //Tangible continue code after comment*/
	// "\016Y\017",
	// /* 0216 //Tangible continue code after comment*/
	// "\016X\017",
	// /* 0217 //Tangible continue code after comment*/
	// "\016P\017",
	//
	// /* 0220 //Tangible continue code after comment*/
	// "\016\134\017",
	// /* 0221 //Tangible continue code after comment*/
	// "\016W\017",
	// /* 0222 //Tangible continue code after comment*/
	// "\016S\017",
	// /* 0223 //Tangible continue code after comment*/
	// "\016B\017",
	// /* 0224 //Tangible continue code after comment*/
	// "\016N\017",
	// /* 0225 //Tangible continue code after comment*/
	// "\016J\017",
	// /* 0226 //Tangible continue code after comment*/
	// "\016C\017",
	// /* 0227 //Tangible continue code after comment*/
	// "\016K\017",
	//
	// /* 0230 //Tangible continue code after comment*/
	// "\016o\017",
	// /* 0231 //Tangible continue code after comment*/
	// "\016Z\017",
	// /* 0232 //Tangible continue code after comment*/
	// "\016[\017",
	// /* 0233 //Tangible continue code after comment*/
	// "\016V\017",
	// /* 0234 //Tangible continue code after comment*/
	// "\016;\017",
	// /* 0235 //Tangible continue code after comment*/
	// "\016R\017",
	// /* 0236 //Tangible continue code after comment*/
	// "",
	// /* 0237 //Tangible continue code after comment*/
	// "\016>\017",
	//
	// /* 0240 //Tangible continue code after comment*/
	// "\016D\017",
	// /* 0241 //Tangible continue code after comment*/
	// "\016U\017",
	// /* 0242 //Tangible continue code after comment*/
	// "\016F\017",
	// /* 0243 //Tangible continue code after comment*/
	// "\016G\017",
	// /* 0244 //Tangible continue code after comment*/
	// "\0167\017",
	// /* 0245 //Tangible continue code after comment*/
	// "\0166\017",
	// /* 0246 //Tangible continue code after comment*/
	// "\016y\017",
	// /* 0247 //Tangible continue code after comment*/
	// "\016z\017",
	//
	// /* 0250 //Tangible continue code after comment*/
	// "\0169\017",
	//
	// /* 0251 //Tangible continue code after comment*/
	// "",
	// /* 0252 //Tangible continue code after comment*/
	// "",
	//
	// /* 0253 //Tangible continue code after comment*/
	// "\016x\017",
	// /* 0254 //Tangible continue code after comment*/
	// "\016w\017",
	// /* 0255 //Tangible continue code after comment*/
	// "\0168\017",
	// /* 0256 //Tangible continue code after comment*/
	// "\016{\017",
	// /* 0257 //Tangible continue code after comment*/
	// "\016}\017",
	//
	// /* 0260 //Tangible continue code after comment*/
	// "",
	// /* 0261 //Tangible continue code after comment*/
	// "",
	// /* 0262 //Tangible continue code after comment*/
	// "",
	// /* 0263 //Tangible continue code after comment*/
	// "",
	// /* 0264 //Tangible continue code after comment*/
	// "",
	//
	// /* 0265 //Tangible continue code after comment*/
	// "\016`\017",
	// /* 0266 //Tangible continue code after comment*/
	// "\016\042\017",
	// /* 0267 //Tangible continue code after comment*/
	// "\016!\017",
	//
	// /* 0270 //Tangible continue code after comment*/
	// "",
	// /* 0271 //Tangible continue code after comment*/
	// "",
	// /* 0272 //Tangible continue code after comment*/
	// "",
	// /* 0273 //Tangible continue code after comment*/
	// "",
	// /* 0274 //Tangible continue code after comment*/
	// "",
	//
	// /* 0275 //Tangible continue code after comment*/
	// "\016?\017",
	// /* 0276 //Tangible continue code after comment*/
	// "\016<\017",
	//
	// /* 0277 //Tangible continue code after comment*/
	// "",
	//
	// /* 0300 //Tangible continue code after comment*/
	// "",
	// /* 0301 //Tangible continue code after comment*/
	// "",
	// /* 0302 //Tangible continue code after comment*/
	// "",
	// /* 0303 //Tangible continue code after comment*/
	// "",
	// /* 0304 //Tangible continue code after comment*/
	// "",
	// /* 0305 //Tangible continue code after comment*/
	// "",
	//
	// /* 0306 //Tangible continue code after comment*/
	// "\016b\017",
	// /* 0307 //Tangible continue code after comment*/
	// "\016a\017",
	//
	// /* 0310 //Tangible continue code after comment*/
	// "",
	// /* 0311 //Tangible continue code after comment*/
	// "",
	// /* 0312 //Tangible continue code after comment*/
	// "",
	// /* 0313 //Tangible continue code after comment*/
	// "",
	// /* 0314 //Tangible continue code after comment*/
	// "",
	// /* 0315 //Tangible continue code after comment*/
	// "",
	// /* 0316 //Tangible continue code after comment*/
	// "",
	//
	// /* 0317 //Tangible continue code after comment*/
	// "\016:\017",
	//
	// /* 0320 //Tangible continue code after comment*/
	// "\016d\017",
	// /* 0321 //Tangible continue code after comment*/
	// "\016c\017",
	// /* 0322 //Tangible continue code after comment*/
	// "\016$\017",
	// /* 0323 //Tangible continue code after comment*/
	// "\016%\017",
	// /* 0324 //Tangible continue code after comment*/
	// "\016#\017",
	//
	// /* 0325 //Tangible continue code after comment*/
	// "",
	//
	// /* 0326 //Tangible continue code after comment*/
	// "\016e\017",
	// /* 0327 //Tangible continue code after comment*/
	// "\016&\017",
	//
	// /* 0330 //Tangible continue code after comment*/
	// "\016'\017",
	//
	// /* 0331 //Tangible continue code after comment*/
	// "",
	// /* 0332 //Tangible continue code after comment*/
	// "",
	// /* 0333 //Tangible continue code after comment*/
	// "",
	// /* 0334 //Tangible continue code after comment*/
	// "",
	// /* 0335 //Tangible continue code after comment*/
	// "",
	//
	// /* 0336 //Tangible continue code after comment*/
	// "\016f\017",
	// /* 0337 //Tangible continue code after comment*/
	// "",
	//
	// /* 0340 //Tangible continue code after comment*/
	// "\016g\017",
	// /* 0341 //Tangible continue code after comment*/
	// "\016^\017",
	// /* 0342 //Tangible continue code after comment*/
	// "\016_\017",
	// /* 0343 //Tangible continue code after comment*/
	// "\016h\017",
	// /* 0344 //Tangible continue code after comment*/
	// "\016j\017",
	// /* 0345 //Tangible continue code after comment*/
	// "\016i\017",
	// /* 0346 //Tangible continue code after comment*/
	// "",
	// /* 0347 //Tangible continue code after comment*/
	// "\016q\017",
	//
	// /* 0350 //Tangible continue code after comment*/
	// "\016p\017",
	// /* 0351 //Tangible continue code after comment*/
	// "\016m\017",
	// /* 0352 //Tangible continue code after comment*/
	// "\016.\017",
	// /* 0353 //Tangible continue code after comment*/
	// "\016-\017",
	// /* 0354 //Tangible continue code after comment*/
	// "",
	// /* 0355 //Tangible continue code after comment*/
	// "",
	// /* 0356 //Tangible continue code after comment*/
	// "\0160\017",
	// /* 0357 //Tangible continue code after comment*/
	// "\016(\017",
	//
	// /* 0360 //Tangible continue code after comment*/
	// "\016v\017",
	// /* 0361 //Tangible continue code after comment*/
	// "\016~\017",
	// /* 0362 //Tangible continue code after comment*/
	// "",
	// /* 0363 //Tangible continue code after comment*/
	// "",
	// /* 0364 //Tangible continue code after comment*/
	// "",
	// /* 0365 //Tangible continue code after comment*/
	// "\016=\017",
	// /* 0366 //Tangible continue code after comment*/
	// "",
	// /* 0367 //Tangible continue code after comment*/
	// "",
	//
	// /* 0370 //Tangible continue code after comment*/
	// "\016z\017",
	// /* 0371 //Tangible continue code after comment*/
	// "\016+\017",
	// /* 0372 //Tangible continue code after comment*/
	// "",
	// /* 0373 //Tangible continue code after comment*/
	// "",
	// /* 0374 //Tangible continue code after comment*/
	// "",
	// /* 0375 //Tangible continue code after comment*/
	// "",
	// /* 0376 //Tangible continue code after comment*/
	// "",
	// /* 0377 //Tangible continue code after comment*/
	// ""
	//};
	//
	//
	// /* encoding vector for iso-8859-1 , characters 128 (0200) -> 255 (0377) */
	//
	//static char hpgl_iso_8859_1[128][4] = {
	//
	// /* 0200 //Tangible continue code after comment*/
	// "",
	// /* 0201 //Tangible continue code after comment*/
	// "",
	// /* 0202 //Tangible continue code after comment*/
	// "",
	// /* 0203 //Tangible continue code after comment*/
	// "",
	// /* 0204 //Tangible continue code after comment*/
	// "",
	// /* 0205 //Tangible continue code after comment*/
	// "",
	// /* 0206 //Tangible continue code after comment*/
	// "",
	// /* 0207 //Tangible continue code after comment*/
	// "",
	//
	// /* 0210 //Tangible continue code after comment*/
	// "",
	// /* 0211 //Tangible continue code after comment*/
	// "",
	// /* 0212 //Tangible continue code after comment*/
	// "",
	// /* 0213 //Tangible continue code after comment*/
	// "",
	// /* 0214 //Tangible continue code after comment*/
	// "",
	// /* 0215 //Tangible continue code after comment*/
	// "",
	// /* 0216 //Tangible continue code after comment*/
	// "",
	// /* 0217 //Tangible continue code after comment*/
	// "",
	//
	// /* 0220 //Tangible continue code after comment*/
	// "",
	// /* 0221 //Tangible continue code after comment*/
	// "\016\017",
	// /* 0222 //Tangible continue code after comment*/
	// "\016\017",
	// /* 0223 //Tangible continue code after comment*/
	// "",
	// /* 0224 //Tangible continue code after comment*/
	// "",
	// /* 0225 //Tangible continue code after comment*/
	// "",
	// /* 0226 //Tangible continue code after comment*/
	// "",
	// /* 0227 //Tangible continue code after comment*/
	// "",
	//
	// /* 0230 //Tangible continue code after comment*/
	// "",
	// /* 0231 //Tangible continue code after comment*/
	// "",
	// /* 0232 //Tangible continue code after comment*/
	// "",
	// /* 0233 //Tangible continue code after comment*/
	// "",
	// /* 0234 //Tangible continue code after comment*/
	// "",
	// /* 0235 //Tangible continue code after comment*/
	// "",
	// /* 0236 //Tangible continue code after comment*/
	// "",
	// /* 0237 //Tangible continue code after comment*/
	// "",
	//
	// /* 0240 //Tangible continue code after comment*/
	// "",
	// /* 0241 //Tangible continue code after comment*/
	// "\0168\017",
	// /* 0242 //Tangible continue code after comment*/
	// "\0165\017",
	// /* 0243 //Tangible continue code after comment*/
	// "\016;\017",
	// /* 0244 //Tangible continue code after comment*/
	// "\016:\017",
	// /* 0245 //Tangible continue code after comment*/
	// "\016<\017",
	// /* 0246 //Tangible continue code after comment*/
	// "\017|\017",
	// /* 0247 //Tangible continue code after comment*/
	// "\016=\017",
	//
	// /* 0250 //Tangible continue code after comment*/
	// "\016+\017",
	// /* 0251 //Tangible continue code after comment*/
	// "",
	// /* 0252 //Tangible continue code after comment*/
	// "\016y\017",
	// /* 0253 //Tangible continue code after comment*/
	// "\016{\017",
	// /* 0254 //Tangible continue code after comment*/
	// "",
	// /* 0255 //Tangible continue code after comment*/
	// "",
	// /* 0256 //Tangible continue code after comment*/
	// "",
	// /* 0257 //Tangible continue code after comment*/
	// "\0160\017",
	//
	// /* 0260 //Tangible continue code after comment*/
	// "\016z\017",
	// /* 0261 //Tangible continue code after comment*/
	// "\016~\017",
	// /* 0262 //Tangible continue code after comment*/
	// "",
	// /* 0263 //Tangible continue code after comment*/
	// "",
	// /* 0264 //Tangible continue code after comment*/
	// "",
	// /* 0265 //Tangible continue code after comment*/
	// "",
	// /* 0266 //Tangible continue code after comment*/
	// "",
	// /* 0267 //Tangible continue code after comment*/
	// "",
	//
	// /* 0270 //Tangible continue code after comment*/
	// "",
	// /* 0271 //Tangible continue code after comment*/
	// "",
	// /* 0272 //Tangible continue code after comment*/
	// "\016z\017",
	// /* 0273 //Tangible continue code after comment*/
	// "\016}\017",
	// /* 0274 //Tangible continue code after comment*/
	// "\016w\017",
	// /* 0275 //Tangible continue code after comment*/
	// "\016x\017",
	// /* 0276 //Tangible continue code after comment*/
	// "",
	// /* 0277 //Tangible continue code after comment*/
	// "\0169\017",
	//
	// /* 0300 //Tangible continue code after comment*/
	// "\016!\017",
	// /* 0301 //Tangible continue code after comment*/
	// "\016`\017",
	// /* 0302 //Tangible continue code after comment*/
	// "\016\042\017",
	// /* 0303 //Tangible continue code after comment*/
	// "\016a\017",
	// /* 0304 //Tangible continue code after comment*/
	// "\016X\017",
	// /* 0305 //Tangible continue code after comment*/
	// "\016P\017",
	// /* 0306 //Tangible continue code after comment*/
	// "\016S\017",
	// /* 0307 //Tangible continue code after comment*/
	// "\0164\017",
	//
	// /* 0310 //Tangible continue code after comment*/
	// "\016#\017",
	// /* 0311 //Tangible continue code after comment*/
	// "\016\134\017",
	// /* 0312 //Tangible continue code after comment*/
	// "\016$\017",
	// /* 0313 //Tangible continue code after comment*/
	// "\016%\017",
	// /* 0314 //Tangible continue code after comment*/
	// "\016f\017",
	// /* 0315 //Tangible continue code after comment*/
	// "\016e\017",
	// /* 0316 //Tangible continue code after comment*/
	// "\016\046\017",
	// /* 0317 //Tangible continue code after comment*/
	// "\016'\017",
	//
	// /* 0320 //Tangible continue code after comment*/
	// "\016c\017",
	// /* 0321 //Tangible continue code after comment*/
	// "\0166\017",
	// /* 0322 //Tangible continue code after comment*/
	// "\016h\017",
	// /* 0323 //Tangible continue code after comment*/
	// "\016g\017",
	// /* 0324 //Tangible continue code after comment*/
	// "\016_\017",
	// /* 0325 //Tangible continue code after comment*/
	// "\016i\017",
	// /* 0326 //Tangible continue code after comment*/
	// "\016Z\017",
	// /* 0327 //Tangible continue code after comment*/
	// "",
	//
	// /* 0330 //Tangible continue code after comment*/
	// "\016R\017",
	// /* 0331 //Tangible continue code after comment*/
	// "\016-\017",
	// /* 0332 //Tangible continue code after comment*/
	// "\016m\017",
	// /* 0333 //Tangible continue code after comment*/
	// "\016.\017",
	// /* 0334 //Tangible continue code after comment*/
	// "\016[\017",
	// /* 0335 //Tangible continue code after comment*/
	// "",
	// /* 0336 //Tangible continue code after comment*/
	// "\016p\017",
	// /* 0337 //Tangible continue code after comment*/
	// "\016^\017",
	//
	// /* 0340 //Tangible continue code after comment*/
	// "\016H\017",
	// /* 0341 //Tangible continue code after comment*/
	// "\016D\017",
	// /* 0342 //Tangible continue code after comment*/
	// "\016@\017",
	// /* 0343 //Tangible continue code after comment*/
	// "\016b\017",
	// /* 0344 //Tangible continue code after comment*/
	// "\016L\017",
	// /* 0345 //Tangible continue code after comment*/
	// "\016T\017",
	// /* 0346 //Tangible continue code after comment*/
	// "\016W\017",
	// /* 0347 //Tangible continue code after comment*/
	// "\0165\017",
	//
	// /* 0350 //Tangible continue code after comment*/
	// "\016I\017",
	// /* 0351 //Tangible continue code after comment*/
	// "\016E\017",
	// /* 0352 //Tangible continue code after comment*/
	// "\016A\017",
	// /* 0353 //Tangible continue code after comment*/
	// "\016M\017",
	// /* 0354 //Tangible continue code after comment*/
	// "\016Y\017",
	// /* 0355 //Tangible continue code after comment*/
	// "\016U\017",
	// /* 0356 //Tangible continue code after comment*/
	// "\016Q\017",
	// /* 0357 //Tangible continue code after comment*/
	// "\016]\017",
	//
	// /* 0360 //Tangible continue code after comment*/
	// "\016d\017",
	// /* 0361 //Tangible continue code after comment*/
	// "\0167\017",
	// /* 0362 //Tangible continue code after comment*/
	// "\016J\017",
	// /* 0363 //Tangible continue code after comment*/
	// "\016F\017",
	// /* 0364 //Tangible continue code after comment*/
	// "\016B\017",
	// /* 0365 //Tangible continue code after comment*/
	// "\016j\017",
	// /* 0366 //Tangible continue code after comment*/
	// "\016N\017",
	// /* 0367 //Tangible continue code after comment*/
	// "",
	//
	// /* 0370 //Tangible continue code after comment*/
	// "\016V\017",
	// /* 0371 //Tangible continue code after comment*/
	// "\016K\017",
	// /* 0372 //Tangible continue code after comment*/
	// "\016G\017",
	// /* 0373 //Tangible continue code after comment*/
	// "\016C\017",
	// /* 0374 //Tangible continue code after comment*/
	// "\016O\017",
	// /* 0375 //Tangible continue code after comment*/
	// "",
	// /* 0376 //Tangible continue code after comment*/
	// "\016q\017",
	// /* 0377 //Tangible continue code after comment*/
	// "\016o\017"
	//};
	//
	//
	// /*
	//  * Static variables to keep track of where we are, etc.
	//  */
	//
	//static int HPGL_ang = 0, HPGL_x = UNKNOWN, HPGL_y = UNKNOWN,
	//	   HPGL_penstate = UNKNOWN, HPGL_pentype, HPGL2_pentype = UNKNOWN,
	//	   HPGL2_in_pe, HPGL2_lost;
	//
	// /*
	//  * The subroutines, grouped by function for different versions.
	//  */
	//
	//static int HPGL_numpen, HPGL_eject;
	//
	//TERM_PUBLIC void
	//HPGL_options()
	//{
	//    HPGL_numpen = 6;		// default to six pens 
	//    HPGL_eject = 0;		// default to no eject 
	//
	//    while (!END_OF_COMMAND) {
	//	if (almost_equals(c_token, "eje$ct"))
	//	    HPGL_eject = 1;
	//	else if (isanumber(c_token)) {
	//	    HPGL_numpen = (int) real(&token[c_token].l_val);
	//	    if (HPGL_numpen <= 0) {
	//		HPGL_numpen = 6;
	//		int_error(c_token, "Number of pens must be positive");
	//	    }
	//	} else
	//	    int_error(c_token, "expecting \"eject\" or number of pens");
	//
	//	c_token++;
	//    }
	//
	//
	//    sprintf(term_options, "%d pens %s", HPGL_numpen,
	//	    HPGL_eject ? "eject" : "noeject");
	//}
	//
	//static int HPGL2_color = 1, HPGL2_numpen = 6;	// default to 6 pen color 
	//static int HPGL2_dashed = 0;	// current dashed linetype 
	//static int HPGL2_solid = 1;	// default to solid lines 
	//static int HPGL2_font_num = 0;	// font from options 
	//static int HPGL2_font_num_current = 0; // current font 
	//static int pspointset = 0;	// default to standard point types 
	//static double HPGL2_point_size = HPGL2_DEF_POINT; // pointsize from options 
	//static double HPGL2_point_size_current = 0; // current pointsize 
	//static const char *PCL_dim = "noextended"; // default plotting dimensions 
	//
	//
	//enum HPGL2_id {
	//    HPGL2_MONOCHROME, HPGL2_COLOR, HPGL2_SOLID, HPGL2_DASHED, HPGL2_FONT,
	//    HPGL2_SIZE, HPGL2_NOPSPOINTS, HPGL2_PSPOINTS,
	//    HPGL2_INVALID
	//};
	//
	//static struct gen_table HPGL2_opts[] =
	//{
	//    { "mono$chrome", HPGL2_MONOCHROME },
	//    { "col$or", HPGL2_COLOR },
	//    { "col$our", HPGL2_COLOR },
	//    { "sol$id", HPGL2_SOLID },
	//    { "das$hed", HPGL2_DASHED },
	//    { "f$ont", HPGL2_FONT },
	//    { "s$ize", HPGL2_SIZE },
	//    { "n$opspoints", HPGL2_NOPSPOINTS },
	//    { "p$spoints", HPGL2_PSPOINTS },
	//    { NULL, HPGL2_INVALID }
	//};
	//
	//TERM_PUBLIC void
	//HPGL2_options()
	//{
	//    struct termentry *t = term;
	//    int i;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&HPGL2_opts[0],c_token)) {
	//	case HPGL2_MONOCHROME:
	//	    HPGL2_color = 0;
	//	    c_token++;
	//	    break;
	//	case HPGL2_COLOR:
	//	    HPGL2_color = 1;
	//	    c_token++;
	//	    if (!END_OF_COMMAND && isanumber(c_token)) {
	//		HPGL2_numpen = (int) real(&token[c_token].l_val);
	//		if (HPGL2_numpen <= 0) {
	//		    HPGL2_numpen = 6;
	//		    int_error(c_token, "Number of pens must be a positive");
	//		}
	//	    c_token++;
	//	    }
	//	    break;
	//	case HPGL2_SOLID:
	//	    HPGL2_solid = 1;
	//	    c_token++;
	//	    break;
	//	case HPGL2_DASHED:
	//	    HPGL2_solid = 0;
	//	    c_token++;
	//	    break;
	//	case HPGL2_FONT:
	//	    c_token++;
	//	    if (!END_OF_COMMAND) {
	//		for (i = 0; i < HPGL2_FONTS && !almost_equals(c_token, HPGL2_font_table[i].compare); i++);
	//		if (i < HPGL2_FONTS) {
	//		    HPGL2_font = &HPGL2_font_table[i];
	//		    HPGL2_font_num = i;
	//		    HPGL2_font_num_current = HPGL2_font_num;
	//		} else
	//		    int_error(c_token,
	//			      "expecting font: stick, cg_times, univers, zapf_dingbats, antique_olive,\narial, courier, garamond_antigua, letter_gothic, cg_omega, albertus,\ntimes_new_roman, clarendon, coronet, marigold, truetype_symbols, or wingdings");
	//		c_token++;
	//	    } else
	//		int_error(c_token,
	//			  "expecting font: stick, cg_times, univers, zapf_dingbats, antique_olive,\narial, courier, garamond_antigua, letter_gothic, cg_omega, albertus,\ntimes_new_roman, clarendon, coronet, marigold, truetype_symbols, or wingdings");
	//	    break;
	//	case HPGL2_SIZE:
	//	    c_token++;
	//	    if (!END_OF_COMMAND) {
	//		if ((HPGL2_point_size = real(&token[c_token].l_val)) > 0.0) {
	//		    HPGL2_point_size_current = HPGL2_point_size;
	//		    t->v_char = (int) HPGL_PUPI *HPGL2_point_size / 72;
	//		    t->h_char = t->v_char * 2 / 3;
	//		    if (HPGL2_font->spacing)
	//			HPGL2_font->height = HPGL2_point_size;
	//		    else
	//			HPGL2_font->pitch = 72 * 3 / (HPGL2_point_size * 2);
	//		} else
	//		    int_error(c_token, "expecting point size: real number");
	//		c_token++;
	//	    } else
	//		int_error(c_token, "expecting point size: real number");
	//	    break;
	//	case HPGL2_NOPSPOINTS:
	//	    c_token++;
	//	    pspointset = 0;
	//	    break;
	//	case  HPGL2_PSPOINTS:
	//	    c_token++;
	//	    pspointset = 1;
	//	    break;
	//	case HPGL2_INVALID:
	//	    c_token++;
	//	default:
	//	    break;
	//	}
	//    }
	//
	//    sprintf(term_options+strlen(term_options)," %s %d %s \\\n"
	//					      "   %s %s %f %s",
	//	    HPGL2_color ? "color" : "monochrome",
	//	    HPGL2_color == 1 ? HPGL2_numpen : 1,
	//	    HPGL2_solid ? "solid" : "dashed",
	//	    HPGL2_font->name,
	//	    HPGL2_font->spacing ? "height" : "pitch",
	//	    HPGL2_font->spacing ? HPGL2_font->height : HPGL2_font->pitch,
	//	    pspointset ? "pspoints" : "nopspoints");
	//}
	//
	///#if 0
	// /* Unused for now */
	//
	//enum PCL_id {
	//    PCL_MODE, PCL_EXTENDED, PCL_EXTENDED, PCL_LEGAL, PCL_LETTER,
	//    PCL_INVALID
	//};
	//
	//static struct gen_table PCL_opts[] =
	//{
	//    { "m$ode", PCL_MODE },
	//    { "ext$ended", PCL_EXTENDED },
	//    { "noext$ended", PCL_NOEXTENDED },
	//    { "leg$al", PCL_LEGAL },
	//    { "let$ter", PCL_LETTER },
	//    { NULL, PCL_INVALID }
	//};
	///#endif
	//
	//TERM_PUBLIC void
	//PCL_options()
	//{
	//    int i;
	//
	//    if (!END_OF_COMMAND && almost_equals(c_token, "m$ode")) {
	//	c_token++;
	//	if (!END_OF_COMMAND) {
	//	    for (i = 0; i < PCL_MODES && !almost_equals(c_token, PCL_mode_table[i].compare); i++);
	//	    if (i < PCL_MODES)
	//		PCL_mode = &PCL_mode_table[i];
	//	    else
	//		int_error(c_token, "expecting mode: portrait or landscape");
	//	    c_token++;
	//	} else
	//	    int_error(c_token, "expecting mode: portrait or landscape");
	//    }
	//    if (!END_OF_COMMAND && almost_equals(c_token, "ext$ended")) {
	//	PCL_mode->xmax = (HPGL_XMAX_D);
	//	PCL_mode->ymax = (HPGL_YMAX_D - 60);
	//	PCL_dim = "extended";
	//	c_token++;
	//    } else if (!END_OF_COMMAND && almost_equals(c_token, "noext$ended")) {
	//	PCL_mode->xmax = (HPGL_XMAX_C);
	//	PCL_mode->ymax = (HPGL_YMAX_C - 60);
	//	PCL_dim = "noextended";
	//	c_token++;
	//    } else if (!END_OF_COMMAND && almost_equals(c_token, "leg$al")) {
	//	PCL_mode->xmax = (HPGL_XMAX_B);
	//	PCL_mode->ymax = (HPGL_YMAX_B - 60);
	//	PCL_dim = "legal";
	//	c_token++;
	//    } else if (!END_OF_COMMAND && almost_equals(c_token, "let$ter")) {
	//	PCL_mode->xmax = (HPGL_XMAX_A);
	//	PCL_mode->ymax = (HPGL_YMAX_A - 60);
	//	PCL_dim = "letter";
	//	c_token++;
	//    }
	//    sprintf(term_options, "%s %s", PCL_mode->name, PCL_dim);
	//    HPGL2_options();
	//}
	//
	//TERM_PUBLIC void
	//HPGL_init()
	//{
	//}
	//
	// /* void HPGL2_init ()
	// {
	// } */
	//
	//TERM_PUBLIC void
	//PCL_init()
	//{
	//    struct termentry *t = term;
	// /*
	//  * Reset printer, set to one copy, orientation of user's choice.
	//  * Make the change to the new orientation all at once.
	//  */
	//    fprintf(gpoutfile, "\033E\033&l1X%s\n", PCL_mode->command);
	//    t->xmax = PCL_mode->xmax;
	//    t->ymax = PCL_mode->ymax;
	// /*
	//  * Enter HPGL/2 graphics mode
	//  * Necessary here to keep the first DI0,1DI1,0 orientation command from being
	//  * printed as literal text on the page for some devices. Hopefully this
	//  * workaround has no bad consequences elsewhere; omit this line if it does.
	//  */
	//    fputs("\033%0B", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//HPGL_graphics()
	//{
	//    fputs("\033.Y\n\033.I81;;17:\033.N;19:\033.M500:\n", gpoutfile);
	// /*	       1
	// 	1. enable eavesdropping
	// */
	//    fprintf(gpoutfile,
	//	    "IN;%s\nSC0,%d,0,%d;\nSR%f,%f;\n",
	//	    ((encoding == S_ENC_CP850) || (encoding == S_ENC_ISO8859_1)) ?
	//	    "CA7;" : "",
	//	    HPGL_XMAX, HPGL_YMAX, ((double) (HPGL_HCHAR) * 200 / 3 / HPGL_XMAX), ((double) (HPGL_VCHAR) * 100 / 2 / HPGL_YMAX));
	// /*	 1    2             3
	// 	1. reset to power-up defaults
	// 	2. set SCaling
	// 	3. set character size
	// */
	//    HPGL_ang = 0;
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_graphics()
	//{
	// /*
	//  * IN - Initialize
	//  * SP - Select pen
	//  * SD - Set default font
	//  */
	//    fprintf(gpoutfile, "INSP1SD1,%d,2,%d,", HPGL2_font->symbol_set, HPGL2_font->spacing);
	//    if (HPGL2_font->spacing)
	//	fprintf(gpoutfile, "4,%f,", HPGL2_font->height);
	//    else
	//	fprintf(gpoutfile, "3,%f,", HPGL2_font->pitch);
	//    fprintf(gpoutfile, "5,%d,6,%d,7,%d;SS;\n", HPGL2_font->posture, HPGL2_font->stroke_weight, HPGL2_font->typeface);
	// /*
	//  * Add a set of user-defined dashed linetypes if the dashed option is
	//  * selected. Of course, the UL's below can be edited to user preference.
	//  */
	//    if (HPGL2_solid == 0) {
	//	fputs("
	//UL1,100;\n
	//UL2,8,8,9,8,8,9,8,8,9,8,8,9;\n
	//UL3,6,6,6,7,6,6,6,7,6,6,6,7,6,6,6,7;\n
	//UL4,5,5,5,10,5,5,5,10,5,5,5,10;\n
	//UL5,5,5,5,5,5,8,5,5,5,5,5,8,5,5,5,5,5,9;\n
	//UL6,8,8,0,9,8,8,0,9,8,8,0,9;\n
	//UL7,4,4,4,4,0,4,4,4,4,4,0,4,4,4,4,4,0,4;\n
	//UL8,6,6,6,6,6,6,0,6,6,6,6,6,6,6,0,6;\n",
	//		gpoutfile);
	//    }
	// /*
	//  * Control variables
	//  */
	//    HPGL_ang = 0;		// Horizontal 
	//    HPGL2_in_pe = FALSE;	// Not in PE command 
	//    HPGL2_lost = TRUE;		// Pen position is unknown 
	//    HPGL_penstate = UP;		// Pen is up 
	//}
	//
	//TERM_PUBLIC void
	//PCL_graphics()
	//{
	// /*
	//  * Enter HPGL/2 graphics mode
	//  */
	//    fputs("\033%0B", gpoutfile);
	//    HPGL2_graphics();
	//}
	//
	//TERM_PUBLIC void
	//HPGL_text()
	//{
	//    if (HPGL_eject == 0) {
	//	fputs("PUSP0;\033.Z\n\0", gpoutfile);
	// /*		 1 2   3
	// 	1. pen up
	// 	2. park pen
	// 	3. disable eavesdropping
	// */
	//    } else {
	//	fputs("PUSP0;PG;\033.Z\n\0", gpoutfile);
	// /*		 1 2   3  4
	// 	1. pen up
	// 	2. park pen
	// 	3. page eject
	// 	4. disable eavesdropping
	// */
	//    }
	//    HPGL_penstate = UP;
	//}
	//
	///#if 0				// not used 
	//void
	//HPGL2_text()
	//{
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	// /*
	//  * Pen up, park pen
	//  */
	//    fputs("PUSP0;", gpoutfile);
	//    HPGL_penstate = UP;
	//}
	///#endif
	//
	//TERM_PUBLIC void
	//PCL_text()
	//{
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	// /*
	//  * Go into PCL mode and eject the page
	//  */
	//    fputs("\033%1A\033&l0H\n\0", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//HPGL_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	// /* allow for set number of pens */
	//    linetype = (linetype + 2) % HPGL_numpen + 1;
	// /* only select pen if necessary */
	//    if (HPGL_pentype != linetype) {
	//	fprintf(gpoutfile, "PU;\nSP%d;\n", linetype);
	//	HPGL_pentype = linetype;
	//	HPGL_penstate = UP;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_linetype(int linetype)
	//{
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	// /* allow for set number of pens for color displays */
	//    if (HPGL2_color == 1) {
	//	if (linetype >= 0) {
	//	    if (HPGL2_solid == 0)
	//		HPGL2_dashed = linetype % HPGL2_LINETYPES + 1;
	//	    linetype = (linetype + 2) % HPGL2_numpen + 1;
	//	}
	// /* only select pen if necessary */
	//	if (linetype != HPGL2_pentype) {
	//	    if (linetype >= 0) {
	//		if (HPGL2_solid == 0) {
	//		    fprintf(gpoutfile, "PU;\nSP%d;\nLT%d;", linetype, HPGL2_dashed);
	//		} else
	//		    fprintf(gpoutfile, "PU;\nSP%d;\nLT;", linetype);
	// /* Borders and Tics */
	//	    } else if (linetype == LT_BLACK) {
	//		fprintf(gpoutfile, "PU;\nSP1;\nPW.2LT");
	// /* Axes and Grids */
	//	    } else if (linetype == LT_AXIS)
	//		fprintf(gpoutfile, "PU;\nSP1;\nPW.2LT1,.25");
	//	    HPGL_penstate = UP;
	//	    HPGL2_pentype = linetype;
	//	}
	// /* allow for lots of linetypes for monochrome displays */
	//    } else {
	//	if (linetype >= 0) {
	//	    if (HPGL2_solid == 0)
	//		HPGL2_dashed = linetype % HPGL2_LINETYPES + 1;
	//	    linetype = linetype % (HPGL2_LINETYPES * HPGL2_PENWIDTHS);
	//	}
	// /* only select pen if necessary */
	//	if (linetype != HPGL2_pentype) {
	//	    if (linetype >= 0) {
	//		if (HPGL2_solid == 0) {
	//		    fprintf(gpoutfile, "PW%sLT%d%s", HPGL2_pw[linetype / HPGL2_LINETYPES], HPGL2_dashed,
	//			    HPGL2_lt[linetype % HPGL2_LINETYPES]);
	//		} else
	//		    fprintf(gpoutfile, "PW%sLT", HPGL2_pw[linetype / HPGL2_LINETYPES]);
	// /* Borders and Tics */
	//	    } else if (linetype == LT_BLACK) {
	//		fprintf(gpoutfile, "PW.2LT");
	// /* Axes and Grids */
	//	    } else if (linetype == LT_AXIS)
	//		fprintf(gpoutfile, "PW.1LT1,.25");
	//	    HPGL2_pentype = linetype;
	//	}
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HPGL_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    if (HPGL_ang == 1)
	//	HPGL_move(x + HPGL_VCHAR / 4, y);
	//    else
	//	HPGL_move(x, y - HPGL_VCHAR / 4);
	//    if (encoding == S_ENC_CP850) {
	//	unsigned char *s;
	//	fputs("LB", gpoutfile);
	//	for (s = (unsigned char *) str; *s; ++s)
	//	    if (*s >= 128 && hpgl_cp_850[*s - 128][0])
	//		fputs(hpgl_cp_850[*s - 128], gpoutfile);
	//	    else
	//		putc(*s, gpoutfile);
	//	fputs("\003\n", gpoutfile);
	//    } else if (encoding == S_ENC_ISO8859_1) {
	//	unsigned char *s;
	//	fputs("LB", gpoutfile);
	//	for (s = (unsigned char *) str; *s; ++s)
	//	    if (*s >= 128 && hpgl_iso_8859_1[*s - 128][0])
	//		fputs(hpgl_iso_8859_1[*s - 128], gpoutfile);
	//	    else
	//		putc(*s, gpoutfile);
	//	fputs("\003\n", gpoutfile);
	//    } else
	//	fprintf(gpoutfile, "LB%s\003\n", str);
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    struct termentry *t = term;
	// /*
	//  * Position the pen
	//  */
	//    if (HPGL_ang == 1)
	//	HPGL2_move(x + t->v_char / 4, y);
	//    else
	//	HPGL2_move(x, y - t->v_char / 4);
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	// /*
	//  * Print the text string
	//  */
	//    fprintf(gpoutfile, "LB%s\003\n", str);
	//    HPGL2_lost = 1;
	//}
	//
	// /*
	//  * Some early HPGL plotters (e.g. HP7220C) require the
	//  * Pen Up/Down and Pen (move) Absolute commands to be separate.
	//  */
	//
	//TERM_PUBLIC void
	//HPGL_move(unsigned int x, unsigned int y)
	//{
	//    if (HPGL_x != x || HPGL_y != y) {	// only move if necessary 
	//	fprintf(gpoutfile, "PU;PA%d,%d;\n", x, y);
	//	HPGL_penstate = UP;
	//	HPGL_x = x;
	//	HPGL_y = y;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HPGL_vector(unsigned int x, unsigned int y)
	//{
	//    if (HPGL_penstate != DOWN) {
	//	fprintf(gpoutfile, "PD;PA%d,%d;\n", x, y);
	//	HPGL_penstate = DOWN;
	//    } else
	//	fprintf(gpoutfile, "PA%d,%d;\n", x, y);
	//    HPGL_x = x;
	//    HPGL_y = y;
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_move(unsigned int x, unsigned int y)
	//{
	//    int dx, dy;
	//    if (HPGL2_in_pe) {
	//	dx = x - HPGL_x;
	//	dy = y - HPGL_y;
	//	fputs("<", gpoutfile);
	//    } else {
	///#if HPGL2_BASE64
	//	fputs("PE<", gpoutfile);
	///#else
	//	fputs("PE7<", gpoutfile);
	///#endif
	//	if (HPGL2_lost) {
	//	    dx = x;
	//	    dy = y;
	//	    HPGL2_lost = 0;
	//	    fputs("=", gpoutfile);
	//	} else {
	//	    dx = x - HPGL_x;
	//	    dy = y - HPGL_y;
	//	}
	//	HPGL2_in_pe = 1;
	//    }
	///#if HPGL2_EXPLICIT_PD
	//    if (HPGL_penstate == DOWN)
	//	HPGL_penstate = UP;
	///#endif
	//    HPGL2_encode(dx);
	//    HPGL2_encode(dy);
	//    fputs("\n", gpoutfile);
	//    HPGL_x = x;
	//    HPGL_y = y;
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_vector(unsigned int x, unsigned int y)
	//{
	//    int dx, dy;
	//    if (HPGL2_in_pe) {
	//	dx = x - HPGL_x;
	//	dy = y - HPGL_y;
	//    } else {
	///#if HPGL2_BASE64
	//	fputs("PE", gpoutfile);
	///#else
	//	fputs("PE7", gpoutfile);
	///#endif
	//	if (HPGL2_lost) {
	//	    dx = x;
	//	    dy = y;
	//	    HPGL2_lost = 0;
	//	    fputs("=", gpoutfile);
	//	} else {
	//	    dx = x - HPGL_x;
	//	    dy = y - HPGL_y;
	//	}
	//	HPGL2_in_pe = 1;
	//    }
	///#if HPGL2_EXPLICIT_PD
	// /*
	//  * Put the pen down in the current position,
	//  * relative vector of 0,0.
	//  */
	//    if (HPGL_penstate == UP) {
	//	fputc((char) HPGL2_HIGH_OFFS, gpoutfile);
	//	fputc((char) HPGL2_HIGH_OFFS, gpoutfile);
	//	HPGL_penstate = DOWN;
	//    }
	///#endif
	//    HPGL2_encode(dx);
	//    HPGL2_encode(dy);
	//    fputs("\n", gpoutfile);
	//    HPGL_x = x;
	//    HPGL_y = y;
	//}
	//
	// /*
	//  * Routine to encode position in base 32 or base 64 characters
	//  */
	//
	//TERM_PUBLIC void
	//HPGL2_encode(int d)
	//{
	//    int c;
	//
	//    if ((d <<= 1) < 0)
	//	d = 1 - d;
	//    do {
	//	c = d & HPGL2_MASK;
	//	d >>= HPGL2_BITS;
	//	if (d > 0)
	//	    fputc((char) (c + HPGL2_LOW_OFFS), gpoutfile);
	//	else
	//	    fputc((char) (c + HPGL2_HIGH_OFFS), gpoutfile);
	//    } while (d > 0);
	//}
	//
	//TERM_PUBLIC int
	//HPGL_text_angle(int ang)
	//{
	//    if (ang == -90 || ang == 270)
	//	HPGL_ang = -1;
	//    else
	//	HPGL_ang = (ang ? 1 : 0);
	//
	//    if (HPGL_ang == 0) 			// Horizontal 
	//	fputs("DI1,0;\n", gpoutfile);
	//    else if (HPGL_ang == -1)		// Vertical Down 
	//	fputs("DI0,-1;\n", gpoutfile);
	//    else				// Vertical Up 
	//	fputs("DI0,1;\n", gpoutfile);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int
	//HPGL2_text_angle(int ang)
	//{
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (ang == -90 || ang == 270)
	//	HPGL_ang = -1;
	//    else
	//	HPGL_ang = (ang ? 1 : 0);
	//
	//    if (HPGL2_in_pe) {
	//	fputs(";", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	//    if (HPGL_ang == 1)			// Vertical Up 
	//	fputs("DI0,1", gpoutfile);
	//    else if (HPGL_ang == -1)		// Vertical Down 
	//	fputs("DI0,-1", gpoutfile);
	//    else				// Horizontal 
	//	fputs("DI1,0", gpoutfile);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//HPGL_reset()
	//{
	// /*
	//  * do nothing
	//  */
	//}
	//
	///#if 0
	//void
	//HPGL2_reset()
	//{
	// /*
	//  * Park the pen
	//  * Advance a page
	//  * End with ";"
	//  */
	//    fputs("SP0PG;\n", gpoutfile);
	//}
	//
	///#endif
	//
	//TERM_PUBLIC void
	//PCL_reset()
	//{
	// /*
	//  * Return to PCL mode
	//  * Printer reset (conditional eject)
	//  */
	//    fputs("\033%0A\033E\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC int
	//HPGL2_justify_text(enum JUSTIFY just)
	//{
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	//    switch (just) {
	//    case LEFT:
	//	fputs("LO1", gpoutfile);
	//	break;
	//    case CENTRE:
	//	fputs("LO4", gpoutfile);
	//	break;
	//    case RIGHT:
	//	fputs("LO7", gpoutfile);
	//	break;
	//    default:
	//	return 0;
	//    }
	//    return 1;
	//}
	//
	//TERM_PUBLIC int
	//HPGL2_set_font(const char *font)
	//{
	//    struct termentry *t = term;
	//    char name[MAX_ID_LEN + 1];
	//    int i, sep, int_size, sep2;
	//    double size;
	// /*
	//  * If in Polyline Encoded command, leave Polyline Encoded command
	//  */
	//    if (HPGL2_in_pe) {
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//    }
	// /* determine font, use default from options if invalid */
	//    sep = strcspn(font, ",");
	//    strncpy(name, font, sep);
	//    name[sep] = NUL;
	//    for (i = 0; i < HPGL2_FONTS; i++) {
	//	sep2 = strcspn(HPGL2_font_table[i].compare, "$");
	//	if (strncmp(name, HPGL2_font_table[i].compare, sep2) == 0)
	//	    break;
	//    }
	//    if (i >= HPGL2_FONTS)
	//	i = HPGL2_font_num;
	// /* determine font size, use default from options if invalid */
	//    int_size = 0;
	//    sscanf(&(font[sep + 1]), "%d", &int_size);
	//    if (int_size > 0) {
	//	size = int_size;
	//    } else
	//	size = HPGL2_point_size;
	// /* apply font changes only if necessary */
	//    if (size == HPGL2_point_size_current && i == HPGL2_font_num_current)
	//	return FALSE;
	//    HPGL2_font = &HPGL2_font_table[i];
	//    HPGL2_font_num_current = i;
	//    HPGL2_point_size_current = size;
	//    t->v_char = (int) HPGL_PUPI *HPGL2_point_size_current / 72;
	//    t->h_char = t->v_char * 2 / 3;
	//    fprintf(gpoutfile, "SD1,%d,2,%d,", HPGL2_font->symbol_set, HPGL2_font->spacing);
	//    if (HPGL2_font->spacing) {
	//	HPGL2_font->height = HPGL2_point_size_current;
	//	fprintf(gpoutfile, "4,%f,", HPGL2_font->height);
	//    } else {
	//	HPGL2_font->pitch = 72 * 3 / (HPGL2_point_size_current * 2);
	//	fprintf(gpoutfile, "3,%f,", HPGL2_font->pitch);
	//    }
	//    fprintf(gpoutfile, "5,%d,6,%d,7,%d;SS;\n", HPGL2_font->posture, HPGL2_font->stroke_weight, HPGL2_font->typeface);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_point(unsigned int x, unsigned int y, int number)
	//{
	//    int htic, vtic;
	//    if (pspointset) {		// postscript style points 
	//	if (number < 0) {
	//	    HPGL2_neg_point(x, y, number);
	//	} else {
	//	    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
	//	    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
	//	    number %= HPGL2_NUM_PSPOINTS;
	//	    switch (number) {
	//	    case 0:		// plus 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x, y + vtic);
	//		break;
	//	    case 1:		// X 
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_move(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		break;
	//	    case 2:		// star 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_move(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		break;
	//	    case 3:		// hollow square 1 
	//		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 4:		// solid square 1 
	//		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%.2f,%.2f;EP;\n", ((double) x + (3 * htic / 4)), ((double) y + (3 * vtic / 4)));
	//		break;
	//	    case 5:		// hollow circle 1 
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//		break;
	//	    case 6:		// solid circle 1 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//		break;
	//	    case 7:		// hollow triangle 1 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 8:		// solid triangle 1 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 9:		// hollow triangle 2 
	//		HPGL2_move(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 10:		// solid triangle 2 
	//		HPGL2_move(x, y - (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 11:		// hollow diamond 1 
	//		HPGL2_move(x - (3 * htic / 4), y);
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y);
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y);
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 12:		// solid diamond 1 
	//		HPGL2_move(x - (3 * htic / 4), y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y);
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 13:		// hollow pentagon 1 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 14:		// solid pentagon 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 15:		// hollow circle 2 
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "CI%d;\n", htic);
	//		break;
	//	    case 16:		// semisolid circle 1 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,0,90;EP;EW%d,90,270;\n", htic, htic);
	//		break;
	//	    case 17:		// semisolid circle 2 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,90,90;EP;EW%d,180,270;\n", htic, htic);
	//		break;
	//	    case 18:		// semisolid circle 3 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,0,180;EP;EW%d,180,180;\n", htic, htic);
	//		break;
	//	    case 19:		// semisolid circle 4 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,180,90;EP;EW%d,270,270;\n", htic, htic);
	//		break;
	//	    case 20:		// semisolid circle 5 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,0,90;EP;EW%d,90,90;WG%d,180,90;EP;EW%d,270,90;\n", htic, htic, htic, htic);
	//		break;
	//	    case 21:		// semisolid circle 6 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,90,180;EP;EW%d,270,180;\n", htic, htic);
	//		break;
	//	    case 22:		// semisolid circle 7 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,0,270;EP;EW%d,270,90;\n", htic, htic);
	//		break;
	//	    case 23:		// semisolid circle 8 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,270,90;EP;EW%d,0,270;\n", htic, htic);
	//		break;
	//	    case 24:		// semisolid circle 9 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,270,180;EP;EW%d,90,180;\n", htic, htic);
	//		break;
	//	    case 25:		// semisolid circle 10 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,90,90;EP;EW%d,180,90;WG%d,270,90;EP;EW%d,0,90;\n", htic, htic, htic, htic);
	//		break;
	//	    case 26:		// semisolid circle 11 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,270,270;EP;EW%d,180,90;\n", htic, htic);
	//		break;
	//	    case 27:		// semisolid circle 12 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,180,180;EP;EW%d,0,180;\n", htic, htic);
	//		break;
	//	    case 28:		// semisolid circle 13 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,180,270;EP;EW%d,90,90;\n", htic, htic);
	//		break;
	//	    case 29:		// semisolid circle 14 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,90,270;EP;EW%d,0,90;\n", htic, htic);
	//		break;
	//	    case 30:		// solid circle 2 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "WG%d,0,360;EP;\n", htic);
	//		break;
	//	    case 31:		// hollow square 2 
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 32:		// semisolid square 1 
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 33:		// semisolid square 2 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		break;
	//	    case 34:		// semisolid square 3 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 35:		// semisolid square 4 
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y);
	//		break;
	//	    case 36:		// semisolid square 5 
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y);
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 37:		// semisolid square 6 
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		break;
	//	    case 38:		// semisolid square 7 
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 39:		// semisolid square 8 
	//		HPGL2_move(x + htic, y);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
	//		break;
	//	    case 40:		// semisolid square 9 
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 41:		// semisolid square 10 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_move(x + htic, y);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		HPGL2_move(x, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
	//		break;
	//	    case 42:		// semisolid square 11 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		break;
	//	    case 43:		// semisolid square 12 
	//		HPGL2_move(x + htic, y);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
	//		break;
	//	    case 44:		// semisolid square 13 
	//		HPGL2_move(x, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 45:		// semisolid square 14 
	//		HPGL2_move(x + htic, y);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
	//		break;
	//	    case 46:		// solid square 2 
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
	//		break;
	//	    case 47:		// hollow diamond 2 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 48:		// semisolid diamond 1 
	//		HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 49:		// semisolid diamond 2 
	//		HPGL2_move(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 50:		// semisolid diamond 3 
	//		HPGL2_move(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 51:		// semisolid diamond 4 
	//		HPGL2_move(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 52:		// semisolid diamond 5 
	//		HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		HPGL2_move(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 53:		// semisolid diamond 6 
	//		HPGL2_move(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 54:		// semisolid diamond 7 
	//		HPGL2_move(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 55:		// semisolid diamond 8 
	//		HPGL2_move(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 56:		// semisolid diamond 9 
	//		HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 57:		// semisolid diamond 10 
	//		HPGL2_move(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		HPGL2_move(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 58:		// semisolid diamond 11 
	//		HPGL2_move(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 59:		// semisolid diamond 12 
	//		HPGL2_move(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 60:		// semisolid diamond 13 
	//		HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 61:		// semisolid diamond 14 
	//		HPGL2_move(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//		HPGL2_vector(x, y);
	//		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 62:		// solid diamond 2 
	//		HPGL2_move(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FP;EP;\n");
	//		break;
	//	    case 63:		// hollow square 3 
	//		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
	//		break;
	//	    case 64:		// hollow circle 3 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//		break;
	//	    case 65:		// hollow triangle 3 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		break;
	//	    case 66:		// hollow triangle 4 
	//		HPGL2_move(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		break;
	//	    case 67:		// hollow diamond 3 
	//		HPGL2_move(x - (3 * htic / 4), y);
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y);
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y);
	//		break;
	//	    case 68:		// hollow pentagon 2 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		break;
	//	    case 69:		// opaque square 
	//		HPGL2_move(x - htic, y - vtic);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "FT10,30;RA%d,%d;EP;FT;\n", x + (3 * htic / 4), y + (3 * vtic / 4));
	//		break;
	//	    case 70:		// opaque circle 
	//		HPGL2_move(x, y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "FT10,30;WG%.2f,0,360;EP;FT;\n", ((double) 3 * (htic) / 4));
	//		break;
	//	    case 71:		// opaque triangle 1 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
	//		break;
	//	    case 72:		// opaque triangle 2 
	//		HPGL2_move(x, y - (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
	//		break;
	//	    case 73:		// opaque diamond 
	//		HPGL2_move(x - (3 * htic / 4), y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x, y - (3 * vtic / 4));
	//		HPGL2_vector(x + (3 * htic / 4), y);
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		HPGL2_vector(x - (3 * htic / 4), y);
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
	//		break;
	//	    case 74:		// opaque pentagon 
	//		HPGL2_move(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM0;\n");
	//		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
	//		HPGL2_vector(x, y + (3 * vtic / 4));
	//		fputs(";\n", gpoutfile);
	//		HPGL2_in_pe = 0;
	//		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
	//		break;
	//	    }
	//	}
	//    } else {			// default style points 
	//	if (number < 0) {
	//	    HPGL2_neg_point(x, y, number);
	//	} else {
	//	    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
	//	    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
	//	    number %= HPGL2_NUM_NOPSPOINTS;
	//	    switch (number) {
	//	    case 0:		// diamond 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 1:		// plus 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x, y + vtic);
	//		break;
	//	    case 2:		// box 
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 3:		// X 
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_move(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		break;
	//	    case 4:		// triangle 
	//		HPGL2_move(x, y + (4 * vtic / 3));
	//		HPGL2_vector(x - (4 * htic / 3), y - (2 * vtic / 3));
	//		HPGL2_vector(x + (4 * htic / 3), y - (2 * vtic / 3));
	//		HPGL2_vector(x, y + (4 * vtic / 3));
	//		HPGL2_move(x, y);
	//		HPGL2_vector(x, y);
	//		break;
	//	    case 5:		// star 
	//		HPGL2_move(x - htic, y);
	//		HPGL2_vector(x - htic, y);
	//		HPGL2_vector(x + htic, y);
	//		HPGL2_move(x, y - vtic);
	//		HPGL2_vector(x, y - vtic);
	//		HPGL2_vector(x, y + vtic);
	//		HPGL2_move(x - htic, y - vtic);
	//		HPGL2_vector(x - htic, y - vtic);
	//		HPGL2_vector(x + htic, y + vtic);
	//		HPGL2_move(x - htic, y + vtic);
	//		HPGL2_vector(x - htic, y + vtic);
	//		HPGL2_vector(x + htic, y - vtic);
	//		break;
	//	    }
	//	}
	//    }
	//}
	//
	// /*
	//  * This is for special purpose negative point types. If they are not needed,
	//  * they should be safely ignorable, but the special pointypes can be omitted
	//  * if necessary, leaving only the dot (which is -1).
	//  */
	//
	//TERM_PUBLIC void
	//HPGL2_neg_point(unsigned int x, unsigned int y, int number)
	//{
	//    int htic, vtic;
	//    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
	//    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
	//    switch (number) {
	//    case -20:			// well 18 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x + htic, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -19:			// well 17 
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (vtic / 2));
	//	HPGL2_move(x, y + (vtic / 2));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x - (htic / 4), y - (3 * vtic / 4));
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x + (htic / 4), y - (3 * vtic / 4));
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) (htic) / 2));
	//	break;
	//    case -18:			// well 16 
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -17:			// well 15 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + htic, y + vtic);
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
	//	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -16:			// well 14 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + htic, y + vtic);
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -15:			// well 13 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + htic, y + vtic);
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -14:			// well 12 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + htic, y + vtic);
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -13:			// well 11 
	//	HPGL2_move(x - htic, y - vtic);
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + htic, y + vtic);
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -12:			// well 10 
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
	//	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -11:			// well 9 
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -10:			// well 8 
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
	//	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -9:			// well 7 
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
	//	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -8:			// well 6 
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -7:			// well 5 
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -6:			// well 4 
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
	//	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -5:			// well 3 
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -4:			// well 2 
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -3:			// well 1 
	//	HPGL2_move(x, y);
	//	fputs(";\n", gpoutfile);
	//	HPGL2_in_pe = 0;
	//	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
	//	break;
	//    case -2:			// v box 
	//	HPGL2_move(x - htic, y);
	//	HPGL2_vector(x - (3 * htic / 4), y);
	//	HPGL2_move(x + (3 * htic / 4), y);
	//	HPGL2_vector(x + htic, y);
	//	HPGL2_move(x, y - vtic);
	//	HPGL2_vector(x, y - (3 * vtic / 4));
	//	HPGL2_move(x, y + (3 * vtic / 4));
	//	HPGL2_vector(x, y + vtic);
	//	HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
	//	HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
	//	HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
	//	HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
	//	HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
	//	HPGL2_move(x - (htic / 2), y + (vtic / 2));
	//	HPGL2_vector(x, y - (vtic / 2));
	//	HPGL2_vector(x + (htic / 2), y + (vtic / 2));
	//	break;
	//    default:			// dot 
	//	HPGL2_move(x, y);
	//	HPGL2_vector(x, y);
	//	break;
	//	return;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HPGL2_pointsize(double size)
	//{
	//    HPGL2_psize = (size >= 0 ? size : 1);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(hpgl_driver)
	//    "hpgl", "HP7475 and relatives [number of pens] [eject]",
	//    HPGL_XMAX, HPGL_YMAX, HPGL_VCHAR, HPGL_HCHAR,
	//    HPGL_VTIC, HPGL_HTIC, HPGL_options, HPGL_init, HPGL_reset,
	//    HPGL_text, null_scale, HPGL_graphics, HPGL_move, HPGL_vector,
	//    HPGL_linetype, HPGL_put_text, HPGL_text_angle, null_justify_text, do_point, do_arrow, set_font_null TERM_TABLE_END(hpgl_driver)
	///#undef LAST_TERM
	///#define LAST_TERM hpgl_driver
	//    TERM_TABLE_START(pcl5_driver)
	//    "pcl5", "HP Designjet 750C, HP Laserjet III/IV, etc. (many options)",
	//    PCL_XMAX, PCL_YMAX, HPGL2_VCHAR, HPGL2_HCHAR,
	//    PCL_VTIC, PCL_HTIC, PCL_options, PCL_init, PCL_reset,
	//    PCL_text, null_scale, PCL_graphics, HPGL2_move, HPGL2_vector,
	//    HPGL2_linetype, HPGL2_put_text, HPGL2_text_angle,
	//    HPGL2_justify_text, HPGL2_point, do_arrow, HPGL2_set_font, HPGL2_pointsize TERM_TABLE_END(pcl5_driver)
	///#undef LAST_TERM
	///#define LAST_TERM pcl5_driver
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 
	///#ifdef TERM_HELP
	//START_HELP(hpgl)
	//"1 hpgl",
	//"?commands set terminal hpgl",
	//"?set terminal hpgl",
	//"?set term hpgl",
	//"?terminal hpgl",
	//"?term hpgl",
	//"?hpgl",
	//"?commands set terminal pcl5",
	//"?set terminal pcl5",
	//"?set term pcl5",
	//"?terminal pcl5",
	//"?term pcl5",
	//"?pcl5",
	//" The `hpgl` driver produces HPGL output for devices like the HP7475A plotter.",
	//" There are two options which can be set: the number of pens and `eject`,",
	//" which tells the plotter to eject a page when done.  The default is to use 6",
	//" pens and not to eject the page when done.",
	//"",
	//" The international character sets ISO-8859-1 and CP850 are recognized via",
	//" `set encoding iso_8859_1` or `set encoding cp850` (see `set encoding` for",
	//" details).",
	//"",
	//" Syntax:",
	//"       set terminal hpgl {<number_of_pens>} {eject}",
	//"",
	//" The selection",
	//"",
	//"       set terminal hpgl 8 eject",
	//"",
	//" is equivalent to the previous `hp7550` terminal, and the selection",
	//"",
	//"       set terminal hpgl 4",
	//"",
	//" is equivalent to the previous `hp7580b` terminal.",
	//"",
	//" The `pcl5` driver supports plotters such as the Hewlett-Packard Designjet",
	//" 750C, the Hewlett-Packard Laserjet III, and the Hewlett-Packard Laserjet IV.",
	//" It actually uses HPGL-2, but there is a name conflict among the terminal",
	//" devices.  It has several options which must be specified in the order",
	//" indicated below:",
	//"",
	//" Syntax:",
	//"       set terminal pcl5 {mode <mode>} {<plotsize>}",
	//"           {{color {<number_of_pens>}} | monochrome} {solid | dashed}",
	//"           {font <font>} {size <fontsize>} {pspoints | nopspoints}",
	//"",
	//" <mode> is `landscape` or `portrait`. <plotsize> is the physical",
	//" plotting size of the plot, which is one of the following: `letter` for",
	//" standard (8 1/2\" X 11\") displays, `legal` for (8 1/2\" X 14\") displays,",
	//" `noextended` for (36\" X 48\") displays (a letter size ratio) or,",
	//" `extended` for (36\" X 55\") displays (almost a legal size ratio).",
	//" `color` is for multi-pen (i.e. color) plots, and <number_of_pens> is",
	//" the number of pens (i.e. colors) used in color plots. `monochrome` is for",
	//" one (e.g. black) pen plots. `solid` draws all lines as solid lines, or",
	//" `dashed` will draw lines with different dashed and dotted line patterns.",
	//" <font> is `stick`, `univers`, `cg_times`, `zapf_dingbats`, `antique_olive`,",
	//" `arial`, `courier`, `garamond_antigua`, `letter_gothic`, `cg_omega`,",
	//" `albertus`, `times_new_roman`, `clarendon`, `coronet`, `marigold`,",
	//" `truetype_symbols`, or `wingdings`. <fontsize> is the font size in points.",
	//" The point type selection can be the standard default set by specifying",
	//" `nopspoints`, or the same set of point types found in the postscript terminal",
	//" by specifying `pspoints`.",
	//"",
	//" Note that built-in support of some of these options is printer device",
	//" dependent. For instance, all the fonts are supposedly supported by the HP",
	//" Laserjet IV, but only a few (e.g. univers, stick) may be supported by the HP",
	//" Laserjet III and the Designjet 750C. Also, color obviously won't work on the",
	//" the laserjets since they are monochrome devices.",
	//"",
	//" Defaults: landscape, noextended, color (6 pens), solid, univers, 12 point,",
	//"           and nopspoints.",
	//"",
	//" With `pcl5` international characters are handled by the printer; you just put",
	//" the appropriate 8-bit character codes into the text strings.  You don't need",
	//" to bother with `set encoding`.",
	//"",
	//" HPGL graphics can be imported by many software packages."
	//END_HELP(hpgl)
	///#endif // TERM_HELP 


	/* HP Laserjet II */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hpljii.trm,v 1.24 2006/07/21 02:35:47 sfeam Exp $
	 *
	 */

	/* GNUPLOT - hpljii.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  hpljii, hpdj
	 *
	 * AUTHORS
	 *  John Engels
	 *  Russell Lang
	 *  Maurice Castro
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* The following HP laserjet series II driver uses generic bit mapped graphics
	   routines from bitmap.c to build up a bit map in memory.  The driver
	   interchanges colomns and lines in order to access entire lines
	   easily and returns the lines to get bits in the right order :
	   (x,y) -> (y,XMAX-1-x). */
	/* This interchange is done by calling b_makebitmap() with reversed
	   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
	   will then perform the interchange before each pixel is plotted */
	/* by John Engels JENGELS@BNANDP51.BITNET, inspired by the hpljet driver
	   of Jyrki Yli-Nokari */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(hpljii)
	//register_term(hpdj)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HPLJII_options __PROTO((void));
	//TERM_PUBLIC void HPLJII_init __PROTO((void));
	//TERM_PUBLIC void HPLJII_graphics __PROTO((void));
	//TERM_PUBLIC void HPLJII_text __PROTO((void));
	//TERM_PUBLIC void HPLJII_linetype __PROTO((int linetype));
	//TERM_PUBLIC void HPLJII_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void HPLJII_reset __PROTO((void));
	//
	//TERM_PUBLIC void HPDJ_graphics __PROTO((void));
	//TERM_PUBLIC void HPDJ_text __PROTO((void));
	//
	// /* default values for term_tbl */
	///#define HPLJII_75PPI_XMAX (1920/4)
	///#define HPLJII_75PPI_YMAX (1920/4)
	///#define HPLJII_75PPI_HCHAR (1920/4/6)
	///#define HPLJII_75PPI_VCHAR (1920/4/10)
	///#define HPLJII_75PPI_VTIC 5
	///#define HPLJII_75PPI_HTIC 5
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	// /* We define 4 different print qualities : 300ppi, 150ppi, 100ppi and
	//    75ppi.  (Pixel size = 1, 2, 3, 4 dots) */
	//
	///#define HPLJII_DPP (hplj_dpp)	// dots per pixel 
	///#define HPLJII_PPI (300/HPLJII_DPP)	// pixel per inch 
	// /* make XMAX and YMAX a multiple of 8 */
	///#define HPLJII_XMAX (8*(unsigned int)(xsize*1920/HPLJII_DPP/8.0+0.9))
	///#define HPLJII_YMAX (8*(unsigned int)(ysize*1920/HPLJII_DPP/8.0+0.9))
	//
	// /* Courier font with 6 lines per inch */
	///#define HPLJII_VCHAR (HPLJII_PPI/6)
	// /* Courier font with 10 caracters per inch */
	///#define HPLJII_HCHAR (HPLJII_PPI/10)
	// /* Save current cursor position */
	///#define HPLJII_PUSH_CURSOR fputs("\033&f0S",gpoutfile)
	// /* Restore cursor position */
	///#define HPLJII_POP_CURSOR fputs("\033&f1S",gpoutfile)
	// /* be sure to use courier font with 6lpi and 10cpi */
	///#define HPLJII_COURIER fputs("\033(0N\033(s0p10.0h12.0v0s0b3T\033&l6D",gpoutfile)
	//
	//
	//static void HPLJII_putc __PROTO((unsigned int x, unsigned int y, int c, int ang));
	// /* note: c is char, but must be declared int due to an old K&R ANSI-C strict HP cc */
	//static int hplj_dpp = 4;
	// /* bm_pattern not appropriate for 300ppi graphics */
	///#ifndef GOT_300_PATTERN
	///#define GOT_300_PATTERN
	//static unsigned int b_300ppi_pattern[] =
	//{
	//    0xffff, 0x1111, 0xffff, 0x3333,
	//    0x0f0f, 0x3f3f, 0x0fff, 0x00ff, 0x33ff
	//};
	///#endif
	//
	//TERM_PUBLIC void
	//HPLJII_options()
	//{
	//    char opt[4];
	//    int parse_error = 0;
	//
	//    if (END_OF_COMMAND) {
	//	term_options[0] = NUL;
	//    } else {
	//	if (token[c_token].length > 3) {
	//	    parse_error = 1;	// see below 
	//	} else {
	// /* almost_equals() won't accept numbers - use strcmp() instead */
	//	    capture(opt, c_token, c_token, 4);
	//	    if (!strcmp(opt, "75")) {
	//		hplj_dpp = 4;
	//	    } else if (!strcmp(opt, "100")) {
	//		hplj_dpp = 3;
	//	    } else if (!strcmp(opt, "150")) {
	//		hplj_dpp = 2;
	//	    } else if (!strcmp(opt, "300")) {
	//		hplj_dpp = 1;
	//	    } else {
	// /* error, but set dpi anyway, since term it already set */
	//		parse_error = 1;
	//	    }
	//	    c_token++;
	//	}
	//    }
	//
	//    term->xmax = HPLJII_XMAX;
	//    term->ymax = HPLJII_YMAX;
	//    switch (hplj_dpp) {
	//    case 1:
	//	strcpy(term_options, "300");
	//	term->v_tic = 15;
	//	term->h_tic = 15;
	//	break;
	//    case 2:
	//	strcpy(term_options, "150");
	//	term->v_tic = 8;
	//	term->h_tic = 8;
	//	break;
	//    case 3:
	//	strcpy(term_options, "100");
	//	term->v_tic = 6;
	//	term->h_tic = 6;
	//	break;
	//    case 4:
	//	strcpy(term_options, "75");
	//	term->v_tic = 5;
	//	term->h_tic = 5;
	//	break;
	//    }
	//
	//    if (parse_error)
	//	int_error(c_token, "expecting dots per inch size 75, 100, 150 or 300");
	//}
	//
	//
	//TERM_PUBLIC void
	//HPLJII_init()
	//{
	//    term->v_char = HPLJII_VCHAR;
	//    term->h_char = HPLJII_HCHAR;
	//}
	//
	//
	//TERM_PUBLIC void
	//HPLJII_graphics()
	//{
	//    HPLJII_COURIER;
	//    HPLJII_PUSH_CURSOR;
	// /* rotate plot -90 degrees by reversing XMAX and YMAX and by
	//    setting b_rastermode to TRUE */
	//    b_makebitmap(HPLJII_YMAX, HPLJII_XMAX, 1);
	//    b_rastermode = TRUE;
	//}
	//
	//
	// /* HPLJIItext by rjl - no compression */
	//TERM_PUBLIC void
	//HPLJII_text()
	//{
	//    register int x, j, row;
	//
	//    fprintf(gpoutfile, "\033*t%dR", HPLJII_PPI);
	//    HPLJII_POP_CURSOR;
	//    fputs("\033*r1A", gpoutfile);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	fprintf(gpoutfile, "\033*b0m%dW", b_ysize / 8);
	//	for (j = row; j >= 0; j--) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	}
	//    }
	//    fputs("\033*rB", gpoutfile);
	//
	//    b_freebitmap();
	//
	///#ifndef VMS
	// /* most vms spoolers add a formfeed character */
	//    putc('\f', gpoutfile);
	///#endif // !VMS 
	//}
	//
	//
	//
	//TERM_PUBLIC void
	//HPLJII_linetype(int linetype)
	//{
	//
	//    if (hplj_dpp == 1) {
	//	if (linetype >= 7)
	//	    linetype %= 7;
	// /* b_pattern not appropriate for 300ppi graphics */
	//	b_linemask = b_300ppi_pattern[linetype + 2];
	//	b_maskcount = 0;
	//    } else {
	//	b_setlinetype(linetype);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//HPLJII_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    switch (b_angle) {
	//    case 0:
	//	y -= HPLJII_VCHAR / 5;
	//	HPLJII_POP_CURSOR;
	//	HPLJII_PUSH_CURSOR;
	// /* (0,0) is the upper left point of the paper */
	//	fprintf(gpoutfile, "\033*p%+dx%+dY", x * HPLJII_DPP
	//		,(HPLJII_YMAX - y - 1) * HPLJII_DPP);
	//	fputs(str, gpoutfile);
	// /*       for (; *str; ++str, x += HPLJII_HCHAR)
	//             HPLJII_putc (x, y, *str, b_angle);*/
	//	break;
	//    case 1:
	//	y += (HPLJII_HCHAR - 2 * HPLJII_VCHAR) / 2;
	//	y += (HPLJII_VCHAR + HPLJII_HCHAR) * strlen(str) / 2;
	//	for (; *str; ++str, y -= HPLJII_VCHAR)
	//	    HPLJII_putc(x, y, *str, b_angle);
	//	break;
	//    }
	//}
	//
	//static void
	//HPLJII_putc(unsigned int x, unsigned int y, int c, int ang)
	//{
	//    HPLJII_POP_CURSOR;
	//    HPLJII_PUSH_CURSOR;
	//    (void) ang;			// avoid -Wunused warnings 
	// /* (0,0) is the upper left point of the paper */
	//    fprintf(gpoutfile, "\033*p%+dx%+dY",
	//	    x * HPLJII_DPP, (HPLJII_YMAX - y - 1) * HPLJII_DPP);
	//    fputc(c, gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//HPLJII_reset()
	//{
	///#ifdef VMS
	//    fflush_binary();
	///#endif // VMS 
	//}
	//
	//
	// /* HP DeskJet routines */
	//TERM_PUBLIC void
	//HPDJ_graphics()
	//{
	//    switch (hplj_dpp) {
	//    case 1:
	//	b_charsize(FNT13X25);
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	break;
	//    case 2:
	//	b_charsize(FNT13X25);
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	break;
	//    case 3:
	//	b_charsize(FNT9X17);
	//	term->v_char = FNT9X17_VCHAR;
	//	term->h_char = FNT9X17_HCHAR;
	//	break;
	//    case 4:
	//	b_charsize(FNT5X9);
	//	term->v_char = FNT5X9_VCHAR;
	//	term->h_char = FNT5X9_HCHAR;
	//	break;
	//    }
	// /* rotate plot -90 degrees by reversing XMAX and YMAX and by
	//    setting b_rastermode to TRUE */
	//    b_makebitmap(HPLJII_YMAX, HPLJII_XMAX, 1);
	//    b_rastermode = TRUE;
	//}
	//
	//
	// /* 0 compression raster bitmap dump. Compatible with HP DeskJet 500
	//    hopefully compatible with other HP Deskjet printers */
	//TERM_PUBLIC void
	//HPDJ_text()
	//{
	//    register int x, j, row;
	//
	//    fprintf(gpoutfile, "
	//\033*b0M
	//\033*t%dR
	//\033*r1A",
	//	    HPLJII_PPI);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	fprintf(gpoutfile, "\033*b%dW", b_ysize / 8);
	//	for (j = row; j >= 0; j--) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	}
	//    }
	//    fputs("\033*rbC", gpoutfile);
	//
	//    b_freebitmap();
	//
	///#ifndef VMS			// most vms spoolers add a formfeed character 
	//    putc('\f', gpoutfile);
	///#endif // !VMS 
	//}
	//
	///#endif

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(hpljii_driver)
	//    "hpljii", "HP Laserjet series II, [75 100 150 300]",
	//    HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
	//    HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJII_options,
	//    HPLJII_init, HPLJII_reset, HPLJII_text, null_scale,
	//    HPLJII_graphics, b_move, b_vector, HPLJII_linetype,
	//    HPLJII_put_text, b_text_angle, null_justify_text, line_and_point,
	//    do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(hpljii_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hpljii_driver
	//
	//TERM_TABLE_START(hpdj_driver)
	//    "hpdj", "HP DeskJet 500, [75 100 150 300]",
	//    HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
	//    HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJII_options,
	//    HPLJII_init, HPLJII_reset, HPDJ_text, null_scale,
	//    HPDJ_graphics, b_move, b_vector, HPLJII_linetype,
	//    b_put_text, b_text_angle, null_justify_text, line_and_point,
	//    do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(hpdj_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hpdj_driver
	//
	///#endif
	///#endif

	///#ifdef TERM_HELP
	//START_HELP(hpljii)
	//"1 hpljii",
	//"?commands set terminal hpljii",
	//"?set terminal hpljii",
	//"?set term hpljii",
	//"?terminal hpljii",
	//"?term hpljii",
	//"?hpljii",
	//"?commands set terminal hpdj",
	//"?set terminal hpdj",
	//"?set term hpdj",
	//"?terminal hpdj",
	//"?term hpdj",
	//"?hpdj",
	//" The `hpljii` terminal driver supports the HP Laserjet Series II printer.  The",
	//" `hpdj` driver supports the HP DeskJet 500 printer.  These drivers allow a",
	//" choice of resolutions.",
	//"",
	//" Syntax:",
	//"       set terminal hpljii | hpdj {<res>}",
	//"",
	//" where `res` may be 75, 100, 150 or 300 dots per inch; the default is 75.",
	//" Rasterization at the higher resolutions may require a large amount of memory.",
	//"",
	//" The `hp500c` terminal is similar to `hpdj`; `hp500c` additionally supports",
	//" color and compression."
	//END_HELP(hpljii)
	///#endif // TERM_HELP 


	/* HP PrintJet */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: hppj.trm,v 1.15 2006/07/21 02:35:47 sfeam Exp $
	 *
	 */

	/* GNUPLOT - hppj.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  hppj
	 *
	 * AUTHORS
	 *  Dan Merget (danm@sr.hp.com)
	 *
	 * This file was based on the hpljii file by:
	 *  John Engels
	 *  Russell Lang
	 *  Maurice Castro
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* The following HP laserjet series II driver uses generic bit mapped graphics
	 * routines from bitmap.c to build up a bit map in memory.
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(hppj)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void HPPJ_options __PROTO((void));
	//TERM_PUBLIC void HPPJ_init __PROTO((void));
	//TERM_PUBLIC void HPPJ_reset __PROTO((void));
	//TERM_PUBLIC void HPPJ_graphics __PROTO((void));
	//TERM_PUBLIC void HPPJ_text __PROTO((void));
	//TERM_PUBLIC void HPPJ_linetype __PROTO((int linetype));
	//
	// /* We define 3 different font sizes: 5x9, 9x17, and 13x25 */
	//
	///#define HPPJ_DPI 180		// dots per inch 
	///#define HPPJ_PLANES 3		// color planes 
	///#define HPPJ_COLORS (1 << HPPJ_PLANES)
	// /* make XMAX and YMAX a multiple of 8 */
	///#define HPPJ_XMAX (8*(unsigned int)(9.5 * HPPJ_DPI / 8.0 + 0.9))
	///#define HPPJ_YMAX (8 * HPPJ_DPI)
	//
	// /* default values for term_tbl */
	///#define HPPJ_9x17_VCHAR FNT9X17_VCHAR
	///#define HPPJ_9x17_HCHAR FNT9X17_HCHAR
	///#define HPPJ_9x17_VTIC (FNT9X17_VCHAR / 2)
	///#define HPPJ_9x17_HTIC (FNT9X17_HCHAR / 2)
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static int hppj_font = FNT9X17;
	//
	//TERM_PUBLIC void
	//HPPJ_options()
	//{
	//    char opt[10];
	///#define HPPJERROR "expecting font size FNT5X9, FNT9X17, or FNT13X25"
	//
	//    term_options[0] = NUL;	// default to empty string and 9x17 font 
	//    hppj_font = FNT9X17;	// in case of error or empty options     
	//
	//    if (!END_OF_COMMAND) {
	//	if (token[c_token].length > 8) {
	//	    int_error(c_token, HPPJERROR);
	//	}
	//	capture(opt, c_token, c_token, //4 
	// 9);	// HBB 980226 
	//	if (!strcmp(opt, "FNT5X9")) {
	//	    hppj_font = FNT5X9;
	//	    strcpy(term_options, "FNT5X9");
	//	} else if (!strcmp(opt, "FNT9X17")) {
	//	    hppj_font = FNT9X17;
	//	    strcpy(term_options, "FNT9X17");
	//	} else if (!strcmp(opt, "FNT13X25")) {
	//	    hppj_font = FNT13X25;
	//	    strcpy(term_options, "FNT13X25");
	//	} else {
	//	    int_error(c_token, HPPJERROR);
	//	}
	//	c_token++;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//HPPJ_init()
	//{
	// /* HBB 980226: moved this here, from graphics(): only init() may
	//  * change fields of *term ! */
	//    switch (hppj_font) {
	//    case FNT5X9:
	//	term->v_char = FNT5X9_VCHAR;
	//	term->h_char = FNT5X9_HCHAR;
	//	term->v_tic = FNT5X9_VCHAR / 2;
	//	term->h_tic = FNT5X9_HCHAR / 2;
	//	break;
	//    case FNT9X17:
	//	term->v_char = FNT9X17_VCHAR;
	//	term->h_char = FNT9X17_HCHAR;
	//	term->v_tic = FNT9X17_VCHAR / 2;
	//	term->h_tic = FNT9X17_HCHAR / 2;
	//	break;
	//    case FNT13X25:
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	term->v_tic = FNT13X25_VCHAR / 2;
	//	term->h_tic = FNT13X25_HCHAR / 2;
	//	break;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//HPPJ_reset()
	//{
	///#ifdef VMS
	//    fflush_binary();
	///#endif // VMS 
	//}
	//
	//
	//TERM_PUBLIC void
	//HPPJ_graphics()
	//{
	// /* HBB 980226: move a block of code from here to init() */
	//    b_charsize(hppj_font);
	//
	//    b_makebitmap(HPPJ_XMAX, HPPJ_YMAX, HPPJ_PLANES);
	//}
	//
	//
	//TERM_PUBLIC void
	//HPPJ_text()
	//{
	//    int x, plane, y;		// loop indexes 
	//    int minRow, maxRow;		// loop bounds 
	//    int numBytes;		// Number of run-length coded bytes to output 
	//    int numReps;		// Number of times the current byte is repeated 
	//
	//    fprintf(gpoutfile, "
	//\033E\033*t%dR\033*r%dS
	//\033*b0X\033*b0Y\033*r%dU
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*v%dA\033*v%dB\033*v%dC\033*v%dI
	//\033*b1M\033*r1A",
	//	    HPPJ_DPI, HPPJ_YMAX,
	//	    HPPJ_PLANES,
	//	    90, 88, 85, 0,
	//	    53, 8, 14, 1,
	//	    3, 26, 22, 2,
	//	    4, 4, 29, 3,
	//	    53, 5, 25, 4,
	//	    2, 22, 64, 5,
	//	    89, 83, 13, 6,
	//	    4, 4, 6, 7);
	//
	// /* dump bitmap in raster mode using run-length encoding */
	//    for (x = HPPJ_XMAX - 1; x >= 0; --x) {
	//	for (plane = 0; plane < HPPJ_PLANES; plane++) {
	//	    minRow = b_psize * plane;
	//	    maxRow = b_psize * plane + b_psize - 1;
	//
	// /* Print column header */
	//	    numBytes = 0;
	//	    for (y = maxRow; y >= minRow; --y) {
	//		if (y == minRow || *((*b_p)[y] + x) != *((*b_p)[y - 1] + x)) {
	//		    numBytes += 2;
	//		}
	//	    }
	//	    fprintf(gpoutfile, "\033*b%d", numBytes);
	//	    (void) fputc((char) (plane < HPPJ_PLANES - 1 ? 'V' : 'W'), gpoutfile);
	//
	// /* Print remainder of column */
	//	    numReps = 0;
	//	    for (y = maxRow; y >= minRow; --y) {
	//		if (y == minRow || *((*b_p)[y] + x) != *((*b_p)[y - 1] + x)) {
	//		    (void) fputc((char) (numReps), gpoutfile);
	//		    (void) fputc((char) (*((*b_p)[y] + x)), gpoutfile);
	//		    numReps = 0;
	//		} else {
	//		    numReps++;
	//		}
	//	    }
	//	}
	//    }
	//    fputs("\033*r1B\033E", gpoutfile);
	//
	//    b_freebitmap();
	//}
	//
	//
	//TERM_PUBLIC void
	//HPPJ_linetype(int linetype)
	//{
	//    if (linetype >= 0) {
	//	b_setlinetype(0);
	//	b_setvalue((linetype % (HPPJ_COLORS - 1)) + 1);
	//    } else {
	//	b_setlinetype(linetype + 2);
	//	b_setvalue(HPPJ_COLORS - 1);
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(hppj_driver)
	//    "hppj", "HP PaintJet and HP3630 [FNT5X9 FNT9X17 FNT13X25]",
	//    HPPJ_XMAX, HPPJ_YMAX,
	//    HPPJ_9x17_VCHAR, HPPJ_9x17_HCHAR, HPPJ_9x17_VTIC, HPPJ_9x17_HTIC,
	//    HPPJ_options, HPPJ_init, HPPJ_reset, HPPJ_text, null_scale, HPPJ_graphics,
	//    b_move, b_vector, HPPJ_linetype, b_put_text, b_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(hppj_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM hppj_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(hppj)
	//"1 hppj",
	//"?commands set terminal hppj",
	//"?set terminal hppj",
	//"?set term hppj",
	//"?terminal hppj",
	//"?term hppj",
	//"?hppj",
	//" The `hppj` terminal driver supports the HP PaintJet and HP3630 printers.  The",
	//" only option is the choice of font.",
	//"",
	//" Syntax:",
	//"       set terminal hppj {FNT5X9 | FNT9X17 | FNT13X25}",
	//"",
	//" with the middle-sized font (FNT9X17) being the default."
	//END_HELP(hppj)
	///#endif


	/* Imagen laser printers */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: imagen.trm,v 1.20 2006/07/21 02:35:47 sfeam Exp $
	 */

	/* GNUPLOT - imagen.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   Imagen laser printers
	 *
	 * AUTHORS
	 *   Paul E. McKenney, David Kotz
	 *   Rewritten/extended by:
	 *	Hans Olav Eggestad
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * Original for direct Imagen output (but retaining many of the
	 * LaTeX extensions) by Paul E. McKenney, 1989.
	 * Further modified by David Kotz to fit into gnuplot 2.0.
	 * Information Science and Technology Division, SRI International,
	 * 333 Ravenswood Ave, Menlo Park, CA 94025.
	 * Mail to mckenney@sri.com.
	 */
	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(imagen)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void IMAGEN_init __PROTO((void));
	//TERM_PUBLIC void IMAGEN_graphics __PROTO((void));
	//TERM_PUBLIC void IMAGEN_options __PROTO((void));
	//TERM_PUBLIC void IMAGEN_text __PROTO((void));
	//TERM_PUBLIC void IMAGEN_linetype __PROTO((int lt));
	//TERM_PUBLIC void IMAGEN_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void IMAGEN_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC int IMAGEN_text_angle __PROTO((int ang));
	//TERM_PUBLIC int IMAGEN_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void IMAGEN_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void IMAGEN_reset __PROTO((void));
	///#define IMAGEN_PTS_PER_INCH (300)
	///#define IMAGEN_XMAX (IMAGEN_PTS_PER_INCH * 11)	// 10.0 inches 
	///#define IMAGEN_YMAX (IMAGEN_PTS_PER_INCH * 78 / 10)	// 7.5 inches 
	///#define IMAGEN_HTIC (20)
	///#define IMAGEN_VTIC (20)
	///#define IMAGEN_VCHAR (IMAGEN_FONTSIZE*5)
	///#define IMAGEN_HCHAR (IMAGEN_VCHAR/2)
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static void IM_page __PROTO((void));
	//static void IMAGEN_draw_path __PROTO((void));
	//static void IMAGEN_setpos __PROTO((int ux, int uy));
	//static unsigned char *IMAGEN_cvts __PROTO((unsigned char *str, int *width, int *height));
	//static void IMAGEN_putwd __PROTO((unsigned int w));
	//static void IMAGEN_createfamily __PROTO((char *c, int sz));
	//static void IMAGEN_setfont __PROTO((int sz));
	//static void IMP_set_draw_pattern __PROTO((int pattern, int sz));
	//static void IMAGEN_mapsinit __PROTO((void));
	//static void IMAGEN_createmap __PROTO((int name, unsigned short *map));
	//
	//
	// /*
	// #ifndef __malloc_h
	// #include <malloc.h>
	// #endif
	// */
	///#include "impcodes.h"
	//
	// /* default is landscape */
	///#define IMAGEN_A4_H  (IMAGEN_PTS_PER_INCH * 83 / 10)
	///#define IMAGEN_A4_W  (IMAGEN_PTS_PER_INCH * 116 / 10)
	//
	// /* width in current orientation */
	//static int IMAGEN_Xmax = IMAGEN_XMAX;
	//static int IMAGEN_Ymax = IMAGEN_YMAX;
	//
	///#define IMAGEN_FONTSIZE 12
	///#define IMAGEN_FONT "cour"
	//
	//
	//static unsigned short IMP_gmap[128];
	//static unsigned char IMP_chmap[256];
	//
	//static int IMAGEN_page_h = IMAGEN_A4_H;
	//static int IMAGEN_page_w = IMAGEN_A4_W;
	//static int IM_win_horiz = 1;
	//static int IM_win_verti = 1;
	//static int IM_plot_nr = 0;
	//
	//static int IMAGEN_fontsize = IMAGEN_FONTSIZE;
	//static int IMAGEN_familytable[36];
	//static int IMAGEN_orgX;		// absolute-pixel-ORIgin of graph page. 
	//static int IMAGEN_orgY;
	//static int IMAGEN_orgx;		// absolute-pixel-ORIgin of current graph. 
	//static int IMAGEN_orgy;
	//static int IMAGEN_posx;		// current drawing position (lines).    
	//static int IMAGEN_posy;
	// /* static int IMAGEN_inplot; */
	//static int IMAGEN_xmax = IMAGEN_XMAX;	// width of graph in pixels.    
	//static int IMAGEN_ymax = IMAGEN_YMAX;	// height of graph in pixels.   
	//static int IMAGEN_winx = IMAGEN_XMAX;	// width of window in pixels.   
	//static int IMAGEN_winy = IMAGEN_YMAX;	// height of window in pixels.  
	//static int IMAGEN_hchar;	// Height of CHAR in current font.      
	//static int IMAGEN_wchar;	// Width of CHAR in current font.       
	//static int IMAGEN_blofs;	// BaseLine OFfSet from bounding box.   
	//static int IMAGEN_angle = -1;	// 0 for horizontal text, 1 for vertical 
	//static int IMAGEN_portrait;	// 0 for landscape 
	//static enum JUSTIFY IMAGEN_justify = LEFT;	// left/center/right 
	//
	///#define STOREPATH 100
	//static unsigned int IM_xvector[STOREPATH]; // draw path vector of x values 
	//static unsigned int IM_yvector[STOREPATH]; // draw path vector of y values 
	//static unsigned int IM_veclen;	// length of allocated path vector 
	//static unsigned int IM_vecpos = 0; // current pos in vector 
	//
	// /* char IMPdrpattern[10][10] = { {0}, {30,10,0}, {0}, {10,30,0}, {2,20,0},
	// 	{20,10,0}, {30,20,10,20,0}, {30,20,4,10,10,10,4,20,0}, {40,20,0}, {30,15,4,15,0}
	// };
	// */
	//
	//static char IMPdrpattern[10][10] =
	//{
	// /* -2 //Tangible continue code after comment*/
	// {0},
	// /* -1 //Tangible continue code after comment*/
	// {1, 8, 0},
	// /*  0 //Tangible continue code after comment*/
	// {0},
	// /*  1 //Tangible continue code after comment*/
	// {16, 4, 0},
	// /*  2 //Tangible continue code after comment*/
	// {3, 8, 0},
	// /*  3 //Tangible continue code after comment*/
	// {8, 8, 0},
	// /*  4 //Tangible continue code after comment*/
	// {16, 6, 3, 6, 0},
	// /*  5 //Tangible continue code after comment*/
	// {16, 6, 8, 6, 0},
	// /*  6 //Tangible continue code after comment*/
	// {16, 4, 1, 4, 8, 4, 1, 4, 0},
	// /*  7 //Tangible continue code after comment*/
	// {16, 4, 1, 8, 1, 4, 0}
	//};
	//
	//enum IMAGEN_id { IMAGEN_PORTRAIT, IMAGEN_LANDSCAPE, IMAGEN_OTHER };
	//
	//static struct gen_table IMAGEN_opts[] =
	//{
	//    { "p$ortrait", IMAGEN_PORTRAIT },
	//    { "l$andscape", IMAGEN_LANDSCAPE },
	//    { NULL, IMAGEN_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//IMAGEN_options()
	//{
	//    struct value a;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&IMAGEN_opts[0],c_token)) {
	//	case IMAGEN_PORTRAIT:
	//	    IMAGEN_portrait = TRUE;
	//	    IMAGEN_page_h = IMAGEN_A4_W;
	//	    IMAGEN_page_w = IMAGEN_A4_H;
	//	    IMAGEN_Xmax = IMAGEN_YMAX;
	//	    IMAGEN_Ymax = IMAGEN_XMAX;
	//	    c_token++;
	//	    break;
	//	case IMAGEN_LANDSCAPE:
	//	    IMAGEN_portrait = FALSE;
	//	    c_token++;
	//	    break;
	//	case IMAGEN_OTHER:
	//	default:
	//	    if (equals(c_token, "[")) {	// windows spesified 
	//		c_token++;
	// /* if (IM_plot_nr>1) */
	//		if (equals(c_token, "]")) {
	//		    IM_page();
	//		    c_token++;
	//		    break;
	//		}
	//		if (END_OF_COMMAND) {
	//		    int_error(c_token, "no. windows: [horizontal,vertical] expected");
	//		} else if (!equals(c_token, ",")) {
	//		    IM_win_horiz = (int) real(const_express(&a));
	//		}
	//		if (!equals(c_token, ","))
	//		    int_error(c_token, "',' expected");
	//		c_token++;
	//		if (!equals(c_token, "]")) {
	//		    IM_win_verti = (int) real(const_express(&a));
	//		}
	//		if (!equals(c_token, "]"))
	//		    int_error(c_token, "expecting ']'");
	//		c_token++;
	//	    } else {
	// /* We have font size specified */
	//		IMAGEN_fontsize = (int) real(const_express(&a));
	//		if (IMAGEN_fontsize < 8)
	//		    IMAGEN_fontsize = 8;
	//		if (IMAGEN_fontsize > 15)
	//		    IMAGEN_fontsize = 15;
	//	    }
	//	}
	//    }
	//    sprintf(term_options, "%d %s [%1d,%1d]", IMAGEN_fontsize, (IMAGEN_portrait) ? "portrait" :
	//	    "landscape", IM_win_horiz, IM_win_verti);
	//}
	//
	//
	//TERM_PUBLIC void
	//IMAGEN_init()
	//{
	//    register struct termentry *t = term;
	// /* char font[10];   //Tangible continue code after comment*/
	// /* font name */
	//
	//    IMAGEN_posx = IMAGEN_posy = 0;
	//
	//    IMAGEN_orgX = (IMAGEN_page_w - IMAGEN_Xmax) / 2;
	//    IMAGEN_orgY = (IMAGEN_page_h - IMAGEN_Ymax) / 2;
	//
	//    IMAGEN_xmax = IMAGEN_winx = (int) (IMAGEN_Xmax / IM_win_horiz);
	//    IMAGEN_ymax = IMAGEN_winy = (int) (IMAGEN_Ymax / IM_win_verti);
	//
	//    t->xmax = (unsigned int) (IMAGEN_xmax);
	//    t->ymax = (unsigned int) (IMAGEN_ymax);
	//
	//    fputs("@document(language impress, paper a4)", gpoutfile);
	//
	//    if (IMAGEN_portrait) {
	//	putc(imP_SET_ABS_V, gpoutfile);
	//	IMAGEN_putwd(3520);
	//    }
	//    putc(imP_SET_HV_SYSTEM, gpoutfile);
	//    putc(((IMAGEN_portrait ? 3 : 0) << 5) | (3 << 3) | (IMAGEN_portrait ? 0 : 5), gpoutfile);
	//
	// /* sprintf(font, "cour%02d", IMAGEN_FONTSIZE); */
	//    IMAGEN_mapsinit();
	//    IMAGEN_createmap(1, IMP_gmap);
	// /* IMAGEN_createfamily(font, IMAGEN_FONTSIZE); */
	//    IMAGEN_setfont(IMAGEN_fontsize);
	//
	//    IMAGEN_text_angle(0);
	//
	//    putc(imP_SET_ABS_H, gpoutfile);
	//    IMAGEN_putwd(0);
	//    putc(imP_SET_ABS_V, gpoutfile);
	//    IMAGEN_putwd(0);
	//
	//    IMAGEN_linetype(LT_AXIS);
	// /*
	//    if ((IM_xvector = (unsigned int *) malloc(STOREPATH*sizeof(int))) == NULL) {
	//    fputs("Imagendriver: Unable to allocate memory for draw path\n", stderr);
	//    exit(1);
	//    }
	//    if ((IM_yvector = (unsigned int *) malloc(STOREPATH*sizeof(int))) == NULL) {
	//    fputs("Imagendriver: Unable to allocate memory for draw path\n", stderr);
	//    exit(1);
	//    }
	//  */
	//    IM_veclen = STOREPATH;
	//    IM_vecpos = 0;
	//}
	//
	//static void
	//IM_page()
	//{
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"graphics, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    putc(imP_ENDPAGE, gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//IMAGEN_graphics()
	//{
	//    int tmpx, tmpy;
	// /*    int xoff, yoff; */
	//
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"graphics, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    if (IM_plot_nr >= (IM_win_horiz * IM_win_verti)) {
	//	IM_page();
	//	IM_plot_nr = 0;
	//    }
	//    IM_plot_nr++;
	//    tmpx = IMAGEN_orgX + ((IM_plot_nr - 1) % IM_win_horiz) * IMAGEN_winx;
	//    tmpy = IMAGEN_orgY + ((IM_win_verti - 1) - (int) ((IM_plot_nr - 1) / IM_win_horiz)) * IMAGEN_winy;
	//    IMAGEN_orgx = tmpx + (int) ((IMAGEN_winx - IMAGEN_xmax) / 2);
	//    IMAGEN_orgy = tmpy + (int) ((IMAGEN_winy - IMAGEN_ymax) / 2);
	//}
	//
	//
	//TERM_PUBLIC void
	//IMAGEN_text()
	//{
	//}
	//
	//
	///#define DRAW_PATTERNS 6
	//
	//
	//TERM_PUBLIC void
	//IMAGEN_linetype(int lt)
	//{
	//    static int lastlinetype = -10;
	//    int pen //, pattern 
	// ;
	//
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"move, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//
	//    if (lt < -2)
	//	lt = LT_BLACK;
	//
	//    if (lt == LT_BLACK) {
	//	pen = 4;
	//    } else {
	//	pen = (int) (lt / 8) * 2;
	//	if (pen <= 0)
	//	    pen = 1;
	//    }
	//    lt = (lt % 8) + 2;
	//
	//    if (lastlinetype == lt)
	//	return;
	//
	//    lastlinetype = lt;
	//
	//    putc(imP_SET_PEN, gpoutfile);
	//    putc(pen, gpoutfile);
	//    IMP_set_draw_pattern(lt, pen);
	//}
	//
	//
	//TERM_PUBLIC void
	//IMAGEN_move(unsigned int x, unsigned int y)
	//{
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"move, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    IM_xvector[0] = x + IMAGEN_orgx;
	//    IM_yvector[0] = y + IMAGEN_orgy;
	// /* fprintf(stderr,"Ny vector: startpos: %1d %1d\n",IM_xvector[0],IM_yvector[0]); */
	//    IM_vecpos = 1;
	// /*
	//    IMAGEN_posx = x;
	//    IMAGEN_posy = y;
	//  */
	//}
	//
	//TERM_PUBLIC void
	//IMAGEN_vector(unsigned int ux, unsigned int uy)
	//{
	// /* void IMAGEN_draw_path(); */
	//
	// /* Store path. */
	//    IM_xvector[IM_vecpos] = ux + IMAGEN_orgx;
	//    IM_yvector[IM_vecpos] = uy + IMAGEN_orgy;
	// /* fprintf(stderr,"Ny node: nr: %1d; %1d %1d\n",IM_vecpos,IM_xvector[IM_vecpos],IM_yvector[IM_vecpos]);  */
	//    IM_vecpos++;
	//    if (IM_vecpos >= IM_veclen) {
	//	IMAGEN_draw_path();
	//	IM_xvector[0] = ux + IMAGEN_orgx;
	//	IM_yvector[0] = uy + IMAGEN_orgy;
	//	IM_vecpos = 1;
	//    }
	//}
	//
	//static void
	//IMAGEN_draw_path()
	//{
	// /*    unsigned int pos; */
	//    register int i;
	//
	//    putc(imP_CREATE_PATH, gpoutfile);
	//    IMAGEN_putwd(IM_vecpos);
	//    for (i = 0; i < IM_vecpos; i++) {
	// /*
	//    IMAGEN_putwd(IM_xvector[i] + IMAGEN_orgx);
	//    IMAGEN_putwd(IM_yvector[i] + IMAGEN_orgy);
	//  */
	//	IMAGEN_putwd(IM_xvector[i]);
	//	IMAGEN_putwd(IM_yvector[i]);
	//    }
	//    IM_vecpos = 0;
	// /* Draw path with black pen. */
	//
	//    putc(imP_DRAW_PATH, gpoutfile);
	//    putc(15, gpoutfile);
	//
	// /* Set current position to end of line. */
	//
	// /* IMAGEN_move(ux, uy); */
	//}
	//
	//static void
	//IMAGEN_setpos(int ux, int uy)
	//{
	// /* Set x and y position (for text), also set beginning-of-line. */
	//
	//    putc(imP_SET_ABS_H, gpoutfile);
	//    IMAGEN_putwd(ux + IMAGEN_orgx);
	//    putc(imP_SET_ABS_V, gpoutfile);
	//    IMAGEN_putwd(uy + IMAGEN_orgy);
	//    putc(imP_SET_BOL, gpoutfile);
	//    if (IMAGEN_angle == 1)
	//	IMAGEN_putwd(uy + IMAGEN_orgx);		// vertical 
	//    else
	//	IMAGEN_putwd(ux + IMAGEN_orgx);		// horizontal 
	//}
	//
	//TERM_PUBLIC int
	//IMAGEN_text_angle(int ang)
	//{
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"text_angle, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    if (IMAGEN_angle != ang) {
	//	IMAGEN_angle = ang;	// record for later use 
	//	putc(imP_SET_ADV_DIRS, gpoutfile);
	//	putc(ang == 0 ? 0 : 7, gpoutfile);	// 0=>horiz : 7=>vert 
	//    }
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//IMAGEN_justify_text(enum JUSTIFY mode)
	//{
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"justify_text, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    IMAGEN_justify = mode;
	//    return (TRUE);
	//}
	//
	//static unsigned char *
	//IMAGEN_cvts(unsigned char *str, int *width, int *height)
	//{
	//    unsigned char *cp1;
	//    unsigned char *cp2;
	//    static unsigned char *buf = NULL;
	//    int h;
	//    int maxw;
	//    int w;
	//
	// /* Free up old buffer, if there is one, get a new one.  Since       */
	// /* all transformations shorten the string, get a buffer that is     */
	// /* the same size as the input string.                               */
	//
	//    if (buf != NULL)
	//	(void) free(buf);
	//    buf = (unsigned char *) gp_alloc(strlen((char *) str)+2, "converted label string");
	//
	// /* Do the transformations. */
	//
	//    cp1 = str;
	//    cp2 = buf;
	//    h = 1;
	//    maxw = 0;
	//    w = 0;
	//    while (strlen((char *) cp1) > 0) {
	//	switch (*cp1) {
	//	case ' ':		// Space character. 
	//	    *cp2++ = imP_SP;
	//	    w++;
	//	    break;
	//
	//	case '\\':		// Escape sequence. 
	//	    if (*++cp1 == '\\') {
	// /* Begin new line. */
	//		h++;
	//		if (w > maxw)
	//		    maxw = w;
	//		w = 0;
	//		*cp2++ = '\n';
	// /* *cp2++ = imP_CRLF; */
	//		break;
	//	    }
	// /* Fall through to just copy next char out. */
	//
	//	default:
	// /* *cp2++ = *cp1; */
	//	    *cp2++ = IMP_chmap[*cp1];
	//	    w++;
	//	    break;
	//	}
	//	cp1++;
	//    }
	//
	//    *cp2++ = '\n';
	//    *cp2 = '\0';
	//    if (w > maxw)
	//	maxw = w;
	//
	//    if (height != NULL)
	//	*height = IMAGEN_angle ?
	//	    IMAGEN_wchar * maxw :
	//	    IMAGEN_hchar * h;
	//    if (width != NULL)
	//	*width = IMAGEN_angle ?
	//	    IMAGEN_hchar * h :
	//	    IMAGEN_wchar * maxw;
	//    return (buf);
	//}
	//
	//TERM_PUBLIC void
	//IMAGEN_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    unsigned char *cvstr, *p;
	//    int height;
	//    int width;
	//    int sx, sy;
	//
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"put_text, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    cvstr = IMAGEN_cvts((unsigned char *) str, &width, &height);
	//
	//    if (IMAGEN_angle) {		// vertical 
	// /* x += IMAGEN_hchar; */
	//	x -= width / 2 - IMAGEN_hchar;
	// /* y -= height/2; */
	//    } else			// horizontal 
	//	y += height / 2 - IMAGEN_hchar;
	//
	//    while ((p = (unsigned char *) strchr((char *) cvstr, '\n'))) {
	//	*p = '\0';
	//	sx = x;
	//	sy = y;
	//	if (IMAGEN_angle)
	//	    sx = x - IMAGEN_blofs;
	//	else
	//	    sy = y + IMAGEN_blofs;
	//
	//	width = strlen((char *) cvstr) * IMAGEN_wchar;
	//
	//	switch (IMAGEN_justify) {
	//	case LEFT:
	//	    break;
	//	case CENTRE:
	//	    if (IMAGEN_angle) {
	//		sy = y - width / 2;
	//	    } else {
	//		sx = x - width / 2;
	//	    }
	//	    break;
	// /*x -= width/2; break; */
	//	case RIGHT:
	//	    if (IMAGEN_angle) {
	//		sy = y - width;
	//	    } else {
	//		sx = x - width;
	//	    }
	//	    break;
	// /* x -= width; break; */
	//	}
	//
	//	IMAGEN_setpos(sx, sy);
	//	fputs((char *) cvstr, gpoutfile);
	//	cvstr = ++p;
	//	if (IMAGEN_angle) {	// vertical 
	//	    x += IMAGEN_hchar;
	//	} else {
	//	    y -= IMAGEN_hchar;
	//	}
	//
	//    }
	//}
	//
	//TERM_PUBLIC void
	//IMAGEN_reset()
	//{
	//    if (IM_vecpos) {
	// /* fprintf(stderr,"reset, draw path\n"); */
	//	IMAGEN_draw_path();
	//    }
	//    putc(imP_EOF, gpoutfile);
	//}
	//
	//static void
	//IMAGEN_putwd(unsigned int w)
	//{
	// /* fprintf(stderr,"%1u\n",w); */
	//    putc(w >> 8, gpoutfile);
	//    putc(w, gpoutfile);
	//}
	//
	//static void
	//IMAGEN_createfamily(char *c, int sz)
	//{
	//
	//    putc(imP_CREATE_FAMILY_TABLE, gpoutfile);
	//    putc(sz, gpoutfile);
	//    putc(1, gpoutfile);
	//    putc(1, gpoutfile);
	// /* putc(0, gpoutfile); */
	//    fputs(c, gpoutfile);
	//    putc(0, gpoutfile);
	//}
	//
	//static void
	//IMAGEN_setfont(int sz)
	//{
	//    char font[20];
	//
	//    if (!IMAGEN_familytable[sz]) {
	//	sprintf(font, "%s%02d", IMAGEN_FONT, sz);
	//	IMAGEN_createfamily(font, sz);
	//	IMAGEN_familytable[sz] = sz;
	//    }
	//    IMAGEN_hchar = sz * 5;
	//    IMAGEN_wchar = IMAGEN_hchar / 2;
	//    IMAGEN_blofs = IMAGEN_hchar / 3;
	//    term->v_char = IMAGEN_hchar;
	//    term->h_char = IMAGEN_wchar;
	//    putc(imP_SET_FAMILY, gpoutfile);
	//    putc(sz, gpoutfile);
	//    putc(imP_SET_SP, gpoutfile);
	//    IMAGEN_putwd(IMAGEN_wchar);
	//    putc(imP_SET_IL, gpoutfile);
	//    IMAGEN_putwd(IMAGEN_hchar);
	//}
	//
	//static void
	//IMP_set_draw_pattern(int pattern, int sz)
	//{
	//    int i //,j 
	// ;
	//    putc(imP_SET_DRAW_PATTERN, gpoutfile);
	//    putc(0, gpoutfile);
	//    putc(imP_SET_DRAW_PATTERN, gpoutfile);
	// /* if ( strlen(IMPdrpattern[pattern]) == 1 ) {
	//    putc(type,gpoutfile);
	//    return;
	//    } */
	//    putc(strlen(IMPdrpattern[pattern]), gpoutfile);
	//    for (i = 0; i < strlen(IMPdrpattern[pattern]); i++) {
	//	IMAGEN_putwd(IMPdrpattern[pattern][i] * sz);
	//    }
	//}
	//
	//
	//static void
	//IMAGEN_mapsinit()
	//{
	//
	//    register int i //, j 
	// ;
	//
	//    for (i = 32; i < 127; i++) {
	//	IMP_gmap[i] = i;
	//    }
	//    IMP_gmap[1] = 225;
	//    IMP_gmap[2] = 233;
	//    IMP_gmap[3] = 61736;
	//    IMP_gmap[4] = 241;
	//    IMP_gmap[5] = 249;
	//    IMP_gmap[6] = 61864;
	//    IMP_gmap[7] = 162;
	//    IMP_gmap[8] = 163;
	//    IMP_gmap[9] = 164;
	//    IMP_gmap[10] = 165;
	//    IMP_gmap[11] = 167;
	//    IMP_gmap[12] = 171;
	//    IMP_gmap[13] = 182;
	//    IMP_gmap[14] = 61346;
	//    IMP_gmap[15] = 191;
	//    IMP_gmap[16] = 187;
	//    IMP_gmap[17] = 188;
	//    IMP_gmap[18] = 189;
	//    IMP_gmap[19] = 190;
	//    IMP_gmap[20] = 210;
	//    IMP_gmap[21] = 211;
	//    IMP_gmap[22] = 251;
	//    IMP_gmap[23] = 61232;
	//    IMP_gmap[24] = 212;
	//    IMP_gmap[25] = 137;
	//    IMP_gmap[26] = 176;
	//    IMP_gmap[27] = 161;
	//    IMP_gmap[28] = 139;
	//    IMP_gmap[29] = 133;
	//    IMP_gmap[30] = 140;
	//    IMP_gmap[31] = 61249;
	//    IMP_gmap[32] = 8738;
	//    IMP_gmap[34] = 186;
	//    IMP_gmap[36] = 164;
	//    IMP_gmap[39] = 185;
	//    IMP_gmap[127] = 61286;
	//
	// /* for (i=1;i<127;i++) fprintf(stderr,"%d -> %d\n",i,IMP_gmap[i]); */
	//
	//    for (i = 32; i <= 127; i++) {
	//	IMP_chmap[i] = i;
	//    }
	//    for (i = 128; i <= 255; i++) {
	//	IMP_chmap[i] = 128;	// first map all non printable chars to SPACE 
	//    }
	//
	//    IMP_chmap[161] = 27;
	//    IMP_chmap[162] = 7;
	//    IMP_chmap[163] = 8;
	//    IMP_chmap[164] = 120;
	//    IMP_chmap[165] = 10;
	//    IMP_chmap[166] = 124;
	//    IMP_chmap[167] = 11;
	//    IMP_chmap[168] = 25;
	//    IMP_chmap[169] = 21;
	//    IMP_chmap[170] = 45;
	//    IMP_chmap[171] = 12;
	//    IMP_chmap[172] = 83;
	//    IMP_chmap[173] = 45;
	//    IMP_chmap[174] = 20;
	//    IMP_chmap[175] = 126;
	//    IMP_chmap[176] = 26;
	//    IMP_chmap[177] = 12;
	//    IMP_chmap[178] = 1;
	//    IMP_chmap[179] = 2;
	//    IMP_chmap[180] = 29;
	//    IMP_chmap[181] = 52;
	//    IMP_chmap[182] = 13;
	//    IMP_chmap[183] = 5;
	//    IMP_chmap[184] = 28;
	//    IMP_chmap[185] = 3;
	//    IMP_chmap[186] = 45;
	//    IMP_chmap[187] = 16;
	//    IMP_chmap[188] = 17;
	//    IMP_chmap[189] = 18;
	//    IMP_chmap[190] = 19;
	//    IMP_chmap[191] = 15;
	//    IMP_chmap[192] = 65;
	//    IMP_chmap[193] = 65;
	//    IMP_chmap[194] = 65;
	//    IMP_chmap[195] = 65;
	//    IMP_chmap[196] = 65;
	//    IMP_chmap[197] = 3;
	//    IMP_chmap[198] = 1;
	//    IMP_chmap[199] = 67;
	//    IMP_chmap[200] = 69;
	//    IMP_chmap[201] = 69;
	//    IMP_chmap[202] = 69;
	//    IMP_chmap[203] = 69;
	//    IMP_chmap[204] = 73;
	//    IMP_chmap[205] = 73;
	//    IMP_chmap[206] = 73;
	//    IMP_chmap[207] = 73;
	//    IMP_chmap[208] = 68;
	//    IMP_chmap[209] = 78;
	//    IMP_chmap[210] = 79;
	//    IMP_chmap[211] = 79;
	//    IMP_chmap[212] = 79;
	//    IMP_chmap[213] = 79;
	//    IMP_chmap[214] = 79;
	//    IMP_chmap[215] = 13;
	//    IMP_chmap[216] = 2;
	//    IMP_chmap[217] = 85;
	//    IMP_chmap[218] = 85;
	//    IMP_chmap[219] = 85;
	//    IMP_chmap[220] = 85;
	//    IMP_chmap[221] = 89;
	//    IMP_chmap[222] = 32;
	//    IMP_chmap[223] = 22;
	//    IMP_chmap[224] = 97;
	//    IMP_chmap[225] = 97;
	//    IMP_chmap[226] = 97;
	//    IMP_chmap[227] = 97;
	//    IMP_chmap[228] = 97;
	//    IMP_chmap[229] = 6;
	//    IMP_chmap[230] = 4;
	//    IMP_chmap[231] = 99;
	//    IMP_chmap[232] = 101;
	//    IMP_chmap[233] = 101;
	//    IMP_chmap[234] = 101;
	//    IMP_chmap[235] = 101;
	//    IMP_chmap[236] = 105;
	//    IMP_chmap[237] = 105;
	//    IMP_chmap[238] = 105;
	//    IMP_chmap[239] = 105;
	//    IMP_chmap[240] = 100;
	//    IMP_chmap[241] = 110;
	//    IMP_chmap[242] = 111;
	//    IMP_chmap[243] = 111;
	//    IMP_chmap[244] = 111;
	//    IMP_chmap[245] = 111;
	//    IMP_chmap[246] = 111;
	//    IMP_chmap[247] = 10;
	//    IMP_chmap[248] = 5;
	//    IMP_chmap[249] = 117;
	//    IMP_chmap[250] = 117;
	//    IMP_chmap[251] = 117;
	//    IMP_chmap[252] = 117;
	//    IMP_chmap[253] = 121;
	//    IMP_chmap[254] = 32;
	//    IMP_chmap[255] = 121;
	//}
	//
	//static void
	//IMAGEN_createmap(int name, unsigned short *map)
	//{
	//    register int i, j;
	//    unsigned char s[4], *p;
	//
	//    p = s;
	//    *p++ = imP_CREATE_MAP;
	//    *p++ = name;
	//    j = 0;
	//    for (i = 0; i < 127; i++) {
	//	if (map[i])
	//	    j++;
	//    }
	//    *p = j;
	//    for (i = 0; i < 3; i++)
	//	putc(s[i], gpoutfile);
	//
	//    s[3] = 1;
	//    for (j = 0; j < 127; j++) {
	//	if (map[j]) {
	//	    p = s;
	//	    *p++ = j;
	//	    *p++ = map[j] >> 8;
	//	    *p = map[j] & 255;
	//	    for (i = 0; i < 4; i++)
	//		putc(s[i], gpoutfile);
	//	}
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(imagen_driver)
	//    "imagen", "Imagen laser printer",
	//    IMAGEN_XMAX, IMAGEN_YMAX, IMAGEN_VCHAR, IMAGEN_HCHAR,
	//    IMAGEN_VTIC, IMAGEN_HTIC, IMAGEN_options, IMAGEN_init, IMAGEN_reset,
	//    IMAGEN_text, null_scale, IMAGEN_graphics, IMAGEN_move,
	//    IMAGEN_vector, IMAGEN_linetype, IMAGEN_put_text, IMAGEN_text_angle,
	//    IMAGEN_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(imagen_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM imagen_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(imagen)
	//"1 imagen",
	//"?commands set terminal imagen",
	//"?set terminal imagen",
	//"?set term imagen",
	//"?terminal imagen",
	//"?term imagen",
	//"?imagen",
	//" The `imagen` terminal driver supports Imagen laser printers.  It is capable",
	//" of placing multiple graphs on a single page.",
	//"",
	//" Syntax:",
	//"       set terminal imagen {<fontsize>} {portrait | landscape}",
	//"                           {[<horiz>,<vert>]}",
	//"",
	//" where `fontsize` defaults to 12 points and the layout defaults to `landscape`.",
	//" `<horiz>` and `<vert>` are the number of graphs in the horizontal and",
	//" vertical directions; these default to unity.",
	//"",
	//" Example:",
	//"       set terminal imagen portrait [2,3]",
	//"",
	//" puts six graphs on the page in three rows of two in portrait orientation."
	//END_HELP(imagen)
	///#endif


	/* Kyocera Prescribe printer */
	/* #include "kyo.trm" */

	/* Frame Maker MIF 3.00 format driver */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: mif.trm,v 1.33 2006/07/21 02:35:47 sfeam Exp $
	 */

	/* GNUPLOT -- mif.trm */

	/*[
	 * Copyright 1992, 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver was developed for
	 *      gnuplot for unix version 3.0 (patchlevel 1)
	 *      gnuplot for unix version 3.2 (patchlevel 2)
	 *
	 * This terminal driver supports:
	 *      Frame Maker MIF format version 3.00
	 *
	 * Options for this terminal driver (set terminal mif [options]):
	 *      colour /        Draw primitives with line types >= 0 in colour (sep. 2-7)
	 *      monochrome      Draw primitives in black (sep. 0)
	 *
	 *      polyline /      Draw lines as continuous curves
	 *      vectors         Draw lines as collections of vectors
	 *
	 *      help / ?        Print short usage description on stderr
	 *
	 * Properties for this terminal driver:
	 *     -Gnuplot size of worksheet:              MIF_XMAX * MIF_YMAX
	 *     -Unit in MIF output:                     cm
	 *     -Plot primitives with the same pen will
	 *      be grouped in the same MIF group.
	 *     -Plot primitives with line types >= 0
	 *      will as default be drawn in colour.
	 *     -Lines are plotted as collections of
	 *      vectors, or as continuous lines (default)
	 *     -Plot primitives in a plot will be in a
	 *      Frame in MIF. Several plot Frames will
	 *      be collected in one large Frame.
	 *     -Point size of MIF output characters:    MIF_PSIZE
	 *     -Used font for MIF output characters:    Times
	 *     -Supports vertical text
	 *     -points and dots as characters
	 *     -character formats for TextLines
	 *
	 * AUTHORS:
	 *      Olof Franksson, Physics IV, KTH, S-100 44 Stockholm, Sweden
	 *
	 * NEW TERMINAL FORMAT:  David C. Schooley
	
	 * COMMENTS:
	 *      Send comments and/or suggestions to olof@fysik4.kth.se
	 *
	 * CHANGES:
	 *	Changed to new terminal format 9/29/95		schooley@ee.gatech.edu
	 *      Changed order of routine declarations.          olof@fysik4.kth.se
	 *      Changed mechanism for pen pattern selection.    kssingvo@immd4.informatik.uni-erlangen.de
	 *      Support for vertical text.                      kssingvo@immd4.informatik.uni-erlangen.de
	 *      Fixed plot bug for "set size XS,YS", XS/YS > 1. olof@fysik4.kth.se
	 *	Support colored text				merritt@u.washington.edu
	 *	Support box fill and pattern fill		merritt@u.washington.edu
	 *
	 */


	///#ifdef TERM_REGISTER
	//register_term(mif)
	///#endif



	///#ifdef TERM_PROTO
	//TERM_PUBLIC void MIF_init __PROTO((void));
	//TERM_PUBLIC void MIF_graphics __PROTO((void));
	//TERM_PUBLIC void MIF_text __PROTO((void));
	//TERM_PUBLIC void MIF_linetype __PROTO((int linetype));
	//TERM_PUBLIC void MIF_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void MIF_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void MIF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int MIF_text_angle __PROTO((int ang));
	//TERM_PUBLIC void MIF_reset __PROTO((void));
	//TERM_PUBLIC void MIF_options __PROTO((void));
	//TERM_PUBLIC int MIF_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void MIF_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void MIF_boxfill __PROTO((int style, unsigned int x1, unsigned int y1,
	//	    unsigned int width, unsigned int height));
	//TERM_PUBLIC void MIF_filled_polygon __PROTO((int points, gpiPoint* corners));
	//
	// /** Coordinates **/
	// /* The cast to float is not necessary because we are dividing by a float */
	// /* On OSK the cast to a float is not allowed in a constant expression wich */
	// /* is used by the declaration and initialization of mif_line */
	// /* Converts gnuplot units to MIF units */
	///#define GNP_TO_MIF(P)   ((P) / 1000.0)
	// /* Basic unit: 0.01 mm (15cm -> 15*10*100=15000) */
	///#define MIF_XMAX 15000
	// /* Basic unit: 0.01 mm (10cm -> 10*10*100=10000) */
	///#define MIF_YMAX 10000
	//
	///#define MIF_XLAST (MIF_XMAX - 1)
	///#define MIF_YLAST (MIF_YMAX - 1)
	//
	//static int insert_mif_line __PROTO((double fx, double fy));
	//static int proc_group_id __PROTO((int group_id));
	//static void free_mif_line __PROTO((void));
	//static void put_mif_line __PROTO((void));
	//static void MIF_set_font __PROTO((const char *));
	//static void mif_put_point __PROTO((unsigned int x, unsigned int y, int np));
	//
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	///#ifndef cfree
	///#define cfree free
	///#endif
	//
	//static struct mif_line {	// Line point structure specification 
	//    float fpos_x;		// Line point X coordinate 
	//    float fpos_y;		//            Y coordinate 
	//    struct mif_line *next;	// Pointer to next line point 
	//    struct mif_line *prev;	// Pointer to previous line point 
	//} mif_line =
	//{				// Current position structure. Adjust for orign. Local for this file. 
	//    GNP_TO_MIF(0),
	//	GNP_TO_MIF(MIF_YLAST),
	//	&mif_line,
	//	&mif_line
	//};
	//
	// /** Characters **/
	///#define MIF_PSIZE 9		// Point size of used characters 
	//
	///#define MIF_VCHAR (MIF_YMAX/31)	// Distance between rows (a guess) 
	///#define MIF_HCHAR (MIF_XMAX/95)	// Distance between characters (a guess) 
	//
	// /** Scale marks **/
	///#define MIF_VTIC  (MIF_YMAX/150)	// Size of scale mark (vert) 
	///#define MIF_HTIC  (MIF_XMAX/225)	// Size of scale mark (hor) 
	//
	// /** Drawing properties **/
	//static char mif_justify[64];	// How to justify the used text 
	//static char mif_pen[64], mif_pen_width[64], mif_separation[64];		// How to plot 
	//static char mif_textcolor[64];	// EAM parallels separation 
	//
	//static int mif_text_ang = 0;		// Rotation angle of text 
	//
	//static int mif_fill_patterns[] = {7,12,3,0,9,8,14,13};
	///#define MIF_FILL_SOLID  0
	///#define MIF_FILL_NONE  15
	//
	///#define MIF_NPENS 16		// Number of MIF pen types 
	//static int mif_pentype = 0;	// Pen type to use. Also used to create groups for graphics 
	///#define MIF_PEN_TO_GROUP(P)     ( 1 + (P) )	// Map pen type to group number. Must be >= 1 
	//
	//static int mif_pattern_table[MIF_NPENS] =
	//{ // Table, which pattern should be used for drawing 
	//    0,				// border  
	//    1,				// not used 
	//    2, 3, 4, 8, 12, 13,		// other lines: functions, data, ... (5 is used for grid; 6,7 is (nearly) invisible) 
	//    5,				// grid 
	//    9, 10, 11, 12, 13, 14, 15	// not used 
	//};
	//
	// /** MIF groups administration **/
	///#define MIF_NGROUP_ID           20
	//static struct mif_group_id {
	//    int group_existance;
	// /* This group id should generate a MIF group */
	///#define MIF_GROUP_EXISTS        1
	// /* This group id should not generate a MIF group */
	///#define MIF_GROUP_NOT_EXISTS    0
	//
	//    int group_id;
	///#define MIF_INVALID_GROUP_ID    0	// An invalid MIF group ID 
	//
	//} mif_group_id[MIF_NGROUP_ID];	// List of used group ID:s and corresponding MIF groups existance 
	//
	// /** Semaphores **/
	//static int mif_initialized = 0;	// != 0 when output is active 
	//static int mif_in_frame = 0;	// != 0 when inside a plot frame 
	//static int mif_frameno = -1;	// Current frame number 
	//static int mif_colour = TRUE;	// == TRUE when colour should be used 
	//static int mif_polyline = TRUE;	// == TRUE when lines are drawn as continuous curves 
	//
	//struct mpt {			// point definition structure 
	//    int chr;			// character for point 
	//    float x_offset, y_offset;	// offset for vertical positioning 
	//    char *font;			// font 
	//};
	//
	//static char zgnuplot[] = "ZGnuplot"; // character formats 
	//static char zgnuplotp[] = "ZGnuplotP";
	//static char zgnuplotd[] = "ZGnuplotD";
	//static const char *mif_font = NULL; // actual character format 
	//
	//static struct mpt mpt[POINT_TYPES + 1] =
	//{				// point definition data 
	//    {'.', 0.000, 0.005, zgnuplotd, // dot 
	// },
	//
	//    {'G', 0.002, 0.084, zgnuplotp, // diamond 
	// },
	//    {';', 0.002, 0.084, zgnuplotp, // plus 
	// },
	//    {'n', 0.002, 0.084, zgnuplotp, // box 
	// },
	//    {'5', 0.002, 0.084, zgnuplotp, // X 
	// },
	//    {'s', 0.002, 0.062, zgnuplotp, // triangle 
	// },
	//    {'K', 0.005, 0.075, zgnuplotp, // star 
	// },
	//};
	//
	// /* diamond is offset 0, dot is offset -1 */
	//static struct mpt *mif_point = &(mpt[1]);
	//
	//
	// /** Declaration of routine/s for internal use **/
	//static int insert_mif_line __PROTO((double fx, double fy));
	//static int proc_group_id __PROTO((int group_id));
	//
	//enum MIF_id {
	//    MIF_MONOCHROME, MIF_COLOR, MIF_VECTORS, MIF_POLYLINE, MIF_HELP,
	//    MIF_OTHER
	//};
	//
	//static struct gen_table MIF_opts[] =
	//{
	//    { "m$onochrome", MIF_MONOCHROME },
	//    { "c$olor", MIF_COLOR },
	//    { "c$olour", MIF_COLOR },
	//    { "v$ectors", MIF_VECTORS },
	//    { "p$olyline", MIF_POLYLINE },
	//    { "h$elp", MIF_HELP },
	//    { "?$", MIF_HELP },
	//    { NULL, MIF_OTHER }
	//};
	//
	// /** Routine/s **/
	//
	// /* Called when this terminal type is set in order to parse options */
	//TERM_PUBLIC void
	//MIF_options()
	//{
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&MIF_opts[0],c_token)) {
	// /* Colour options */
	//	case MIF_MONOCHROME:
	//	    mif_colour = FALSE;
	//	    c_token++;
	//	    break;
	//	case MIF_COLOR:
	//	    mif_colour = TRUE;
	//	    c_token++;
	//	    break;
	// /* Curve options */
	//	case MIF_VECTORS:
	//	    mif_polyline = FALSE;
	//	    c_token++;
	//	    break;
	//	case MIF_POLYLINE:
	//	    mif_polyline = TRUE;
	//	    c_token++;
	//	    break;
	// /* Short help */
	//	case MIF_HELP:
	//	case MIF_OTHER:
	//	default:
	//	    fprintf(stderr, "
	//Usage: set terminal mif [options]\n
	//\toptions:\n
	//\t\tcolour /        Draw primitives with line types >= 0 in colour (sep. 2-7)\n
	//\t\tmonochrome      Draw primitives in black (sep. 0)\n\n
	//\t\tpolyline /      Draw lines as continuous curves\n
	//\t\tvectors         Draw lines as collections of vectors\n\n
	//\t\thelp / ?        Print short usage description on stderr\n");
	//	    c_token++;
	//	    break;
	//	}
	//    }
	//    sprintf(term_options, "%s %s",
	//	    (mif_colour == TRUE) ? "colour" : "monochrome",
	//	    (mif_polyline == TRUE) ? "polyline" : "vectors");
	//}
	//
	// /* Deallocate the used line structure elements */
	//static void
	//free_mif_line()
	//{
	//    struct mif_line *tline;
	//
	//    while (mif_line.prev != &mif_line) {
	// /* Unlink */
	//	tline = mif_line.prev;
	//	mif_line.prev = mif_line.prev->prev;
	//	mif_line.prev->next = &mif_line;
	//
	// /* Deallocate */
	//	free(tline);
	//    }
	//
	// /* Make sure that the list will be empty */
	//    mif_line.prev = &mif_line;
	//    mif_line.next = &mif_line;
	//}
	//
	// /* Draw the pending line. Change current position. */
	//static void
	//put_mif_line()
	//{
	//    int np, i;
	//    struct mif_line *tline;
	//
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Count the number of available points */
	//	for (tline = mif_line.next, np = 1; tline != &mif_line; tline = tline->next, np++);
	//
	// /* Draw line (at least two points) */
	//	if (np >= 2) {
	//
	// /* Line preamble */
	//	    fprintf(gpoutfile, "\t<PolyLine <GroupID %d> %s %s %s <Fill 15>\n",
	//		    MIF_PEN_TO_GROUP(mif_pentype), mif_pen, mif_pen_width, mif_separation);
	//
	// /* Draw the line elements */
	//	    fprintf(gpoutfile, "\t\t<NumPoints %d> ", np);
	//	    for (i = 0, tline = &mif_line; i < np; i++, tline = tline->next) {
	//		if (i % 4 == 0)
	//		    fputs("\n\t\t", gpoutfile);
	//		fprintf(gpoutfile, "<Point  %.3f %.3f> ",
	//			tline->fpos_x, tline->fpos_y);
	//	    }
	//
	// /* Line post amble */
	//	    fputs("\n\t>\n", gpoutfile);
	//
	// /* Register the used group ID */
	//	    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
	//
	// /* Avoid to redraw this. The MIF system should remember it. */
	//	    mif_pen[0] = '\0';
	//	    mif_pen_width[0] = '\0';
	//	    mif_separation[0] = '\0';
	//
	// /* Move current position to end of line */
	//	    mif_line.fpos_x = mif_line.prev->fpos_x;
	//	    mif_line.fpos_y = mif_line.prev->fpos_y;
	//
	// /* Restore the line */
	//	    free_mif_line();
	//	}
	//    }				// Line processed 
	//}
	//
	// /* Filled box support - Ethan Merritt <merritt@u.washington.edu> */
	//TERM_PUBLIC void
	//MIF_boxfill(int style, unsigned int x1, unsigned int y1,
	//	    unsigned int width, unsigned int height)
	//{
	//    int fill_pattern;
	//
	//    int fillpar = style >> 4;
	//    style &= 0xf;
	//    switch (style) {
	//	default:
	//	case FS_EMPTY:	fill_pattern = 7;
	//			break;
	//	case FS_SOLID:	fill_pattern = MIF_FILL_SOLID;
	//			break;
	//	case FS_PATTERN:fill_pattern = mif_fill_patterns[fillpar % 8];
	//			break;
	//    }
	//
	// /* Object preamble */
	//    fprintf(gpoutfile, "\t<Rectangle <GroupID %d> %s\n",
	//	    MIF_PEN_TO_GROUP(mif_pentype), mif_separation);
	//
	// /* Set fill type */
	//    fprintf(gpoutfile, "\t\t<Fill %d>\n", fill_pattern);
	//
	// /* Draw the box */
	//    fprintf(gpoutfile, "\t\t<ShapeRect %.3f %.3f %.3f %.3f>\n",
	//	GNP_TO_MIF(x1), GNP_TO_MIF(MIF_YLAST - (y1+height)),
	//	GNP_TO_MIF(width), GNP_TO_MIF(height));
	//
	// /* End of object */
	//    fputs("\n\t>\n", gpoutfile);
	//
	// /* Register the used group ID */
	//    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
	//
	//}
	//
	// /* Filled polygon. Ethan Merritt <merritt@u.washington.edu> */
	//TERM_PUBLIC void
	//MIF_filled_polygon(int points, gpiPoint* corners)
	//{
	//    int i;
	//
	// /* Object preamble */
	//    fprintf(gpoutfile, "\t<Polygon <GroupID %d>\n",
	//	    MIF_PEN_TO_GROUP(mif_pentype));
	//
	// /* Set fill type */
	//    fprintf(gpoutfile, "\t\t<Fill %d>\n", MIF_FILL_SOLID);
	//
	// /* Draw the line elements */
	//    fprintf(gpoutfile, "\t\t<NumPoints %d> ", points);
	//    for (i=0; i<points; i++) {
	//	fprintf(gpoutfile, "<Point  %.3f %.3f> ",
	//		GNP_TO_MIF(corners[i].x),
	//		GNP_TO_MIF(MIF_YLAST - corners[i].y));
	//    }
	//
	// /* End of object */
	//    fputs("\n\t>\n", gpoutfile);
	//
	// /* Register the used group ID */
	//    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
	//
	//}
	//
	// /* Draw a point */
	//static void
	//mif_put_point(unsigned int x, unsigned int y, int np)
	//{
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Draw pending line */
	//	if (mif_polyline == TRUE)
	//	    put_mif_line();
	//
	// /* Adjust current position for text-graphics alignment */
	//	MIF_move(x, y);
	//
	// /* center text */
	//	MIF_justify_text(CENTRE);
	//
	// /* Draw the point */
	//	fprintf(gpoutfile, "\t<TextLine <GroupID %d> %s\n",
	//		MIF_PEN_TO_GROUP(mif_pentype),
	//		mif_textcolor);
	//
	//	MIF_set_font(mif_point[np].font);
	//
	//	fprintf(gpoutfile, "\t\t<TLOrigin  %.3f %.3f> %s <String `%c'>\n",
	//		mif_line.fpos_x + mif_point[np].x_offset,
	//		mif_line.fpos_y + mif_point[np].y_offset,
	//		mif_justify,
	//		mif_point[np].chr);
	//	fputs("\t>\n", gpoutfile);
	//
	// /* Register the used group ID */
	//	proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
	//
	// /* Avoid to redraw this. The MIF system should remember it. */
	//	mif_justify[0] = '\0';
	//
	//    }				// Point processed 
	//}
	//
	//
	// /*
	//  *  draw points
	//  */
	//TERM_PUBLIC void
	//MIF_point(unsigned int x, unsigned int y, int number)
	//{
	//    if (number < 0) {		// dot 
	//	number = -1;
	//    } else {			// point 
	//	number %= POINT_TYPES;
	//    }
	//    mif_put_point(x, y, number);
	//}
	//
	//
	// /* Set up a MIF output file */
	//TERM_PUBLIC void
	//MIF_init()
	//{
	//    int i;
	//
	// /* Process if not inside a MIF file and Frame */
	//    if (mif_initialized == 0 && mif_in_frame == 0) {
	// /* Tell this terminal driver that the output is initialized and
	//  * no current frames are processed */
	//	mif_initialized = 1;
	//	mif_in_frame = 0;
	//
	// /* Reset internal position */
	//	free_mif_line();
	//	mif_line.fpos_x = GNP_TO_MIF(0);
	//	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
	//
	// /* Reset drawing properties strings */
	//	mif_pen[0] = '\0';
	//	mif_pen_width[0] = '\0';
	//	mif_separation[0] = '\0';
	//
	//	MIF_justify_text(LEFT);
	//
	// /* Reset group ID generator */
	//	for (i = 0; i < MIF_NGROUP_ID; i++) {
	//	    mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
	//	    mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
	//	}
	//
	// /* Identify ourselves */
	// /*bs show borders */
	// /* Setup a default environment to use */
	//	fprintf(gpoutfile, "
	//<MIFFile 3.00> # Generated by gnuplot version %s patchlevel %s; identifies this as a MIF file\n
	///#\n# show borders\n<Document\n<DBordersOn Yes>\n>\n# Set a default pen pattern, pen width, unit and font for subsequent objects\n<Pen 0>\n<Fill 15>\n<PenWidth 0.5 pt>\n<Separation 0>\n<Units Ucm>\n<FontCatalog\n\t<Font <FTag `%s'><FFamily `Times'><FSize %d><FPlain Yes>>\n\t<Font <FTag `%s'><FFamily `ZapfDingbats'><FSize 7.0 pt><FPlain Yes>>\n\t<Font <FTag `%s'><FFamily `Symbol'><FSize 5.0 pt><FPlain Yes>>\n>\n#\n",
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//		gnuplot_version, gnuplot_patchlevel,
	//		zgnuplot, MIF_PSIZE,
	//		zgnuplotp,
	//		zgnuplotd);
	//    }				// MIF file created 
	//}
	//
	// /* Finish of a MIF output file */
	//TERM_PUBLIC void
	//MIF_reset()
	//{
	// /* Process if inside a MIF file and not inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame == 0) {
	// /* Finish off the MIF file */
	//	fputs("
	///#\n# End of MIFFile\n", gpoutfile);
	//ignore
	//
	// /* Tell this terminal driver that the output is finished */
	//	mif_initialized = 0;
	//
	// /* bs: reset frame number */
	//	mif_frameno = -1;
	//
	//    }				// MIF file finished 
	//}
	//
	// /* Start plotting a Frame (-> graphics mode) */
	//TERM_PUBLIC void
	//MIF_graphics()
	//{
	//    int i;
	//
	// /* Process if not inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame == 0) {
	// /* Tell that this terminal driver is working with a plot frame */
	//	mif_in_frame = 1;
	//
	// /* Update frame number */
	//	mif_frameno++;
	//
	// /* Set current position */
	//	free_mif_line();
	//	mif_line.fpos_x = GNP_TO_MIF(0);
	//	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
	//
	// /* Set drawing properties */
	//	mif_pen[0] = '\0';
	//	mif_pen_width[0] = '\0';
	//	mif_separation[0] = '\0';
	//
	//	MIF_justify_text(LEFT);
	//
	// /* Reset group ID generator */
	//	for (i = 0; i < MIF_NGROUP_ID; i++) {
	//	    mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
	//	    mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
	//	}
	//
	// /* Frame preamble */
	//	fprintf(gpoutfile, "
	///#\n# Frame number %d with plot of graphics\n<Frame\n\t<Pen 15>\n\t<Fill 15>\n\t<PenWidth  0.5 pt>\n\t<Separation 0>\n\t<BRect 2.000 %.3f %.3f %.3f>\n\t<NSOffset  0.000>\n\t<BLOffset  0.000>\n",
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//	    mif_frameno,
	//	    ((float) mif_frameno) * GNP_TO_MIF(MIF_YMAX + 100),
	//	    GNP_TO_MIF(MIF_XMAX), GNP_TO_MIF(MIF_YMAX));
	//    }				// Frame created 
	//}
	//
	// /* Stop plotting a Frame (-> text mode) */
	//TERM_PUBLIC void
	//MIF_text()
	//{
	//    int i;
	//
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Draw pending line */
	//	if (mif_polyline == TRUE)
	//	    put_mif_line();
	//
	// /* Group the used plot primitives */
	//	fputs("
	//\t#\n
	//\t# Group the the objects in groups to make the chart easier to manipulate\n
	//\t# after it's imported into FrameMaker.\n", gpoutfile);
	//
	//	for (i = 0; i < MIF_NGROUP_ID; i++) {
	//	    if (mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
	//		mif_group_id[i].group_existance == MIF_GROUP_EXISTS) {
	//		fprintf(gpoutfile, "
	//\t<Group\n
	//\t\t<ID %d>\n
	//\t>\n", mif_group_id[i].group_id);
	//	    }
	//	}
	//
	// /* Frame post amble */
	//	fprintf(gpoutfile, "
	//>\n
	///#End of Frame number %d\n#\n",
	//ignore
	//		mif_frameno);
	//
	// /* Tell that this terminal driver is not working with a plot frame */
	//	mif_in_frame = 0;
	//    }				// Frame finshed 
	//}
	//
	// /* Select type of line in grapics */
	// /* NOTE: actually written to output the first time a primitive
	//  * is drawn AFTER this call */
	// /* -2=border, -1=X/Y-axis, 0-13=lines, and 14-=mapped back */
	//TERM_PUBLIC void
	//MIF_linetype(int linetype)
	//{
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Draw pending line */
	//	if (mif_polyline == TRUE)
	//	    put_mif_line();
	//
	// /* Translate gnuplot pen types to MIF pen types */
	//	if (linetype < 0) {	// Special lines 
	//	    if (linetype == LT_AXIS) {
	//		mif_pentype = 8 + MIF_NPENS;	// -1 
	//		if (mif_colour == TRUE)
	//		    sprintf(mif_separation, " <Separation 0> ");
	//	    } else {
	//		mif_pentype = 0 + MIF_NPENS;	// -2 or less 
	//		if (mif_colour == TRUE)
	//		    sprintf(mif_separation, " <Separation 0> ");
	//	    }
	//	    sprintf(mif_pen_width, " <PenWidth 1.0 pt> ");
	// /* EAM - set text color to black */
	//	    sprintf(mif_textcolor, " <Font <FSeparation 0>> ");
	//	} else {		// Normal lines 
	//	    mif_pentype = (linetype) % MIF_NPENS;	// 0-(MIF_NPENS-1) 
	//	    sprintf(mif_pen_width, " <PenWidth 0.1 pt> ");
	//	    if (mif_colour == TRUE)
	//		sprintf(mif_separation, " <Separation %d> ",
	//			2 + (mif_pentype % 6));	// 2-7 
	// /* EAM - set text color also */
	//	    if (mif_colour == TRUE)
	//		sprintf(mif_textcolor, " <Font <FSeparation %d>> ",
	//			2 + (mif_pentype % 6));	// 2-7 
	//	}
	//
	// /* Set pen type */
	//	sprintf(mif_pen, " <Pen %d> ",
	//		mif_pattern_table[mif_pentype % MIF_NPENS]);
	//
	//    }				// Primitive processed 
	//}
	//
	// /* Allow arbitrary text rotation */
	//TERM_PUBLIC int
	//MIF_text_angle(int ang)
	//{
	//    mif_text_ang = ang;
	//    return (TRUE);
	//}
	//
	// /* Justify following text lines (MIF_put_text()) relative to the
	//  * insertion point
	//  * NOTE: actually written to output in text primitives which are
	//  * drawn AFTER this call */
	//TERM_PUBLIC int
	//MIF_justify_text(enum JUSTIFY mode)
	//{
	//    int rval = TRUE;
	//
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//	switch (mode) {
	//	case LEFT:
	//	    sprintf(mif_justify, " <TLAlignment Left> ");
	//	    break;
	//	case CENTRE:
	//	    sprintf(mif_justify, " <TLAlignment Center> ");
	//	    break;
	//	case RIGHT:
	//	    sprintf(mif_justify, " <TLAlignment Right> ");
	//	    break;
	//	default:
	//	    rval = FALSE;
	//	    break;
	//	}
	//
	//    }
	// /* Primitive processed */
	//    else {
	//	rval = FALSE;
	//    }
	//
	//    return (rval);
	//}
	//
	// /* Draw a vector from current position to (x, y) and change current position.
	//  * NOTE: actually written to output the first time another primitive
	//  * is called AFTER this call */
	//TERM_PUBLIC void
	//MIF_vector(unsigned int x, unsigned int y)
	//{
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Setup the vector as a part of the line */
	//	insert_mif_line(GNP_TO_MIF(x), GNP_TO_MIF(MIF_YLAST - (int) y));
	//
	// /* Draw pending line -> vector */
	//	if (mif_polyline == FALSE)
	//	    put_mif_line();
	//
	//    }				// Vector processed 
	//}
	//
	// /* Move current position */
	//TERM_PUBLIC void
	//MIF_move(unsigned int x, unsigned int y)
	//{
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Draw pending line */
	//	if (mif_polyline == TRUE)
	//	    put_mif_line();
	//
	//	mif_line.fpos_x = GNP_TO_MIF(x);
	//	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST - (int) y);
	//    }
	//}
	//
	//
	// /* set font */
	//static void
	//MIF_set_font(const char *font)
	//{
	//    if (font != mif_font) {
	//	fprintf(gpoutfile, "\t\t<Font\n\t\t\t<FTag `%s'>\n\t\t>\n", font);
	//	mif_font = font;
	//    }
	//}
	//
	//
	// /* Draw the text string str at (x, y). Adjust according to MIF_justify_text().
	//  * Change current position. */
	//TERM_PUBLIC void
	//MIF_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Draw pending line */
	//	if (mif_polyline == TRUE)
	//	    put_mif_line();
	//
	// /* Adjust current position for text-graphics alignment */
	//	MIF_move(x, y - MIF_VCHAR / 5);
	//
	//	if (strlen(str) > 0) {
	//
	// /* Draw the text */
	//	    fprintf(gpoutfile, "\t<TextLine <GroupID %d> %s %s %s %s\n",
	//		    MIF_PEN_TO_GROUP(mif_pentype), mif_pen,
	//		    mif_pen_width, mif_separation, mif_textcolor);
	//
	//	    MIF_set_font(zgnuplot);
	//
	//	    fprintf(gpoutfile, "
	//\t\t<TLOrigin  %.3f %.3f> %s <Angle %d> <String `%s'>\n
	//\t>\n",
	//		    mif_line.fpos_x, mif_line.fpos_y, mif_justify,
	//		    mif_text_ang, str);
	//
	// /* Register the used group ID */
	//	    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
	//
	// /* Avoid to redraw this. The MIF system should remember it. */
	//	    mif_pen[0] = '\0';
	//	    mif_pen_width[0] = '\0';
	//	    mif_separation[0] = '\0';
	//
	//	    mif_justify[0] = '\0';	// Independent of linetype 
	//	}
	//    }				// Text processed 
	//}
	//
	//
	// /* Insert one point in the line */
	//static int
	//insert_mif_line(double fx, double fy)
	//{
	//    int rval = TRUE;
	//
	//    if ((mif_line.prev->next = (struct mif_line *) gp_alloc(sizeof(struct mif_line),
	//	"MIF driver")) != (struct mif_line *) NULL) {
	// /* Link */
	//	mif_line.prev->next->next = &mif_line;
	//	mif_line.prev->next->prev = mif_line.prev;
	//	mif_line.prev = mif_line.prev->next;
	//
	// /* Fill */
	//	mif_line.prev->fpos_x = fx;
	//	mif_line.prev->fpos_y = fy;
	//
	//	rval = TRUE;
	//    } else {			// Failed to allocate 
	// /* Relink */
	//	mif_line.prev->next = &mif_line;
	//
	//	rval = FALSE;
	//    }
	//
	//    return (rval);
	//}
	//
	// /* Register group ID. Update group ID existance. */
	// /* Returns:     1       group_id belongs to a MIF group
	// 		0       group_id does not belong to a MIF group
	// 	       -1       not inside a Frame
	// 	       -2       group ID list is full
	//  */
	//static int
	//proc_group_id(int group_id)
	//{
	//    int i, rval = 0;
	//
	// /* Process if inside a Frame */
	//    if (mif_initialized != 0 && mif_in_frame != 0) {
	//
	// /* Find out the group ID, or a free group ID slot index. */
	//	for (i = 0; i < MIF_NGROUP_ID &&
	//	     mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
	//	     mif_group_id[i].group_id != group_id;
	//	     i++) {
	// /* Don't check the group_existance variable */
	//	}
	//
	//	if (i < MIF_NGROUP_ID) {
	//	    if (mif_group_id[i].group_id == MIF_INVALID_GROUP_ID) {
	// /* Register as new group ID for eventual use as MIF group */
	//		mif_group_id[i].group_id = group_id;
	//		mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
	//	    } else {
	// /* If second use of this group ID -> create a new MIF group */
	//		if (mif_group_id[i].group_id == group_id) {
	//		    mif_group_id[i].group_existance = MIF_GROUP_EXISTS;
	// /* NOTE: a group MUST have at least two members. */
	//		    rval = 1;
	//		}
	//	    }
	//	} else {
	//	    rval = -2;		// No place for this group ID in the list 
	//	}
	//
	//    }
	// /* Group ID processed */
	//    else {
	//	rval = -1;		// Not inside a Frame 
	//    }
	//
	// /* Return MIF group status */
	//    return (rval);
	//}
	//
	//
	///#endif


	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(mif_driver)
	//    "mif", "Frame maker MIF 3.00 format",
	//    MIF_XMAX, MIF_YMAX, MIF_VCHAR, MIF_HCHAR,
	//    MIF_VTIC, MIF_HTIC, MIF_options, MIF_init, MIF_reset,
	//    MIF_text, null_scale, MIF_graphics, MIF_move, MIF_vector,
	//    MIF_linetype, MIF_put_text, MIF_text_angle,
	//    MIF_justify_text, MIF_point, do_arrow, set_font_null,
	//    0, // pointsize 
	//    0, // flags 
	//    0, 0, // suspend, resume 
	//    MIF_boxfill,
	//    0  // linewidth 
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0
	///#endif
	//    ,0 // make_palette 
	//    ,0 // previous_palette 
	//    ,0 // set_color 
	//    ,MIF_filled_polygon // filled_polygon 
	//TERM_TABLE_END(mif_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM mif_driver
	//
	///#endif
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(mif)
	//"1 mif",
	//"?commands set terminal mif",
	//"?set terminal mif",
	//"?set term mif",
	//"?terminal mif",
	//"?term mif",
	//"?mif",
	//" The `mif` terminal driver produces Frame Maker MIF format version 3.00.  It",
	//" plots in MIF Frames with the size 15*10 cm, and plot primitives with the same",
	//" pen will be grouped in the same MIF group.  Plot primitives in a `gnuplot`",
	//" page will be plotted in a MIF Frame, and several MIF Frames are collected in",
	//" one large MIF Frame.  The MIF font used for text is \"Times\".",
	//"",
	//" Several options may be set in the MIF 3.00 driver.",
	//"",
	//" Syntax:",
	//"       set terminal mif {color | colour | monochrome} {polyline | vectors}",
	//"                        {help | ?}",
	//"",
	//" `colour` plots lines with line types >= 0 in colour (MIF sep. 2--7) and",
	//" `monochrome` plots all line types in black (MIF sep. 0).",
	//" `polyline` plots curves as continuous curves and `vectors` plots curves as",
	//" collections of vectors.",
	//" `help` and `?` print online help on standard error output---both print a",
	//" short description of the usage; `help` also lists the options.",
	//"",
	//" Examples:",
	//"       set term mif colour polylines    # defaults",
	//"       set term mif                     # defaults",
	//"       set term mif vectors",
	//"       set term mif help"
	//END_HELP(mif)
	///#endif // TERM_HELP 


	/* portable bit map */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: pbm.trm,v 1.29.2.1 2009/08/26 19:16:13 sfeam Exp $
	 *
	 */

	/* GNUPLOT - pbm.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  pbm
	 *
	 * AUTHORS
	 *  Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* The following pbmplus drivers use the generic bit mapped graphics
	   routines from bitmap.c to build up a bit map in memory.  The driver
	   interchanges colomns and lines in order to access entire lines
	   easily and returns the lines to get bits in the right order :
	   (x,y) -> (y,XMAX-1-x). */
	/* This interchange is done by calling b_makebitmap() with reversed
	   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
	   will then perform the interchange before each pixel is plotted */
	/* See Jef Poskanzer's excellent PBMplus package for more details of
	   the Portable BitMap format and for programs to convert PBM files
	   to other bitmap formats. */


	///#ifdef TERM_REGISTER
	//register_term(pbm_driver)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void PBM_options __PROTO((void));
	//TERM_PUBLIC void PBM_init __PROTO((void));
	//TERM_PUBLIC void PBM_reset __PROTO((void));
	//TERM_PUBLIC void PBM_setfont __PROTO((void));
	//TERM_PUBLIC void PBM_graphics __PROTO((void));
	//TERM_PUBLIC void PBM_monotext __PROTO((void));
	//TERM_PUBLIC void PBM_graytext __PROTO((void));
	//TERM_PUBLIC void PBM_colortext __PROTO((void));
	//TERM_PUBLIC void PBM_text __PROTO((void));
	//TERM_PUBLIC void PBM_linetype __PROTO((int linetype));
	//TERM_PUBLIC void PBM_point __PROTO((unsigned int x, unsigned int y, int point));
	///#endif // TERM_PROTO 

	/* make XMAX and YMAX a multiple of 8 */
	///#define PBM_XMAX (640)
	///#define PBM_YMAX (480)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PBM_VCHAR (FNT5X9_VCHAR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PBM_HCHAR (FNT5X9_VCHAR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PBM_VTIC FNT5X9_HBITS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PBM_HTIC FNT5X9_HBITS

	///#ifdef TERM_BODY
	//
	//static int pbm_font = 1;	// small font 
	//static int pbm_mode = 0;	// 0:monochrome 1:gray 2:color 
	//
	// /* Only needed for dubious backwards compatibility with 'set size'
	//  * in pre-4.2 versions that didn't support 'set term size'
	//  */
	//static TBOOLEAN PBM_explicit_size = FALSE;
	//
	// /* 7=black, 0=white */
	//static int pgm_gray[] = { 7, 1, 6, 5, 4, 3, 2, 1, 7 };	// grays  
	// /* bit3=!intensify, bit2=!red, bit1=!green, bit0=!blue */
	//static int ppm_color[] ={ 15, 8, 3, 5, 6, 2, 4, 1, 11, 13, 14 };  // colors 
	//
	//enum PBM_id {
	//    PBM_SMALL, PBM_MEDIUM, PBM_LARGE,
	//    PBM_MONOCHROME, PBM_GRAY, PBM_COLOR, PBM_SIZE,
	//    PBM_OTHER
	//};
	//
	//static struct gen_table PBM_opts[] =
	//{
	//    { "s$mall", PBM_SMALL },
	//    { "me$dium", PBM_MEDIUM },
	//    { "l$arge", PBM_LARGE },
	//    { "mo$nochrome", PBM_MONOCHROME },
	//    { "g$ray", PBM_GRAY },
	//    { "c$olor", PBM_COLOR },
	//    { "c$olour", PBM_COLOR },
	//    { "size", PBM_SIZE },
	//    { NULL, PBM_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//PBM_options()
	//{
	//    int xpixels = PBM_XMAX;
	//    int ypixels = PBM_YMAX;
	//    struct value a;
	//    pbm_font = 1;
	//    pbm_mode = 0;
	//
	//    term_options[0] = NUL;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&PBM_opts[0],c_token)) {
	//	case PBM_SMALL:
	//	    pbm_font = 1;
	//	    c_token++;
	//	    break;
	//	case PBM_MEDIUM:
	//	    pbm_font = 2;
	//	    c_token++;
	//	    break;
	//	case PBM_LARGE:
	//	    pbm_font = 3;
	//	    c_token++;
	//	    break;
	//	case PBM_MONOCHROME:
	//	    pbm_mode = 0;
	//	    term->flags |= TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case PBM_GRAY:
	//	    pbm_mode = 1;
	//	    c_token++;
	//	    break;
	//	case PBM_COLOR:
	//	    pbm_mode = 2;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case PBM_SIZE:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		term->xmax = PBM_XMAX;
	//		term->ymax = PBM_YMAX;
	//		PBM_explicit_size = FALSE;
	//	    } else {
	//		xpixels = real(const_express(&a));
	//		if (equals(c_token, ",")) {
	//		    c_token++;
	//		    ypixels = real(const_express(&a));
	//		}
	//		PBM_explicit_size = TRUE;
	//	    }
	//	    if (xpixels > 0)
	//		term->xmax = xpixels;
	//	    if (ypixels > 0)
	//		term->ymax = ypixels;
	//	    break;
	//	case PBM_OTHER:
	//	default:
	// /* reset to default, since term is already set */
	//	    pbm_font = 1;
	//	    pbm_mode = 0;
	//	    int_error(c_token, "expecting: {small, medium, large} and {monochrome, gray, color}");
	//	    break;
	//	}
	//    }
	//
	//    term->v_tic = (term->xmax < term->ymax) ? term->xmax/100 : term->ymax/100;
	//    if (term->v_tic < 1)
	//        term->v_tic = 1;
	//    term->h_tic = term->v_tic;
	//
	// /* setup options string */
	//
	//    switch (pbm_font) {
	//    case 1:
	//	strcat(term_options, "small");
	//	break;
	//    case 2:
	//	strcat(term_options, "medium");
	//	break;
	//    case 3:
	//	strcat(term_options, "large");
	//	break;
	//    }
	//
	//    switch (pbm_mode) {
	//    case 0:
	//	strcat(term_options, " monochrome");
	//	break;
	//    case 1:
	//	strcat(term_options, " gray");
	//	break;
	//    case 2:
	//	strcat(term_options, " color");
	//	break;
	//    }
	//
	//    if (PBM_explicit_size)
	//	sprintf(term_options + strlen(term_options), " size %d,%d",
	//	    term->xmax, term->ymax);
	//}
	//
	//
	//TERM_PUBLIC void
	//PBM_init()
	//{
	//    PBM_setfont();		// HBB 980226: call it here! 
	//}
	//
	//
	//TERM_PUBLIC void
	//PBM_reset()
	//{
	///#ifdef VMS
	//    fflush_binary();
	///#endif // VMS 
	//}
	//
	//
	//TERM_PUBLIC void
	//PBM_setfont()
	//{
	//    switch (pbm_font) {
	//    case 1:
	//	b_charsize(FNT5X9);
	//	term->v_char = FNT5X9_VCHAR;
	//	term->h_char = FNT5X9_HCHAR;
	//	break;
	//    case 2:
	//	b_charsize(FNT9X17);
	//	term->v_char = FNT9X17_VCHAR;
	//	term->h_char = FNT9X17_HCHAR;
	//	break;
	//    case 3:
	//	b_charsize(FNT13X25);
	//	term->v_char = FNT13X25_VCHAR;
	//	term->h_char = FNT13X25_HCHAR;
	//	break;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PBM_graphics()
	//{
	//    int numplanes = 1;
	//    unsigned int xpixels = term->xmax;
	//    unsigned int ypixels = term->ymax;
	//
	// /* 'set size' should not affect the size of the canvas in pixels,
	//  * but versions prior to 4.2 did not have a separate 'set term size'
	//  */
	//    if (!PBM_explicit_size) {
	// 	xpixels *= xsize;
	//	ypixels *= ysize;
	//    }
	//
	//    switch (pbm_mode) {
	//    case 1:
	//	numplanes = 3;
	//	break;
	//    case 2:
	//	numplanes = 4;
	//	break;
	//    }
	//
	// /* HBB 980226: this is not the right place to do this: setfont() influences
	//  * fields of the termtable entry, and therefore must be called by init()
	//  * already. */
	// /* PBMsetfont(); */
	// /* rotate plot -90 degrees by reversing XMAX and YMAX and by
	//    setting b_rastermode to TRUE */
	//    b_makebitmap(ypixels, xpixels, numplanes);
	//    b_rastermode = TRUE;
	//
	//    if (pbm_mode != 0)
	//	b_setlinetype(0);	// solid lines 
	//}
	//
	//
	//static void
	//PBM_monotext()
	//{
	//    register int x, j, row;
	//
	//    fputs("P4\n", gpoutfile);
	//    fprintf(gpoutfile, "%u %u\n", b_ysize, b_xsize);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	for (j = row; j >= 0; j--) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	}
	//    }
	//
	//    b_freebitmap();
	//}
	//
	//static void
	//PBM_graytext()
	//{
	//    register int x, j, row;
	//    register int i, value;
	//    int mask, plane1, plane2, plane3;
	//
	//    fprintf(gpoutfile, "
	//P5\n
	//%u %u\n
	//%u\n",
	//	    b_ysize, b_xsize,
	//	    255);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	for (j = row; j >= 0; j--) {
	//	    mask = 0x80;
	//	    plane1 = (*((*b_p)[j] + x));
	//	    plane2 = (*((*b_p)[j + b_psize] + x));
	//	    plane3 = (*((*b_p)[j + b_psize + b_psize] + x));
	//	    for (i = 0; i < 8; i++) {
	// /* HBB: The values below are set to span the full range
	//  * from 0 up to 255 in 7 steps: */
	//		value = 255;
	//		if (plane1 & mask)
	//		    value -= 36;
	//		if (plane2 & mask)
	//		    value -= 73;
	//		if (plane3 & mask)
	//		    value -= 146;
	//		(void) fputc((char) (value), gpoutfile);
	//		mask >>= 1;
	//	    }
	//	}
	//    }
	//
	//    b_freebitmap();
	//}
	//
	//static void
	//PBM_colortext()
	//{
	//    register int x, j, row;
	//    register int i;
	//    int mask, plane1, plane2, plane3, plane4;
	//    int red, green, blue;
	//
	//    fprintf(gpoutfile, "P6\n
	//%u %u\n
	//%u\n",
	//	    b_ysize, b_xsize,
	//	    255);
	//
	// /* dump bitmap in raster mode */
	//    for (x = b_xsize - 1; x >= 0; x--) {
	//	row = (b_ysize / 8) - 1;
	//	for (j = row; j >= 0; j--) {
	//	    mask = 0x80;
	//	    plane1 = (*((*b_p)[j] + x));
	//	    plane2 = (*((*b_p)[j + b_psize] + x));
	//	    plane3 = (*((*b_p)[j + b_psize + b_psize] + x));
	//	    plane4 = (*((*b_p)[j + b_psize + b_psize + b_psize] + x));
	//	    for (i = 0; i < 8; i++) {
	//		red = (plane3 & mask) ? 1 : 3;
	//		green = (plane2 & mask) ? 1 : 3;
	//		blue = (plane1 & mask) ? 1 : 3;
	//		if (plane4 & mask) {
	//		    red--;
	//		    green--;
	//		    blue--;
	//		}
	// /* HBB: '85' is exactly 255/3, so this spans the full
	//  * range of colors in three steps: */
	//		(void) fputc((char) (red * 85), gpoutfile);
	//		(void) fputc((char) (green * 85), gpoutfile);
	//		(void) fputc((char) (blue * 85), gpoutfile);
	//		mask >>= 1;
	//	    }
	//	}
	//    }
	//
	//    b_freebitmap();
	//}
	//
	//TERM_PUBLIC void
	//PBM_text()
	//{
	//    switch (pbm_mode) {
	//    case 0:
	//	PBM_monotext();
	//	break;
	//    case 1:
	//	PBM_graytext();
	//	break;
	//    case 2:
	//	PBM_colortext();
	//	break;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PBM_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//
	//    switch (pbm_mode) {
	//    case 0:
	//	b_setlinetype(linetype);
	//	break;
	//    case 1:
	//	if (linetype >= 7)
	//	    linetype %= 7;
	//	b_setvalue(pgm_gray[linetype + 2]);
	//	break;
	//    case 2:
	//	if (linetype >= 9)
	//	    linetype %= 9;
	//	b_setvalue(ppm_color[linetype + 2]);
	//	break;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//PBM_point(unsigned int x, unsigned int y, int point)
	//{
	//    if (pbm_mode == 0)
	//	line_and_point(x, y, point);
	//    else
	//	do_point(x, y, point);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(pbm_driver)
	//    "pbm", "Portable bitmap [small medium large] [monochrome gray color]",
	//    PBM_XMAX, PBM_YMAX, PBM_VCHAR,
	//    PBM_HCHAR, PBM_VTIC, PBM_HTIC, PBM_options,
	//    PBM_init, PBM_reset, PBM_text, null_scale,
	//    PBM_graphics, b_move, b_vector, PBM_linetype,
	//    b_put_text, b_text_angle, null_justify_text, PBM_point,
	//    do_arrow, set_font_null,
	//    0,				// pointsize 
	//    TERM_CAN_MULTIPLOT | TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(pbm_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM pbm_driver
	//
	///#endif // TERM_TABLE 


	///#ifdef TERM_HELP
	//START_HELP(pbm)
	//"1 pbm",
	//"?commands set terminal pbm",
	//"?set terminal pbm",
	//"?set term pbm",
	//"?terminal pbm",
	//"?term pbm",
	//"?pbm",
	//" Syntax:",
	//"       set terminal pbm {<fontsize>} {<mode>} {size <x>,<y>}",
	//"",
	//" where <fontsize> is `small`, `medium`, or `large` and <mode> is `monochrome`,",
	//" `gray` or `color`.  The default plot size is 640 pixels wide and 480 pixels",
	//" high. The output size is white-space padded to the nearest multiple of",
	//" 8 pixels on both x and y. This empty space may be cropped later if needed.",
	//"",
	//" The output of the `pbm` driver depends upon <mode>: `monochrome` produces a",
	//" portable bitmap (one bit per pixel), `gray` a portable graymap (three bits",
	//" per pixel) and `color` a portable pixmap (color, four bits per pixel).",
	//"",
	//" The output of this driver can be used with various image conversion and",
	//" manipulation utilities provided by NETPBM.  Based on Jef Poskanzer's",
	//" PBMPLUS package, NETPBM provides programs to convert the above PBM formats",
	//" to GIF, TIFF, MacPaint, Macintosh PICT, PCX, X11 bitmap and many others.",
	//" Complete information is available at http://netpbm.sourceforge.net/.",
	//"",
	//" Examples:",
	//"       set terminal pbm small monochrome                # defaults",
	//"       set terminal pbm color medium size 800,600",
	//"       set output '| pnmrotate 45 | pnmtopng > tilted.png'  # uses NETPBM"
	//END_HELP(pbm)
	///#endif // TERM_HELP 


	/* Adobe Portable Document Format (PDF) */
	/* NOTE THAT PDF REQUIRES A SEPARATE LIBRARY : see term/pdf.trm */
	///#ifdef HAVE_LIBPDF
	///#include "pdf.trm"
	///#endif

	///#if defined(HAVE_GD_PNG) || defined(HAVE_GD_JPEG) || defined(HAVE_GD_GIF)
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: gd.trm,v 1.136.2.10 2010/02/24 20:33:57 sfeam Exp $
	 * based on gif.trm,v 1.26.2.1 2000/05/01 00:17:20 joze
	 */

	/* GNUPLOT -- gd.trm */

	/*[
	 * Copyright 1998, 2001, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports PNG and JPEG output using
	 *  GD library 1.8, 2.0
	 *
	 * To Use:
	 *
	 * set terminal png ?options ...?
	 *
	 * Where an option is:
	 *
	 * transparent - generate transparent PNGs.  The first color will
	 * be the transparent one.
	 *
	 * interlace - generate interlaced PNGs.
	 *
	 * image size (in pixels)
	 *
	 * font size (tiny,small,medium,large,giant)
	 *
	 * font name (TrueType or Adobe Type 1 font name is passed to libgd)
	 *
	 * xrrggbb - sets the next color.  x is the literal character 'x',
	 * rrggbb are the red green and blue components in hex.  For example
	 * x00ff00 is green.  The background color is set first, then the
	 * color borders, then the X & Y axis, then the plotting colors.
	 * (The wierd color spec is in order to get around limitations
	 * in gnuplot's scanner.)
	 * EAM Feb 2010: This mechanism is totally obsolete except for setting the
	 * background color.  Revise the documentation accordingly.
	 *
	 * This driver is modeled after the PBM driver pbm.trm.
	 *
	 * AUTHORS
	 *  Sam Shen <sls@mh1.lbl.gov>
	 *  Alex Woo <woo@playfair.stanford.edu>
	 *  Ethan A Merritt <merritt@u.washington.edu>
	 *
	 * CONTRIBUTORS
	 *  Alfred Reibenschuh <alfred.reibenschuh@it-austria.com> or <fredo@blackbox.at>
	 *  Ben Laurie <ben@algroup.co.uk>
	 *
	 * This version outputs either indexed or truecolor (24-bit RGB) images
	 * The default size is 640x480 pixels.
	 *
	 ******************************************************************************
	 * PLEASE READ                                                                *
	 * This driver uses the gd library, available from http://www.libgd.org       *
	 * This driver allows you to use TrueType, OpenType, or Adobe Type 1 fonts.   *
	 * If you have libgd version 2.0.36 or later, you may also be able to access  *
	 * any fonts that are managed by the fontconfig utility.                      *
	 * You can use this driver without having any TrueType fonts installed,       *
	 * but the default fonts are comparatively limited.                           *
	 ******************************************************************************
	 *
	 * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
	 * Ethan Merritt, May 2001: modified gd/gif driver to produce png instead;
	 *                          added support for line width and TrueType fonts
	 */

	/* Approximate "fillstyle solid FRAC " for indexed palettes */
	///#define PASTEL_PALETTE

	///#define GD_DEFINED_COLORS 96


	///#ifdef TERM_REGISTER
	//register_term(png)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void PNG_options __PROTO((void));
	//TERM_PUBLIC void PNG_init __PROTO((void));
	//TERM_PUBLIC void PNG_graphics __PROTO((void));
	//TERM_PUBLIC void PNG_text __PROTO((void));
	//TERM_PUBLIC void PNG_linetype __PROTO((int linetype));
	//TERM_PUBLIC void PNG_linewidth __PROTO((double linewidth));
	//TERM_PUBLIC void PNG_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void PNG_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void PNG_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC int PNG_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void PNG_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC int PNG_text_angle __PROTO((int ang));
	//TERM_PUBLIC void PNG_reset __PROTO((void));
	//TERM_PUBLIC int PNG_set_font __PROTO((const char *fontname));
	//TERM_PUBLIC void PNG_pointsize __PROTO((double ptsize));
	//TERM_PUBLIC void PNG_boxfill(int, unsigned int, unsigned int, unsigned int, unsigned int);
	//TERM_PUBLIC int PNG_make_palette (t_sm_palette *);
	// /* TERM_PUBLIC void PNG_previous_palette (void); */
	//TERM_PUBLIC void PNG_set_color (t_colorspec *);
	//TERM_PUBLIC void PNG_filled_polygon (int, gpiPoint *);
	//TERM_PUBLIC void PNG_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
	//
	// /* To support "set term png enhanced" */
	//TERM_PUBLIC void ENHGD_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void ENHGD_OPEN __PROTO((char * fontname, double fontsize,
	//			double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//			int overprint));
	//TERM_PUBLIC void ENHGD_FLUSH __PROTO((void));
	//
	//
	///#include "gd.h"
	//
	// /* Before version 2.0.36, the libgd function gdFTUseFontConfig() didn't */
	// /* do what we need.  Test for earlier versions and ignore it.           */
	///#ifdef GD_MAJOR_VERSION
	///#if (GD_MINOR_VERSION > 0  ||  GD_RELEASE_VERSION > 35)
	///#define gdUseFontConfig(x) gdFTUseFontConfig(x)
	///#endif
	///#endif
	///#ifndef gdUseFontConfig
	///#define gdUseFontConfig(x) 0
	///#endif
	//
	///#if defined(WIN32) && !defined(NONDLL)
	// /* static font pointers are recommended when using bgd.dll */
	///#ifndef GD_NEED_LOCAL_FONT_POINTERS
	///#define GD_NEED_LOCAL_FONT_POINTERS
	///#endif
	///#endif
	//
	///#ifdef GD_NEED_LOCAL_FONT_POINTERS
	///#include "gdfonts.h"
	///#include "gdfontl.h"
	///#include "gdfontmb.h"
	///#include "gdfontt.h"
	///#include "gdfontg.h"
	///#endif
	//
	// /* This is required for the shared library version of libgd on Windows.
	//    Newer versions of libgd (>=2.0.24 ?) already define it. */
	///#ifndef BGD_EXPORT_DATA_PROT 
	///#define BGD_EXPORT_DATA_PROT extern
	///#endif
	//
	// /* These intermediate functions are necessary on Windows since 
	//    the shared version of libgd uses a different calling convention
	//    and there is no proper macro defined.
	// */
	///#if defined(WIN32) && !defined(NONDLL)
	//static void gp_gdImagePolygon(gdImagePtr, gdPointPtr, int, int);
	//static void gp_gdImageFilledPolygon(gdImagePtr, gdPointPtr, int, int);
	///#else
	///#define gp_gdImagePolygon gdImagePolygon
	///#define gp_gdImageFilledPolygon gdImageFilledPolygon 
	///#endif
	//
	//static void PNG_PointX __PROTO((unsigned int, unsigned int));
	//static void PNG_PointPlus __PROTO((unsigned int, unsigned int));
	//static void PNG_Triangle(unsigned int x, unsigned int y, int direction,
	//	void (*draw_func)(gdImagePtr, gdPointPtr, int, int));
	//static void PNG_Diamond(unsigned int x, unsigned int y,
	//	void (*draw_func)(gdImagePtr, gdPointPtr, int, int));
	//static void PNG_init_brush __PROTO((int));
	//
	///#ifndef GD_NEED_LOCAL_FONT_POINTERS
	//BGD_EXPORT_DATA_PROT gdFontPtr gdFontSmall;	// 6x12 
	//BGD_EXPORT_DATA_PROT gdFontPtr gdFontLarge;	// 8x16 
	//BGD_EXPORT_DATA_PROT gdFontPtr gdFontMediumBold;	// 7x13 
	//BGD_EXPORT_DATA_PROT gdFontPtr gdFontGiant;  // 9x15 
	//BGD_EXPORT_DATA_PROT gdFontPtr gdFontTiny;  // 5x8 
	///#else
	//static gdFontPtr gdFontSmall;	// 6x12 
	//static gdFontPtr gdFontLarge;	// 8x16 
	//static gdFontPtr gdFontMediumBold;	// 7x13 
	//static gdFontPtr gdFontGiant;  // 9x15 
	//static gdFontPtr gdFontTiny;  // 5x8 
	///#endif
	//
	///#define GREG_XMAX 640
	///#define GREG_YMAX 480
	//
	// /* This will be the default font */
	///#define gdfont gdFontMediumBold
	///#define PNG_VCHAR 13
	///#define PNG_HCHAR 7
	//
	///#define PNG_TICSIZE (GREG_YMAX/100)
	//
	///#define PNG_MAX_COLORS 256
	///#define GOT_NEXT_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static TBOOLEAN PNG_initialized = FALSE;	// Set when terminal first initialized 
	//
	//static struct {
	//    gdImagePtr image;
	//    gdFontPtr font;
	//    unsigned int x, y;
	//    int height;
	//    int charh, charw;
	//    int color;             // Magic index returned by libgd 
	//    int rgb;               // Our guess at the corresponding rgb 
	//    int n_colors;
	//    int color_table[PNG_MAX_COLORS];
	//    int rgb_table[PNG_MAX_COLORS];
	//    int angle;
	//    enum JUSTIFY justify;
	//    int flags;
	//    int linetype;
	//    int linewidth;
	//    TBOOLEAN capbutt;  // use capbutt on lines with GD2, 20051205 MWS
	//    TBOOLEAN use_builtin;
	//    int ttfsize;
	//    char *ttffont;
	//    gdFontPtr default_font;
	//    char *    default_ttffont;
	//    int       default_ttfsize;
	//    TBOOLEAN  TrueColor;
	// /* Variables for animated gif support: */
	//    TBOOLEAN  animate;		// Only gif supports animation 
	//    int       loop_count;	// Number of times to repeat sequence 
	//    int       frame_count;	// Number of frames in animation 
	//    int       frame_delay;	// Time between frames in .01 seconds 
	//    TBOOLEAN  frame_optimization;
	//    gdImagePtr previous_image;	// Needed to encode animation as a series of deltas 
	//} png_state;
	//
	///#define PNG_USE_TRANSPARENT 1
	///#define PNG_USE_INTERLACE   2
	///#define PNG_USE_CROP        4
	//
	//enum PNG_id {
	//    PNG_TRANSPARENT, PNG_NOTRANSPARENT,
	//    PNG_INTERLACE, PNG_NOINTERLACE,
	//    PNG_CROP, PNG_NOCROP,
	// /* Font size */
	//    PNG_TINY, PNG_SMALL, PNG_MEDIUM, PNG_LARGE, PNG_GIANT,
	//    PNG_FONT,
	//    PNG_SIZE,
	//    PNG_ENHANCED, PNG_NOENHANCED,
	//    PNG_TRUECOLOR, PNG_NOTRUECOLOR,
	//    PNG_LINEWIDTH, PNG_BUTT, PNG_ROUNDED, PNG_DASHLENGTH,
	//    GIF_ANIMATE, GIF_DELAY, GIF_LOOP, GIF_NOOPT, GIF_OPT,
	//    PNG_OTHER
	//};
	//
	///#ifdef Y
	///#undef Y
	///#endif
	///#define Y(y) (png_state.height - (y))
	//
	//static int PNG_XMAX = GREG_XMAX;
	//static int PNG_YMAX = GREG_YMAX;
	//static const int PNG_POINT_SCALE = 3;
	//static int PNG_ps = 3;
	//
	//static struct gen_table PNG_opts[] =
	//{
	//    { "trans$parent", PNG_TRANSPARENT },
	//    { "notran$sparent", PNG_NOTRANSPARENT },
	//    { "inter$lace", PNG_INTERLACE },
	//    { "nointer$lace", PNG_NOINTERLACE },
	//    { "crop", PNG_CROP },
	//    { "nocrop", PNG_NOCROP },
	//    { "ti$ny", PNG_TINY },
	//    { "s$mall", PNG_SMALL },
	//    { "m$edium", PNG_MEDIUM },
	//    { "l$arge", PNG_LARGE },
	//    { "g$iant", PNG_GIANT },
	//    { "fo$nt", PNG_FONT },
	//    { "si$ze", PNG_SIZE },
	//    { "enh$anced", PNG_ENHANCED },
	//    { "noenh$anced", PNG_NOENHANCED },
	//    { "true$color", PNG_TRUECOLOR },
	//    { "notrue$color", PNG_NOTRUECOLOR },
	//    { "linew$idth", PNG_LINEWIDTH },
	//    { "anim$ate", GIF_ANIMATE }, // gif animation options 
	//    { "delay", GIF_DELAY },
	//    { "loop", GIF_LOOP },
	//    { "noopt$imize", GIF_NOOPT },
	//    { "opt$imize", GIF_OPT }, // end of gif animation options 
	//    { "lw", PNG_LINEWIDTH },
	//    { "butt", PNG_BUTT},
	//    { "round$ed", PNG_ROUNDED},
	//    { "dashl$ength", PNG_DASHLENGTH},
	//    { "dl", PNG_DASHLENGTH},
	//    { NULL, PNG_OTHER }
	//};
	//
	///#undef MAXLINEWIDTH
	///#define MAXLINEWIDTH 100
	//static double PNG_linewidth_factor = 1.0;
	//static double PNG_dashlength_factor = 1.0;
	//
	// /* EAM - gdImage structure to hold brushes for linewidth */
	// /* We will allocate and initialize these on demand */
	//typedef struct {
	//    gdImagePtr im;
	//    unsigned int last_rgb;
	//    int bgnd;
	//    int fgnd;
	//}   PNG_BRUSH;
	//
	//static PNG_BRUSH *PNG_brush[MAXLINEWIDTH+1];
	//
	//typedef struct {
	//    gdImagePtr im;
	//    unsigned int last_rgb;
	//    int fillpar;
	//}   PNG_FILL_TILE;
	//
	//static PNG_FILL_TILE PNG_fill_tile = { (gdImagePtr)0, 0, 0 };
	//
	// /* To be used with libgd 2.0.34 to request Symbol encoding */
	///#ifdef gdFTEX_Adobe_Custom
	//static gdFTStringExtra PNG_FONT_INFO = {0,0,0,0,0,NULL,NULL};
	///#endif
	//
	///#if defined(WIN32) && !defined(NONDLL)
	//static void 
	//gp_gdImagePolygon(gdImagePtr im, gdPointPtr p, int n, int c)
	//{
	//    gdImagePolygon(im, p, n, c);
	//}
	//
	//static void 
	//gp_gdImageFilledPolygon(gdImagePtr im, gdPointPtr p, int n, int c)
	//{
	//    gdImageFilledPolygon(im, p, n, c);
	//}
	///#endif
	//
	//
	// /* Common code to crop the image around its bounding box, just before writing
	//    down the file.
	// */
	//static void
	//image_do_crop ()
	//{
	//    if (png_state.flags & PNG_USE_CROP) {
	//	int x, y, x1, y1, x2, y2, flag;
	//	int bg = png_state.color_table[0]; // index of the background color 
	//	gdImagePtr im_crop;
	//	for (flag=0, x1=0; x1 < gdImageSX(png_state.image)-1; x1++) {
	//	    for (y=0; y < gdImageSY(png_state.image); y++)
	//		if (gdImageGetPixel(png_state.image, x1, y) != bg) { flag = 1; break; }
	//	    if (flag) break;
	//	}
	//	for (flag=0, x2=gdImageSX(png_state.image)-1; x2 >= x1; x2--) {
	//	    for (y=0; y < gdImageSY(png_state.image); y++)
	//		if (gdImageGetPixel(png_state.image, x2, y) != bg) { flag = 1; break; }
	//	    if (flag) break;
	//	}
	//	for (flag=0, y1=0; y1 < gdImageSY(png_state.image)-1; y1++) {
	//	    for (x=x1; x <= x2; x++)
	//		if (gdImageGetPixel(png_state.image, x, y1) != bg) { flag = 1; break; };
	//	    if (flag) break;
	//	}
	//	for (flag=0, y2=gdImageSY(png_state.image)-1; y2 >= y1; y2--) {
	//	    for (x=x1; x <= x2; x++)
	//		if (gdImageGetPixel(png_state.image, x, y2) != bg) { flag = 1; break; };
	//	    if (flag) break;
	//	}
	//	x = x2 - x1 + 1; // width 
	//	y = y2 - y1 + 1; // height 
	///#if (GD2_VERS >= 2)
	//	if (png_state.TrueColor)
	//	    im_crop = gdImageCreateTrueColor(x,y);
	//	else
	//	    im_crop = gdImageCreate(x,y);
	//	if (!im_crop) {
	//	    int_warn(NO_CARET,"libgd: failed to create cropped image structure");
	//	    return;
	//	}
	//	bg = gdImageColorAllocateAlpha(im_crop,255,255,255,127);
	///#else
	//	im_crop = gdImageCreate(x,y);
	///#endif
	//
	//	gdImagePaletteCopy(im_crop, png_state.image);
	//	if (png_state.flags & PNG_USE_TRANSPARENT) {
	//	    gdImageColorTransparent(im_crop, bg);
	// /* WARNING: This is a work-around for strangeness in libgd,  */
	// /* which doesn't copy transparent pixels in TrueColor images. */
	//	    if (png_state.TrueColor)
	//		gdImageColorTransparent(png_state.image, -1);
	//	} else
	//	    gdImageColorTransparent(im_crop, -1);
	//
	//	gdImageCopy(im_crop, png_state.image, 0, 0, x1, y1, x, y);
	//	gdImageDestroy(png_state.image);
	//	png_state.image = im_crop;
	//    }
	//}
	//
	//
	//static int PNG_FillSolid __PROTO((int fillpar));
	//static int PNG_FillPattern __PROTO((int fillpar));
	//static int PNG_FillTransparent __PROTO((int fillpar));
	//
	//static int
	//PNG_FillSolid(int fillpar)
	//{
	//    int red   = (png_state.rgb >> 16) & 0xff;
	//    int green = (png_state.rgb >> 8) & 0xff;
	//    int blue  = png_state.rgb & 0xff;
	//
	//    double fact = (double)(100 - fillpar) * 0.01;
	//
	//    int color;
	//
	//    if (fact <= 0 || fact >= 1.0)
	//	return png_state.color;
	//
	//    red   += (0xff - red) * fact;
	//    green += (0xff - green) * fact;
	//    blue  += (0xff - blue) * fact;
	//
	//    color = gdImageColorExact(png_state.image, red, green, blue);
	//    if (color < 0) {
	//	color = gdImageColorAllocate(png_state.image, red, green, blue);
	//    }
	//    if (color < 0) {
	//	color = gdImageColorClosest(png_state.image, red, green, blue);
	//    }
	//
	//    return color;
	//}
	//
	//static int
	//PNG_FillTransparent(int fillpar)
	//{
	//    int red   = (png_state.rgb >> 16) & 0xff;
	//    int green = (png_state.rgb >> 8) & 0xff;
	//    int blue  = png_state.rgb & 0xff;
	//    int alpha = 127 * (float)(100-fillpar) / 100.;
	//
	//    return  gdImageColorExactAlpha(png_state.image, red, green, blue, alpha);
	//}
	//
	//static int
	//PNG_FillPattern(int style)
	//{
	//    int rgb = png_state.rgb;
	//    int brgb = png_state.rgb_table[0];
	//    int fillpar = (style >> 4) % 8;
	//    style = style & 0xf;
	//
	//    if (!PNG_fill_tile.im || rgb != PNG_fill_tile.last_rgb || PNG_fill_tile.fillpar != fillpar) {
	//
	//	int foreground, background;
	//
	//	if (PNG_fill_tile.im) {
	//	    gdImageDestroy(PNG_fill_tile.im);
	//	    PNG_fill_tile.im = (gdImagePtr)0;
	//	}
	//
	// /* save new values */
	//	PNG_fill_tile.fillpar = fillpar;
	//	PNG_fill_tile.last_rgb = rgb;
	//
	// /* create new tile */
	//	if (!((PNG_fill_tile.im = gdImageCreate(8, 8))))
	//	    int_error(NO_CARET,"libgd: failed to create pattern-fill tile");
	//
	//	background = gdImageColorAllocate(PNG_fill_tile.im,
	//		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff);
	//	if (style == FS_TRANSPARENT_PATTERN)
	//	    gdImageColorTransparent(PNG_fill_tile.im, background);
	//	gdImageFilledRectangle(PNG_fill_tile.im, 0, 0, 7, 7, background);
	//
	// /* foreground */
	//	foreground = gdImageColorAllocate(PNG_fill_tile.im,
	//		(rgb >> 16) & 0xff, (rgb >> 8) & 0xff, rgb & 0xff);
	//
	//	switch (fillpar) {
	//	    case 0: // no fill 
	//	    default:
	//		break;
	//	    case 1: // cross-hatch 
	//		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 6, 6, 0, foreground);
	//		break;
	//	    case 2: // double cross-hatch 
	//		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 6, 6, 0, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 2, 2, 0, foreground);
	//		gdImageLine(PNG_fill_tile.im, 7, 3, 3, 7, foreground);
	//		gdImageLine(PNG_fill_tile.im, 4, 0, 7, 3, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 4, 3, 7, foreground);
	//		break;
	//	    case 3: // solid 
	//		gdImageFilledRectangle(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
	//		break;
	//	    case 4:
	//		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
	//		break;
	//	    case 5:
	//		gdImageLine(PNG_fill_tile.im, 0, 7, 7, 0, foreground);
	//		break;
	//	    case 6:
	//		gdImageLine(PNG_fill_tile.im, 0, 0, 3, 7, foreground);
	//		gdImageLine(PNG_fill_tile.im, 4, 0, 7, 7, foreground);
	//		break;
	//	    case 7:
	//		gdImageLine(PNG_fill_tile.im, 0, 7, 3, 0, foreground);
	//		gdImageLine(PNG_fill_tile.im, 4, 7, 7, 0, foreground);
	//		break;
	//	    case 8:
	//		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 3, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 4, 7, 7, foreground);
	//		break;
	//	    case 9:
	//		gdImageLine(PNG_fill_tile.im, 0, 3, 7, 0, foreground);
	//		gdImageLine(PNG_fill_tile.im, 0, 7, 7, 4, foreground);
	//		break;
	//	}
	//    }
	//
	//    gdImageSetTile(png_state.image, PNG_fill_tile.im);
	//    return (int)gdTiled;
	//}
	//
	//static void
	//PNG_PointX(unsigned int x, unsigned int y)
	//{
	//    gdImageLine(png_state.image, x - PNG_ps, y - PNG_ps,
	//	    x + PNG_ps, y + PNG_ps, png_state.color);
	//    gdImageLine(png_state.image, x + PNG_ps, y - PNG_ps,
	//	    x - PNG_ps, y + PNG_ps, png_state.color);
	//}
	//
	//static void
	//PNG_PointPlus(unsigned int x, unsigned int y)
	//{
	//    gdImageLine(png_state.image, x - PNG_ps, y,
	//	    x + PNG_ps, y, png_state.color);
	//    gdImageLine(png_state.image, x, y - PNG_ps,
	//	    x, y + PNG_ps, png_state.color);
	//}
	//
	//static void
	//PNG_Triangle(
	//    unsigned int x, unsigned int y,
	//    int direction,
	//    void (*draw_func)(gdImagePtr, gdPointPtr, int, int))
	//{
	//    int delta  = (int)((1.33 * (double)PNG_ps) + 0.5);
	//    int delta_ = (int)((0.67 * (double)PNG_ps) + 0.5);
	//
	//    gdPoint points[4];
	//    points[0].x = x;
	//    points[0].y = y - direction * delta;
	//    points[1].x = x - delta;
	//    points[1].y = y + direction * delta_;
	//    points[2].x = x + delta;
	//    points[2].y = y + direction * delta_;
	//    points[3].x = points[0].x;
	//    points[3].y = points[0].y;
	//    draw_func(png_state.image, points, 4, png_state.color);
	//}
	//
	//static void
	//PNG_Diamond(
	//    unsigned int x, unsigned int y,
	//    void (*draw_func)(gdImagePtr, gdPointPtr, int, int))
	//{
	//    gdPoint points[5];
	//    points[0].x = x;
	//    points[0].y = y - PNG_ps;
	//    points[1].x = x + PNG_ps;
	//    points[1].y = y;
	//    points[2].x = x;
	//    points[2].y = y + PNG_ps;
	//    points[3].x = x - PNG_ps;
	//    points[3].y = y;
	//    points[4].x = points[0].x;
	//    points[4].y = points[0].y;
	//    draw_func(png_state.image, points, 5, png_state.color);
	//}
	//
	// /*
	//  * _options()  Called when terminal type is selected.
	//  * This procedure should parse options on the command line.  A list of the
	//  * currently selected options should be stored in term_options[] in a form
	//  * suitable for use with the set term command.  term_options[] is used by
	//  * the save command.  Use options_null() if no options are available.
	//  */
	//TERM_PUBLIC void
	//PNG_options()
	//{
	//    int i;
	//    char *string;
	//    unsigned long color;
	//    TBOOLEAN new_colors = FALSE;
	//    TBOOLEAN gif_anim_option = FALSE; // set to TRUE if an animated gif option given 
	//
	//    if (!PNG_initialized) {
	//	PNG_initialized = TRUE;
	//	term_options[0] = '\0';
	//	term->h_char = PNG_HCHAR; // Default to medium font 
	//	png_state.default_font = gdfont;
	//	png_state.n_colors = 0;
	//	png_state.flags = 0;
	//	png_state.use_builtin = FALSE;
	//	png_state.ttffont = NULL;
	//	png_state.default_ttffont = NULL;
	//	png_state.default_ttfsize = 0;
	//	png_state.justify = CENTRE;
	//	png_state.TrueColor = FALSE;
	//	PNG_linewidth_factor = 1.0;
	//	PNG_dashlength_factor = 1.0;
	//	png_state.capbutt = FALSE; // to preserve previous default behavior 
	///#ifdef GD_NEED_LOCAL_FONT_POINTERS
	//	gdFontSmall = gdFontGetSmall();
	//	gdFontLarge = gdFontGetLarge();
	//	gdFontMediumBold = gdFontGetMediumBold();
	//	gdFontGiant = gdFontGetGiant();
	//	gdFontTiny = gdFontGetTiny();
	///#endif
	//    } else {
	// /* FIXME EAM - these should never happen! */
	//	if (!png_state.default_font) {
	//	    fprintf(stderr,"gd.trm: caught initialization error\n");
	//	    png_state.default_font = gdfont;
	//	}
	//    }
	//
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we are already in animation mode.                          */
	//    if (c_token == 2)
	//	FPRINTF((stderr,"gif: Maintaining animation state\n"));
	//    else {
	// /* Otherwise reset animation parameters */
	//	if (png_state.previous_image)
	//	    gdImageDestroy(png_state.previous_image);
	//	png_state.animate = FALSE;
	//	png_state.previous_image = NULL;
	//	png_state.frame_optimization = FALSE;
	//	png_state.loop_count = 0;
	// /* And default font size */
	//	term->h_char = PNG_HCHAR;
	//	png_state.default_ttfsize = 0;
	//	PNG_linewidth_factor = 1.0;
	//	PNG_dashlength_factor = 1.0;
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&PNG_opts[0],c_token)) {
	//	case PNG_TRANSPARENT:
	//	    png_state.flags |= PNG_USE_TRANSPARENT;
	//	    ++c_token;
	//	    break;
	//	case PNG_NOTRANSPARENT:
	//	    png_state.flags &= ~PNG_USE_TRANSPARENT;
	//	    ++c_token;
	//	    break;
	//	case PNG_INTERLACE:
	//	    png_state.flags |= PNG_USE_INTERLACE;
	//	    ++c_token;
	//	    break;
	//	case PNG_NOINTERLACE:
	//	    png_state.flags &= ~PNG_USE_INTERLACE;
	//	    ++c_token;
	//	    break;
	//	case PNG_CROP:
	//	    png_state.flags |= PNG_USE_CROP;
	//	    ++c_token;
	//	    break;
	//	case PNG_NOCROP:
	//	    png_state.flags &= ~PNG_USE_CROP;
	//	    ++c_token;
	//	    break;
	//
	///#ifdef HAVE_GD_TTF
	///#define UNSET_TTF_FONT 	    free(png_state.ttffont); 	    png_state.ttffont = NULL; 	    png_state.default_ttfsize = 2 * term->h_char - 2; 	    png_state.use_builtin = TRUE;
	//ignore
	//ignore
	//ignore
	//ignore
	///#else
	///#define UNSET_TTF_FONT 	    ; 
	//ignore
	///#endif
	//
	//	case PNG_TINY:
	//	    png_state.default_font=gdFontTiny;
	//	    term->v_char = png_state.default_font->h;
	//	    term->h_char = png_state.default_font->w;
	//	    ++c_token;
	//	    UNSET_TTF_FONT;
	//	    break;
	//	case PNG_SMALL:
	//	    png_state.default_font = gdFontSmall;
	//	    term->v_char = png_state.default_font->h;
	//	    term->h_char = png_state.default_font->w;
	//	    ++c_token;
	//	    UNSET_TTF_FONT;
	//	    break;
	//	case PNG_MEDIUM:
	//	    png_state.default_font = gdFontMediumBold;
	//	    term->v_char = png_state.default_font->h;
	//	    term->h_char = png_state.default_font->w;
	//	    ++c_token;
	//	    UNSET_TTF_FONT;
	//	    break;
	//	case PNG_LARGE:
	//	    png_state.default_font = gdFontLarge;
	//	    term->v_char = png_state.default_font->h;
	//	    term->h_char = png_state.default_font->w;
	//	    ++c_token;
	//	    UNSET_TTF_FONT;
	//	    break;
	//	case PNG_GIANT:
	//	    png_state.default_font=gdFontGiant;
	//	    term->v_char = png_state.default_font->h;
	//	    term->h_char = png_state.default_font->w;
	//	    ++c_token;
	//	    UNSET_TTF_FONT;
	//	    break;
	//
	//	case PNG_FONT:
	//	    c_token++;
	///#ifdef HAVE_GD_TTF
	//	    if (END_OF_COMMAND) {
	//		free(png_state.ttffont);
	//		png_state.ttffont = NULL;
	//		png_state.default_ttfsize = 0;
	//	    } else {
	//		int brect[8];
	//		char *err;
	//
	//		if (isstringvalue(c_token)) {
	//		    char *s = try_to_get_string();
	//		    char *comma = strrchr(s,',');
	//		    double fontsize;
	//		    if (comma && (1 == sscanf(comma+1,"%lf",&fontsize))) {
	//			png_state.default_ttfsize = (int)(fontsize+0.5);
	//			png_state.ttfsize = png_state.default_ttfsize;
	//			*comma = '\0';
	//		    }
	//		    if (*s) {
	//			free(png_state.ttffont);
	//			png_state.ttffont = s;
	//		    } else {
	//			continue;
	//		    }
	//		} else {
	//		    free(png_state.ttffont);
	//		    png_state.ttffont = gp_alloc(token_len(c_token)+1,"new font");
	//		    copy_str(png_state.ttffont, c_token, token_len(c_token)+1);
	//		    c_token++;
	//		}
	//		free(png_state.default_ttffont);
	//		png_state.default_ttffont = gp_strdup(png_state.ttffont);
	//
	// /* First try the old GDFONTPATH mechanism for locating fonts */
	//		(void)gdUseFontConfig(0);
	//		err = gdImageStringFT(NULL, &brect[0], 0,
	//			png_state.ttffont, (double)png_state.default_ttfsize,
	//			0.0, 0, 0, "test");
	//	
	// /* If that didn't work, try again using the fontconfig mechanism */
	//		if (err && gdUseFontConfig(1)) {
	//		    err = gdImageStringFT(NULL, &brect[0], 0,
	//			png_state.ttffont, (double)png_state.default_ttfsize,
	//			0.0, 0, 0, "test");
	//		}
	//
	// /* If we still haven't found the font, punt to the internal non-TTF default set */
	//		if (err) {
	//		    fprintf(stderr, "%s when opening font %s, trying default\n",
	//				err, png_state.ttffont);
	//		    free(png_state.ttffont);
	//		    free(png_state.default_ttffont);
	//		    png_state.ttffont = NULL;
	//		    png_state.default_ttffont = NULL;
	//		}
	//
	//	    }
	///#else
	//	    c_token++;
	//	    fprintf(stderr,"No TTF font support, using internal non-scalable font\n");
	///#endif
	//	    break;
	///#undef UNSET_TTF_FONT
	//
	//	case PNG_SIZE:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		PNG_XMAX = GREG_XMAX;
	//		PNG_YMAX = GREG_YMAX;
	//	    } else {
	//		PNG_XMAX = real_expression();
	//		if (equals(c_token, ",")) {
	//		    c_token++;
	//		    PNG_YMAX = real_expression();
	//		}
	//		if (PNG_XMAX < 0)
	//		    PNG_XMAX = GREG_XMAX;
	//		if (PNG_YMAX < 0)
	//		    PNG_YMAX = GREG_YMAX;
	//	    }
	//	    term->ymax = PNG_YMAX;
	//	    term->xmax = PNG_XMAX;
	// /* EAM Apr 2003 - same tic size on both x and y axes */
	//	    term->v_tic = (PNG_XMAX < PNG_YMAX) ? PNG_XMAX/100 : PNG_YMAX/100;
	//	    if (term->v_tic < 1)
	//		term->v_tic = 1;
	//	    term->h_tic = term->v_tic;
	//	    break;
	//	case PNG_ENHANCED:
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    term->put_text = ENHGD_put_text;
	//	    ++c_token;
	//	    break;
	//	case PNG_NOENHANCED:
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    term->put_text = PNG_put_text;
	//	    ++c_token;
	//	    break;
	//	case PNG_TRUECOLOR:
	//	    png_state.TrueColor = TRUE;
	//	    term->flags |= TERM_ALPHA_CHANNEL;
	//	    c_token++;
	//	    break;
	//	case PNG_NOTRUECOLOR:
	//	    png_state.TrueColor = FALSE;
	//	    term->flags &= ~TERM_ALPHA_CHANNEL;
	//	    c_token++;
	//	    break;
	//	case PNG_LINEWIDTH:
	//	    c_token++;
	//	    PNG_linewidth_factor = real_expression();
	//	    if (PNG_linewidth_factor < 0)
	//		PNG_linewidth_factor = 1.0;
	//	    break;
	//	case PNG_DASHLENGTH:
	//	    c_token++;
	//	    PNG_dashlength_factor = real_expression();
	//	    if (PNG_dashlength_factor <= 0.2)
	//		PNG_dashlength_factor = 1.0;
	//	    break;
	//
	// /* parse gif animation options */
	//	case GIF_ANIMATE:
	//	    if (strncmp("gif",term->name,3))
	//		int_error(c_token,"Only the gif terminal supports animation");
	//	    c_token++;
	//	    png_state.animate = TRUE;
	//	    png_state.frame_count = 0;
	//	    png_state.frame_delay = 10;
	//	    png_state.frame_optimization = FALSE;
	//	    gif_anim_option = 1;
	//	    break;
	//	case GIF_DELAY:
	//	    if (strncmp("gif",term->name,3))
	//		int_error(c_token,"Only the gif terminal supports animation");
	//	    c_token++;
	//	    png_state.frame_delay = int_expression();
	//	    if (png_state.frame_delay <= 0)
	//		png_state.frame_delay = 10;
	//	    gif_anim_option = 1;
	//	    break;
	//	case GIF_LOOP:
	//	    if (strncmp("gif",term->name,3))
	//		int_error(c_token,"Only the gif terminal supports animation");
	//	    c_token++;
	//	    png_state.loop_count = int_expression();
	//	    gif_anim_option = 1;
	//	    break;
	//	case GIF_NOOPT:
	//	    if (strncmp("gif",term->name,3))
	//		int_error(c_token,"Only the gif terminal supports animation");
	//	    c_token++;
	//	    png_state.frame_optimization = FALSE;
	//	    gif_anim_option = 1;
	//	    break;
	//	case GIF_OPT:
	//	    if (strncmp("gif",term->name,3))
	//		int_error(c_token,"Only the gif terminal supports animation");
	//	    c_token++;
	//	    png_state.frame_optimization = TRUE;
	//	    gif_anim_option = 1;
	//	    break;
	//
	//	case PNG_BUTT:
	//	    png_state.capbutt = TRUE;
	//	    c_token++;
	//	    break;
	//
	//	case PNG_ROUNDED:
	//	    png_state.capbutt = FALSE;
	//	    c_token++;
	//	    break;
	//
	//	case PNG_OTHER:
	//	default:
	// /* not "size" */
	//	    string = gp_input_line + token[c_token].start_index;
	//
	///#ifdef HAVE_GD_TTF
	// /* Check for explicit TTF font size */
	//	    if (sscanf(string, "%d", &i) == 1) {
	//		if (i > 0 && i < 999)
	//		    png_state.default_ttfsize = i;
	//		else
	//		    int_warn(c_token,"illegal font size");
	//		++c_token;
	//	        break;
	//	    }
	///#endif
	//
	//	    if (sscanf(string, "x%lx", &color) != 1) {
	//		int_error(c_token, "invalid color spec, must be xRRGGBB");
	//	    } else if (png_state.n_colors == PNG_MAX_COLORS && new_colors) {
	//		int_warn(c_token, "too many colors, ignoring");
	//		++c_token;
	//	    } else {
	//	        if (!new_colors) {
	//		    new_colors = TRUE;
	//		    png_state.n_colors = 0;
	//		}
	//		png_state.rgb_table[png_state.n_colors++] = color;
	//		++c_token;
	//	    }
	//	    break;
	//	}
	//    }
	//
	///#ifndef GIF_ANIMATION // animated gifs not supported by the current GD library 
	//    if (gif_anim_option) {
	//	png_state.animate = FALSE;
	//	int_warn(NO_CARET, "gif animation options ignored (not compiled into this binary)");
	//    }
	///#endif
	//
	///#ifdef HAVE_GD_TTF
	// /* If no font has been chosen but there is a default, use it */
	//    if (!png_state.ttffont && !png_state.use_builtin) {
	//	char *external_default = getenv("GNUPLOT_DEFAULT_GDFONT");
	//	int brect[8];
	//	char *err;
	//
	//	if (external_default)
	//		png_state.ttffont = gp_strdup(external_default);
	//	else	// Might as well try some plausible font; it's no worse than failing immediately 
	//		png_state.ttffont = gp_strdup("arial");
	//
	//	free(png_state.default_ttffont);
	//	png_state.default_ttffont = gp_strdup(png_state.ttffont);
	//	if (png_state.default_ttfsize == 0)
	//		png_state.default_ttfsize = 2 * term->h_char - 2;
	//
	// /* First try the old GDFONTPATH mechanism for locating fonts */
	//	(void)gdUseFontConfig(0);
	//	err = gdImageStringFT(NULL, &brect[0], 0,
	//		png_state.ttffont, (double)png_state.default_ttfsize,
	//		0.0, 0, 0, "test");
	//
	// /* If that didn't work, try again using fontconfig mechanism */
	//	if (err && gdUseFontConfig(1)) {
	//	    err = gdImageStringFT(NULL, &brect[0], 0,
	//		png_state.ttffont, (double)png_state.default_ttfsize,
	//		0.0, 0, 0, "test");
	//	}
	//
	// /* If we still haven't found the font, punt to the internal non-TTF default set */
	//	if (err) {
	//		fprintf(stderr,"%s when opening font \"%s\", using internal non-scalable font\n",
	//			err, png_state.ttffont);
	//		free(png_state.ttffont);
	//		free(png_state.default_ttffont);
	//		png_state.ttffont = NULL;
	//		png_state.default_ttffont = NULL;
	//	}
	//
	//    }
	//
	// /* If no explicit TTF font size found, generate default */
	//    if (png_state.default_ttfsize == 0)
	//	png_state.default_ttfsize = 2 * term->h_char - 2;
	//    png_state.ttfsize = png_state.default_ttfsize;
	//
	// /* Find approximate character width of selected TTF font   */
	// /* This is needed in order to set appropriate border width */
	//    if (png_state.default_ttffont) {
	//	int brect[8];
	//	char *err;
	//	err = gdImageStringFT(NULL, &brect[0], 0,
	//		png_state.default_ttffont, (double)png_state.default_ttfsize,
	//		0.0, 0, 0, "f00000000g");
	//	if (!err) {
	//	    term->h_char = .11 * (float)(brect[2] - brect[0]) + 0.5;
	//	    term->v_char = 1.1 * (float)(brect[1] - brect[7]) + 0.5;
	//	}
	//    }
	///#endif
	//
	// /* This code is shared by png, gif, and jpeg terminal types */
	//    if (!strcmp(term->name,"jpeg"))
	//	png_state.flags &= ~PNG_USE_TRANSPARENT;
	//
	// /* now generate options string */
	//
	//    if (png_state.flags & PNG_USE_TRANSPARENT) {
	//	strcat(term_options, "transparent ");
	//    }
	//    if (png_state.flags & PNG_USE_INTERLACE) {
	//	strcat(term_options, "interlace ");
	//    }
	// /* JPEG files are always 24-bit color */
	//    if (strcmp(term->name, "jpeg") == 0) {
	//	png_state.TrueColor = TRUE;
	//	term->flags |= TERM_ALPHA_CHANNEL;
	//    } else if (png_state.TrueColor) {
	//	strcat(term_options, "truecolor ");
	//    }
	//    if (!(png_state.flags & PNG_USE_CROP)) {
	//	strcat(term_options, "no");
	//    }
	//    strcat(term_options, "crop ");
	//
	//    if (term->flags & TERM_ENHANCED_TEXT) {
	//	strcat(term_options, "enhanced ");
	//    }
	//
	//    if (png_state.ttffont) {
	//	sprintf(term_options + strlen(term_options),
	//		"font %s %d ", png_state.ttffont, png_state.ttfsize);
	//    } else switch (term->h_char) {
	//    case 5:
	//	strcat(term_options,"tiny ");
	//	break;
	//    case 6:
	//	strcat(term_options, "small ");
	//	break;
	//    case 7:
	//    default:
	//	strcat(term_options, "medium ");
	//	break;
	//    case 8:
	//	strcat(term_options, "large ");
	//	break;
	//    case 9:
	//	strcat(term_options,"giant ");
	//	break;
	//    }
	//
	//    if (PNG_linewidth_factor != 1.0)
	//	sprintf(term_options + strlen(term_options),
	//	    "linewidth %3.1f ", PNG_linewidth_factor);
	//
	//    if (PNG_dashlength_factor != 1.0)
	//	sprintf(term_options + strlen(term_options),
	//	    "dashlength %3.1f ", PNG_dashlength_factor);
	//
	//    if (png_state.capbutt) {
	//	sprintf(term_options + strlen(term_options),
	//	    "butt ");
	//    }
	//
	//    if (png_state.animate) {
	//	sprintf(term_options + strlen(term_options),
	//	    "animate delay %d loop %d %soptimize ", 
	//	    png_state.frame_delay, png_state.loop_count,
	//	    png_state.frame_optimization ? "" : "no");
	//    }
	//
	//    sprintf(term_options + strlen(term_options),
	//	    "size %d,%d ", PNG_XMAX, PNG_YMAX);
	//
	//    if (new_colors)
	//	for (i = 0; strlen(term_options) + 9 < MAX_LINE_LEN &&
	//	     i < png_state.n_colors; i++) {
	//	    sprintf(term_options + strlen(term_options),
	//		"x%06x ", png_state.rgb_table[i]);
	//	}
	//}
	//
	//
	// /*
	//  * _init()  Called once, when the device is first selected.  This procedure
	//  * should set up things that only need to be set once, like handshaking and
	//  * character sets etc...
	//  */
	//TERM_PUBLIC void
	//PNG_init()
	//{
	//int i;
	//
	//    png_state.linetype = 0;
	//    png_state.linewidth = 1;
	//
	// /* Clear brush array, then initialize a few small ones */
	//    for (i=2; i<=MAXLINEWIDTH; i++)
	//	PNG_brush[i] = NULL;
	//}
	//
	// /*
	//  * Internal helper routine to initialize brushes used for stroking linewidth > 1
	//  */
	//static void
	//PNG_init_brush(int width)
	//{
	//    PNG_BRUSH *brush = PNG_brush[width];
	//
	//    if (!brush) {
	//	brush = gp_alloc(sizeof(PNG_BRUSH),"gd brush");
	//	PNG_brush[width] = brush;
	//	brush->last_rgb = -99;  // Something invalid 
	//	if (!((brush->im = gdImageCreate(width,width))))
	//	    int_error(NO_CARET,"libgd: failed to create brush structure");
	//	brush->bgnd = gdImageColorAllocate( brush->im, 255, 255, 255 );
	//	gdImageFill(brush->im, 0, 0, brush->bgnd);
	//	gdImageColorTransparent(brush->im, brush->bgnd);
	//    }
	//
	//    if (png_state.color != brush->last_rgb) {
	//	brush->fgnd = gdImageColorResolve(brush->im,
	//	    gdImageRed(png_state.image,png_state.color),
	//	    gdImageGreen(png_state.image,png_state.color),
	//	    gdImageBlue(png_state.image,png_state.color) );
	//	brush->last_rgb = png_state.color;
	//
	// /* EAM - quick and dirty is to fill the entire brush (square nib)  */
	// /* It might be better to approximate a circular nib by selectively */
	// /* coloring the individual pixels of the brush image.          	   */
	//	gdImageFilledRectangle(brush->im, 0, 0, width-1, width-1, brush->fgnd);
	//    }
	//}
	//
	// /*
	//  * _reset()  Called when gnuplot is exited, the output device changed or
	//  * the terminal type changed.  This procedure should reset the device,
	//  * possibly flushing a buffer somewhere or generating a form feed.
	//  */
	//TERM_PUBLIC void
	//PNG_reset()
	//{
	//    int i;
	// /* EAM - Clean up the brushes used for linewidth */
	//    for (i=2; i<=MAXLINEWIDTH; i++) {
	//	if (PNG_brush[i]) {
	//	    if (PNG_brush[i]->im)
	//		gdImageDestroy(PNG_brush[i]->im);
	//	    PNG_brush[i] = NULL;
	//	}
	//    }
	//    if (PNG_fill_tile.im) {
	//	gdImageDestroy(PNG_fill_tile.im);
	//	PNG_fill_tile.im = (gdImagePtr)0;
	//    }
	///#ifdef GIF_ANIMATION
	//    if (png_state.animate) {
	//	gdImageGifAnimEnd(gpoutfile);
	//	png_state.frame_count = 0;
	//	png_state.animate = FALSE;
	//	fprintf(stderr,"End of animation sequence\n");
	//    }
	///#endif
	//}
	//
	///#if 0
	// /* use  #if 1  that's just for debugging */
	//void
	//PNG_show_current_palette()
	//{
	//    int i;
	//
	//    fprintf(stderr, "*****\n SHOW THE PALETTE! total=%i\n",
	//	    gdImageColorsTotal(png_state.image));
	//    for (i=0; i < gdImageColorsTotal(png_state.image); i++) {
	// /* Use access macros to learn colors. */
	//	fprintf(stderr, "%i\tr=%d\t g=%d\tb=%d\n",
	//		i,
	//		gdImageRed(png_state.image,i),
	//		gdImageGreen(png_state.image,i),
	//		gdImageBlue(png_state.image,i));
	//    }
	//}
	///#endif
	//
	// /*
	// How this works: Gray interval [0;1] will be mapped to interval
	// [0;sm_palette.colors-1] those r,g,b components are mapped by the array
	// below palette.offset equals 0 since png_smooth_color[0..colors] are
	// from ColorAllocate
	// */
	//static int png_smooth_color[gdMaxColors];
	//
	///#ifdef PASTEL_PALETTE
	// /*
	//  * This is only needed in order to maintain png_state_rgb for fillstyle variants,
	//  * and only for palette-based coloring. It doesn't seem worth the space or effort.
	//  * EAM November 2004
	//  */
	//static int png_smooth_rgb[gdMaxColors];
	///#endif
	//
	// /* TODO: how to recover from a multiplot with two colour pm3d maps?
	//    They must use the same palette! Or palette size must be
	//    restricted to certain number of colours---a new user's option
	// */
	//
	//TERM_PUBLIC int PNG_make_palette (t_sm_palette *palette)
	//{
	//    int i;
	//    if (palette == NULL) {
	// /* If the output format is TrueColor there in no color limit */
	//	if (png_state.TrueColor)
	//	    return(0);
	//
	// /* return maximal number of colours in a PNG palette */
	//	i = gdMaxColors //256
	// - gdImageColorsTotal(png_state.image);
	// /* the latter is the number of currently allocated colours. We want
	//    to allocate the rest */
	// /*BACK PLEASE  fprintf(stderr,"colors in PNG palette=%i\n",(int)gdMaxColors); */
	//	if (i == 0) {
	//	    i = (sm_palette.colors <= 0) ? -1 : sm_palette.colors;
	// /* (no more colorus) : (previous palette (obviously multiplot mode)) */
	///#if 0
	//	    if (i > 0) fprintf(stderr,"reusing it again\n");
	///#endif
	//	}
	//	return i;
	//    }
	//    if (0 == gdMaxColors //256
	// - gdImageColorsTotal(png_state.image))
	//	return 0; // reuse previous palette (without warning) 
	//    for (i = 0; i < sm_palette.colors; i++) {
	//	png_smooth_color[i] = gdImageColorAllocate(png_state.image,
	//	    (int)( palette->color[i].r * 255 + 0.5 ), // r,g,b values for png 
	//	    (int)( palette->color[i].g * 255 + 0.5 ), // terminal are [0;255] 
	//	    (int)( palette->color[i].b * 255 + 0.5 ) );
	///#ifdef PASTEL_PALETTE
	//	png_smooth_rgb[i] = (((int)(palette->color[i].r * 255.) & 0xff) << 16)
	//	                  + (((int)(palette->color[i].g * 255.) & 0xff) << 8)
	//			  +  ((int)(palette->color[i].b * 255.) & 0xff);
	///#endif
	//	if (png_smooth_color[i] < 0) { // this should never happen! take away? 
	//	    FPRINTF((stderr,"png_smooth_color[i]<0 cannot happen"));
	//	    exit(1);
	//	}
	///#if 0
	//	fprintf(stderr,"ALLOCATED: i=%i\t=> pal_index=%i\tr=%g g=%g b=%g\n",
	//	    i, png_smooth_color[i],
	//	    palette->color[i].r, palette->color[i].g, palette->color[i].b );
	///#endif
	//    }
	//    return 0;
	//}
	//
	//
	//TERM_PUBLIC
	//void PNG_set_color (t_colorspec *colorspec)
	//{
	//    double gray = colorspec->value;
	//
	//    if (colorspec->type == TC_LT) {
	//	int savetype = png_state.linetype;
	//	PNG_linetype(colorspec->lt);
	// /* Harmless now; will be needed if we ever support dot/dash */
	//	png_state.linetype = savetype;
	//    }
	//
	//    if (colorspec->type == TC_RGB) {
	//	png_state.rgb = colorspec->lt;
	//	png_state.color = gdImageColorResolve(png_state.image,
	//	    colorspec->lt >> 16, (colorspec->lt >> 8) & 0xff, colorspec->lt & 0xff);
	//    }
	//
	//    if (colorspec->type != TC_FRAC)
	//	return;
	//
	//    if (png_state.TrueColor) {
	//	rgb255_color color;
	//	rgb255maxcolors_from_gray(gray, &color);
	//	png_state.color = gdImageColorResolve(png_state.image,
	//	    (int)color.r, (int)color.g, (int)color.b);
	//	png_state.rgb = (color.r << 16) + (color.g << 8) +color.b;
	//	return;
	//    } else {
	//	int png_color = (gray <= 0) ? 0 : (int)(gray * sm_palette.colors);
	//	if (png_color >= sm_palette.colors)
	//	    png_color = sm_palette.colors - 1;
	// /* map [0;1] to interval [0;png_smooth_colors-1] */
	//	png_state.color = png_smooth_color[ png_color ];
	///#ifdef PASTEL_PALETTE
	//	png_state.rgb = png_smooth_rgb[ png_color ];
	///#endif
	//    }
	//}
	//
	//TERM_PUBLIC
	//void PNG_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int i;
	//    int fillpar = corners->style >> 4;
	//    int color = png_state.color;
	//    
	// /* since gpiPoint carries more than just x and y if
	//  * we have EXTENDED_COLOR_SPECS defined, we need to
	//  * copy it to the gdPointPtr struct; make it static
	//  * so that is faster (joze) */
	//    static gdPointPtr gd_corners = (gdPointPtr) 0;
	//    static unsigned int size = 0;
	//    if (points > size) {
	//	size = points;
	//	gd_corners = gp_realloc(gd_corners, sizeof(gdPoint) * size,
	//	    "PNG_filled_polygon->gd_corners");
	//    }
	//    for (i = 0; i < points; i++) {
	//	gd_corners[i].x = corners[i].x;
	//	gd_corners[i].y = Y(corners[i].y);
	//    }
	//
	//    switch (corners->style & 0xf) {
	//	case FS_EMPTY: // fill with background color 
	//	    color = png_state.color_table[0];
	//	    break;
	//	case FS_SOLID: // solid fill 
	//	    color = PNG_FillSolid(fillpar);
	//	    break;
	//	case FS_TRANSPARENT_SOLID:
	//	    if (png_state.TrueColor)
	//		color = PNG_FillTransparent(fillpar);
	//	    else
	//		color = PNG_FillSolid(fillpar);
	//	    break;
	//	case FS_PATTERN: // pattern fill 
	//	case FS_TRANSPARENT_PATTERN:
	//	    color = PNG_FillPattern(corners->style);
	//	    break;
	//	default:
	//	    color = png_state.color;
	//	    break;
	//    }
	//
	//    gdImageFilledPolygon(png_state.image, gd_corners, points, color);
	//}
	//
	// /*
	//  * This function is used for filledboxes
	//  * style parameter is some garbled hash combining fillstyle and filldensity
	//  */
	//TERM_PUBLIC void
	//PNG_boxfill(
	//    int style,
	//    unsigned int x, unsigned int y,
	//    unsigned int width, unsigned int height)
	//{
	//    unsigned int x1, y1, x2, y2;
	//    int          color;
	//
	// /* fillpar:
	//  * - solid   : 0 - 100
	//  * - pattern : 0 - 100
	//  */
	//    int fillpar = style >> 4;
	//
	//    switch (style & 0xf) {
	//	case FS_EMPTY: // fill with background color 
	//	    color = png_state.color_table[0];
	//	    break;
	//	case FS_SOLID: // solid fill 
	//	    color = PNG_FillSolid(fillpar);
	//	    break;
	//	case FS_TRANSPARENT_SOLID:
	//	    if (png_state.TrueColor)
	//		color = PNG_FillTransparent(fillpar);
	//	    else
	//		color = PNG_FillSolid(fillpar);
	//	    break;
	//	case FS_PATTERN: // pattern fill 
	//	case FS_TRANSPARENT_PATTERN:
	//	    color = PNG_FillPattern(style);
	//	    break;
	//	default:
	// /* should never happen */
	//	    color = png_state.color;
	//	    break;
	//    }
	//
	//    x1 = x;
	//    x2 = x + width - 1;
	//    y2 = Y(y);
	//    y1 = y2 - height + 1;
	//    gdImageFilledRectangle(png_state.image, x1, y1, x2, y2, color);
	//}
	//
	// /*
	//  * _graphics()  Called just before a plot is going to be displayed.  This
	//  * procedure should set the device into graphics mode.  Devices which can't
	//  * be used as terminals (like plotters) will probably be in graphics mode
	//  * always and therefore won't need this.
	//  */
	//TERM_PUBLIC void
	//PNG_graphics()
	//{
	//    int i;
	//    unsigned int rgb;
	// 
	//    for (i = png_state.n_colors; i < GD_DEFINED_COLORS; i++)
	//	png_state.rgb_table[i] = pm3d_color_names_tbl[i].value;
	//    if (png_state.n_colors < GD_DEFINED_COLORS)
	//	png_state.n_colors = GD_DEFINED_COLORS;
	//
	///#if (GD2_VERS >= 2)
	// /* TrueColor images default to a black background; load white instead.	*/
	// /* If PNG_USE_TRANSPARENT, store the background alpha in the output file	*/
	// /* but apply alpha for the rest of the image internally. Otherwise you	*/
	// /* see only background through the topmost transparent layer.		*/
	//    if (png_state.TrueColor) {
	//        unsigned int brgb = png_state.rgb_table[0];
	//	png_state.image = gdImageCreateTrueColor(PNG_XMAX, PNG_YMAX);
	//	if (!png_state.image)
	//	    int_error(NO_CARET,"libgd: failed to create output image structure");
	//	if (png_state.flags & PNG_USE_TRANSPARENT) {
	//	    rgb = gdImageColorAllocateAlpha(png_state.image,
	//		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff, 127);
	//	    gdImageSaveAlpha(png_state.image, 1);
	//	    gdImageAlphaBlending(png_state.image, 0);
	//	} else {
	//	    rgb = gdImageColorAllocate(png_state.image,
	//		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff);
	//	}
	//	gdImageFill(png_state.image, 1, 1, rgb);
	//	gdImageAlphaBlending(png_state.image, 1);
	//    } else
	///#endif
	//	png_state.image = gdImageCreate(PNG_XMAX, PNG_YMAX);
	//    if (!png_state.image)
	//	int_error(NO_CARET,"libgd: failed to create output image structure");
	//
	//    png_state.height = PNG_YMAX - 1;
	//    png_state.charw = term->h_char;	// png_state.font->w; 
	//    png_state.charh = term->v_char;	// png_state.font->h; 
	//    png_state.font = png_state.default_font;
	//    png_state.color = 0;
	//
	//    for (i = 0; i < png_state.n_colors; i++) {
	//	rgb = png_state.rgb_table[i];
	//	png_state.color_table[i] =
	//	    gdImageColorAllocate(png_state.image, (rgb >> 16) & 0xff,
	//				 (rgb >> 8) & 0xff, rgb & 0xff);
	//    }
	//    if (png_state.flags & PNG_USE_TRANSPARENT)
	//	gdImageColorTransparent(png_state.image, png_state.color_table[0]);
	//    else
	//	gdImageColorTransparent(png_state.image, -1);
	//
	//}
	//
	// /*
	//  * _text()  Called immediately after a plot is displayed.  This procedure
	//  * should set the device back into text mode if it is also a terminal, so
	//  * that commands can be seen as they're typed.  Again, this will probably
	//  * do nothing if the device can't be used as a terminal.
	//  */
	//TERM_PUBLIC void
	//PNG_text()
	//{
	//    image_do_crop();
	//    if (png_state.flags & PNG_USE_INTERLACE)
	//	gdImageInterlace(png_state.image, 1);
	//    gdImagePng(png_state.image, gpoutfile);
	//    gdImageDestroy(png_state.image);
	//}
	//
	// /* _move(x,y)  Called at the start of a line.  The cursor should move to the
	//  * (x,y) position without drawing.
	//  */
	//TERM_PUBLIC void
	//PNG_move(unsigned int x, unsigned int y)
	//{
	//    png_state.x = x;
	//    png_state.y = y;
	//}
	//
	// /* _vector(x,y)  Called when a line is to be drawn.  This should display a line
	//  * from the last (x,y) position given by _move() or _vector() to this new (x,y)
	//  * position.
	//  */
	//TERM_PUBLIC void
	//PNG_vector(unsigned int x, unsigned int y)
	//{
	//    int lw = png_state.linewidth;
	//
	// /* Dashed line style; used only for the x/y grid */
	//    if (png_state.linetype == -1) {
	//	static int last_lw = -1;
	//	static double last_dl = -1;
	//	static int last_color = -1;
	//	static int *png_linetype_dotted = NULL;
	//	static int ssize;
	//
	// /* Adjust the style when linewidth or dashlength has changed. */
	//	if (lw != last_lw || PNG_dashlength_factor != last_dl || last_color != png_state.color) {
	//	    int i;
	//	    int dashlength = 2 * PNG_dashlength_factor;
	//	    int spacelength = 3 * PNG_dashlength_factor;
	//	    int psize = lw*lw*dashlength;
	//	    
	//	    ssize = lw*lw*(spacelength + dashlength);
	//	    png_linetype_dotted = gp_realloc( png_linetype_dotted, ssize*sizeof(int), "dashes");
	//
	// /* Fill style with with color then transparent.
	//  * The style is 2 on / 3 off and scales with linewidth and dashlength.
	//  */
	//	    for(i = 0;i < psize; i++)
	//		png_linetype_dotted[i] = png_state.color;
	//	    for (;i < ssize; i++)
	//		png_linetype_dotted[i] = gdTransparent;
	//	    last_lw = lw;
	//	    last_dl = PNG_dashlength_factor;
	//	    last_color = png_state.color;
	//	}
	// /* This driver does not in general use gd's built-in SetThickness command,
	//  * because it only works right for purely horizontal or vertical lines.
	//  * But that's OK for a 2D grid.
	//  */
	//	gdImageSetStyle(png_state.image, png_linetype_dotted, ssize);
	//	gdImageSetThickness(png_state.image,lw);
	//	gdImageLine(png_state.image, png_state.x, Y(png_state.y), x, Y(y), gdStyled);
	//	gdImageSetThickness(png_state.image,1);
	//
	// /* All other (not dashed) vectors */
	//    } else {
	//	if (png_state.linewidth == 1) {
	///#if (GD2_VERS >= 2) && defined(gdAntiAliased) 
	//	    gdImageSetThickness(png_state.image,1);
	//	    gdImageSetAntiAliased(png_state.image, png_state.color);
	//	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
	//			x, Y(y), gdAntiAliased);
	///#else
	//	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
	//			x, Y(y), png_state.color);
	///#endif
	///#if (GD2_VERS >= 2)
	//	} else if (png_state.capbutt){
	//
	//	    gdImageSetThickness(png_state.image,png_state.linewidth);
	//	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
	//			x, Y(y), png_state.color);
	///#endif
	//	} else {
	// /* EAM - Implement linewidth by using a brush */
	//	    PNG_init_brush(lw);
	//	    gdImageSetBrush(png_state.image, PNG_brush[lw]->im);
	//	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
	//			x, Y(y), gdBrushed );
	//	}
	//    }
	//
	//    png_state.x = x;
	//    png_state.y = y;
	//}
	//
	// /* _linetype(lt)  Called to set the line type before text is displayed or
	//  * line(s) plotted.
	//  * Negative linetypes are defined in gadgets.h
	//  * lt 0 and upwards are used for plots 0 and upwards.
	//  * If _linetype() is called with lt greater than the available line types,
	//  * it should map it to one of the available line types.
	//  */
	//TERM_PUBLIC void
	//PNG_linetype(int type)
	//{
	//    if (type >= (png_state.n_colors - 3))
	//	type %= (png_state.n_colors - 3);
	//    if (type <= LT_BACKGROUND) // LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED 
	//	type = -3;	// Draw in background color 
	//
	//    png_state.color = png_state.color_table[type + 3];
	//    png_state.rgb = png_state.rgb_table[type + 3];
	//    png_state.linetype = type;
	//}
	//
	// /* Use the "brush" tools in the gd library to control line width.
	//  * Pre-define brushes for linewidths 2, 3, 4, 5, 6 (1 doesn't need a brush!).
	//  * Here we just remember the state.
	//  */
	//TERM_PUBLIC void
	//PNG_linewidth(double linewidth)
	//{
	//    png_state.linewidth = (int)(PNG_linewidth_factor * linewidth+0.49);
	//    if (png_state.linewidth > MAXLINEWIDTH) png_state.linewidth = MAXLINEWIDTH;
	//    if (png_state.linewidth < 1) png_state.linewidth = 1;
	//}
	//
	// /* _put_text(x,y,str)  Called to display text at the (x,y) position,
	//  * while in graphics mode.   The text should be vertically (with respect
	//  * to the text) justified about (x,y).  The text is rotated according
	//  * to _text_angle and then horizontally (with respect to the text)
	//  * justified according to _justify_text.
	//  */
	///#ifdef HAVE_GD_TTF
	//TERM_PUBLIC void
	//PNG_put_text(unsigned int x, unsigned int y, const char *string)
	//{
	//    if (png_state.ttffont) {
	//	int brect[8]; char *err;
	// /* Draw once with a NULL image to get the bounding rectangle */
	// /* then draw it again, centered.                             */
	//	err = gdImageStringFT(NULL, brect, png_state.color,
	//			png_state.ttffont, (double)png_state.ttfsize,
	//			(double)png_state.angle * M_PI_2 / 90. ,
	//			x, Y(y), (char *)string);
	//	if (err) {
	//	    fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
	//		err,string,png_state.ttffont);
	//	} else {
	//	    x += sin((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
	//	    y -= cos((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
	//	    switch (png_state.justify) {
	//		case RIGHT:
	//				x -= (brect[2]-brect[0]);
	//				y += (brect[3]-brect[1]);
	//				break;
	//		case CENTRE:
	//				x -= (brect[2]-brect[0]) / 2.;
	//				y += (brect[3]-brect[1]) / 2.;
	//				break;
	//		case LEFT:
	//		default:	break;
	//	    }
	//	    err = gdImageStringFT(png_state.image, brect, png_state.color,
	//			png_state.ttffont, (double)png_state.ttfsize,
	//			(double)png_state.angle * M_PI_2 / 90.,
	//			x, Y(y), (char *)string);
	//	    if (err)
	//		fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
	//		    err,string,png_state.ttffont);
	//	}
	//    } else if (png_state.angle != 0) {
	//	x -= png_state.charh / 2;
	//	switch (png_state.justify) {
	//	    case RIGHT:	y -= png_state.charw * strlen(string);
	//			break;
	//	    case CENTRE:y -= png_state.charw * strlen(string) / 2;
	//			break;
	//	    case LEFT:
	//	    default:	break;
	//	}
	//	gdImageStringUp(png_state.image, png_state.font,
	//			x, Y(y),
	//			(unsigned char *)string, png_state.color);
	//    } else {
	//	y += png_state.charh / 2;
	//	switch (png_state.justify) {
	//	    case RIGHT:	x -= png_state.charw * strlen(string);
	//			break;
	//	    case CENTRE:x -= png_state.charw * strlen(string) / 2;
	//			break;
	//	    case LEFT:
	//	    default:	break;
	//	}
	//	gdImageString(png_state.image, png_state.font,
	//		      x, Y(y),
	//		      (unsigned char *)string, png_state.color);
	//    }
	//}
	//
	///#else  // not HAVE_GD_TTF 
	//
	//TERM_PUBLIC void
	//PNG_put_text(unsigned int x, unsigned int y, const char *string)
	//{
	//    if (png_state.angle == 0) {
	//	y += png_state.charh / 2;
	//	gdImageString(png_state.image, png_state.font,
	//		      x, Y(y),
	//		      (unsigned char *)string, png_state.color);
	//    } else {
	//	x -= png_state.charh / 2;
	//	gdImageStringUp(png_state.image, png_state.font,
	//			x, Y(y),
	//			(unsigned char *)string, png_state.color);
	//    }
	//}
	//
	///#endif // HAVE_GD_TTF 
	//
	//
	//TERM_PUBLIC int
	//PNG_text_angle(int ang)
	//{
	//    while (ang < -180) ang += 360;	// Should not be needed, but reported to 
	//    while (ang > 180) ang -= 360;	// avoid a bug in some libgd versions    
	//    png_state.angle = ang;
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int
	//PNG_justify_text(enum JUSTIFY mode)
	//{
	///#ifdef HAVE_GD_TTF
	//    png_state.justify = mode;
	//    return TRUE;
	///#else
	//    return null_justify_text(mode);
	///#endif
	//}
	//
	//TERM_PUBLIC void
	//PNG_point(unsigned int x, unsigned int y, int number)
	//{
	//    int save_color = png_state.color;
	//
	//    if (number < 0) { // Dot 
	//	gdImageSetPixel(png_state.image, x, Y(y), png_state.color);
	//	return;
	//    }
	// /* Use current linewidth to draw the point symbol */
	//    if (png_state.linewidth > 1) {
	// /* EAM - Implement linewidth by using a brush */
	//	int lw   = png_state.linewidth;
	//	PNG_init_brush(lw);
	//	gdImageSetBrush(png_state.image, PNG_brush[lw]->im);
	//	png_state.color = gdBrushed;
	//    }
	//
	//    y = Y(y);
	//
	//    switch (number % 13) {
	//    case 0: // plus 
	//    default:
	//	PNG_PointPlus(x, y);
	//	break;
	//    case 1: // X 
	//	PNG_PointX(x, y);
	//	break;
	//    case 2: // star 
	//	PNG_PointPlus(x, y);
	//	PNG_PointX(x, y);
	//	break;
	//    case 3: // box 
	//	gdImageRectangle(png_state.image, x - PNG_ps, y - PNG_ps,
	//			 x + PNG_ps, y + PNG_ps, png_state.color);
	//	break;
	//    case 4: // box                   filled 
	//	gdImageFilledRectangle(png_state.image, x - PNG_ps, y - PNG_ps,
	//			       x + PNG_ps, y + PNG_ps, png_state.color);
	//	break;
	//    case 5: // circle 
	//	gdImageArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
	//		   0, 360, png_state.color);
	//	break;
	//    case 6: // circle (disk)         filled 
	///#if (GD2_VERS >= 2)
	//	gdImageFilledArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
	//		   0, 360, png_state.color, gdArc);
	///#else
	//	gdImageArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
	//		   0, 360, png_state.color);
	//	gdImageFillToBorder(png_state.image, x, y,
	//			    png_state.color, png_state.color);
	///#endif
	//	break;
	//    case 7: // triangle 
	//	PNG_Triangle(x, y, 1, gp_gdImagePolygon);
	//	break;
	//    case 8: // triangle              filled 
	//	PNG_Triangle(x, y, 1, gp_gdImageFilledPolygon);
	//	break;
	//    case 9: // upside down triangle 
	//	PNG_Triangle(x, y, -1, gp_gdImagePolygon);
	//	break;
	//    case 10: // upside down triangle  filled 
	//	PNG_Triangle(x, y, -1, gp_gdImageFilledPolygon);
	//	break;
	//    case 11: // diamond 
	//	PNG_Diamond(x, y, gp_gdImagePolygon);
	//	break;
	//    case 12: // diamond               filled 
	//	PNG_Diamond(x, y, gp_gdImageFilledPolygon);
	//	break;
	//    }
	//
	//    png_state.color = save_color;
	//}
	//
	//TERM_PUBLIC int
	//PNG_set_font(const char *fontname)
	//{
	//    int  sep;
	//    int  size;
	//    gdFontPtr font = png_state.default_font;
	//    char *name = gp_strdup(fontname);
	//
	//    sep = strcspn(fontname,",");
	//    strncpy(name,fontname,sep);
	//    name[sep] = '\0';
	//    size = png_state.default_ttfsize;
	//    sscanf (&(fontname[sep+1]),"%d",&size);
	//
	//    if (!strcmp(name,"small"))
	//	font = gdFontSmall;
	//    else if (!strcmp(name,"medium"))
	//	font = gdFontMediumBold;
	//    else if (!strcmp(name,"large"))
	//	font = gdFontLarge;
	//    else if (!strcmp(name,"giant"))
	//	font = gdFontGiant;
	//    else if (!strcmp(name,"tiny"))
	//	font = gdFontTiny;
	//    else if (*name) {
	// /* New ttf font */
	//	free(png_state.ttffont);
	//	png_state.ttffont = gp_strdup(name);
	//	png_state.ttfsize = size;
	//    } else {
	// /* Restore initial default font */
	//	free(png_state.ttffont);
	//	png_state.ttffont = gp_strdup(png_state.default_ttffont);
	//	png_state.ttfsize = png_state.default_ttfsize;
	//    }
	//    free(name);
	//
	//    png_state.font  = font;
	//    png_state.charw = font->w;
	//    png_state.charh = font->h;
	//
	// /* EAM 9-Feb-2003 Make new font size visible to higher level routines like write_multiline */
	//    term->h_char = font->w;
	//    term->v_char = font->h;
	///#ifdef HAVE_GD_TTF
	// /* Find approximate character width and height of selected TTF font */
	//    if (png_state.ttffont) {
	//	int brect[8];
	//	char *err;
	//	err = gdImageStringFT(NULL, &brect[0], 0,
	//		png_state.ttffont, (double)png_state.ttfsize,
	//		0.0, 0, 0, "f00000000g");
	//	if (!err) {
	//	    term->h_char = .11 * (float)(brect[2] - brect[0]) + 0.5;
	//	    term->v_char = 1.1 * (float)(brect[1] - brect[7]) + 0.5;
	//	}
	//    }
	///#endif
	//
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//PNG_pointsize(double ptsize)
	//{
	//    if (ptsize < 0)
	//	ptsize = 1;
	//    PNG_ps = (int)(((double)PNG_POINT_SCALE * ptsize) + 0.5);
	//}
	//
	// /*
	//  * Ethan A Merritt November 2003
	//  *	- Support for enhanced text mode
	//  * BUGS:
	//  *	- placement of overprinted characters is not correct;
	//  *	  the overprinted text (pass 2) should be centered, not left-justified
	//  * PROBLEMS:
	//  *	- the Symbol font encoding didn't work in libgd until 2.0.21
	//  * 	- Placement of superscripts and subscripts relies on information
	//  * 	  in the font description that is not always reliable
	//  *	- the TTF character encoding for non-keyboard characters does
	//  *	  not always match the PostScript standard.
	//  *	- Spacing of rotated text is incorrect; I believe this is a due
	//  *	  to a problem in the text rotation code (aspect ratio??).
	//  */
	//
	//static TBOOLEAN ENHgd_opened_string;
	//
	// /* used in determining height of processed text */
	//static float ENHgd_base;
	//
	// /* use these so that we don't over-write the current font settings in png_state */
	//static double  ENHgd_fontsize;
	//static char   *ENHgd_font;
	//
	//static TBOOLEAN ENHgd_show = TRUE;
	//static TBOOLEAN ENHgd_sizeonly = FALSE;
	//static int ENHgd_overprint = 0;
	//static TBOOLEAN ENHgd_widthflag = TRUE;
	//static unsigned int ENHgd_xsave, ENHgd_ysave;
	//
	//TERM_PUBLIC void
	//ENHGD_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag,
	//    TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* If the overprint code requests a save or restore, that's all we do */
	//    if (overprint == 3) {
	//	ENHgd_xsave = png_state.x;
	//	ENHgd_ysave = png_state.y;
	//	return;
	//    } else if (overprint == 4) {
	//	PNG_move(ENHgd_xsave, ENHgd_ysave);
	//	return;
	//    }
	//
	//    if (!ENHgd_opened_string) {
	//	ENHgd_opened_string = TRUE;
	//	enhanced_cur_text = &enhanced_text[0];
	//	ENHgd_font = fontname;
	//	ENHgd_fontsize = fontsize;
	//	ENHgd_base = base;
	//	ENHgd_show = showflag;
	//	ENHgd_overprint = overprint;
	//	ENHgd_widthflag = widthflag;
	//    }
	//}
	//
	// /* Write a string fragment and update the current position */
	//TERM_PUBLIC void
	//ENHGD_FLUSH()
	//{
	//    int brect[8]; char *err;
	//    unsigned int x, y;
	//
	//	if (ENHgd_opened_string) {
	//	    ENHgd_opened_string = FALSE;
	//	    *enhanced_cur_text = '\0';
	//	    x = png_state.x;
	//	    y = png_state.y;
	//	    x -= sin((double)png_state.angle * M_PI_2/90.) * ENHgd_base;
	//	    y += cos((double)png_state.angle * M_PI_2/90.) * ENHgd_base;
	//	    x += sin((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
	//	    y -= cos((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
	//
	///#ifdef gdFTEX_Adobe_Custom
	// /* libgd defaults to UTF-8 encodings. We have limited options for	*/
	// /* over-riding this, but we can try					*/
	//	    if (encoding != S_ENC_UTF8 && ENHgd_font && !strcmp(ENHgd_font,"Symbol")) {
	//		PNG_FONT_INFO.flags |= gdFTEX_CHARMAP;
	//		PNG_FONT_INFO.charmap = gdFTEX_Adobe_Custom;
	//	    } else {
	//		PNG_FONT_INFO.flags &= ~gdFTEX_CHARMAP;
	//		PNG_FONT_INFO.charmap = 0;   // gdFTEX_Adobe_Custom 
	//	    }
	//	    err = gdImageStringFTEx(
	//			(ENHgd_show && !ENHgd_sizeonly) ? png_state.image : NULL,
	//			brect, png_state.color,
	//			ENHgd_font, ENHgd_fontsize,
	//			(double)png_state.angle * M_PI_2/90.,
	//			x, Y(y), enhanced_text, &PNG_FONT_INFO);
	///#else
	//	    err = gdImageStringFT(
	//			(ENHgd_show && !ENHgd_sizeonly) ? png_state.image : NULL,
	//			brect, png_state.color,
	//			ENHgd_font, ENHgd_fontsize,
	//			(double)png_state.angle * M_PI_2/90.,
	//			x, Y(y), enhanced_text);
	///#endif
	//	    if (err) 
	//		fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
	//		    err,enhanced_text,ENHgd_font);
	//
	//	    FPRINTF((stderr,"outputstring: %s boundingbox: %d %d %d %d\n",
	//			enhanced_text, brect[6], brect[7], brect[2], brect[3]));
	//	    if (ENHgd_overprint == 1) {
	//		png_state.x += ((brect[2] - brect[0]))/2;
	//		png_state.y -= (brect[3] - brect[1]);
	//	    } else if (ENHgd_widthflag) {
	//		png_state.x += (brect[2] - brect[0]);
	//		png_state.y -= (brect[3] - brect[1]);
	//	    }
	//	}
	//}
	//
	//TERM_PUBLIC void
	//ENHGD_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char *original_string = (char *)str;
	//
	//    if (ignore_enhanced_text || !png_state.ttffont) {
	//	PNG_put_text(x,y,str);
	//	return;
	//    }
	//
	//    if (!strlen(str))
	//	return;
	//
	// /* if there are no magic characters, we should just be able
	//  * punt the string to PNG_put_text()
	//  */
	//    if (!strpbrk(str, "{}^_@&~")) {
	// /* FIXME: do something to ensure default font is selected */
	//	PNG_put_text(x,y,str);
	//	return;
	//    }
	//
	//    PNG_move(x,y);
	//
	// /* set up the global variables needed by enhanced_recursion() */
	//    enhanced_fontscale = 1.0;
	//    strncpy(enhanced_escape_format,"&#x%2.2x;",sizeof(enhanced_escape_format));
	//
	//    ENHgd_opened_string = FALSE;
	//    ENHgd_show = TRUE;
	//    ENHgd_overprint = 0;
	//
	// /* EAM - post.trm wasn't doing this, but how else do they get initialized? */
	//	ENHgd_font = png_state.ttffont;
	//	ENHgd_fontsize = png_state.ttfsize;
	//
	// /* EAM - Software text justification requires two passes */
	//    if (png_state.justify == RIGHT || png_state.justify == CENTRE)
	//	ENHgd_sizeonly = TRUE;
	//
	// /* Set the recursion going. We say to keep going until a
	//  * closing brace, but we don't really expect to find one.
	//  * If the return value is not the nul-terminator of the
	//  * string, that can only mean that we did find an unmatched
	//  * closing brace in the string. We increment past it (else
	//  * we get stuck in an infinite loop) and try again.
	//  */
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//			ENHgd_font, ENHgd_fontsize,
	//			0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//
	// /* I think we can only get here if *str == '}' */
	//	    enh_err_check(str);
	//
	//	if (!*++str)
	//	    break; // end of string 
	//
	// /* else carry on and process the rest of the string */
	//    }
	//
	// /* We can do text justification by running the entire top level string */
	// /* through 2 times, with the ENHgd_sizeonly flag set the first time.   */
	// /* After seeing where the final position is, we then offset the start  */
	// /* point accordingly and run it again without the flag set.            */
	//    if (png_state.justify == RIGHT || png_state.justify == CENTRE) {
	//	int justification = png_state.justify;
	//	int x_offset = png_state.x - x;
	//	int y_offset = 0;
	//
	//	if (png_state.angle != 0)
	//	    y_offset = png_state.y - y;
	//	png_state.justify = LEFT;
	//	ENHgd_sizeonly = FALSE;
	//
	//	if (justification == RIGHT) {
	//	    ENHGD_put_text(x - x_offset, y - y_offset, original_string);
	//	} else if (justification == CENTRE) {
	//	    ENHGD_put_text(x - x_offset/2, y - y_offset/2, original_string);
	//	}
	//	png_state.justify = justification;
	//    }
	//
	//}
	//
	///#undef gdfont
	//
	//TERM_PUBLIC void
	//PNG_image (unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode)
	//{
	//    int m, n, mout, nout;
	//    int x1,y1,x2,y2;
	//    int xclip1, xclip2, yclip1, yclip2;
	//    int pixel;
	//    gdImagePtr im;
	//
	///#if (GD2_VERS >= 2)
	//    if (png_state.TrueColor) {
	//	im = gdImageCreateTrueColor(M, N);
	//	if (!im)
	//	    int_error(NO_CARET,"libgd: failed to create image structure");
	//    } else
	///#endif
	//    {
	//	im = gdImageCreate(M, N);
	//	if (!im)
	//	    int_error(NO_CARET,"libgd: failed to create image structure");
	//	gdImagePaletteCopy(im, png_state.image);
	//    }
	//
	///#if (GD2_VERS >= 2)
	// /* Set clipping bound for area into which we will copy */
	//    xclip1 = GPMIN(corner[2].x, corner[3].x);
	//    xclip2 = GPMAX(corner[2].x, corner[3].x);
	//    yclip1 = GPMIN(Y(corner[2].y), Y(corner[3].y));
	//    yclip2 = GPMAX(Y(corner[2].y), Y(corner[3].y));
	//    gdImageGetClip(png_state.image, &x1, &y1, &x2, &y2);
	//    gdImageSetClip(png_state.image, xclip1, yclip1, xclip2, yclip2);
	///#endif
	//
	// /* Initialize image area with current contents of plot. */
	//    mout = abs( (int)corner[1].x - (int)corner[0].x );
	//    nout = abs( (int)corner[1].y - (int)corner[0].y );
	//
	//    if (color_mode == IC_RGBA) {
	// /* RGB + Alpha channel
	//  * Resize explicitly in a loop rather than calling a library
	//  * routine in order not to apply the alpha correction more than
	//  * once when building up any given output pixel.
	//  */
	//	for (n=0; n<nout; n++) {
	//	for (m=0; m<mout; m++) {
	//	    rgb_color rgb1;
	//	    rgb255_color rgb255;
	//	    int alpha;
	//	    int msrc = (m*(long)(M-1))/(mout-1);
	//	    int nsrc = (n*(long)(N-1))/(nout-1);
	//	    coordval *cval = image + 4*(M*nsrc + msrc);
	//	    rgb1.r = *cval++;
	//	    rgb1.g = *cval++;
	//	    rgb1.b = *cval++;
	//	    alpha  = *cval++;
	//	    alpha  = 127 - (alpha>>1);	// input is [0:255] but gd wants [127:0] 
	//	    rgb255_from_rgb1( rgb1, &rgb255 );
	//	    pixel = gdImageColorResolveAlpha( png_state.image,
	//		(int)rgb255.r, (int)rgb255.g, (int)rgb255.b, alpha);
	//	    gdImageSetPixel( png_state.image, m + corner[0].x, n + Y(corner[0].y), pixel );
	//	}
	//	}
	//
	//    } else if (color_mode == IC_RGB) {
	// /* TrueColor 24-bit color mode */
	//	for (n=0; n<N; n++) {
	//	for (m=0; m<M; m++) {
	//	    rgb_color rgb1;
	//	    rgb255_color rgb255;
	//	    rgb1.r = *image++;
	//	    rgb1.g = *image++;
	//	    rgb1.b = *image++;
	//	    rgb255_from_rgb1( rgb1, &rgb255 );
	//	    pixel = gdImageColorResolve( im, 
	//		(int)rgb255.r, (int)rgb255.g, (int)rgb255.b );
	//	    gdImageSetPixel( im, m, n, pixel );
	//	}
	//	}
	//
	//    } else if (color_mode == IC_PALETTE) {
	// /* Palette color lookup from gray value */
	//	for (n=0; n<N; n++) {
	//	for (m=0; m<M; m++) {
	//	    rgb255_color rgb;
	//	    if (isnan(*image)) {
	// /* Transparent would be even better */
	//		pixel = png_state.color_table[0];
	//		image++;
	//	    } else {
	//		rgb255maxcolors_from_gray( *image++, &rgb );
	//		pixel = gdImageColorResolve( im,
	//		    (int)rgb.r, (int)rgb.g, (int)rgb.b );
	//	    }
	//	    gdImageSetPixel( im, m, n, pixel );
	//	}
	//	}
	//    }
	//
	// /* Copy and resize onto requested region of plot */
	//    if (color_mode != IC_RGBA)
	//	gdImageCopyResized(png_state.image, im,
	//		(corner[0].x), Y(corner[0].y),	// Destination X, Y 
	//		0, 0, 				// Source X, Y 
	//		mout, nout,			// Destination Width, Height 
	//		M, N				// Source Width, Height 
	//		);
	//    gdImageDestroy(im);
	//
	///#if (GD2_VERS >= 2)
	// /* Restore previous clipping, if any */
	//    gdImageSetClip(png_state.image, x1, y1, x2, y2);
	///#endif
	//
	//}
	//
	///#undef MAXLINEWIDTH
	///#undef Y
	//
	///#endif // TERM_BODY 
	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(png_driver)
	//    "png", "PNG images using libgd and TrueType fonts",
	//    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
	//    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
	//    PNG_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
	//    PNG_linetype, PNG_put_text, PNG_text_angle,
	//    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
	//    PNG_pointsize,
	//    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_LINEWIDTH, // TERM_ALPHA_CHANNEL only if truecolor 
	//    0 //suspend
	//, 0 //resume
	//,
	//    PNG_boxfill //EAM - fillbox
	//,
	//    PNG_linewidth //EAM - linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0 // no mouse support 
	///#endif
	//    , PNG_make_palette,
	//    0, // previous_palette() ... no, single array of 256 colours for PNG 
	//    PNG_set_color,
	//    PNG_filled_polygon
	//    , PNG_image
	//    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
	//TERM_TABLE_END(png_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM png_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifndef JPEG_HELP_ONLY
	///#ifdef TERM_HELP
	//START_HELP(png)
	//"1 png",
	//"?commands set terminal png",
	//"?set terminal png",
	//"?set term png",
	//"?terminal png",
	//"?term png",
	//"?png",
	//" Syntax:",
	//"       set terminal png ",
	//"              {{no}transparent} {{no}interlace}",
	//"              {{no}truecolor} {rounded|butt}",
	//"              {linewidth <lw>} {dashlength <dl>}",
	//"              {tiny | small | medium | large | giant}",
	//"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
	//"              {size <x>,<y>} {{no}crop}",
	//"              {<background_color>}",
	//"",
	//" PNG, JPEG and GIF images are created using the external library libgd.",
	//" PNG plots may be viewed interactively by piping the output to the",
	//" 'display' program from the ImageMagick package as follows:",
	//"                set term png",
	//"                set output '| display png:-'",
	//" You can view the output from successive plot commands interactively by typing",
	//" <space> in the display window.  To save the current plot to a file,",
	//" left click in the display window and choose `save`.",
	//"",
	//" `transparent` instructs the driver to make the background color transparent.",
	//" Default is `notransparent`.",
	//"",
	//" `interlace` instructs the driver to generate interlaced PNGs.",
	//" Default is `nointerlace`.",
	//"",
	//" The `linewidth` and `dashlength` options are scaling factors that affect all",
	//" lines drawn, i.e. they are multiplied by values requested in various drawing",
	//" commands.",
	//"",
	//" By default output png images use 256 indexed colors. The `truecolor` option",
	//" instead creates TrueColor images with 24 bits of color information per pixel.",
	//" Transparent fill styles require the `truecolor` option. See `fillstyle`.",
	//" A transparent background is possible in either indexed or TrueColor images.",
	//"",
	//" `butt` instructs the driver to use a line drawing method that does",
	//" not overshoot the desired end point of a line.  This setting is only",
	//" applicable for line widths greater than 1.  This setting is most useful when",
	//" drawing horizontal or vertical lines.  Default is `rounded`.",
	//"",
	//" The details of font selection are complicated.",
	//" Two equivalent simple examples are given below:",
	//"      set term png font arial 11",
	//"      set term png font \"arial,11\"",
	//" For more information please see the separate section under `fonts`.",
	//"",
	//" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
	//" Please see additional information under `canvas` and `set size`.",
	//" Blank space at the edges of the finished plot may be trimmed using the `crop`",
	//" option, resulting in a smaller final image size. Default is `nocrop`.",
	//"",
	//" The background color must be given in the form 'xrrggbb', where x is the",
	//" literal character 'x' and 'rrggbb' are the red, green and blue components",
	//" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
	//" additional colors other than the background is deprecated.",
	//"",
	//"2 examples",
	//"?set term png examples",
	//"       set terminal png medium size 640,480 xffffff",
	//"",
	//" Use the medium size built-in non-scaleable, non-rotatable font.",
	//" Use white (xffffff) for the non-transparent background.",
	//"",
	//"       set terminal png font arial 14 size 800,600",
	//"",
	//" Searches for a scalable font with face name 'arial' and sets the font",
	//" size to 14pt.  Please see `fonts` for details of how the font search",
	//" is done.",
	//"",
	//"       set terminal png transparent truecolor enhanced",
	//"",
	//" Use 24 bits of color information per pixel, with a transparent background.",
	//" Use the `enhanced text` mode to control the layout of strings to be printed.",
	//""
	//END_HELP(png)
	///#endif // TERM_HELP 
	///#endif // JPEG_HELP_ONLY 

	/*
	 * JPEG support comes almost for free.
	 * We just piggy-back on the PNG routines, since they both go via libgd
	 */
	///#ifdef HAVE_GD_JPEG

	///#ifdef TERM_REGISTER
	//register_term(jpeg)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void JPEG_text __PROTO((void));
	///#define GOT_NEXT_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "gd.h"
	// /*
	//  * All functions except the final write to file
	//  * are actually performed by the PNG driver code
	//  */
	//TERM_PUBLIC void
	//JPEG_text()
	//{
	//int quality = 90;
	//
	//    image_do_crop();
	//    if (png_state.flags & PNG_USE_INTERLACE)
	//	gdImageInterlace(png_state.image, 1);
	//    gdImageJpeg(png_state.image, gpoutfile, quality);
	//    gdImageDestroy(png_state.image);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(jpeg_driver)
	//    "jpeg", "JPEG images using libgd and TrueType fonts",
	//    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
	//    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
	//    JPEG_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
	//    PNG_linetype, PNG_put_text, PNG_text_angle,
	//    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
	//    PNG_pointsize,
	//    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
	//    0 //suspend
	//, 0 //resume
	//,
	//    PNG_boxfill //EAM - fillbox
	//,
	//    PNG_linewidth //EAM - linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0 // no mouse support 
	///#endif
	//    , PNG_make_palette,
	//    0, // previous_palette() ... no, single array of 256 colours for PNG 
	//    PNG_set_color,
	//    PNG_filled_polygon
	//    , PNG_image
	//    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
	//TERM_TABLE_END(jpeg_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM jpeg_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(jpeg)
	//"1 jpeg",
	//"?commands set terminal jpeg",
	//"?set terminal jpeg",
	//"?set term jpeg",
	//"?terminal jpeg",
	//"?term jpeg",
	//"?jpeg",
	//" Syntax:",
	//"       set terminal jpeg ",
	//"              {{no}interlace}",
	//"              {linewidth <lw>} {dashlength <dl>} {rounded|butt}",
	//"              {tiny | small | medium | large | giant}",
	//"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
	//"              {size <x>,<y>} {{no}crop}",
	//"              {<background_color>}",
	//"",
	//" PNG, JPEG and GIF images are created using the external library libgd.",
	//" In most cases, PNG is to be preferred for single plots, and GIF for",
	//" animations.  Both are loss-less image formats, and produce better image",
	//" quality than the lossy JPEG format. This is in particular noticeable",
	//" for solid color lines against a solid background, i.e. exactly the sort",
	//" of image typically created by gnuplot.",
	//"",
	//" The `interlace` option creates a progressive JPEG image.",
	//" Default is `nointerlace`.",
	//"",
	//" The `linewidth` and `dashlength` options are scaling factors that affect all",
	//" lines drawn, i.e. they are multiplied by values requested in various drawing",
	//" commands.",
	//"",
	//" `butt` instructs the driver to use a line drawing method that does",
	//" not overshoot the desired end point of a line.  This setting is only",
	//" applicable for line widths greater than 1.  This setting is most useful when",
	//" drawing horizontal or vertical lines.  Default is `rounded`.",
	//"",
	//" The details of font selection are complicated.",
	//" Two equivalent simple examples are given below:",
	//"      set term jpeg font arial 11",
	//"      set term jpeg font \"arial,11\"",
	//" For more information please see the separate section under `fonts`.",
	//"",
	//" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
	//" Please see additional information under `canvas` and `set size`.",
	//" Blank space at the edges of the finished plot may be trimmed using the `crop`",
	//" option, resulting in a smaller final image size. Default is `nocrop`.",
	//"",
	//" The background color must be given in the form 'xrrggbb', where x is the",
	//" literal character 'x' and 'rrggbb' are the red, green and blue components",
	//" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
	//" additional colors other than the background is deprecated.",
	//""
	//END_HELP(jpeg)
	///#endif // TERM_HELP 
	///#endif // HAVE_GD_JPEG 

	///#ifdef HAVE_GD_GIF
	/*
	 * GIF support comes almost for free.
	 * We just piggy-back on the PNG routines, since they both go via libgd.
	 * Required libgd version is 2.0.28 or newer.
	 */
	///#ifdef HAVE_GD_GIF

	///#ifdef TERM_REGISTER
	//register_term(gif)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void GIF_text __PROTO((void));
	///#define GOT_NEXT_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "gd.h"
	// /*
	//  * All functions except the final write to file
	//  * are actually performed by the PNG driver code
	//  */
	//TERM_PUBLIC void
	//GIF_text()
	//{
	//    image_do_crop();
	//
	///#ifdef GIF_ANIMATION
	//    if (png_state.animate) {
	// /* Note - using a global colormap saves space, but it breaks	*/
	// /* if later frames add new colors to the palette.		*/
	//	if (png_state.frame_count == 0) {
	//	    gdImageGifAnimBegin(png_state.image, gpoutfile, 
	//		1, // Load Global Colormap even if it isn't used  
	//		png_state.loop_count );
	//	}
	//	gdImageGifAnimAdd(png_state.image, gpoutfile,
	//	    png_state.frame_optimization ? 0  // use global map  
	//	                                 : 1, // use private map 
	//	    0, 0 // No offset 
	//,
	//	    png_state.frame_delay,
	//	    (png_state.flags & PNG_USE_TRANSPARENT)
	//			? gdDisposalRestorePrevious 
	//			: gdDisposalNone, 
	//	    (png_state.frame_optimization && !(png_state.flags & PNG_USE_TRANSPARENT))
	//	    ? png_state.previous_image : NULL);
	//	png_state.frame_count++;
	//	if (png_state.previous_image)
	//	    gdImageDestroy(png_state.previous_image);
	//	png_state.previous_image = png_state.image;
	//	return;
	//    }
	///#endif
	//
	//    gdImageGif(png_state.image, gpoutfile);
	//    gdImageDestroy(png_state.image);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(gif_driver)
	//    "gif", "GIF images using libgd and TrueType fonts",
	//    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
	//    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
	//    GIF_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
	//    PNG_linetype, PNG_put_text, PNG_text_angle,
	//    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
	//    PNG_pointsize,
	//    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_LINEWIDTH,
	//    0 //suspend
	//, 0 //resume
	//,
	//    PNG_boxfill //EAM - fillbox
	//,
	//    PNG_linewidth //EAM - linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0 // no mouse support 
	///#endif
	//    , PNG_make_palette,
	//    0, // previous_palette() ... no, single array of 256 colours for PNG 
	//    PNG_set_color,
	//    PNG_filled_polygon
	//    , PNG_image
	//    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
	//TERM_TABLE_END(gif_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM gif_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 


	///#ifdef TERM_HELP
	//START_HELP(gif)
	//"1 gif",
	//"?commands set terminal gif",
	//"?set terminal gif",
	//"?set term gif",
	//"?terminal gif",
	//"?term gif",
	//"?gif",
	//" Syntax:",
	//"       set terminal gif ",
	//"              {{no}transparent} {rounded|butt}",
	//"              {linewidth <lw>} {dashlength <dl>}",
	//"              {tiny | small | medium | large | giant}",
	//"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
	//"              {size <x>,<y>} {{no}crop}",
	//"              {animate {delay <d>} {loop <n>} {{no}optimize}}",
	//"              {<background_color>}",
	//"",
	//" PNG, JPEG and GIF images are created using the external library libgd.",
	//" GIF plots may be viewed interactively by piping the output to the",
	//" 'display' program from the ImageMagick package as follows:",
	//"                set term gif",
	//"                set output '| display gif:-'",
	//" You can view the output from successive plot commands interactively by typing",
	//" <space> in the display window.  To save the current plot to a file,",
	//" left click in the display window and choose `save`.",
	//"",
	//" `transparent` instructs the driver to make the background color transparent.",
	//" Default is `notransparent`.",
	//"",
	//" The `linewidth` and `dashlength` options are scaling factors that affect all",
	//" lines drawn, i.e. they are multiplied by values requested in various drawing",
	//" commands.",
	//"",
	//" `butt` instructs the driver to use a line drawing method that does",
	//" not overshoot the desired end point of a line.  This setting is only",
	//" applicable for line widths greater than 1.  This setting is most useful when",
	//" drawing horizontal or vertical lines.  Default is `rounded`.",
	//"",
	//" The details of font selection are complicated.",
	//" Two equivalent simple examples are given below:",
	//"      set term gif font arial 11",
	//"      set term gif font \"arial,11\"",
	//" For more information please see the separate section under `fonts`.",
	//"",
	//" The `animate` option is available only if your local gd library supports",
	//" the creation of animated gifs. The default delay between display of",
	//" successive images may be specified in units of 1/100 second (default 5).",
	//" The actual delay may vary depending on the program used as a viewer.",
	//" Number of animation loops can be specified, default 0 means infinity.",
	//" An animation sequence is terminated by the next `set output` or `set term`",
	//" command.  The `optimize` option has two effects on the animation.",
	//"",
	//" 1) A single color map is used for the entire animation. This requires",
	//" that all colors used in any frame of the animation are already",
	//" defined in the first frame.",
	//"",
	//" 2) If possible, only the portions of a frame that differ from the",
	//" previous frame are stored in the animation file.  This space saving",
	//" may not be possible if the animation uses transparency.",
	//"",
	//" Both of these optimizations are intended to produce a smaller output file,",
	//" but the decrease in size is probably only significant for long animations",
	//" or very small frame sizes.",
	//" The `nooptimize` option turns off both of the effects just described.",
	//" Each frame is stored in its entirety along with a private color map.",
	//" Note that it is possible to post-process a non-optimized animation",
	//" using external utilities, and this post-processing can yield a smaller",
	//" file than gnuplot's internal optimization mode.",
	//" The default is `nooptimize`.",
	//"",
	//" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
	//" Please see additional information under `canvas` and `set size`.",
	//" Blank space at the edges of the finished plot may be trimmed using the `crop`",
	//" option, resulting in a smaller final image size. Default is `nocrop`.",
	//"",
	//" The background color must be given in the form 'xrrggbb', where x is the",
	//" literal character 'x' and 'rrggbb' are the red, green and blue components",
	//" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
	//" additional colors other than the background is deprecated.",
	//"",
	//"2 examples",
	//"?set term gif examples",
	//"       set terminal gif medium size 640,480 xffffff",
	//"",
	//" Use the medium size built-in non-scaleable, non-rotatable font.",
	//" Use white (xffffff) for the non-transparent background.",
	//"",
	//"       set terminal gif font arial 14 enhanced",
	//"",
	//" Searches for a scalable font with face name 'arial' and sets the font",
	//" size to 14pt.  Please see `fonts` for details of how the font search",
	//" is done.  Because this is a scalable font, we can use enhanced text mode.",
	//"",
	//"       set term gif animate transparent opt delay 10 size 200,200 x000000",
	//"       load \"animate2.dem\"",
	//"",
	//" Open the gif terminal for creation of an animated gif file.  The individual",
	//" frames of the animation sequence are created by the script file animate2.dem",
	//" from the standard collection of demos.",
	//""
	//END_HELP(gif)
	///#endif // TERM_HELP 
	///#endif // HAVE_GD_GIF 
	///#endif

	///#endif

	/* postscript */
	///#ifdef POSTSCRIPT_DRIVER
	/* Hello, Emacs: this is -*-C-*- !
	 * $Id: post.trm,v 1.243.2.4 2009/09/13 17:54:09 sfeam Exp $
	 */

	/* GNUPLOT - post.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 1999, 2000, 2001, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This terminal driver supports:
	 *     postscript
	 *
	 * AUTHORS
	 *  Russell Lang  <rjl@monu1.cc.monash.edu.au>
	 *
	 * modified 10/5/95 by drd - put in support for other postscript drivers
	 * (enhpost, pslatex, ...) so they dont have to work quite so hard
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 * The 'postscript' driver produces landscape output 10" wide and 7" high.
	 * To change font to Times-Roman and font size to 20pts use
	 * 'set term postscript "Times-Roman" 20'.
	 * To get a smaller (5" x 3.5") eps output use 'set term post eps'
	 * and make only one plot per file.  Font size for eps will be half
	 * the specified size.
	 *
	 * Erik Luijten 30/5/97: added %%CreationDate, made %%DocumentFonts conform
	 *                       to DSC, added version no. and patchl. to %%Creator
	 * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
	 *
	 * Dick Crawford 24/5/00: added 'a{}{}' syntax to allow for overprinting
	 *
	 * Dan Sebald, 7 March 2003: terminal entry for image functionality
	 *
	 * Harald Harders (h.harders@tu-bs.de), 2004-12-02:
	 * Moved all terminal settings into a single structure.
	 *
	 * Harald Harders (h.harders@tu-bs.de), 2005-02-08:
	 * Merged functionality of postscript, pslatex, pstex, and epslatex terminals.
	 *
	 * Ethan Merritt Mar 2006:   Break out prolog and character encodings into
	 * separate files loaded at runtime
	 *
	 * Thomas Henlich Sep 2007:   Add support for UTF-8 encoding via the glyphshow
	 * operator.  It supports PostScript Type1 fonts that use glyph names according
	 * to the Adobe Glyph List For New Fonts.
	 */


	///#ifdef TERM_PROTO
	///#include "variable.h"	// For loadpath_handler used in PS_dump_prologue_file 
	///#endif

	///#ifdef TERM_REGISTER
	//register_term(post)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void PS_options __PROTO((void));
	//TERM_PUBLIC void PS_common_init __PROTO((TBOOLEAN uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int bb_xmin, unsigned int bb_ymin, unsigned int bb_xmax, unsigned int bb_ymax, const char **dict));
	//TERM_PUBLIC void PS_init __PROTO((void));
	//TERM_PUBLIC void PS_graphics __PROTO((void));
	//TERM_PUBLIC void PS_text __PROTO((void));
	//TERM_PUBLIC void PS_reset __PROTO((void));
	//TERM_PUBLIC void PS_linetype __PROTO((int linetype));
	//TERM_PUBLIC void PS_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void PS_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void PS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int PS_text_angle __PROTO((int ang));
	//TERM_PUBLIC int PS_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void PS_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void PS_arrow __PROTO(( unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey, int head));
	//TERM_PUBLIC int PS_set_font __PROTO((const char * font));
	//TERM_PUBLIC void PS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
	//TERM_PUBLIC void PS_linewidth __PROTO((double linewidth)); // JFi [linewidth] 
	//TERM_PUBLIC void PS_pointsize __PROTO((double ptsize)); // JFi [pointsize] 
	//TERM_PUBLIC int PS_make_palette (t_sm_palette *);
	//TERM_PUBLIC void PS_previous_palette (void);
	//TERM_PUBLIC void PS_set_color (t_colorspec *);
	//TERM_PUBLIC void PS_filled_polygon (int, gpiPoint *);
	//TERM_PUBLIC void PS_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
	//
	// /* To support "set term post enhanced" */
	//TERM_PUBLIC void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC int  ENHPS_set_font __PROTO((const char * font));
	//TERM_PUBLIC void ENHPS_OPEN __PROTO((char * fontname, double fontsize,
	//	    		double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//			int overprint));
	//TERM_PUBLIC void ENHPS_FLUSH __PROTO((void));
	//TERM_PUBLIC void ENHPS_WRITEC __PROTO((int c));
	//static void PS_RememberFont __PROTO((char *fname));
	//
	//TERM_PUBLIC char *PS_escape_string __PROTO((char *origstr, char *escapelist));
	//
	//TERM_PUBLIC void PS_path __PROTO((int p));
	//static TBOOLEAN PS_newpath = FALSE;
	//static TBOOLEAN ENHps_opened_string = FALSE;  // try to cut out empty ()'s 
	//
	//TERM_PUBLIC void PS_layer __PROTO((t_termlayer syncpoint));
	//
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "post.h"
	//
	///#define PS_FLUSH_PATH do {			    if (ps_path_count) {				fputs("stroke\n", gppsfile);			ps_path_count = 0;				PS_relative_ok = FALSE;			    }						} while (0)
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	// /* Data structure implementing inclusion of font files */
	//struct ps_fontfile_def {
	//    struct ps_fontfile_def *next;// pointer to next fontfile in linked list 
	//    char *fontfile_name;
	//    char *fontfile_fullname;
	//    char *fontname;
	//};
	//
	// /* Terminal type of postscript dialect */
	//enum PS_TERMINALTYPE {
	//    PSTERM_PSTEX, PSTERM_PSLATEX, PSTERM_EPSLATEX, PSTERM_POSTSCRIPT
	//};
	//
	//enum PS_PSFORMAT {
	//    PSTERM_EPS, PSTERM_PORTRAIT, PSTERM_LANDSCAPE
	//};
	//
	// /* One struct that takes all terminal parameters
	//  * by Harald Harders <h.harders@tu-bs.de> */
	//typedef struct ps_params_t {
	//    enum PS_TERMINALTYPE terminal;
	//    int xoff;
	//    int yoff;
	//    enum PS_PSFORMAT psformat;
	//    TBOOLEAN level1;
	//    TBOOLEAN color;
	//    TBOOLEAN blacktext;
	//    TBOOLEAN solid;
	//    float dash_length;
	//    float linewidth_factor;
	//    TBOOLEAN duplex_option;           // one of duplex or simplex specified? 
	//    TBOOLEAN duplex_state;
	//    TBOOLEAN rounded;                 // rounded linecaps and linejoins 
	//    TBOOLEAN clipped;                 // path clipped to BoundingBox? 
	//    struct ps_fontfile_def *first_fontfile;
	//    char font[MAX_ID_LEN+1];          // name of font 
	//    float fontsize;                     // size of font in pts 
	//    TBOOLEAN useauxfile;              // only necessary for ps(la)tex 
	//    TBOOLEAN rotate;                  // only necessary for ps(la)tex 
	//    int palfunc_samples;              // setable via "palf$uncparam" 
	//    double palfunc_deviation;         // terminal option 
	//    TBOOLEAN oldstyle;
	//    TBOOLEAN epslatex_standalone;
	//    TBOOLEAN adobeglyphnames;         // Choice of output names for UTF8 
	//} ps_params_t;
	//
	///#define POST_PARAMS_DEFAULT {     PSTERM_POSTSCRIPT, 50, 50,     PSTERM_LANDSCAPE, FALSE, FALSE, FALSE, FALSE, 1.0, 1.0, FALSE,     FALSE, FALSE, FALSE, NULL, "Helvetica", 14, FALSE, FALSE, 2000, 0.003,     FALSE, TRUE, FALSE }
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	//static ps_params_t post_params = POST_PARAMS_DEFAULT;
	//static const ps_params_t post_params_default = POST_PARAMS_DEFAULT;
	//
	///#define EPSLATEX_PARAMS_DEFAULT {     PSTERM_EPSLATEX, 50, 50,     PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE,     FALSE, FALSE, FALSE, NULL, "", 11, TRUE, FALSE, 2000, 0.003,     FALSE, FALSE, FALSE }
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//static ps_params_t epslatex_params = EPSLATEX_PARAMS_DEFAULT;
	//static const ps_params_t epslatex_params_default = EPSLATEX_PARAMS_DEFAULT;
	//
	///#define PSLATEX_PARAMS_DEFAULT {     PSTERM_PSLATEX, 0, 0,     PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE,     FALSE, FALSE, FALSE, NULL, "", 0, FALSE, TRUE, 2000, 0.003,     FALSE, FALSE, FALSE }
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//static ps_params_t pslatex_params = PSLATEX_PARAMS_DEFAULT;
	//static const ps_params_t pslatex_params_default = PSLATEX_PARAMS_DEFAULT;
	//
	///#define PSTEX_PARAMS_DEFAULT {     PSTERM_PSTEX, 0, 0,     PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE,     FALSE, FALSE, FALSE, NULL, "", 0, FALSE, TRUE, 2000, 0.003,     FALSE, FALSE, FALSE }
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//static ps_params_t pstex_params = PSTEX_PARAMS_DEFAULT;
	//static const ps_params_t pstex_params_default = PSTEX_PARAMS_DEFAULT;
	//
	//static ps_params_t *ps_params = &post_params;
	//
	//static void make_interpolation_code __PROTO((void));
	//static void make_color_model_code __PROTO((void));
	//static char * save_space __PROTO((double gray));
	//static void write_component_array __PROTO((const char *text, gradient_struct *grad, int cnt, int offset));
	//static void write_gradient_definition __PROTO((gradient_struct *gradient, int cnt));
	//static void write_color_space __PROTO((t_sm_palette *palette));
	//static void make_palette_formulae __PROTO((void));
	//static void PS_make_header __PROTO((t_sm_palette *palette));
	//
	//static float ps_fontsize;
	//
	// /* for enhanced mode, we keep a separate font name and size, which
	//  * is restored to the default value on font of ""
	//  */
	//static char ps_enh_font[MAX_ID_LEN+1];
	//static float ps_enh_fontsize;
	//static int  ENHPS_initialized;
	//
	//static int ps_page = 0;		// page count 
	//static int ps_path_count = 0; 	// count of lines in path 
	//static int ps_ang = 0;			// text angle 
	//static enum JUSTIFY ps_justify = LEFT;	// text is flush left 
	//
	//static void delete_ps_fontfile __PROTO((struct ps_fontfile_def *, struct ps_fontfile_def *));
	//
	//TERM_PUBLIC void PS_load_fontfile __PROTO((struct ps_fontfile_def *,TBOOLEAN));
	//TERM_PUBLIC void PS_load_fontfiles __PROTO((TBOOLEAN));
	//
	//static TBOOLEAN ps_explicit_size = FALSE;
	//static size_units ps_explicit_units = INCHES;
	//static int eps_explicit_x = 0;
	//static int eps_explicit_y = 0;
	//
	///#define DOTS_PER_INCH (300)    // resolution of printer we expect to use 
	//
	// /* name of auxiliary file */
	//static char *pslatex_auxname = NULL;
	//
	// /* Routine to copy pre-existing prolog files into output stream */
	//static FILE *PS_open_prologue_file __PROTO((char *));
	//static void PS_dump_prologue_file __PROTO((char *));
	//static void PS_load_glyphlist __PROTO((void));
	//
	//static const char GPFAR * GPFAR OldEPSL_linetypes[] = {
	// /* Line Types */
	//"% Redefine line types to match old epslatex driver\n",
	//"/LTw { PL [] 1 setgray } def\n", // background (assumed white) 
	//"/LTb { BL [] 0 0 0 DL } def\n", // border 
	//"/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def\n", // axes 
	//"/LT0 { PL [] 1 0 0 DL } def\n",
	//"/LT1 { PL [8 dl1 5 dl1] 0 0 1 DL } def\n",
	//"/LT2 { PL [4 dl1 4 dl1] 0 1 1 DL } def\n",
	//"/LT3 { PL [8 dl1 5 dl1 0.5 dl1 5 dl1] 1 0 1 DL } def\n",
	//NULL
	//};
	//
	//static const char GPFAR * GPFAR ENHPS_header[] = {
	// /* For MFshow and MFwidth the tos is an array with the string and font info:  */
	// /*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <printed?> <overprint> <text string>]  */
	// /* EAM Mar 2004 - Add in a special case overprint 3 = save, overprint 4 = restore */
	// /* EAM Nov 2007 - Accommodate UTF-8 support (Gshow) */
	//
	//"/MFshow {\n",
	//"   { dup 5 get 3 ge\n",	// EAM test for overprint 3 or 4 
	//"     { 5 get 3 eq {gsave} {grestore} ifelse }\n", // EAM 
	//"     {dup dup 0 get findfont exch 1 get scalefont setfont\n",
	//"     [ currentpoint ] exch dup 2 get 0 exch R dup 5 get 2 ne {dup dup 6\n",
	//"     get exch 4 get {Gshow} {stringwidth pop 0 R} ifelse }if dup 5 get 0 eq\n",
	//"     {dup 3 get {2 get neg 0 exch R pop} {pop aload pop M} ifelse} {dup 5\n",
	//"     get 1 eq {dup 2 get exch dup 3 get exch 6 get stringwidth pop -2 div\n",
	//"     dup 0 R} {dup 6 get stringwidth pop -2 div 0 R 6 get\n",
	//"     show 2 index {aload pop M neg 3 -1 roll neg R pop pop} {pop pop pop\n",
	//"     pop aload pop M} ifelse }ifelse }ifelse }\n",
	//"     ifelse }\n", // EAM 
	//"   forall} def\n",
	//
	// /* get the width of the text */
	// /* HH 2005-07-24 - Add in a special case overprint 3 = save, 4 = restore
	//  * also for estimation of string width. This is done by interposing an 
	//  * additional value on the stack. between XYsave and XYrestore,
	//  * this number is increased by the strings. By pop'ing this number, all
	//  * strings between XYsave and XYrestore are ignored. */
	// /* EAM Nov 2007 - GSwidth is to allow the operator to work either with a string
	//  * or with a glyph.  Needed for UTF-8 support. Gwidth may do it better. */
	//"/Gswidth {dup type /stringtype eq {stringwidth} {pop (n) stringwidth} ifelse} def\n",
	//"/MFwidth {0 exch { dup 5 get 3 ge { 5 get 3 eq { 0 } { pop } ifelse }\n",
	//" {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont\n",
	//"     6 get Gswidth pop add} {pop} ifelse} ifelse} forall} def\n",
	//
	// /* flush left show */
	//"/MLshow { currentpoint stroke M\n",
	//"  0 exch R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
	//
	// /* flush right show */
	//"/MRshow { currentpoint stroke M\n",
	//"  exch dup MFwidth neg 3 -1 roll R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
	//
	// /* centred show */
	//"/MCshow { currentpoint stroke M\n",
	//"  exch dup MFwidth -2 div 3 -1 roll R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
	//
	// /* Save and restore for @-text (phantom box) */
	//"/XYsave    { [( ) 1 2 true false 3 ()] } bind def\n",
	//"/XYrestore { [( ) 1 2 true false 4 ()] } bind def\n",
	//
	//NULL
	//};
	//
	// /* external/internal prologue files machinery */
	///#if defined(GNUPLOT_PS_DIR)
	///#if defined(_Windows)
	///#include "win/winmain.h"
	///#elif defined(OS2)
	///#define INCL_DOSPROCESS
	///#define INCL_DOSMODULEMGR
	///#include <os2.h>
	///#endif // _Windows || OS2 
	///#else // GNUPLOT_PS_DIR 
	///#include "PostScript/prologues.h"
	///#endif // GNUPLOT_PS_DIR 
	//
	// /* added to enhpost by Matt Heffron <heffron@falstaff.css.beckman.com> */
	// /* moved to post.trm by drd */
	//
	//static struct PS_FontName {
	//	char *name;
	//	struct PS_FontName *next;
	//} *PS_DocFonts = NULL;
	//
	//static char PS_default_font[MAX_ID_LEN+1] = {'H','e','l','v','e','t','i','c','a',',','1','4','\0'};
	//
	// /* given a font, look in store to see if it is there already
	//  * if so, return NULL. If not, reencode it if allowed to, otherwise
	//  * return an appropriate re-encode string
	//  */
	//
	//static void
	//PS_RememberFont(char *fname)
	//{
	//    struct PS_FontName *fnp;
	//    char *recode = NULL;
	//    char *myfname = "Symbol";
	//
	//    if (strcmp(fname, "Symbol-Oblique") != 0)
	//	myfname = fname;
	//
	//    for (fnp = PS_DocFonts; fnp ; fnp = fnp->next)
	//	if (strcmp(fnp->name, myfname) == 0)
	//	    return;
	//
	// /* Ignore it if illegal characters will corrupt the PostScript syntax */
	//    if (strpbrk(myfname, "{}[]() "))
	//	return;
	//
	// /* we have not seen this font before; store name and apply encoding */
	//    fnp = (struct PS_FontName *)gp_alloc(sizeof(struct PS_FontName),
	//					 "PostScript Font record");
	//    fnp->name = gp_strdup(myfname);
	//    fnp->next = PS_DocFonts;
	//    PS_DocFonts = fnp;
	//
	//    switch(encoding) {
	//    case S_ENC_ISO8859_1:
	//    case S_ENC_UTF8:
	//	recode = "reencodeISO def\n";
	//	break;
	//    case S_ENC_ISO8859_2:
	//	recode = "reencodeISO2 def\n";
	//	break;
	//    case S_ENC_ISO8859_9: // ISO8859-9 is Latin5 
	//    case S_ENC_CP1254:
	//	recode = "reencodeISO9 def\n";
	//	break;
	//    case S_ENC_ISO8859_15: // ISO8859-15 is Latin9 
	//	recode = "reencodeISO15 def\n";
	//	break;
	//    case S_ENC_CP437:
	//	recode = "reencodeCP437 def\n";
	//	break;
	//    case S_ENC_CP850 :
	//	recode = "reencodeCP850 def\n";
	//	break;
	//    case S_ENC_CP852 :
	//	recode = "reencodeCP852 def\n";
	//	break;
	//    case S_ENC_KOI8_R :
	//	recode = "reencodeKOI8R def\n";
	//	break;
	//    case S_ENC_CP1250 :
	//	recode = "reencodeCP1250 def\n";
	//	break;
	//    case S_ENC_KOI8_U :
	//	recode = "reencodeKOI8U def\n";
	//	break;
	//    default:
	// /* do nothing */
	//	break;
	//    }
	//
	//    if (recode) {
	//	if (ENHps_opened_string)
	//	    ENHPS_FLUSH();
	//	fprintf(gppsfile,"/%s %s", fnp->name, recode);
	//    }
	//
	//    return;
	//}
	//
	//char *
	//PS_escape_string(char *origstr, char *escapelist)
	//{
	//    char *newstr;
	//    char *n;
	//
	//    if (!origstr || !*origstr)
	//	return NULL;
	//
	//    newstr = gp_alloc(2*strlen(origstr)+1,"PS_escape_string");
	//    for (n=newstr; *origstr; *n++ = *origstr++) {
	//	if (strchr(escapelist,*origstr))
	//	    *n++ = '\\';
	//    }
	//    *n = '\0';
	//
	//    return newstr;
	//}
	//
	//static int PS_pen_x, PS_pen_y;
	//static int PS_taken;
	//static int PS_linetype_last;
	//static double PS_linewidth_last;
	//static double PS_linewidth_current;
	//static TBOOLEAN PS_relative_ok;
	//
	// /* HBB 990914: PS_SOLID is already used by the WIN32 API headers.
	//  * Renamed to PS_SOLIDE, therefore... */
	//enum PS_id {
	//    PS_PORTRAIT, PS_LANDSCAPE,
	//    PS_EPSF, PS_DEFAULT, PS_ENHANCED, PS_NOENHANCED,
	//    PS_LATEX, EPSLATEX_STANDALONE, EPSLATEX_INPUT,
	//    PS_MONOCHROME, PS_COLOR, PS_BLACKTEXT, PS_COLORTEXT,
	//    PS_SOLIDE, PS_DASHED, PS_DASHLENGTH, PS_LINEWIDTH,
	//    PS_SIMPLEX, PS_DUPLEX, PS_DEFAULTPLEX,
	//    PS_ROUNDED, PS_NOROUNDED, PS_CLIP, PS_NOCLIP, PS_FONTFILE, PS_NOFONTFILES,
	//    PS_PALFUNCPARAM,
	//    PS_LEVEL1, PS_LEVELDEFAULT, PS_FONT,
	//    PSLATEX_ROTATE, PSLATEX_NOROTATE, PSLATEX_AUXFILE, PSLATEX_NOAUXFILE,
	//    PSLATEX_OLDSTYLE, PSLATEX_NEWSTYLE, EPSLATEX_HEADER, EPSLATEX_NOHEADER,
	//    PS_SIZE,
	//    PS_ADOBEGLYPHNAMES, PS_NOADOBEGLYPHNAMES,
	//    PS_OTHER
	//};
	//
	//static struct gen_table PS_opts[] =
	//{
	//    { "d$efault", PS_DEFAULT },
	//    { "p$ortrait", PS_PORTRAIT },
	//    { "l$andscape", PS_LANDSCAPE },
	//    { "ep$sf", PS_EPSF },
	//    { "enh$anced", PS_ENHANCED },
	//    { "noenh$anced", PS_NOENHANCED },
	//    { "m$onochrome", PS_MONOCHROME },
	//    { "c$olor", PS_COLOR },
	//    { "c$olour", PS_COLOR },
	//    { "b$lacktext", PS_BLACKTEXT },
	//    { "colort$ext", PS_COLORTEXT },
	//    { "colourt$ext", PS_COLORTEXT },
	//    { "so$lid", PS_SOLIDE },
	//    { "da$shed", PS_DASHED },
	//    { "dashl$ength", PS_DASHLENGTH },
	//    { "dl", PS_DASHLENGTH },
	//    { "linew$idth", PS_LINEWIDTH },
	//    { "lw", PS_LINEWIDTH },
	//    { "size", PS_SIZE },
	//    { "si$mplex", PS_SIMPLEX },
	//    { "du$plex", PS_DUPLEX },
	//    { "defaultp$lex", PS_DEFAULTPLEX },
	//    { "butt", PS_NOROUNDED },
	//    { "rou$nded", PS_ROUNDED },
	//    { "clip", PS_CLIP },
	//    { "noclip", PS_NOCLIP },
	//    { "fontf$ile", PS_FONTFILE },
	//    { "nofontf$iles", PS_NOFONTFILES },
	//    { "palf$uncparam", PS_PALFUNCPARAM },
	//    { "level1", PS_LEVEL1 },
	//    { "leveldefault", PS_LEVELDEFAULT },
	//    { "font", PS_FONT },
	//    { "stand$alone", EPSLATEX_STANDALONE },
	//    { "inp$ut", EPSLATEX_INPUT },
	//    { "header", EPSLATEX_HEADER },
	//    { "noheader", EPSLATEX_NOHEADER },
	//    { "r$otate", PSLATEX_ROTATE },
	//    { "n$orotate", PSLATEX_NOROTATE },
	//    { "a$uxfile", PSLATEX_AUXFILE },
	//    { "noa$uxfile", PSLATEX_NOAUXFILE },
	//    { "old$style", PSLATEX_OLDSTYLE },
	//    { "new$style", PSLATEX_NEWSTYLE },
	//    { "adobe$glyphnames", PS_ADOBEGLYPHNAMES },
	//    { "noadobe$glyphnames", PS_NOADOBEGLYPHNAMES },
	//    { NULL, PS_OTHER }
	//};
	//
	//
	//TERM_PUBLIC void
	//PS_options()
	//{
	//    char *s;
	//    char *ps_fontfile_char = NULL;
	//    char tmp_term_options[MAX_LINE_LEN+1] = "";
	//
	//    TBOOLEAN set_orientation = FALSE, set_enhanced = FALSE, set_plex = FALSE;
	//    TBOOLEAN set_level = FALSE, set_color = FALSE, set_dashed = FALSE;
	//    TBOOLEAN set_dashlen = FALSE, set_linewidth = FALSE, set_round = FALSE;
	//    TBOOLEAN set_clip = FALSE, set_palfunc = FALSE, set_colortext = FALSE;
	//    TBOOLEAN set_standalone = FALSE, set_epslheader = FALSE;
	//    TBOOLEAN set_pslrotate = FALSE, set_pslauxfile = FALSE;
	//    TBOOLEAN set_psloldstyle = FALSE, set_font = FALSE, set_fontsize = FALSE;
	//
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we have already initialized the terminal.                  */
	//    if (c_token != 2)
	//	ps_explicit_size = FALSE;
	//
	//    if (strcmp(term->name, "pstex") == 0)
	//	ps_params = &pstex_params;
	//    else if (strcmp(term->name, "pslatex") == 0)
	//	ps_params = &pslatex_params;
	//    else if (strcmp(term->name, "epslatex") == 0) {
	//	ps_params = &epslatex_params;
	//    } else
	//	ps_params = &post_params;
	//
	//    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
	//	if (pslatex_auxname)
	//	    free(pslatex_auxname);
	//	pslatex_auxname = NULL;
	//    } else {
	//	term->set_font = PS_set_font;
	//    }
	//
	//    if (!END_OF_COMMAND) {
	//	if (lookup_table(&PS_opts[0],c_token) == PS_DEFAULT) {
	//	    switch (ps_params->terminal) {
	//	    case PSTERM_POSTSCRIPT:
	//		while (ps_params->first_fontfile != NULL)
	//		    delete_ps_fontfile((struct ps_fontfile_def *) NULL,
	//				       ps_params->first_fontfile);
	//		*ps_params = post_params_default;
	//		break;
	//	    case PSTERM_EPSLATEX:
	//		*ps_params = epslatex_params_default;
	//		break;
	//	    case PSTERM_PSLATEX:
	//		*ps_params = pslatex_params_default;
	//		break;
	//	    case PSTERM_PSTEX:
	//		*ps_params = pstex_params_default;
	//		break;
	//	    }
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    c_token++;
	//	    if (!END_OF_COMMAND) 
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	}
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&PS_opts[0],c_token)) {
	//	case PS_PORTRAIT:
	//	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_orientation = TRUE;
	//	    ps_params->psformat = PSTERM_PORTRAIT;
	//	    c_token++;
	//	    break;
	//	case PS_LANDSCAPE:
	//	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_orientation = TRUE;
	//	    ps_params->psformat = PSTERM_LANDSCAPE;
	//	    c_token++;
	//	    break;
	//	case PS_EPSF:
	//	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_orientation = TRUE;
	//	    ps_params->psformat = PSTERM_EPS;
	//	    c_token++;
	//	    break;
	//	case PS_LEVEL1:
	//	    if (set_level)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_level = TRUE;
	//	    ps_params->level1 = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_LEVELDEFAULT:
	//	    if (set_level)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_level = TRUE;
	//	    ps_params->level1 = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_DEFAULT:
	//	    int_error(c_token,
	//		      "extraneous argument in set terminal %s",term->name);
	//	    c_token++;
	//	    break;
	//	case PS_ENHANCED:
	//	    if (set_enhanced || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_enhanced = TRUE;
	//	    term->put_text = ENHPS_put_text;
	//	    term->set_font = ENHPS_set_font;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    ++c_token;
	//	    break;
	//	case PS_NOENHANCED:
	//	   if (set_enhanced || ps_params->terminal != PSTERM_POSTSCRIPT)
	//	        int_error(c_token,
	//	                  "extraneous argument in set terminal %s",term->name);
	//	    set_enhanced = TRUE;
	//	    term->put_text = PS_put_text;
	//	    term->set_font = PS_set_font;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    ++c_token;
	//	    break;
	///#ifdef PSLATEX_DRIVER
	//	case EPSLATEX_STANDALONE:
	//	    if (set_standalone || ps_params->terminal != PSTERM_EPSLATEX)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_standalone = TRUE;
	//	    ps_params->epslatex_standalone = TRUE;
	//	    ++c_token;
	//	    break;
	//	case EPSLATEX_INPUT:
	//	    if (set_standalone || ps_params->terminal != PSTERM_EPSLATEX)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_standalone = TRUE;
	//	    ps_params->epslatex_standalone = FALSE;
	//	    ++c_token;
	//	    break;
	//
	//	case EPSLATEX_HEADER:
	//	    if (set_epslheader || ps_params->terminal != PSTERM_EPSLATEX)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_epslheader = TRUE;
	//	    ++c_token;
	//	    free(epslatex_header);
	// /* Protect against int_error() bail from try_to_get_string() */
	//		epslatex_header = NULL;
	//	    epslatex_header = try_to_get_string();
	//	    if (!epslatex_header)
	//		int_error(c_token,"String containing header information expected");
	//	    break;
	//
	//	case EPSLATEX_NOHEADER:
	//	    if (set_epslheader || ps_params->terminal != PSTERM_EPSLATEX)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_epslheader = TRUE;
	//	    free(epslatex_header);
	//	    epslatex_header = NULL;
	//	    ++c_token;
	//	    break;
	//
	//	case PSLATEX_ROTATE:
	//	    if (set_pslrotate || ((ps_params->terminal != PSTERM_PSLATEX) &&
	//				  (ps_params->terminal != PSTERM_PSTEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_pslrotate = TRUE;
	//	    ps_params->rotate = TRUE;
	//	    ++c_token;
	//	    break;
	//	case PSLATEX_NOROTATE:
	//	    if (set_pslrotate || ((ps_params->terminal != PSTERM_PSLATEX) &&
	//				  (ps_params->terminal != PSTERM_PSTEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_pslrotate = TRUE;
	//	    ps_params->rotate = FALSE;
	//	    ++c_token;
	//	    break;
	//	case PSLATEX_AUXFILE:
	//	    if (set_pslauxfile ||
	//		((ps_params->terminal == PSTERM_POSTSCRIPT) ||
	//		 (ps_params->terminal == PSTERM_EPSLATEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_pslauxfile = TRUE;
	//	    ps_params->useauxfile = TRUE;
	//	    c_token++;
	//	    break;
	//	case PSLATEX_NOAUXFILE:
	//	    if (set_pslauxfile ||
	//		((ps_params->terminal == PSTERM_POSTSCRIPT) ||
	//		 (ps_params->terminal == PSTERM_EPSLATEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_pslauxfile = TRUE;
	//	    ps_params->useauxfile = FALSE;
	//	    c_token++;
	//	    break;
	//	case PSLATEX_OLDSTYLE:
	//	    if (set_psloldstyle || ps_params->terminal == PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_psloldstyle = TRUE;
	//	    ps_params->oldstyle = TRUE;
	//	    if (ps_params->terminal == PSTERM_EPSLATEX)
	//		ps_params->rounded = TRUE;
	//	    c_token++;
	//	    break;
	//	case PSLATEX_NEWSTYLE:
	//	    if (set_psloldstyle || ps_params->terminal == PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_psloldstyle = TRUE;
	//	    ps_params->oldstyle = FALSE;
	//	    c_token++;
	//	    break;
	///#endif
	//	case PS_MONOCHROME:
	//	    if (set_color)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_color = TRUE;
	//	    ps_params->color = FALSE;
	//	    term->flags |= TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case PS_COLOR:
	//	    if (set_color)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_color = TRUE;
	//	    ps_params->color = TRUE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case PS_BLACKTEXT:
	//	    if (set_colortext || ((ps_params->terminal != PSTERM_POSTSCRIPT) &&
	//				  (ps_params->terminal != PSTERM_EPSLATEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_colortext = TRUE;
	//	    ps_params->blacktext = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_COLORTEXT:
	//	    if (set_colortext || ((ps_params->terminal != PSTERM_POSTSCRIPT) &&
	//				  (ps_params->terminal != PSTERM_EPSLATEX)))
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_colortext = TRUE;
	//	    ps_params->blacktext = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_SOLIDE:
	//	    if (set_dashed)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_dashed = TRUE;
	//	    ps_params->solid = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_DASHED:
	//	    if (set_dashed)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_dashed = TRUE;
	//	    ps_params->solid = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_DASHLENGTH:
	//	    if (set_dashlen)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_dashlen = TRUE;
	//	    c_token++;
	//	    ps_params->dash_length = real_expression();
	//	    if (ps_params->dash_length <= 0.0)
	//		ps_params->dash_length = 1.0;
	//	    break;
	//	case PS_LINEWIDTH:
	//	    if (set_linewidth)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_linewidth = TRUE;
	//	    c_token++;
	//	    ps_params->linewidth_factor = real_expression();
	//	    if (ps_params->linewidth_factor <= 0.0)
	//		ps_params->linewidth_factor = 1.0;
	//	    break;
	//	case PS_SIMPLEX:
	//	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_plex = TRUE;
	//	    ps_params->duplex_state  = FALSE;
	//	    ps_params->duplex_option = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_DUPLEX:
	//	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_plex = TRUE;
	//	    ps_params->duplex_state  = TRUE;
	//	    ps_params->duplex_option = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_DEFAULTPLEX:
	//	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_plex = TRUE;
	//	    ps_params->duplex_option = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_ROUNDED:
	//	    if (set_round)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_round = TRUE;
	//	    ps_params->rounded = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_NOROUNDED:
	//	    if (set_round)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_round = TRUE;
	//	    ps_params->rounded = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_CLIP:
	//	    if (set_clip)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_clip = TRUE;
	//	    ps_params->clipped = TRUE;
	//	    c_token++;
	//	    break;
	//	case PS_NOCLIP:
	//	    if (set_clip)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_clip = TRUE;
	//	    ps_params->clipped = FALSE;
	//	    c_token++;
	//	    break;
	//	case PS_FONTFILE: {
	//	    TBOOLEAN deleteentry = FALSE;
	//	    char *fontfilename = NULL;
	//	    c_token++;
	//	    if (ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//
	//	    if (equals(c_token, "add"))
	//		c_token++;
	//	    else if (almost_equals(c_token, "del$ete")) {
	//		deleteentry = TRUE;
	//		c_token++;
	//	    }
	//
	//	    if (!(fontfilename = try_to_get_string())) {
	//		int_error(c_token, "Font filename expected");
	//	    } else {
	//		TBOOLEAN filename_doubled = FALSE;
	//		struct ps_fontfile_def *curr_ps_fontfile = 
	//		    ps_params->first_fontfile;
	//		struct ps_fontfile_def *prev_ps_fontfile = NULL;
	//		struct ps_fontfile_def *new_ps_fontfile =
	//		     gp_alloc(sizeof(struct ps_fontfile_def),
	//			     "new_ps_fontfile");
	//
	//		new_ps_fontfile->fontfile_name =
	//		    gp_alloc (token_len(c_token),
	//			      "new_ps_fontfile->fontfile_name");
	//		gp_expand_tilde(&fontfilename);
	//		new_ps_fontfile->fontfile_name = fontfilename;
	//		new_ps_fontfile->fontname = NULL;
	//		if (!deleteentry) {
	///#if defined(PIPES)
	//		    if (*(new_ps_fontfile->fontfile_name) != '<') {
	///#endif
	//			new_ps_fontfile->fontfile_fullname =
	//			    fontpath_fullname(new_ps_fontfile->fontfile_name);
	//			if (!new_ps_fontfile->fontfile_fullname)
	//			    int_error(c_token-1, "Font file '%s' not found",
	//				      new_ps_fontfile->fontfile_name);
	///#if defined(PIPES)
	//		    } else
	//			new_ps_fontfile->fontfile_fullname = NULL;
	///#endif
	//
	//		}
	//		new_ps_fontfile->next = NULL;
	//
	//		if (!deleteentry) {
	//		    LFS *lf=lf_head;
	//		    if (lf) {
	//			while (lf->prev)
	//			    lf=lf->prev;
	//		    }
	//		    if ((lf && lf->interactive) || interactive)
	//			PS_load_fontfile(new_ps_fontfile,FALSE);
	//		}
	//
	//		if (ps_params->first_fontfile) {
	//		    while (curr_ps_fontfile) {
	//			if (strcmp(curr_ps_fontfile->fontfile_name,
	//				   new_ps_fontfile->fontfile_name) == 0) {
	//			    filename_doubled = TRUE;
	//			    if (deleteentry) {
	//				delete_ps_fontfile(prev_ps_fontfile,
	//						   curr_ps_fontfile);
	//				curr_ps_fontfile = NULL;
	//				break;
	//			    }
	//			}
	//			prev_ps_fontfile = curr_ps_fontfile;
	//			curr_ps_fontfile = curr_ps_fontfile->next;
	//		    }
	//		    if (!filename_doubled) {
	//			if (!deleteentry)
	//			    prev_ps_fontfile->next = new_ps_fontfile;
	//			else
	//			    int_warn(c_token-1,"Can't delete Font filename '%s'",
	//				     new_ps_fontfile->fontfile_name);
	//		    }
	//		} else {
	//		    if (!deleteentry)
	//			ps_params->first_fontfile = new_ps_fontfile;
	//		    else
	//			int_warn(c_token-1, "Can't delete Font filename '%s'",
	//				 new_ps_fontfile->fontfile_name);
	//		}
	//	    }
	//	    break;
	//	}
	//	case PS_NOFONTFILES:
	//	    if (ps_params->terminal != PSTERM_POSTSCRIPT)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    while (ps_params->first_fontfile != NULL)
	//		delete_ps_fontfile((struct ps_fontfile_def *) NULL,
	//				   ps_params->first_fontfile);
	//	    ++c_token;
	//	    break;
	//	case PS_ADOBEGLYPHNAMES:
	//	    ps_params->adobeglyphnames = TRUE;
	//	    ++c_token;
	//	    break;
	//	case PS_NOADOBEGLYPHNAMES:
	//	    ps_params->adobeglyphnames = FALSE;
	//	    ++c_token;
	//	    break;
	//	case PS_PALFUNCPARAM:
	//	    if (set_palfunc)
	//		int_error(c_token,
	//			  "extraneous argument in set terminal %s",term->name);
	//	    set_palfunc = TRUE;
	//	    ++c_token;
	//	    ps_params->palfunc_samples = int_expression();
	//	    if (ps_params->palfunc_samples < 2)
	//		ps_params->palfunc_samples = 2;
	//	    if (!END_OF_COMMAND && equals(c_token, ",")) {
	//		++c_token;
	//		ps_params->palfunc_deviation = fabs(real_expression());
	//		if (ps_params->palfunc_deviation >= 1)
	//		    int_error(c_token-1,"allowed deviation must be < 1");
	//	    }
	//	    break;
	//	
	//	case PS_SIZE:
	//	    {
	//	    float xmax_t, ymax_t;
	//
	//	    c_token++;
	//	    ps_explicit_size = TRUE;
	//	    ps_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
	//
	// /* PostScript *always* works in pts, not locally defined dpi */
	//	    term->xmax = xmax_t * PS_SC * 72./gp_resolution;
	//	    term->ymax = ymax_t * PS_SC * 72./gp_resolution;
	//	    eps_explicit_x = 2 * term->xmax;
	//	    eps_explicit_y = 2 * term->ymax;
	//	    break;
	//	    }
	//	
	//	case PS_FONT:
	//	    c_token++;
	// /* Fall through to attempt to read font name */
	//	case PS_OTHER:
	//	default:
	//	    if ((s = try_to_get_string())) {
	//		if (set_font)
	//		    int_error(c_token,
	//			      "extraneous argument in set terminal %s",
	//			      term->name);
	//		set_font = TRUE;
	//		if ((ps_params->terminal == PSTERM_POSTSCRIPT) ||
	//		    (ps_params->terminal == PSTERM_EPSLATEX)) {
	//		    char *comma = strrchr(s,',');
	//		    if (comma && (1 == sscanf(comma+1,"%f",&ps_params->fontsize))) {
	//			set_fontsize = TRUE;
	//			*comma = '\0';
	//		    }
	//		    if (*s) {
	// /* Filter out characters that would confuse PostScript */
	//			if (strpbrk(s, "()[]{}| ")) {
	//			    int_warn(c_token-1,"Illegal characters in PostScript font name.");
	//			    int_warn(NO_CARET,"I will try to fix it but this may not work.");
	//			    while (strpbrk(s, "()[]{}| "))
	//				*(strpbrk(s, "()[]{}| ")) = '-';
	//			}
	//			strncpy(ps_params->font, s, sizeof(ps_params->font));
	//		    }
	//		    free(s);
	//		} else
	//		    int_error(c_token-1,
	//			      "terminal %s does not allow specification %s",
	//			      term->name, "of font name");
	//	    } else {
	//		if (set_fontsize)
	//		    int_error(c_token,
	//			      "extraneous argument in set terminal %s",
	//			      term->name);
	//		set_fontsize = TRUE;
	// /* We have font size specified */
	//		ps_params->fontsize = real_expression();
	//	    }
	//	    break;
	//	}
	//    }
	//
	//    switch (ps_params->terminal) {
	//    case PSTERM_POSTSCRIPT:
	//	ps_fontsize = ps_params->fontsize;
	//	break;
	//    case PSTERM_EPSLATEX:
	//	ps_fontsize = 2 * ps_params->fontsize;
	//	break;
	//    case PSTERM_PSLATEX:
	//    case PSTERM_PSTEX:
	//	if (ps_params->fontsize > 0)
	//	    ps_fontsize = 2 * ps_params->fontsize;
	//	else
	//	    ps_fontsize = 20; // default: 10pt 
	//	break;
	//    }
	//    term->v_char = (unsigned int)(ps_fontsize*PS_SC);
	//    if (ps_params->oldstyle)
	//	term->h_char = (unsigned int)(ps_fontsize*PS_SC*5/10);
	//    else
	//	term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	//    sprintf(PS_default_font,"%s,%g",ps_params->font,ps_fontsize);
	//
	//    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
	//	if (ps_params->first_fontfile) {
	//	    struct ps_fontfile_def *curr_ps_fontfile =
	//		ps_params->first_fontfile;
	//	    unsigned int totlength = 0;
	//	    char *running;
	//
	//	    while (curr_ps_fontfile) {
	//		totlength += strlen(curr_ps_fontfile->fontfile_name) +
	//		    strlen(" fontfile \"\"");
	//		curr_ps_fontfile = curr_ps_fontfile->next;
	//	    }
	//	    curr_ps_fontfile = ps_params->first_fontfile;
	//	    ps_fontfile_char = gp_alloc (totlength+1,"ps_fontfile_char");
	//	    running = ps_fontfile_char;
	//	    while (curr_ps_fontfile) {
	//		sprintf(running," fontfile \"%s\"",
	//			curr_ps_fontfile->fontfile_name);
	//		running += strlen(running);
	//		curr_ps_fontfile = curr_ps_fontfile->next;
	//	    }
	//	}
	//    }
	//
	// /* HBB 19990823: fixed the options string. It violated the 'save
	//  * loadable output' rule */
	//    if (ps_params->terminal == PSTERM_POSTSCRIPT)
	//	sprintf(term_options,"%s %s %s \\\n",
	//		ps_params->psformat==PSTERM_EPS ? "eps" :
	//		(ps_params->psformat==PSTERM_PORTRAIT ?
	//		 "portrait" : "landscape"),
	//		term->put_text == ENHPS_put_text ? "enhanced" : "noenhanced",
	//		ps_params->duplex_option ? (ps_params->duplex_state ?
	//					    "duplex" : "simplex")
	//		: "defaultplex");
	//    else if (ps_params->terminal != PSTERM_EPSLATEX)
	//	sprintf(term_options, "%s%s",
	//		ps_params->rotate ? "rotate" : "norotate",
	//		ps_params->useauxfile ? " auxfile" : "");
	//    else
	//	term_options[0] = '\0';
	//
	//    sprintf(tmp_term_options,"   %s %s %s \\\n
	//   %s dashlength %.1f linewidth %.1f %s %s \\\n",
	//	    ps_params->level1 ? "level1" : "leveldefault",
	//	    ps_params->color ? "color" : "monochrome",
	//	    ps_params->blacktext ? "blacktext" : "colortext",
	//	    ps_params->solid ? "solid" : "dashed",
	//	    ps_params->dash_length,
	//	    ps_params->linewidth_factor,
	//	    ps_params->rounded ? "rounded" : "butt",
	//	    ps_params->clipped ? "clip" : "noclip");
	//    strcat(term_options,tmp_term_options);
	//
	//    sprintf(tmp_term_options,"   palfuncparam %d,%g \\\n   ",
	//	    ps_params->palfunc_samples, ps_params->palfunc_deviation);
	//    strcat(term_options,tmp_term_options);
	//
	///#ifdef PSLATEX_DRIVER
	//    if ((ps_params->terminal == PSTERM_PSTEX) ||
	//	(ps_params->terminal == PSTERM_PSLATEX)) {
	//	sprintf(tmp_term_options, "%s %s ",
	//		ps_params->rotate ? "rotate" : "norotate",
	//		ps_params->useauxfile ? "auxfile" : "noauxfile");
	//	strcat(term_options,tmp_term_options);
	//    }
	//
	//    if (ps_params->terminal == PSTERM_EPSLATEX) {
	//	sprintf(tmp_term_options, "%s ",
	//		ps_params->epslatex_standalone ? "standalone" : "input");
	//	if (epslatex_header)
	//	    sprintf(tmp_term_options, "header \"%s\" ", epslatex_header);
	//	else
	//	    sprintf(tmp_term_options, "noheader ");
	//	strcat(term_options,tmp_term_options);
	//    }
	///#endif
	//
	//    if ((encoding == S_ENC_UTF8) && (ps_params->terminal == PSTERM_POSTSCRIPT)) {
	//	sprintf(tmp_term_options," %sadobeglyphnames \\\n   ",
	//	    ps_params->adobeglyphnames ? "" : "no");
	//	strcat(term_options,tmp_term_options);
	//    }
	//
	//    if (ps_explicit_size) {
	//	if (ps_explicit_units == CM)
	//	    sprintf(tmp_term_options,"size %.2fcm, %.2fcm ",
	//		2.54*(float)term->xmax/(72.*PS_SC), 2.54*(float)term->ymax/(72.*PS_SC));
	//	else
	//	    sprintf(tmp_term_options,"size %.2fin, %.2fin ",
	//		(float)term->xmax/(72.*PS_SC), (float)term->ymax/(72.*PS_SC));
	//	strcat(term_options,tmp_term_options);
	//    }
	//
	//    if (ps_params->terminal == PSTERM_POSTSCRIPT)
	//	sprintf(tmp_term_options,"\"%s\" %g%s ",
	//		ps_params->font,ps_params->fontsize,
	//		ps_fontfile_char ? ps_fontfile_char : "");
	//    else if (ps_params->terminal == PSTERM_EPSLATEX)
	//	sprintf(tmp_term_options,"\"%s\" %g ",
	//		ps_params->font,ps_params->fontsize);
	//    else if (ps_params->fontsize)
	//	sprintf(tmp_term_options,"%g ",ps_params->fontsize);
	//    else
	//	tmp_term_options[0]='\0';
	//    if (ps_fontfile_char)
	//	free(ps_fontfile_char);
	//
	//    strcat(term_options,tmp_term_options);
	//
	//}
	//
	// /* store settings passed to common_init() for use in PS_graphics()
	//  * ps_params->psformat, etc are reserved for storing the term options
	//  */
	//static TBOOLEAN ps_common_uses_fonts;
	//static unsigned int ps_common_xoff, ps_common_yoff;
	//
	// /* The default UTF8 code will use glyph identifiers uniXXXX for all glyphs above 0x0100.
	//  * If you define ADOBE_ENCODING_NAMES, then it will instead use the glyph names from the
	//  * file aglfn.txt.  Names in the range 0x0100 - 0x01FF correspond to those used by the
	//  * Latin1 encoding scheme.  This unicode code page deliberately uses the same character
	//  * mapping as Latin1.  Adobe also recommends names for many characters outside this 
	//  * range, but not all fonts adhere to this.  You can substitute a different aglfn.txt
	//  * file at run time if you want to use a different scheme.
	//  */
	///#define ADOBE_ENCODING_NAMES 1
	//
	///#if (ADOBE_ENCODING_NAMES)
	//
	//typedef struct ps_glyph {
	//  unsigned long unicode;
	//  char * glyphname;
	//} ps_glyph;
	//
	//static ps_glyph *aglist = NULL;
	//static int aglist_alloc = 0;
	//static int aglist_size = 0;
	//static int psglyphs = 0;
	//
	///#endif
	//
	//TERM_PUBLIC void
	//PS_load_fontfile(struct ps_fontfile_def *current_ps_fontfile, TBOOLEAN doload)
	//{
	//    if (current_ps_fontfile) {
	//	unsigned int linesread = 0;
	//	FILE *ffont = NULL;
	//	char line[256];
	//	char ext[4];
	//	char cmd[256];
	//	char *fontname = NULL;
	///#if defined(PIPES)
	//	char *envcmd = NULL;
	//	TBOOLEAN ispipe = FALSE;
	///#endif
	//
	//	ext[0] = '\0';
	//	cmd[0] = '\0';
	//
	//	if (doload)
	//	    fprintf(gppsfile,"%%%%BeginProcSet: %s\n",
	//		    current_ps_fontfile->fontfile_name);
	//
	// /* get filename extension if no pipe (if pipe *ext=='\0') */
	///#if defined(PIPES)
	//	if (*(current_ps_fontfile->fontfile_name) != '<') {
	// /* Filename is given */
	///#endif
	//	    if (strlen(current_ps_fontfile->fontfile_name) > 3)
	//		strcpy(ext, current_ps_fontfile->fontfile_name +
	//		       strlen(current_ps_fontfile->fontfile_name) - 3);
	//	    else
	//		strcpy(ext, current_ps_fontfile->fontfile_name);
	//
	// /* make extension lowercase for comparison */
	//	    lower_case(ext);
	//
	//	    if (!current_ps_fontfile->fontfile_fullname)
	//		int_error(NO_CARET, "Font file '%s' not found",
	//			  current_ps_fontfile->fontfile_name);
	///#if defined(PIPES)
	//	}
	///#endif
	//	if (strlen(ext) == 0) {
	///#if defined(PIPES)
	// /* Pipe is given */
	//	    ispipe = TRUE;
	//	    strcpy(cmd,current_ps_fontfile->fontfile_name + 1);
	//	    ffont = popen(cmd, "r");
	//	    if (!ffont)
	//		int_error(NO_CARET, "Could not execute pipe '%s'",
	//			  current_ps_fontfile->fontfile_name + 1);
	///#endif
	//	}
	//	else if (!strcmp(ext,"ttf") || !strcmp(ext,"otf")) {
	// /* TrueType */
	///#if defined(PIPES)
	//	    ispipe = TRUE;
	//	    envcmd = getenv("GNUPLOT_TTFTOPFA");
	//	    if (envcmd != NULL)
	//		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
	//	    else
	//		sprintf(cmd,"ttf2pt1 -a -e -W 0 %s -",
	//			current_ps_fontfile->fontfile_fullname);
	//	    if (strlen(cmd) == 0)
	//		int_error(NO_CARET,
	//			  "No command for automatic font conversion ttf->pfa defined");
	//	    else {
	//		ffont = popen(cmd,"r");
	//		if (!ffont)
	//		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
	//	    }
	///#else
	//	    os_error(NO_CARET,
	//		     "Automatic font conversion ttf->pfa not supported");
	///#endif
	//	} else if (strcmp(ext,"pfb") == 0) {
	// /* PFB */
	///#if defined(PIPES)
	//	    ispipe = TRUE;
	//	    envcmd = getenv("GNUPLOT_PFBTOPFA");
	//	    if (envcmd != NULL)
	//		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
	//	    else
	//		sprintf(cmd,"pfbtops %s",
	//			current_ps_fontfile->fontfile_fullname);
	//	    if (strlen(cmd) == 0)
	//		int_error(NO_CARET,
	//			  "No command for automatic font conversion pfb->pfa defined");
	//	    else {
	//		ffont = popen(cmd,"r");
	//		if (!ffont)
	//		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
	//	    }
	///#else
	//	    os_error(NO_CARET,
	//		     "Automatic font conversion pfb->pfa not supported");
	///#endif
	//	} else {
	// /* PFA */
	//	    if (strcmp(ext,"pfa") != 0)
	//		int_warn(NO_CARET,
	//			 "Font file '%s' has unknown extension. Assume it is a pfa file",
	//			 current_ps_fontfile->fontfile_name);
	//	    ffont = fopen(current_ps_fontfile->fontfile_fullname, "r");
	//	    if (!ffont)
	//		int_error(NO_CARET, "Font file '%s' not found",
	//			  current_ps_fontfile->fontfile_name);
	//	}
	// /* read the file */
	//	while (fgets(line,255,ffont)) {
	// /* test file format */
	//	    if ((linesread == 0) &&
	//		 (strstr(line,"%!PS-AdobeFont") != line) &&
	//		 (strstr(line,"%!FontType1") != line)) {
	///#if defined(PIPES)
	//		if (ispipe)
	//		    int_warn(NO_CARET,
	//			     "Command '%s' seems not to generate PFA data",
	//			     cmd);
	//		else
	///#endif
	//		    int_warn(NO_CARET,
	//			     "Font file '%s' seems not to be a PFA file",
	//			     current_ps_fontfile->fontfile_name);
	//	    }
	// /* get fontname */
	//	    if (strstr(line,"/FontName") == line) {
	//		char *fnende = NULL;
	//		fontname = gp_alloc(strlen(line)-9,"load_fontfiles");
	//		strcpy(fontname,strstr(line+1,"/")+1);
	//		fnende = strstr(fontname," ");
	//		*fnende = '\0';
	//		current_ps_fontfile->fontname = gp_strdup(fontname);
	// /* Print font name */
	//		if (!doload) {
	//		    if (current_ps_fontfile->fontfile_fullname)
	//			fprintf(stderr,
	//				"Font file '%s' contains the font '%s'. Location:\n   %s\n",
	//				current_ps_fontfile->fontfile_name,
	//				fontname,
	//				current_ps_fontfile->fontfile_fullname);
	//		    else
	//			fprintf(stderr,
	//				"Pipe '%s' contains the font '%s'.\n",
	//				current_ps_fontfile->fontfile_name,
	//				fontname);
	///#if defined(PIPES)
	// /* Stop reading font file in order to save time */
	// /* This does not work for pipes because they give the */
	// /* error message 'broken pipe' */
	//		    if (!ispipe)
	///#endif
	//			break;
	//		}
	//	    }
	//
	//	    if (doload)
	//		fputs(line, gppsfile);
	//
	//	    ++linesread;
	//	}
	///#if defined(PIPES)
	//	if (ispipe) {
	//	    int exitcode;
	//	    if ((exitcode = pclose(ffont)) != 0)
	//		int_error(NO_CARET,
	//			  "Command '%s' generated error, exitcode is %d",
	//			  cmd, exitcode);
	//	}
	//	else
	///#endif
	//	    fclose(ffont);
	//
	//	if (linesread == 0) {
	///#if defined(PIPES)
	//	    if (ispipe)
	//		int_error(NO_CARET,
	//			  "Command '%s' generates empty output",
	//			  cmd);
	//	    else
	///#endif
	//		int_error(NO_CARET, "Font file '%s' is empty",
	//			  current_ps_fontfile->fontfile_name);
	//	}
	//	if (doload)
	//	    fputs("%%EndProcSet\n", gppsfile);
	//
	// /* Computer Modern Symbol font with corrected baseline if the
	//  * font CMEX10 is embedded */
	//	if (doload && fontname && (strcmp(fontname,"CMEX10") == 0)) {
	//	    fputs("%%BeginProcSet: CMEX10-Baseline\n", gppsfile);
	//	    fputs("/CMEX10-Baseline /CMEX10 findfont [1 0 0 1 0 1] makefont\n",
	//		  gppsfile);
	//	    fputs("dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n", gppsfile);
	//	    fputs("currentdict end definefont pop\n", gppsfile);
	//	    fputs("%%EndProcSet\n",gppsfile);
	//	}
	//
	//	if (fontname) {
	//	    free(fontname);
	//	    fontname = NULL;
	//	}
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_load_fontfiles(TBOOLEAN doload)
	//{
	//    struct ps_fontfile_def *current_ps_fontfile=ps_params->first_fontfile;
	//
	//    while (current_ps_fontfile) {
	//	PS_load_fontfile(current_ps_fontfile,doload);
	//	if (current_ps_fontfile->fontname)
	//		PS_RememberFont(current_ps_fontfile->fontname);
	//	current_ps_fontfile = current_ps_fontfile->next;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_common_init(
	//    TBOOLEAN uses_fonts,		// FALSE for (e)ps(la)tex 
	//    unsigned int xoff, unsigned int yoff, // how much to translate by 
	//    unsigned int bb_xmin, unsigned int bb_ymin,
	//    unsigned int bb_xmax, unsigned int bb_ymax, // bounding box 
	//    const char **dict) // extra entries for the dictionary 
	//{
	//    static const char GPFAR psi1[] = "
	//%%%%Creator: gnuplot %s patchlevel %s\n
	//%%%%CreationDate: %s\n
	//%%%%DocumentFonts: %s\n";
	//
	//    static const char GPFAR psi2[] = "
	//%%%%EndComments\n
	//%%%%BeginProlog\n
	///gnudict 256 dict def\ngnudict begin\n
	//%%\n
	//%% The following true/false flags may be edited by hand if desired.\n
	//%% The unit line width and grayscale image gamma correction may also be changed.\n
	//%%\n
	///Color %s def\n
	///Blacktext %s def\n
	///Solid %s def\n
	///Dashlength %g def\n
	///Landscape %s def\n
	///Level1 %s def\n
	///Rounded %s def\n
	///ClipToBoundingBox %s def\n
	///TransparentPatterns false def\n
	///gnulinewidth %.3f def\n
	///userlinewidth gnulinewidth def\n
	///Gamma 1.0 def\n
	//%%\n
	///vshift %d def\n
	///dl1 {\n
	//  %.1f Dashlength mul mul\n
	//  Rounded { currentlinewidth 0.75 mul sub dup 0 le { pop 0.01 } if } if\n
	//} def\n
	///dl2 {\n
	//  %.1f Dashlength mul mul\n
	//  Rounded { currentlinewidth 0.75 mul add } if\n
	//} def\n
	///hpt_ %.1f def\n
	///vpt_ %.1f def\n
	///hpt hpt_ def\n
	///vpt vpt_ def\n";
	//
	//    static const char GPFAR psi3[] = "
	//Level1 {} {\n
	///SDict 10 dict def\n
	//systemdict /pdfmark known not {\n
	//  userdict /pdfmark systemdict /cleartomark get put\n
	//} if\n
	//SDict begin [\n
	//  /Title (%s)\n
	//  /Subject (gnuplot plot)\n
	//  /Creator (gnuplot %s patchlevel %s)\n
	//  /Author (%s)\n
	//%%  /Producer (gnuplot)\n
	//%%  /Keywords ()\n
	//  /CreationDate (%s)\n
	//  /DOCINFO pdfmark\n
	//end\n
	//} ifelse\n";
	//
	//
	//    struct termentry *t = term;
	//    int i;
	//    time_t now;
	//    char *timedate;
	//
	//    ps_common_uses_fonts = uses_fonts;
	//    ps_common_xoff = xoff;
	//    ps_common_yoff = yoff;
	//
	//    ps_page = 0;
	//
	//    time(&now);
	//    timedate=asctime(localtime(&now));
	//    timedate[strlen(timedate)-1]='\0';
	//
	///#ifdef PSLATEX_DRIVER
	// /* Set files for (e)ps(la)tex terminals */
	//    switch (ps_params->terminal) {
	//    case PSTERM_EPSLATEX:
	//	EPSLATEX_common_init();
	//	break;
	//    case PSTERM_PSLATEX:
	//    case PSTERM_PSTEX:
	//	PSTEX_common_init();
	//	break;
	//    default:; // do nothing, just avoid a compiler warning 
	//    }
	///#endif
	//
	//    if (ps_params->psformat == PSTERM_EPS)
	//	fputs("%!PS-Adobe-2.0 EPSF-2.0\n", gppsfile);
	//    else
	//	fputs("%!PS-Adobe-2.0\n", gppsfile);
	//
	//    if (outstr)
	//	fprintf(gppsfile, "%%%%Title: %s\n", outstr);   //  JFi  
	//    fprintf(gppsfile, psi1, gnuplot_version, gnuplot_patchlevel,
	//	    timedate, uses_fonts ? "(atend)" : "");
	//
	//    fprintf(gppsfile,"%%%%BoundingBox: %d %d %d %d\n",
	//	    xoff + bb_xmin, yoff + bb_ymin, xoff + bb_xmax, yoff + bb_ymax);
	//
	//    if ((ps_params->terminal == PSTERM_POSTSCRIPT) &&
	//	(ps_params->psformat != PSTERM_EPS))
	//	fprintf(gppsfile,"%%%%Orientation: %s\n",
	//		ps_params->psformat == PSTERM_LANDSCAPE ?
	//		"Landscape" : "Portrait");
	//
	//    if (ps_params->psformat != PSTERM_EPS)
	//	fputs("%%Pages: (atend)\n", gppsfile);
	//    fprintf(gppsfile, psi2,
	//	    ps_params->color ? "true" : "false",
	//	    ps_params->blacktext ? "true" : "false",
	//	    ps_params->solid ? "true" : "false",
	//	    ps_params->dash_length,	// dash length 
	//	    ps_params->psformat == PSTERM_LANDSCAPE ? "true" : "false",
	//	    ps_params->level1 ? "true" : "false",
	//	    ps_params->rounded ? "true" : "false",
	//	    ps_params->clipped ? "true" : "false",
	//	    PS_LW*ps_params->linewidth_factor,	// line width 
	//	    (int)(t->v_char)/(-3),	// shift for vertical centring 
	//	    PS_SC*1.0,	// dash length 
	//	    PS_SC*1.0,	// dash length 
	//	    PS_HTIC/2.0,		// half point width 
	//	    PS_VTIC/2.0);		// half point height 
	//
	// /* HH: print pdf information interpreted by ghostscript/acrobat */
	//    {
	//	char *username=getusername();
	//	char *username2=PS_escape_string(username,"()\\");
	//	char *outstr2=PS_escape_string(outstr,"()\\");
	//	fprintf(gppsfile, psi3,
	//		outstr2?outstr2:"",
	//		gnuplot_version, gnuplot_patchlevel,
	//		username2?username2:"", 
	//		timedate);
	//	if (username)
	//	    free(username);
	//	if (username2)
	//	    free(username2);
	//	if (outstr2)
	//	    free(outstr2);
	//    }
	//
	// /* HH: Clip to BoundingBox if the corresponding flag is toggled */
	//    fprintf(gppsfile,"
	///doclip {\n
	//  ClipToBoundingBox {\n
	//    newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto closepath\n
	//    clip\n
	//  } if\n
	//} def\n", 
	//	    xoff + bb_xmin, yoff + bb_ymin, 
	//	    xoff + bb_xmax, yoff + bb_ymin, 
	//	    xoff + bb_xmax, yoff + bb_ymax, 
	//	    xoff + bb_xmin, yoff + bb_ymax);
	//
	// /* Dump the body of the prologue */
	//    PS_dump_prologue_file("prologue.ps");
	//
	// /* insert font encoding vector */
	//    if (uses_fonts) {
	//	switch (encoding) {
	//	    case S_ENC_ISO8859_1:   PS_dump_prologue_file("8859-1.ps"); break;
	//	    case S_ENC_ISO8859_2:   PS_dump_prologue_file("8859-2.ps"); break;
	//	    case S_ENC_CP1254:
	//	    case S_ENC_ISO8859_9:   PS_dump_prologue_file("8859-9.ps"); break;
	//	    case S_ENC_ISO8859_15:  PS_dump_prologue_file("8859-15.ps"); break;
	//	    case S_ENC_CP437:	    PS_dump_prologue_file("cp437.ps"); break;
	//	    case S_ENC_CP850:	    PS_dump_prologue_file("cp850.ps"); break;
	//	    case S_ENC_CP852:	    PS_dump_prologue_file("cp852.ps"); break;
	//	    case S_ENC_CP1250:	    PS_dump_prologue_file("cp1250.ps"); break;
	//	    case S_ENC_KOI8_R:	    PS_dump_prologue_file("koi8r.ps"); break;
	//	    case S_ENC_KOI8_U:	    PS_dump_prologue_file("koi8u.ps"); break;
	//	    case S_ENC_UTF8:   	    PS_dump_prologue_file("utf-8.ps");
	//				    if (!aglist) PS_load_glyphlist();
	//				    break;
	//	    case S_ENC_DEFAULT:
	//	    default:		    break;
	//	}
	//    }
	//
	// /* Redefine old epslatex linetypes if requested */
	//    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle) {
	//	for (i = 0; OldEPSL_linetypes[i] != NULL; i++)
	//	    fprintf(gppsfile,"%s",OldEPSL_linetypes[i]);
	//    }
	//
	//    if (ps_params->duplex_option)
	//	fprintf(gppsfile, "statusdict begin %s setduplexmode end\n",
	//		ps_params->duplex_state ? "true" : "false");
	//
	//    if (dict)
	//	while (*dict)
	//	    fputs(*(dict++), gppsfile);
	//
	//    if (uses_fonts) {
	//	PS_load_fontfiles(TRUE);
	//	PS_RememberFont(ps_params->font);
	//    }
	//
	//    fputs("end\n%%EndProlog\n", gppsfile);
	//}
	//
	// /* the init fn for the postscript driver */
	//TERM_PUBLIC void
	//PS_init()
	//{
	//    unsigned int xmin_t = 0, ymin_t = 0, xmax_t = 0, ymax_t = 0;
	//
	//    switch (ps_params->psformat) {
	//    case PSTERM_EPS:
	//	if (ps_explicit_size) {
	//	    term->xmax = eps_explicit_x;
	//	    term->ymax = eps_explicit_y;
	//	} else {
	//	    term->xmax = PS_XMAX;
	//	    if (ps_params->oldstyle)
	//		term->ymax = PS_YMAX_OLDSTYLE;
	//	    else
	//		term->ymax = PS_YMAX;
	//	}
	//	xmin_t = term->xmax * xoffset / (2*PS_SC);
	//	xmax_t = term->xmax * (xsize + xoffset) / (2*PS_SC);
	//	ymin_t = term->ymax * yoffset / (2*PS_SC);
	//	ymax_t = term->ymax * (ysize + yoffset) / (2*PS_SC);
	//	term->tscale = PS_SC * 2;
	//	break;
	//    case PSTERM_PORTRAIT:
	//	if (!ps_explicit_size) {
	//	    term->xmax = PS_YMAX;
	//	    term->ymax = PS_XMAX;
	//	}
	//	xmin_t = term->xmax * xoffset / PS_SC;
	//	xmax_t = term->xmax * (xsize + xoffset) / PS_SC;
	//	ymin_t = term->ymax * yoffset / PS_SC;
	//	ymax_t = term->ymax * (ysize + yoffset) / PS_SC;
	//	term->tscale = PS_SC;
	//	break;
	//    case PSTERM_LANDSCAPE:
	//	if (!ps_explicit_size) {
	//	    term->xmax = PS_XMAX;
	//	    term->ymax = PS_YMAX;
	//	}
	//	ymin_t = term->xmax * xoffset / PS_SC;
	//	ymax_t = term->xmax * (xsize+xoffset) / PS_SC;
	//	xmin_t = term->ymax * (1-ysize-yoffset) / PS_SC;
	//	xmax_t = term->ymax * (1-yoffset) / PS_SC;
	//	term->tscale = PS_SC;
	//	break;
	//    default:
	//	int_error(NO_CARET, "invalid postscript format used");
	//    }
	//
	// /* for enhanced postscript, copy ps_params->font to ps_enh_font
	//  * does no harm for non-enhanced
	//  */
	//    strcpy(ps_enh_font, ps_params->font);
	//    ps_enh_fontsize = ps_fontsize;
	//
	//    switch (ps_params->terminal) {
	//    case PSTERM_POSTSCRIPT:
	//	gppsfile = gpoutfile;
	//	break;
	//    default:
	///#ifdef PSLATEX_DRIVER
	//	PSTEX_reopen_output();
	//	break;
	//    case PSTERM_EPSLATEX:
	//	EPSLATEX_reopen_output();
	///#endif
	//	break;
	//    }
	//
	//    PS_common_init(ps_params->terminal == PSTERM_POSTSCRIPT,
	//		   ps_params->xoff, ps_params->yoff,
	//		   xmin_t, ymin_t, xmax_t, ymax_t,
	//		   (term->put_text == ENHPS_put_text) ? ENHPS_header : NULL);
	//    
	// /* Keep track of whether we have written the enhanced text dictionary yet */
	//    ENHPS_initialized = (term->put_text == ENHPS_put_text) ? 2 : 1;
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_graphics()
	//{
	//    static char GPFAR psg1[] = "0 setgray\nnewpath\n";
	//    struct termentry *t = term;
	//    ps_page++;
	//    if (ps_params->psformat != PSTERM_EPS)
	//	fprintf(gppsfile,"%%%%Page: %d %d\n",ps_page,ps_page);
	//
	// /* If we are about to use enhanced text mode for the first time in a plot that */
	// /* was initialized previously without it, we need to write out the macros now */
	//    if (term->put_text == ENHPS_put_text && ENHPS_initialized == 1) {
	//	const char **dict = ENHPS_header;
	//	while (*dict)
	//	    fputs(*(dict++), gppsfile);
	//	fprintf(stderr,"Writing out PostScript macros for enhanced text mode\n");
	//	ENHPS_initialized = 2;
	//    }
	//
	//    fprintf(gppsfile,"
	//gnudict begin\ngsave\n
	//doclip\n
	//%d %d translate\n
	//%.3f %.3f scale\n",
	//	    ps_common_xoff, ps_common_yoff,
	//	    (ps_params->psformat == PSTERM_EPS ? 0.5 : 1.0)/PS_SC,
	//	    (ps_params->psformat == PSTERM_EPS ? 0.5 : 1.0)/PS_SC);
	//    if (ps_params->psformat == PSTERM_LANDSCAPE)
	//	fprintf(gppsfile,"90 rotate\n0 %d translate\n", -(int)(term->ymax));
	//    fprintf(gppsfile, psg1);
	//    if (ps_common_uses_fonts)
	//	fprintf(gppsfile, "(%s) findfont %d scalefont setfont\n",
	//		ps_params->font, (t->v_char));
	//    ps_path_count = 0;
	//    PS_relative_ok = FALSE;
	//    PS_pen_x = PS_pen_y = -4000;
	//    PS_taken = 0;
	//    PS_linetype_last = LT_UNDEFINED;
	//    PS_linewidth_last = PS_linewidth_current = LT_UNDEFINED;
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_text()
	//{
	//    ps_path_count = 0;
	//    fputs("stroke\ngrestore\nend\nshowpage\n", gppsfile);
	// /* fprintf(stderr,"taken %d times\n",PS_taken); */
	// /* informational:  tells how many times it was "cheaper"
	//  * to do a relative moveto or lineto rather than an
	//  * absolute one */
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_reset()
	//{
	//    fputs("%%Trailer\n", gppsfile);
	//
	//    if (ps_common_uses_fonts) {
	//	fputs("%%DocumentFonts: ", gppsfile);
	//	while (PS_DocFonts) {
	//	    struct PS_FontName *fnp;
	//	    fnp = PS_DocFonts->next;
	//	    fprintf(gppsfile, "%s%s", PS_DocFonts->name, fnp ? " " : "\n");
	//	    free(PS_DocFonts->name);
	//	    free(PS_DocFonts);
	//	    PS_DocFonts = fnp;
	//	}
	//    }
	//    if (ps_params->psformat != PSTERM_EPS)
	//	fprintf(gppsfile,"%%%%Pages: %d\n",ps_page);
	//}
	//
	//TERM_PUBLIC void
	//PS_linetype(int linetype)
	//{
	//    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle)
	//	linetype = (linetype % 4) + 3;
	//    else
	//	linetype = (linetype % 9) + 3;
	//    if (linetype < 0)	// LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED 
	//	linetype = 0;
	//
	//    if (PS_linetype_last == linetype) return;
	//
	//    PS_relative_ok = FALSE;
	//    PS_FLUSH_PATH;
	//
	//    PS_linetype_last = linetype;
	//    PS_linewidth_last = PS_linewidth_current;
	//    fprintf(gppsfile, "LT%c\n", "wba012345678"[linetype]);
	//    ps_path_count = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_linewidth (double linewidth)
	//{
	// /* HBB NEW 20031219: don't do anything if nothing changed */
	//    if (ps_path_count != 0 && PS_linewidth_last == linewidth)
	//	return;
	//    PS_FLUSH_PATH;
	//
	//    PS_linewidth_current = linewidth;
	//    PS_linetype_last = LT_UNDEFINED;	// disable cache for next linetype change 
	//    fprintf(gppsfile, "%.3f UL\n", linewidth);
	//
	// /*
	// Documentation of the 'change linewidth' strategy of the postscript terminal:
	//
	// 1. define a new postscript variable with a default value:
	// /userlinewidth gnulinewidth def
	//
	// 2. define a new postscript command to change the contents of that variable:
	// /UL { gnulinewidth mul /userlinewidth exch def } def
	// usage:  multiplication_factor UL
	//
	// 3. modify the already known postscript command /PL for the plot lines:
	// /PL { stroke userlinewidth setlinewidth } def
	//
	// 4. issue the new command before every change of the plot linestyle:
	// example:
	// 4.0 UL
	// LT0
	// result:
	// Linetype 0 is drawn four times as thick as defined by the contents
	// of the postscript variable 'gnulinewidth'.
	// */
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_pointsize (double ptsize)
	//{
	//    fprintf(gppsfile, "%.3f UP\n", ptsize);
	//
	// /*
	//  *  Documentation of the 'change pointsize' strategy of the postscript
	//  * terminal:
	//  *
	//  * 1. define two new postscript variables to hold the overall pointsize:
	//  *    /hpt_  and  /vpt_
	//  *
	//  * 2. define a new postscript command to use the contents of these variables:
	//  *    /UP { cf. definition above } def
	//  *    usage:  multiplication_factor UP
	//  *
	//  * [3.] [doesn't exist, skip to next number]
	//  *
	//  * 4. issue the new command whereever you change the symbols (and linetype):
	//  *    example:
	//  *        2.5 UP
	//  *        4.0 UL  % optionally change linewidth, too
	//  *        LT0
	//  *    result:
	//  *        Next symbols will be drawn 2.5 times as big as defined by the
	//  *        GNUPLOT `set pointsize` command (= overall pointsize).
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_move(unsigned int x, unsigned int y)
	//{
	// /* Make this semi-dynamic and independent of architecture */
	//    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
	//    int dx = x - PS_pen_x;
	//    int dy = y - PS_pen_y;
	//
	// /* can't cancel all null moves--need a move after stroke'ing */
	//    if (dx==0 && dy==0 && PS_relative_ok)
	//	return;
	//
	//    sprintf(abso, "%d %d M\n", x, y);
	//    sprintf(rel, "%d %d R\n", dx, dy);
	//
	//    if (PS_newpath) {
	//	fprintf(gppsfile, "%d %d N\n", x, y);
	//	PS_newpath = FALSE;
	//    } else
	//    if (strlen(rel) < strlen(abso) && PS_relative_ok) {
	//	fputs(rel, gppsfile);
	//	PS_taken++;
	//    } else
	//	fputs(abso, gppsfile);
	//    PS_relative_ok = TRUE;
	//    ps_path_count += 1;
	//
	//    PS_pen_x = x;
	//    PS_pen_y = y;
	//}
	//
	//TERM_PUBLIC void
	//PS_vector(unsigned int x, unsigned int y)
	//{
	//    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
	//    int dx = x - PS_pen_x;
	//    int dy = y - PS_pen_y;
	//
	//    if (dx==0 && dy==0)
	//	return;
	//
	//    sprintf(abso, "%d %d L\n", x, y);
	//    sprintf(rel, "%d %d V\n", dx, dy);
	//
	// /* The following PS_move() is executed only when the limit of ps_path_count
	//  * has been reached below: then PS_FLUSH_PATH has been called which has not
	//  * moved to currentpoint after the stroke. */
	//    if (!PS_relative_ok)
	//	PS_move(PS_pen_x, PS_pen_y);
	//
	//    if (strlen(rel) < strlen(abso)) {
	//	fputs(rel, gppsfile);
	//	PS_taken++;		// only used for debug info 
	//	ps_path_count += 1;
	//    } else {
	//	fputs(abso, gppsfile);
	//	ps_path_count = 1;  // If we set it to zero, it may never get flushed 
	//    }
	// /* Ghostscript has a "pile-up of rounding errors" bug: a sequence of many
	//  * rmove's or rlineto's does not yield the same line as move's or lineto's.
	//  * Therefore, we periodically force an update of the absolute position.
	//  * There was a case when 400 rlineto's were too much, so let's go a little
	//  * bit higher than the default function sampling rate in gnuplot.
	//  * This runs into a second ghostscript bug, that mixing relative and absolute
	//  * lineto with no intervening 'stroke' is ridiculously slow to render.
	//  * So we stroke the partial line, update the position in absolute terms,
	//  * then continue.  This whole section can go away if ghostscript/gv is fixed.
	//  */
	///#define MAX_REL_PATHLEN 105
	//    if (ps_path_count >= MAX_REL_PATHLEN) {
	//	fprintf(gppsfile, "stroke %d %d M\n", x, y);
	//	ps_path_count = 1;
	//    }
	//
	//    PS_relative_ok = TRUE;
	//    PS_pen_x = x;
	//    PS_pen_y = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	///#define PS_NONE 0
	///#define PS_TEXT 1
	///#define PS_GLYPH 2
	//    unsigned long ch;
	//
	//    if (!str && !strlen(str))
	//	return;
	//    PS_move(x,y);
	//    if (ps_ang != 0)
	//	fprintf(gppsfile,"currentpoint gsave translate %d rotate 0 0 M\n", ps_ang);
	//
	//    if (encoding == S_ENC_UTF8 && contains8bit(str)) {
	// /* UTF-8 encoding with multibyte characters present */
	//	int mode = PS_NONE;
	//
	//	putc('[', gppsfile);
	//
	//	for (utf8toulong(&ch, &str); ch != '\0'; utf8toulong(&ch, &str)) {
	//	    if (ch < 0x100) {
	//		if (mode != PS_TEXT)
	//		    putc('(', gppsfile);
	//		if (ch == '(' || ch == ')' || ch == '\\')
	//		    putc('\\', gppsfile);
	//		putc((char)ch, gppsfile);
	//		mode = PS_TEXT;
	//	    } else {
	//		int i;
	//		if (mode == PS_TEXT)
	//		    putc(')', gppsfile);
	//		putc('/', gppsfile);
	///#if (ADOBE_ENCODING_NAMES)
	//		for (i = 0; i < psglyphs; i++) {
	//		    if (aglist[i].unicode == ch) {
	//		    	fputs(aglist[i].glyphname, gppsfile);
	//			break;
	//		    }
	//		}
	//		if (i >= psglyphs) // Must not have found a glyph name 
	///#endif
	//		    fprintf(gppsfile, (ch > 0xffff) ? "u%lX" : "uni%04lX", ch);
	//		mode = PS_GLYPH;
	//	    }
	//	}
	//
	//	if (mode == PS_TEXT)
	//	    putc(')', gppsfile);
	//
	//	switch(ps_justify) {
	//	    case LEFT :
	//		fputs("] GLshow\n", gppsfile);
	//		break;
	//	    case CENTRE :
	//		fputs("] GCshow\n", gppsfile);
	//		break;
	//	    case RIGHT :
	//		fputs("] GRshow\n", gppsfile);
	//		break;
	//	}
	//
	//    } else {
	// /* plain old 8-bit mode (not UTF-8), or UTF-8 string with only 7-bit characters */
	//	putc('(',gppsfile);
	//	ch = (char) *str++;
	//	while(ch!='\0') {
	//	    if ((ch=='(') || (ch==')') || (ch=='\\'))
	//		putc('\\', gppsfile);
	//	    putc((char) ch, gppsfile);
	//	    ch = (char) *str++;
	//	}
	//
	//	switch(ps_justify) {
	//	    case LEFT :
	//		fputs(") Lshow\n", gppsfile);
	//		break;
	//	    case CENTRE :
	//		fputs(") Cshow\n", gppsfile);
	//		break;
	//	    case RIGHT :
	//		fputs(") Rshow\n", gppsfile);
	//		break;
	//	}
	//    }
	//
	//    if (ps_ang != 0)
	//	fputs("grestore\n", gppsfile);
	//    ps_path_count = 0;
	//    PS_relative_ok = FALSE;
	//
	///#undef PS_NONE
	///#undef PS_TEXT
	///#undef PS_GLYPH
	//}
	//
	//
	//TERM_PUBLIC int
	//PS_text_angle(int ang)
	//{
	//    ps_ang = ang;
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC int
	//PS_justify_text(enum JUSTIFY mode)
	//{
	//    ps_justify = mode;
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC int
	//PS_set_font(const char *font)
	//{
	//    char *name;
	//    unsigned int  i;
	//    float size;
	//    size_t sep;
	//
	//    if (!font || !(*font))
	//	font = PS_default_font;
	//    sep = strcspn(font,",");
	//    name = gp_strdup(font);
	//    name[sep] = NUL;
	//    for (i=0; i<sep; i++)
	//	if (name[i] == ' ') name[i] = '-';
	//    size = ps_fontsize;
	//    if (font[sep] == ',')
	//	sscanf (&(font[sep+1]),"%f",&size);
	//
	// /* If TeX is doing the font handling, we don't need to */
	// /* write anything into the postscript stream */
	//    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
	//	PS_RememberFont(name);
	//	fprintf(gppsfile, "/%s findfont %g scalefont setfont\n",
	//		name, size*PS_SC);
	//    }
	//    free(name);
	//
	//    term->v_char = (unsigned int)(size*PS_SC);
	//    term->h_char = (unsigned int)(size*PS_SC*6/10);
	//    return TRUE;
	//}
	//
	//
	// /* postscript point routines */
	//
	//
	//TERM_PUBLIC void
	//PS_point(unsigned int x, unsigned int y, int number)
	//{
	//    static const char GPFAR * GPFAR pointFNS[] = {
	//	"Pnt",  "Pls",   "Crs",    "Star",
	//	"Box",  "BoxF",  "Circle", "CircleF",
	//	"TriU", "TriUF", "TriD",   "TriDF",
	//	"Dia",  "DiaF",  "Pent",   "PentF",
	//	"C0",   "C1",    "C2",     "C3",
	//	"C4",   "C5",    "C6",     "C7",
	//	"C8",   "C9",    "C10",    "C11",
	//	"C12",  "C13",   "C14",    "C15",
	//	"S0",   "S1",    "S2",     "S3",
	//	"S4",   "S5",    "S6",     "S7",
	//	"S8",   "S9",    "S10",    "S11",
	//	"S12",  "S13",   "S14",    "S15",
	//	"D0",   "D1",    "D2",     "D3",
	//	"D4",   "D5",    "D6",     "D7",
	//	"D8",   "D9",    "D10",    "D11",
	//	"D12",  "D13",   "D14",    "D15",
	//	"BoxE", "CircE", "TriUE",  "TriDE",
	//	"DiaE", "PentE", "BoxW",   "CircW",
	//	"TriUW","TriDW", "DiaW",   "PentW"
	//    };
	//    static const char GPFAR * GPFAR pointFNS_OldEPSL[] = {
	//	"Pnt",  "Dia",   "Circle", "Pls",
	//	"Crs",  "Box",   "DiaF",   "CircleF",
	//	"BoxF"
	//    };
	//    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle) {
	//	if (number < 0)
	//	    number = -1;		// negative types are all 'dot' 
	//	else
	//	    number %= sizeof(pointFNS_OldEPSL)/sizeof(pointFNS_OldEPSL[0]) -1;
	//	fprintf(gppsfile, "%d %d %s\n", x, y, pointFNS_OldEPSL[number+1]);
	//    } else {
	//	if (number < 0)
	//	    number = -1;		// negative types are all 'dot' 
	//	else
	//	    number %= sizeof(pointFNS)/sizeof(pointFNS[0]) -1;
	//	fprintf(gppsfile, "%d %d %s\n", x, y, pointFNS[number+1]);
	//    }
	//
	//    PS_relative_ok = FALSE;
	//    ps_path_count = 0;
	//    PS_linetype_last = LT_UNDEFINED; // force next linetype change 
	//}
	//
	//TERM_PUBLIC void
	//PS_fillbox(
	//    int style,
	//    unsigned int x1, unsigned int y1,
	//    unsigned int width, unsigned int height)
	//{
	//    double filldens;
	//    int pattern;
	//
	//    PS_FLUSH_PATH;
	//
	//    switch(style & 0xf) {
	//
	//    case FS_DEFAULT:
	// /* Fill with current color, wherever it came from */
	//	fprintf(gppsfile, "%d %d %d %d Rec fill\n", x1,y1, width,height);
	//	break;
	//
	//    case FS_SOLID:
	//    case FS_TRANSPARENT_SOLID:
	// /* style == 1 --> fill with intensity according to filldensity */
	//	filldens = (style >> 4) / 100.0;
	//	if(filldens < 0.0)
	//	    filldens = 0.0;
	//	if(filldens > 1.0)
	//	    filldens = 1.0;
	//	fprintf(gppsfile, "%.3f %d %d %d %d BoxColFill\n",
	//		filldens, x1,y1, width,height);
	//	break;
	//
	//    case FS_PATTERN:
	//    case FS_TRANSPARENT_PATTERN:
	// /* style == 2 --> fill with pattern according to fillpattern */
	// /* the upper 3 nibbles of 'style' contain pattern number */
	//	pattern = (style >> 4) % 8;
	//	switch (pattern) {
	//
	//	default:
	//	case 0:
	//		fprintf(gppsfile, "%d %d %d %d BoxFill\n",
	//			x1, y1, width, height);
	//		break;
	//	case 1:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 1 PatternFill\n",
	//			x1, y1, width, height, 80, -45);
	//		break;
	//	case 2:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 2 PatternFill\n",
	//			x1, y1, width, height, 40,  45);
	//		break;
	//	case 3:
	//		fprintf(gppsfile, "1 %d %d %d %d BoxColFill\n",
	//			x1, y1, width, height);
	//		break;
	//	case 4:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
	//			x1, y1, width, height, 80,  45);
	//		break;
	//	case 5:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
	//			x1, y1, width, height, 80, -45);
	//		break;
	//	case 6:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
	//			x1, y1, width, height, 40,  30);
	//		break;
	//	case 7:
	//		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
	//			x1, y1, width, height, 40, -30);
	//		break;
	//	}
	//	break; // end of pattern filling part 
	//
	//    case FS_EMPTY:
	//    default: // fill with background color 
	//	fprintf(gppsfile, "%d %d %d %d BoxFill\n", x1, y1, width, height);
	//    }
	//
	//    PS_relative_ok = FALSE;
	//    PS_linetype_last = LT_UNDEFINED;
	//}
	//
	//
	// /* ENHPOST */
	//
	// /*
	//  * close a postscript string if it has been opened
	//  */
	//TERM_PUBLIC void
	//ENHPS_FLUSH()
	//{
	//    if (ENHps_opened_string) {
	//	fputs(")]\n", gppsfile);
	//	ENHps_opened_string = FALSE;
	//    }
	//}
	//
	//static char *ENHps_opensequence = NULL;
	//
	// /*
	//  * open a postscript string
	//  */
	//TERM_PUBLIC void
	//ENHPS_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* overprint 3 means save current position; 4 means restore saved position */
	// /* EAM FIXME - I couldn't figure out how to use less than the 7 parameters */
	// /* that the normal case macro wants. Somebody more familiar with PostScript*/
	// /* than I am please clean it up!                                           */
	//    if (overprint == 3) {
	//	fputs("XYsave\n", gppsfile);
	//	return;
	//    } else if (overprint == 4) {
	//	fputs("XYrestore\n", gppsfile);
	//	return;
	//    }
	//
	//	if (!ENHps_opened_string) {
	//	    int safelen = strlen(fontname) + 40;
	//	    free(ENHps_opensequence);
	//	    ENHps_opensequence = gp_alloc(safelen,"ENHPS_opensequence");
	// /* EAM November 2007 - moved here from enhanced_recursion() */
	//	    PS_RememberFont(fontname);
	///#ifdef HAVE_SNPRINTF
	//	    snprintf(ENHps_opensequence, safelen, "[(%s) %.1f %.1f %s %s %d ",
	//		    fontname, fontsize, base,
	//		    widthflag ? "true" : "false",
	//		    showflag ? "true" : "false",
	//		    overprint);
	///#else
	//	    sprintf(ENHps_opensequence, "[(%s) %.1f %.1f %s %s %d ",
	//		    fontname, fontsize, base,
	//		    widthflag ? "true" : "false",
	//		    showflag ? "true" : "false",
	//		    overprint);
	///#endif
	//	    fprintf(gppsfile, "%s(", ENHps_opensequence);
	//	    ENHps_opened_string = TRUE;
	//	}
	//}
	//
	// /*
	//  * Write one character from inside enhanced text processing.
	//  * This is trivial except in the case of multi-byte encoding.
	//  */
	//TERM_PUBLIC void
	//ENHPS_WRITEC(int c)
	//{
	//    static int in_utf8 = 0; // nonzero means we are inside a multibyte sequence 
	//    static char utf8[6];    // holds the multibyte sequence being accumulated   
	//    static int nbytes = 0;  // number of bytes expected in the sequence 
	//
	// /* UTF-8 Encoding */
	//    if (encoding == S_ENC_UTF8 && (c & 0x80) != 0) {
	//	if (in_utf8 == 0) {
	//	    nbytes = (c & 0xE0) == 0xC0 ? 2
	//		   : (c & 0xF0) == 0xE0 ? 3
	//		   : (c & 0xF8) == 0xF0 ? 4
	//		   : 0;
	//	    if (!nbytes) // Illegal UTF8 char; hope it's printable  
	//		fputc(c, gppsfile);
	//	    else
	//		utf8[in_utf8++] = c;
	//	} else {
	//	    utf8[in_utf8++] = c;
	//	    if (in_utf8 >= nbytes) {
	//		unsigned long wch = '\0';
	//		const char *str = &utf8[0];
	//		int i;
	//
	//		utf8[nbytes] = '\0';
	//		in_utf8 = 0;
	//		utf8toulong(&wch, &str);
	//
	//		if (wch < 0x100) { // Single byte ISO8859-1 character 
	//		    fputc(wch, gppsfile);
	//		    return;
	//		}
	//
	// /* Finish off previous partial string, if any */
	//		ENHPS_FLUSH();
	//
	// /* Write a new partial string for this glyph */
	//		fprintf(gppsfile, "%s/", ENHps_opensequence);
	///#if (ADOBE_ENCODING_NAMES)
	//		for (i = 0; i < psglyphs; i++) {
	//		    if (aglist[i].unicode == wch) {
	//			fputs(aglist[i].glyphname, gppsfile);
	//			break;
	//		    }
	//		}
	//		if (i >= psglyphs) // Must not have found a glyph name 
	///#endif
	//		    fprintf(gppsfile, (wch > 0xffff) ? "u%lX" : "uni%04lX", wch);
	//		fprintf(gppsfile, "]\n");
	//
	// /* Mark string closed */
	//		ENHps_opened_string = FALSE;
	//	    }
	//	}
	//    } else
	//
	// /* Single byte character */
	//	fputc(c, gppsfile);
	//}
	//
	// /* a set-font routine for enhanced post : simply copies
	//  * the font into a global, or restores the globals
	//  * to the ps_params->font default
	//  */
	//
	//TERM_PUBLIC int
	//ENHPS_set_font(const char *font)
	//{
	//    if (ignore_enhanced_text)
	//	return PS_set_font(font);
	//
	//    if (*font) {
	//	size_t sep = strcspn(font,",");
	//	if (sep > 0) {
	//	    strncpy(ps_enh_font,font,sep);
	//	    ps_enh_font[sep] = NUL;
	//	    PS_RememberFont(ps_enh_font);
	//	}
	//	ps_enh_fontsize = ps_fontsize;
	//	sscanf (font+sep+1,"%f",&ps_enh_fontsize);
	//    } else {
	// /* return to defaults */
	//	strcpy(ps_enh_font, ps_params->font);
	//	ps_enh_fontsize = ps_fontsize;
	//    }
	//    term->v_char = (unsigned int)(ps_enh_fontsize*PS_SC);
	//    term->h_char = (unsigned int)(ps_enh_fontsize*PS_SC*6/10);
	//
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//ENHPS_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    if (ignore_enhanced_text) {
	//	PS_put_text(x,y,str);
	//	return;
	//    }
	//
	// /* flush any pending graphics (all the XShow routines do this...) */
	//
	//    if (!strlen(str))
	//	return;
	//
	//    PS_FLUSH_PATH;
	//
	// /* FIXME: if there are no magic characters, we should just be able
	//  * punt the string to PS_put_text(), which will give shorter
	//  * ps output [eg tics and stuff rarely need extra processing],
	//  * but we need to make sure that the current font is the
	//  * default one before we can do that. {ie I tried it and it
	//  * used the wrong font !}
	//  * if (!strpbrk(str, "{}^_@&~"))
	//  * {
	//  *   - do something to ensure default font is selected
	//  *   PS_put_text(x,y,str);
	//  *   return;
	//  * }
	//  */
	//
	//    PS_move(x,y);
	//
	//    if (ps_ang != 0)
	//	fprintf(gppsfile,"currentpoint gsave translate %d rotate 0 0 moveto\n",
	//		ps_ang);
	//
	//    fputs("[ ", gppsfile);
	//
	// /* set up the global variables needed by enhanced_recursion() */
	//    enhanced_max_height = -1000;
	//    enhanced_min_height = 1000;
	//    enhanced_fontscale = PS_SC;
	//    strncpy(enhanced_escape_format,"\\%o",sizeof(enhanced_escape_format));
	//
	//    ENHps_opened_string = FALSE;
	//
	// /* Set the recursion going. We say to keep going until a
	//  * closing brace, but we don't really expect to find one.
	//  * If the return value is not the nul-terminator of the
	//  * string, that can only mean that we did find an unmatched
	//  * closing brace in the string. We increment past it (else
	//  * we get stuck in an infinite loop) and try again.
	//  *
	//  * ps_enh_font and ps_enh_fontsize are either set to the
	//  * the defaults set on option line, or have been set to
	//  * "font,size". That is to say, ps_params->font is used only
	//  * at startup and by ENHPS_set_font
	//  */
	//    while (*(str = enhanced_recursion((char *)str, TRUE, ps_enh_font,
	//		 (double)(ps_enh_fontsize*PS_SC), 0.0, TRUE, TRUE, 0))) {
	//	ENHPS_FLUSH();
	//
	// /* I think we can only get here if *str == '}' */
	//	enh_err_check(str);
	//
	//	if (!*++str)
	//	    break; // end of string 
	//
	// /* else carry on and process the rest of the string */
	//    }
	//
	//    enhanced_max_height += enhanced_min_height;
	//
	//    fprintf(gppsfile, "] %.1f ", -enhanced_max_height/3);
	//
	//    switch(ps_justify) {
	//    case LEFT :
	//	fputs("MLshow\n", gppsfile);
	//	break;
	//    case CENTRE :
	//	fputs("MCshow\n", gppsfile);
	//	break;
	//    case RIGHT :
	//	fputs("MRshow\n", gppsfile);
	//	break;
	//    }
	//
	//    if (ps_ang != 0)
	//	fputs("grestore\n", gppsfile);
	//    ps_path_count = 0;
	//    PS_relative_ok = FALSE;
	//}
	//
	//static void
	//make_palette_formulae()
	//{
	///#define R sm_palette.formulaR
	///#define G sm_palette.formulaG
	///#define B sm_palette.formulaB
	// /* print the definition of R,G,B formulae */
	//  fputs("/InterpolatedColor false def\n", gppsfile);
	//if (sm_palette.ps_allcF == 0) { // print only those 3 used formulae 
	//    fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
	//	     abs(R), ps_math_color_formulae[ 2*abs(R) ],
	//	     ps_math_color_formulae[ 2*abs(R)+1 ]);
	//    if (abs(G) != abs(R))
	//      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
	//	       abs(G), ps_math_color_formulae[ 2*abs(G) ],
	//	       ps_math_color_formulae[ 2*abs(G)+1 ]);
	//    if ((abs(B) != abs(R)) && (abs(B) != abs(G)))
	//      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
	//	       abs(B), ps_math_color_formulae[ 2*abs(B) ],
	//	       ps_math_color_formulae[ 2*abs(B)+1 ]);
	//    }
	//  else { // all color formulae are written into the output PostScript file 
	//    int i = 0;
	//    while (*(ps_math_color_formulae[2*i])) {
	//      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
	//	       i, ps_math_color_formulae[ 2*i ],
	//	       ps_math_color_formulae[ 2*i+1 ]);
	//      i++;
	//      }
	//    }
	///#undef R
	///#undef G
	///#undef B
	//}
	//
	//
	//
	//static void
	//make_interpolation_code()
	//{
	//    static const char *header[] = {
	//	"/grayindex {/gidx 0 def\n",
	//	"  {GrayA gidx get grayv ge {exit} if /gidx gidx 1 add def} loop} def\n",
	//	"/dgdx {grayv GrayA gidx get sub GrayA gidx 1 sub get\n",
	//	"  GrayA gidx get sub div} def \n",
	//	"/redvalue {RedA gidx get RedA gidx 1 sub get\n",
	//	"  RedA gidx get sub dgdxval mul add} def\n",
	//	"/greenvalue {GreenA gidx get GreenA gidx 1 sub get\n",
	//	"  GreenA gidx get sub dgdxval mul add} def\n",
	//	"/bluevalue {BlueA gidx get BlueA gidx 1 sub get\n",
	//	"  BlueA gidx get sub dgdxval mul add} def\n",
	//	"/interpolate {\n",
	//	"  grayindex grayv GrayA gidx get sub abs 1e-5 le\n",
	//	"    {RedA gidx get GreenA gidx get BlueA gidx get}\n",
	//	"    {/dgdxval dgdx def redvalue greenvalue bluevalue} ifelse} def\n",
	//	NULL,
	//    };
	//    int i;
	//
	//    for(i=0; header[i]!=NULL; ++i) {
	//	fputs(header[i], gppsfile);
	//    }
	//}
	//
	//
	//static void
	//make_color_model_code()
	//{
	// /* Postscript version of the color space transformations in getcolor.c */
	//    static const char *header[] = {
	//	"/HSV2RGB {",
	//	"  exch dup 0.0 eq {pop exch pop dup dup} % achromatic gray\n",
	//	"  { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub\n ",
	//	"    /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def\n",
	//	"	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def \n",
	//	"	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def\n",
	//	"	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}\n",
	//	"	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}\n",
	//	"	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}\n",
	//	"	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse\n",
	//	"  } ifelse} def\n",
	//	"/Constrain {\n",
	//	"  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def\n",
	//	"/YIQ2RGB {\n",
	//	"  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll\n",
	//	"  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll\n",
	//	"  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def\n",
	//	"/CMY2RGB {",
	//	"  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def\n",
	//	"/XYZ2RGB {",
	//	"  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add\n",
	//	"  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch\n",
	//	"  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add\n",
	//	"  exch 1.91 mul exch add Constrain 3 1 roll} def\n",
	//	"/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {\n",
	//	"  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}\n",
	//	"  if} ifelse} ifelse} ifelse} def\n",
	//	NULL,
	//    };
	//    int i;
	//
	//    for(i=0; header[i]!=NULL; ++i) {
	//	fputs(header[i], gppsfile);
	//    }
	//}
	//
	//
	//static char
	//*save_space(double gray)
	//{
	// /* printing the gray with 4 digits and without the leading 0
	//  * ... saving space */
	//    static char s[40];
	//
	//    gray = 0.0001*(int)(gray*10000+0.5); // round it to 4 digits 
	//    sprintf(s, "%.4g", gray);
	//    if (s[0] == '0' && s[1] == '.')
	//	return &(s[1]);  // strip leading 0 
	//    else
	//	return s;
	//}
	//
	//
	//static void
	//write_color_space(t_sm_palette *palette)
	//{
	// /* write something like
	//  *   /ColorSpace (HSV) def
	//  * depending on the selected cmodel in palette */
	//    fputs("/ColorSpace ", gppsfile);
	//    switch(palette->cmodel) {
	//    case C_MODEL_RGB:
	//	fputs("(RGB)", gppsfile);
	//	break;
	//    case C_MODEL_HSV:
	//	fputs("(HSV)", gppsfile);
	//	break;
	//    case C_MODEL_CMY:
	//	fputs("(CMY)", gppsfile);
	//	break;
	//    case C_MODEL_YIQ:
	//	fputs("(YIQ)", gppsfile);
	//	break;
	//    case C_MODEL_XYZ:
	//	fputs("(XYZ)", gppsfile);
	//	break;
	//    default:
	//	fprintf(stderr,"%s:%d ooops: Unkown color model '%c'. Will be RGB\n",
	//		__FILE__, __LINE__, (char)(palette->cmodel));
	//	fputs("(RGB)", gppsfile);
	//	break;
	//    }
	//    fputs(" def\n", gppsfile);
	//}
	//
	//
	//static void
	//write_component_array(const char *text, gradient_struct *grad,
	//		      int cnt, int offset)
	//{
	// /*  write someting like
	//  *     /RedA [ 0 .1 .2 .3 .35 .3 .2 .1 0 0 0 ] def
	//  *  nicely formated to gppsfile
	//  */
	//    int i=0, len=0;
	//    char *val;
	//
	//    fprintf(gppsfile, "/%s [", text);
	//    len = strlen(text) + 4;
	//    for(i=0; i<cnt; ++i) {
	//	char *ref = (char*)(&(grad[i]));
	//
	//	ref += offset;
	//	val = save_space(*((double*) (ref)));
	//	len += strlen(val) + 1;
	//	if(len > 77) {
	//	    fputs("\n  ",gppsfile);
	//	    len = strlen(val) + 3;
	//	}
	//	fprintf(gppsfile, "%s ", val);
	//    }
	//    fputs("] def\n", gppsfile);
	//}
	//
	//
	//static void
	//write_gradient_definition(gradient_struct *gradient, int cnt)
	//{
	// /* some strange pointer acrobatic here, but it seems to work... */
	//    char *ref = (char*) (gradient);
	//    int p = (char*) (&(gradient[0].pos)) - ref;
	//    int r = (char*) (&(gradient[0].col.r)) - ref;
	//    int g = (char*) (&(gradient[0].col.g)) - ref;
	//    int b = (char*) (&(gradient[0].col.b)) - ref;
	//
	//    write_component_array("GrayA", gradient, cnt, p);
	//    write_component_array("RedA", gradient, cnt, r);
	//    write_component_array("GreenA", gradient, cnt, g);
	//    write_component_array("BlueA", gradient, cnt, b);
	//}
	//
	//
	//static void
	//PS_make_header(t_sm_palette *palette)
	//{
	// /* write header for smooth colors */
	//    fputs("gsave % colour palette begin\n", gppsfile);
	//    fprintf(gppsfile, "/maxcolors %i def\n", sm_palette.use_maxcolors);
	//    make_color_model_code();
	//
	//    switch(sm_palette.colorMode) {
	//    case SMPAL_COLOR_MODE_GRAY:
	//	fputs("/InterpolatedColor false def\n", gppsfile);
	//	break;  // nothing to do for gray 
	//    case SMPAL_COLOR_MODE_RGB:
	//	make_palette_formulae();
	//	break;
	//    case SMPAL_COLOR_MODE_FUNCTIONS: {
	//	int cnt=0;
	//	gradient_struct *gradient;
	//
	//	fputs("/InterpolatedColor true def\n", gppsfile);
	//	make_interpolation_code();
	//	gradient = approximate_palette(palette, ps_params->palfunc_samples,
	//				       ps_params->palfunc_deviation, &cnt);
	//	write_gradient_definition(gradient, cnt);
	//	free(gradient);
	//	break;
	//    }
	//    case SMPAL_COLOR_MODE_GRADIENT:
	//	fputs("/InterpolatedColor true def\n", gppsfile);
	//	make_interpolation_code();
	//	write_gradient_definition(palette->gradient, palette->gradient_num);
	//	break;
	//    default:
	//	fprintf(stderr, "%s:%d ooops: Unknown color mode '%c'\n",
	//		 __FILE__, __LINE__, (char)(sm_palette.colorMode));
	//    }
	//    fputs("/pm3dround {maxcolors 0 gt {dup 1 ge\n", gppsfile);
	//    fputs("\t{pop 1} {maxcolors mul floor maxcolors 1 sub div} ifelse} if} def\n",
	//	  gppsfile);
	//    fprintf(gppsfile, "/pm3dGamma 1.0 %g Gamma mul div def\n", sm_palette.gamma);
	//    write_color_space(palette);
	//
	// /* Now print something like
	//    /g {dup cF7 exch dup cF5 exch cF15 setrgbcolor} bind def
	// */
	///#define R sm_palette.formulaR
	///#define G sm_palette.formulaG
	///#define B sm_palette.formulaB
	//
	// /* 18.1.2009 Since the beginning of pm3d, the Color definition switched
	//    between gray and colour map. This led to ambiguities for custom colour
	//    palettes if they contain grays only. Thus let postscript choose always
	//    always colour palette for interpolated colours ('set palette defined',
	//    'set palette file') and colour/gray according to Color otherwise
	//    ('set palette gray', 'set palette rgb').
	// */
	///#if 0
	//    fprintf(gppsfile, "Color %s and { %% COLOUR vs. GRAY map\n",
	//	    (sm_palette.colorMode!=SMPAL_COLOR_MODE_GRAY) ? "true":"false");
	///#else
	//    if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY)
	//	fputs("false { % COLOUR vs. GRAY map\n", gppsfile);
	//    else
	//	fputs("Color InterpolatedColor or { % COLOUR vs. GRAY map\n", gppsfile);
	///#endif
	//
	//    fputs("  InterpolatedColor { %% Interpolation vs. RGB-Formula\n",
	//	  gppsfile);
	//    fputs("    /g {stroke pm3dround /grayv exch def interpolate\n", gppsfile);
	//    fputs("        SelectSpace setrgbcolor} bind def\n", gppsfile);
	//    fputs("  }{\n", gppsfile);
	//    fputs("  /g {stroke pm3dround dup ", gppsfile);
	//    if (R < 0)
	//	fputs("1 exch sub ", gppsfile); // negate 
	//    fprintf(gppsfile,"cF%i Constrain exch dup ", abs(R));
	//    if (G < 0)
	//	fputs("1 exch sub ", gppsfile); // negate 
	//    fprintf(gppsfile,"cF%i Constrain exch ", abs(G));
	//    if (R<0 || G<0 || B<0)
	//	fputs("\n\t", gppsfile);
	//    if (B < 0)
	//	fputs("1 exch sub ", gppsfile); // negate 
	//    fprintf(gppsfile,"cF%i Constrain ", abs(B));
	//    fputs("\n       SelectSpace setrgbcolor} bind def\n", gppsfile);
	//    fputs("  } ifelse\n", gppsfile);
	//    fputs("}{\n", gppsfile);
	//    fputs("  /g {stroke pm3dround pm3dGamma exp setgray} bind def\n", gppsfile);
	//    fputs("} ifelse\n", gppsfile);
	///#undef R
	///#undef G
	///#undef B
	//}
	//
	//
	//TERM_PUBLIC int PS_make_palette (t_sm_palette *palette)
	//{
	//    if (palette == NULL) {
	//	return 0;  // postscript can do continuous colors 
	//    }
	//
	//    PS_make_header(palette);
	//    return 0;
	//}
	//
	//
	//TERM_PUBLIC void PS_set_color (t_colorspec *colorspec)
	//{
	//    double gray;
	//
	//    PS_linetype_last = LT_UNDEFINED;  // Force next call to linetype to be honored 
	//
	//    if (PS_linewidth_last != PS_linewidth_current) {
	//	PS_linewidth_last = PS_linewidth_current;
	//	fprintf(gppsfile, "PL ");
	//    }
	//
	//    if (colorspec->type == TC_LT) {
	//	int linetype = colorspec->lt;
	//	PS_FLUSH_PATH;
	//	if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle)
	//	    linetype = (linetype % 4) + 3;
	//	else
	//	    linetype = (linetype % 9) + 3;
	//	if (linetype < 0)	// LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED 
	//	    linetype = 0;
	//	fprintf(gppsfile, "LC%1c setrgbcolor\n","wba012345678"[linetype]);
	//    } else if (colorspec->type == TC_RGB) {
	//	double r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
	//	double g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
	//	double b = (double)(colorspec->lt & 255) / 255.;
	//	PS_FLUSH_PATH;
	//	fprintf(gppsfile, "%3.2f %3.2f %3.2f C ",r,g,b);
	//    }
	//
	//    if (colorspec->type != TC_FRAC)
	//	return;
	//
	// /* map [0;1] to gray/colors */
	//    gray = colorspec->value;
	//    if (gray <= 0)
	//	fputs("0 g ", gppsfile);
	//    else {
	//	if (gray >= 1)
	//	    fputs("1 g ", gppsfile);
	//	else
	//	    fprintf(gppsfile, "%s g ", save_space(gray));
	//    }
	//    PS_relative_ok = FALSE; // "M" required because "g" forces stroke (??) 
	//}
	//
	//
	//TERM_PUBLIC void PS_filled_polygon (int points, gpiPoint *corners)
	//{
	//    int i;
	//    float filldens = 1.0;
	//    int pattern = 0;
	//    int style = corners->style;
	//
	// /* Stroke the previous graphic element if required. */
	//    if (PS_relative_ok)
	//	PS_FLUSH_PATH;
	//
	//    if (points == 4 && style == FS_OPAQUE) {
	// /* Special case for pm3d surface quadrangles
	//  *  <x0> <y0> ... <x4> <y4> h
	//  */
	//	    fprintf(gppsfile, "%i %i N", corners[0].x, corners[0].y);
	//	    fprintf(gppsfile, " %i %i %i %i %i %i h\n",
	//	    corners[3].x-corners[2].x, corners[3].y-corners[2].y,
	//	    corners[2].x-corners[1].x, corners[2].y-corners[1].y,
	//	    corners[1].x-corners[0].x, corners[1].y-corners[0].y);
	//    } else {
	// /* General case for solid or pattern-filled polygons
	//  * gsave <x0> <y0> N <x1> <y1> ... <xn> <yn> density PolyFill
	//  */
	//	int fillpar = style >> 4;
	//	style = style &0xf;
	//
	//	fprintf(gppsfile, "gsave ");
	//	fprintf(gppsfile, "%i %i N", corners[0].x, corners[0].y);
	//	for (i = 1; i < points; i++) {
	// /* The rationale for mixing V and L is given in PS_vector */
	//	    if (i % MAX_REL_PATHLEN)
	//		fprintf(gppsfile, " %i %i V", corners[i].x-corners[i-1].x,
	//		    corners[i].y-corners[i-1].y);
	//	    else
	//		fprintf(gppsfile, " %i %i L", corners[i].x, corners[i].y);
	//	}
	//
	//	switch(style) {
	//	
	//	case FS_SOLID:
	//	case FS_TRANSPARENT_SOLID:
	//	    filldens = (fillpar) / 100.0;
	//	    if(filldens < 0.0)
	//		filldens = 0.0;
	//	    if(filldens >= 1.0)
	//		fprintf(gppsfile, " 1 PolyFill\n");
	//	    else
	//		fprintf(gppsfile, " %.2f PolyFill\n", filldens);
	//	    break;
	//	    
	//	case FS_TRANSPARENT_PATTERN:
	//	    fprintf(gppsfile," /TransparentPatterns true def\n");
	//	case FS_PATTERN:
	//	    pattern = (fillpar) % 8;
	//	    if (pattern == 0)  {
	//		filldens = 0.5;
	//		fprintf(gppsfile, " %.1f PolyFill\n", filldens);
	//	    } else {
	//		fprintf(gppsfile," Pattern%d fill grestore\n", pattern);
	//	    }
	//	    break;
	//
	//	default:
	//	    fputs(" 1 PolyFill\n", gppsfile);
	//	    break;
	//
	//	}
	//    }
	//
	//    PS_relative_ok = FALSE;
	//}
	//
	///#undef MAX_REL_PATHLEN
	//
	//TERM_PUBLIC void PS_previous_palette()
	//{
	// /* Needed to stroke the previous graphic element. */
	//    PS_FLUSH_PATH;
	//    fputs("grestore % colour palette end\n", gppsfile);
	//}
	//
	//
	// /*
	//  * The reason for having a PostScript-specific wrapper for do_arrow
	//  * is that post.trm draws dotted lines for monochrome output, and
	//  * dotted arrowheads are ugly.  So in that case we call do_arrow twice,
	//  * the second time to retrace the head with the line style forced to solid.
	//  */
	//TERM_PUBLIC void PS_arrow (
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    do_arrow( sx, sy, ex, ey, head );
	//    if (!ps_params->solid && head != 0) {
	//	PS_FLUSH_PATH;
	//	fputs("gsave [] 0 setdash\n", gppsfile);
	//	do_arrow( sx, sy, ex, ey, -head );
	//	PS_FLUSH_PATH;
	//	fputs("grestore\n", gppsfile);
	//    }
	//}
	//
	//static void
	//delete_ps_fontfile(struct ps_fontfile_def *prev, struct ps_fontfile_def *this)
	//{
	//    if (this != NULL) {		// there really is something to delete 
	//	FPRINTF((stderr, "Remove font/kerning file `%s'\n",
	//		 this->fontfile_name));
	//	if (prev != NULL)	// there is a previous ps_fontfile 
	//	    prev->next = this->next;
	//	else			// this = ps_params->first_fontfile 
	// /* so change ps_params->first_fontfile */
	//	    ps_params->first_fontfile = this->next;
	//	free(this->fontfile_name);
	//	free(this->fontfile_fullname);
	//	free(this->fontname);
	//	free(this);
	//	this = NULL;
	//    }
	//}
	//
	//
	//static void
	//PS_encode85(unsigned long tuple4, unsigned char *tuple5)
	//{
	// /* The compiler should know to carry out the powers of
	//  * 85 computation at compilation time.
	//  */
	//    tuple5[0] = tuple4/(85*85*85*85);
	//    tuple4 -= ((unsigned long)tuple5[0])*(85*85*85*85);
	//    tuple5[1] = tuple4/(85*85*85);
	//    tuple4 -= ((unsigned long)tuple5[1])*(85*85*85);
	//    tuple5[2] = tuple4/(85*85);
	//    tuple4 -= ((unsigned long)tuple5[2])*(85*85);
	//    tuple5[3] = tuple4/(85);
	//    tuple4 -= ((unsigned long)tuple5[3])*(85);
	//    tuple5[4] = tuple4;
	//}
	//
	//enum PS_ENCODING {
	//    PS_ASCII_HEX,
	//    PS_ASCII85
	//} PS_ENCODING;
	//
	// /* Returns pointer to encoded image, allocated on heap that the
	//  * caller must free.  Can error to command line so make sure all
	//  * heap memory is recorded in static pointers when calling this
	//  * routine.
	//  */
	//static char *
	//PS_encode_image(unsigned int M, unsigned int N, coordval *image, t_imagecolor color_mode,
	//		int bits_per_component, int max_colors, double cscale,
	//		enum PS_ENCODING encoding, int *return_num_bytes)
	//{
	//    unsigned int coord_remaining;
	//    coordval *coord_ptr;
	//    unsigned short i_line;
	//    unsigned int i_element;
	//    unsigned int end_of_line;
	//    unsigned short bits_remaining, bits_start;
	//
	//    unsigned long tuple4;
	//    unsigned char tuple5[5];
	//    int max_encoded_bytes;
	//    char *encoded_image, *encoded_image_ptr;
	//    unsigned long total_bits;
	//
	///#define ASCII_PER_LINE 78
	//
	// /* 18.1.2009 RGB images ("plot ... with rgbimage") are drawn always in color,
	//  * i.e. for both "set term post color" and "set term post mono".
	//  */
	//    total_bits = bits_per_component*M*N*((color_mode == IC_RGB // && ps_params->color 
	//) ? 3 : 1);
	//
	// /* At the end of each image line, data is aligned to the nearest 8 bits,
	//  * which means potentially adding 7 bits per line.
	//  */
	//    end_of_line = M;
	//    total_bits += N*7;
	//
	// /* Compute max number of ascii characters encoding will require.
	//  */
	//    if (encoding == PS_ASCII_HEX) {
	// /* Straight hex encoding */
	//	max_encoded_bytes = (total_bits/4 + 1);
	//	max_encoded_bytes += max_encoded_bytes / ASCII_PER_LINE; // newline characters 
	//    } else {
	// /* ASCII85 encoding */
	//	max_encoded_bytes = (total_bits/32 + 1)*5 + 2; // 5 tuples and additional ~> 
	//	max_encoded_bytes += max_encoded_bytes / ASCII_PER_LINE; // newline characters 
	//    }
	//
	// /* Reserve enough memory. */
	//    if (!(encoded_image = gp_alloc(max_encoded_bytes, "encoded image")))
	//	int_error(NO_CARET, "GNUPLOT (post.trm):  Error allocating memory.\n");
	//    encoded_image_ptr = encoded_image;
	//
	//    coord_ptr = image;
	//    i_line = ASCII_PER_LINE;
	//    i_element = 0;
	//    coord_remaining = M*N;
	//    if (color_mode == IC_RGB // && ps_params->color 
	//) {
	//	end_of_line *= 3;
	//	coord_remaining *= 3;
	//    }
	//    bits_remaining = 32;
	//    bits_start = 0;
	//    tuple4 = 0;
	//
	//    while (coord_remaining) {
	//	unsigned short us_tmp;
	//	if (0 // color_mode == IC_RGB && !ps_params->color 
	//) {
	//	    coordval c_tmp;
	//	    c_tmp = *coord_ptr++;
	//	    c_tmp += *coord_ptr++;
	//	    c_tmp += *coord_ptr++;
	//	    us_tmp = (unsigned short) (c_tmp*(max_colors-1)/3.0 + 0.5);
	//	} else
	//	    us_tmp = (unsigned short) ((*coord_ptr++) * max_colors);
	//
	//	if (us_tmp > (max_colors-1)) us_tmp = max_colors-1;
	//
	// /* Rescale to accommodate a mismatch between max_colors and # of bits */
	//	us_tmp *= cscale;
	//
	//	if (bits_remaining < bits_per_component) {
	//	    tuple4 <<= bits_remaining;
	//	    bits_start = bits_per_component - bits_remaining;
	//	    bits_remaining = 0;
	//	    tuple4 |= (us_tmp >> bits_start);
	//	} else {
	//	    tuple4 <<= bits_per_component;
	//	    tuple4 |= us_tmp;
	//	    bits_remaining -= bits_per_component;
	//	}
	//
	// /* If this is last pixel in line, pad to nearest 8 bits. */
	//	i_element++;
	//	if (i_element == end_of_line) {
	//	    register unsigned short bit_align = (bits_remaining & 0x7);
	//	    tuple4 <<= bit_align;
	//	    bits_remaining -= bit_align;
	//	    i_element = 0;
	//	}
	//
	// /* Check if another 4-tuple is complete. */
	//	if (!bits_remaining) {
	//	    if (ps_params->level1) {
	// /* A straight hex encoding for every 4 bits. */
	//		unsigned char tuple8[8];
	//		int i;
	//		for (i=7; i >= 0; i--) {
	//		    tuple8[i] = tuple4 & 0xf;
	//		    tuple4 >>= 4;
	//		}
	//		for (i=0; i < 8; i++) {
	//		    sprintf(encoded_image_ptr++, "%1x", tuple8[i]);
	//		    i_line--;
	//		    if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
	//		}
	//	    } else {
	// /* Convert to ASCII85 representation. */
	//		if (tuple4) {
	//		    int i;
	//		    PS_encode85(tuple4, tuple5);
	//		    tuple4 = 0;
	//		    for (i=0; i < 5; i++) {
	//			sprintf(encoded_image_ptr++, "%c", tuple5[i]+'!');
	//			i_line--;
	//			if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
	//		    }
	//		} else {
	//		    *encoded_image_ptr++ = 'z';
	//		    i_line--;
	//		    if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
	//		}
	//	    }
	//
	// /* Now pick up any bits that may have not made it into the 4-tuple. */
	//	    if (bits_start) {tuple4 = us_tmp - ((us_tmp>>bits_start)<<bits_start);}
	//	    bits_remaining = 32 - bits_start;
	//	    bits_start = 0;
	//
	//	}
	//
	//	coord_remaining--;
	//
	//    }
	//
	//    if (bits_remaining < 32) {
	//	int i;
	//	int n = 4 - bits_remaining/8;
	//	if (ps_params->level1) {
	// /* A straight hex encoding for every 4 bits. */
	//	    unsigned char tuple8[8];
	//	    for (i=2*n-1; i >= 0; i--) {
	//		tuple8[i] = tuple4 & 0xf;
	//		tuple4 >>= 4;
	//	    }
	//	    for (i=0; i < 2*n; i++) {
	//		sprintf(encoded_image_ptr++, "%1x", tuple8[i]);
	//		i_line--;
	//		if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
	//	    }
	//	} else {
	// /* Convert to ASCII85 representation.
	//  *
	//  * The case where not all bytes in a tuple are used is slightly different.
	//  * There is no use of 'z' as a special character and the remaining bytes
	//  * need to be filled.  Then use only a portion of the final 5-tuple.
	//  */
	//	    tuple4 <<= bits_remaining;
	//	    PS_encode85(tuple4, tuple5);
	// /* Write first n+1 bytes. */
	//	    for (i=0; i <= n; i++) {
	//		sprintf(encoded_image_ptr++, "%c", tuple5[i]+'!');
	//		i_line--;
	//		if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
	//	    }
	//	}
	//    }
	//
	//    if (!ps_params->level1) {
	//	sprintf(encoded_image_ptr, "~>");
	//	encoded_image_ptr += 2;
	//    }
	//
	//    *return_num_bytes = (encoded_image_ptr - encoded_image);
	//    assert(*return_num_bytes <= max_encoded_bytes); 
	//    return encoded_image;
	//}
	//
	//
	//static void
	//print_five_operand_image(unsigned int M, unsigned int N, gpiPoint *corner, t_imagecolor color_mode, unsigned short bits_per_component)
	//{
	//    char *space = ps_params->level1 ? "" : "  ";
	//
	//    fprintf(gppsfile, "%sgsave\n", space);
	//    if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY)
	//	fprintf(gppsfile, "%s{pm3dGamma exp} settransfer\n", space);
	//    fprintf(gppsfile, "%s%d %d translate\n", space, corner[0].x, corner[0].y);
	//    fprintf(gppsfile, "%s%d %d scale\n", space, (corner[1].x - corner[0].x), (corner[1].y - corner[0].y));
	//    fprintf(gppsfile, "%s%d %d %d\n", space, M, N, bits_per_component);
	//    fprintf(gppsfile, "%s[ %d 0 0 %d 0 0 ]\n", space, M, N);
	//    if (ps_params->level1) {
	//	fprintf(gppsfile, "/imagebuf %d string def\n", 
	//		(M*N*bits_per_component*((color_mode == IC_RGB // && ps_params->color 
	//) ? 3 : 1) + 7)/8);
	//	fputs("{currentfile imagebuf readhexstring pop}\n", gppsfile);
	//    } else
	//	fprintf(gppsfile, "  currentfile /ASCII85Decode filter\n");
	//    if (color_mode == IC_RGB // && ps_params->color 
	//) {
	//	fprintf(gppsfile, "%sfalse 3\n"
	//			  "%scolorimage\n", space, space);
	//    } else
	//	fprintf(gppsfile, "%simage\n", space);
	//}
	//
	//
	//TERM_PUBLIC void
	//PS_image (unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
	//{
	//    char *encoded_image;
	//    int num_encoded_bytes;
	//    unsigned short bits_per_component = 0;
	//    int max_colors, i_tmp;
	//    TBOOLEAN five_operand_image;
	//    double cscale;
	//
	///#define DEFAULT_BITS_PER_COMPONENT 8
	///#define DEFAULT_COMPONENT_MAX (1<<DEFAULT_BITS_PER_COMPONENT)
	//
	//    if (sm_palette.use_maxcolors > 0)
	//	max_colors = sm_palette.use_maxcolors;
	//    else
	//	max_colors = DEFAULT_COMPONENT_MAX;
	//
	//    i_tmp = 1;
	//    while (i_tmp < max_colors) {
	//	bits_per_component++;
	//	i_tmp <<= 1;
	//    }
	//
	//    if (bits_per_component < 1 || bits_per_component > 12) {
	//	fprintf(stderr, "GNUPLOT (post.trm):  Component bits (%d) out of range.\n", bits_per_component);
	//	return;
	//    }
	//
	//    if (bits_per_component > 8)
	//	bits_per_component = 12;
	//    else if (bits_per_component > 4)
	//	bits_per_component = 8;
	//    else if (bits_per_component > 2)
	//	bits_per_component = 4;
	//
	// /* Color and gray scale images do not need a palette and can use
	//  * the 5 operand form of the image routine.
	//  */
	///#if 0
	// /* 18.1.2009 It was decided to use the custom palette (i.e. colours) also
	//    for the monochrome postscript output.
	// */
	//    if ((color_mode == IC_RGB) || (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) || !ps_params->color)
	///#else
	//    if ((color_mode == IC_RGB) || (sm_palette.colorMode == SMPAL_COLOR_MODE_RGB && !ps_params->color) || (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY))
	///#endif
	//	five_operand_image = TRUE;
	//    else
	//	five_operand_image = FALSE;
	//
	// /* The five operand image doesn't have a palette and the values are
	//  * such that 0 maps to 0.0 and 2^bits_per_component - 1 maps to 1.0
	//  * in the PostScript driver.  Without any other knowledge, we scale
	//  * things so that our max colors corresponds to 1.0.
	//  */
	//    if (five_operand_image)
	//	cscale =  (float)((1 << bits_per_component)-1) / (float)(max_colors-1);
	//    else
	//	cscale = 1.0;
	//
	//    encoded_image = PS_encode_image(M, N, image, color_mode, 
	//				bits_per_component, max_colors, cscale,
	//				(ps_params->level1 ? PS_ASCII_HEX : PS_ASCII85), &num_encoded_bytes);
	//
	//    fputs("%%%%BeginImage\n", gppsfile);
	//
	// /* Clip image to requested bounding box */
	//    fprintf(gppsfile,"gsave %d %d N %d %d L %d %d L %d %d L Z clip\n",
	//	corner[2].x, corner[2].y, corner[2].x, corner[3].y, corner[3].x, corner[3].y, corner[3].x, corner[2].y);
	//
	// /* Color and gray scale images do not need a palette and can use
	//  * the 5 operand form of the image routine.  For other types of
	//  * palettes, the 1 operand form of the image routine must be used
	//  * and an indexed palette needs to be constructed.
	//  */
	//    if (five_operand_image) {
	//
	//	if (ps_params->level1) {
	//	    print_five_operand_image(M, N, corner, color_mode, bits_per_component);
	//	} else {
	//	    fputs("InterpretLevel1 {\n"
	//		  "  %% Construct a box instead of image\n"
	//		  "  LTb\n", gppsfile);
	//	    fprintf(gppsfile, "  %d %d M\n", corner[0].x, corner[0].y);
	//	    fprintf(gppsfile, "  %d 0 V\n", (corner[1].x - corner[0].x));
	//	    fprintf(gppsfile, "  0 %d V\n", (corner[1].y - corner[0].y));
	//	    fprintf(gppsfile, "  %d 0 V\n", -(corner[1].x - corner[0].x));
	//	    fprintf(gppsfile, "  %d %d L\n", corner[0].x, corner[0].y);
	//	    fputs("  40 -110 R\n"
	//		  "  (PS level 2 image) Lshow\n"
	//		  "  % Read data but ignore it\n", gppsfile);
	//	    fprintf(gppsfile, "  /imagebuf %d string def\n", num_encoded_bytes);
	//	    fputs("  currentfile imagebuf readstring\n"
	//		  "} {\n", gppsfile);
	//	    print_five_operand_image(M, N, corner, color_mode, bits_per_component);
	//	    fputs("} ifelse\n", gppsfile);
	//	}
	//
	//    }
	//    else {
	//
	//	int allocated;
	//	unsigned short i_tuple;
	//	double fact = 1.0 / (double)(max_colors-1);
	//	if (!ps_params->level1) {
	//	    fputs("InterpretLevel1 {\n"
	//		  "  %% Construct a box instead of image\n"
	//		  "  LTb\n", gppsfile);
	//	    fprintf(gppsfile, "  %d %d M\n", corner[0].x, corner[0].y);
	//	    fprintf(gppsfile, "  %d 0 V\n", (corner[1].x - corner[0].x));
	//	    fprintf(gppsfile, "  0 %d V\n", (corner[1].y - corner[0].y));
	//	    fprintf(gppsfile, "  %d 0 V\n", -(corner[1].x - corner[0].x));
	//	    fprintf(gppsfile, "  %d %d L\n", corner[0].x, corner[0].y);
	//	    fprintf(gppsfile, "  40 -110 R\n"
	//		    "  (PS level 2 image) Lshow\n"
	//		    "  %% Read data but ignore it\n"
	//		    "  /imagebuf %d string def\n"
	//		    "  currentfile imagebuf readstring\n", num_encoded_bytes);
	//	    fputs("} {\n", gppsfile);
	//	}
	//	fputs("gsave\n", gppsfile);
	//	fprintf(gppsfile, "%d %d translate\n", corner[0].x, corner[0].y);
	//	fprintf(gppsfile, "%d %d scale\n", (corner[1].x - corner[0].x), (corner[1].y - corner[0].y));
	//	fputs("%%%%BeginPalette\n", gppsfile);
	//	fprintf(gppsfile, "[ /Indexed\n  /DeviceRGB %d\n  <", (max_colors-1));
	//
	///#define TUPLES_PER_LINE 8
	//
	//	for (allocated = 0, i_tuple = 0; allocated < max_colors; allocated++, i_tuple--) {
	//	    double gray = (double) allocated * fact;
	//	    rgb255_color color;
	//	    rgb255maxcolors_from_gray( gray, &color );
	//	    if (!i_tuple) { fprintf(gppsfile,"\n  "); i_tuple = TUPLES_PER_LINE; }
	//	    fprintf(gppsfile," %2.2x%2.2x%2.2x", (int)color.r, (int)color.g, (int)color.b);
	//	}
	//
	//	fputs("\n  >\n] setcolorspace\n", gppsfile);
	//	fputs("%%%%EndPalette\n", gppsfile);
	//	fprintf(gppsfile, "<<\n  /ImageType 1\n  /Width %d\n  /Height %d\n", M, N);
	//	fprintf(gppsfile, "  /BitsPerComponent %d\n  /ImageMatrix [ %d 0 0 %d 0 0 ]\n", bits_per_component, M, N);
	//	fprintf(gppsfile, "  /Decode [ 0 %d ]\n", ((1<<bits_per_component)-1));
	//	if (ps_params->level1) {
	//	    fprintf(gppsfile, "  /imagebuf %d string def\n", (M*N*bits_per_component + 7)/8);
	//	    fputs("  /DataSource {currentfile imagebuf readhexstring pop}\n", gppsfile);
	//	} else {
	//	    fputs("  /DataSource currentfile /ASCII85Decode filter\n", gppsfile);
	//	}
	//	fputs("  /MultipleDataSources false\n", gppsfile);
	//	fputs("  /Interpolate false\n"
	//	      ">>\n"
	//	      "image\n", gppsfile);
	//	if (!ps_params->level1)
	//	    fputs("} ifelse\n", gppsfile);
	//
	//    }
	//
	// /* Send encoded image to file. */
	//    {
	//    char *encoded_image_ptr;
	//    for (i_tmp=0, encoded_image_ptr = encoded_image; i_tmp < num_encoded_bytes; i_tmp++)
	//	fputc(*encoded_image_ptr++, gppsfile);
	//    }
	//
	//    if (ps_params->level1)
	//	fputs("\ngrestore\n", gppsfile);
	//    else
	//	fputs("\nInterpretLevel1 not {\n"
	//	      "  grestore\n"
	//	      "} if\n", gppsfile);
	//    fputs("grestore\n", gppsfile);
	//    fputs("%%%%EndImage\n", gppsfile);
	//
	//    free(encoded_image);
	//
	//    return;
	//}
	//
	//
	// /* First look for the GNUPLOT_PS_DIR environment variable
	//  * If unsuccessful, look for hardcoded absolute path on UNIX,
	//  * or hardcoded relative path on Windows and OS2,
	//  * or files included at compile time. */
	//static FILE *
	//PS_open_prologue_file(char *name)
	//{
	//    char *fullname;
	//    char *ps_prologue_dir;
	//    FILE *prologue_fd;
	//
	//    if ((ps_prologue_dir = getenv("GNUPLOT_PS_DIR")) == NULL) {
	///#ifdef GNUPLOT_PS_DIR
	///#if defined(_Windows)
	// /* retrieve prologues path relatively to gnuplot executable,
	//  * whose path is in szModuleName (winmain.c) */
	//	ps_prologue_dir = gp_alloc(strlen((char*) szPackageDir)
	//			+ strlen(GNUPLOT_PS_DIR) + 2, "Prolog path");
	//	strcpy(ps_prologue_dir, (char*) szPackageDir);
	//	strcat(ps_prologue_dir, "\\");
	// /* GNUPLOT_PS_DIR is _relative_ path */
	//	strcat(ps_prologue_dir, GNUPLOT_PS_DIR);
	///#elif defined(OS2)
	//	const ULONG bufsiz = 1024;
	//	CHAR exepath[bufsiz];
	//	PPIB ppib;
	//	ULONG rc;
	//	
	//	rc = DosGetInfoBlocks(NULL, &ppib);
	//	if (!rc)
	//		rc = DosQueryModuleName(ppib->pib_hmte, bufsiz, (PCHAR) &exepath);
	//	if (!rc) {
	//	    char *p = strrchr(exepath, '\\');
	//	    *(++p) = '\0';
	//	    ps_prologue_dir = gp_alloc(strlen(exepath) + strlen(GNUPLOT_PS_DIR) + 2,
	//			"Prolog path");
	//	    strcpy(ps_prologue_dir, exepath);
	//	    strcat(ps_prologue_dir, "\\");
	// /* GNUPLOT_PS_DIR is _relative_ path */
	//	    strcat(ps_prologue_dir, GNUPLOT_PS_DIR);
	//	}
	//	else {
	//	    ps_prologue_dir = gp_alloc(1, "Prolog path");
	// /* unsucessful to retrieve executable path */
	//	    strcpy(ps_prologue_dir,"");
	//	}
	///#else // !_Windows && !OS2 
	// /* use hardcoded _absolute_ path */
	//	ps_prologue_dir = GNUPLOT_PS_DIR;
	///#endif
	///#else // using headers included at compile time 
	//	const char **dump = NULL;
	//	int i;
	//
	// /* load from included header */
	//	if (!strcmp(name,"8859-15.ps"))
	//		dump = prologue_8859_15_ps;
	//	else if (!strcmp(name,"8859-1.ps"))
	//		dump = prologue_8859_1_ps;
	//	else if (!strcmp(name,"8859-2.ps"))
	//		dump = prologue_8859_2_ps;
	//	else if (!strcmp(name,"8859-9.ps"))
	//		dump = prologue_8859_9_ps;
	//	else if (!strcmp(name,"cp1250.ps"))
	//		dump = prologue_cp1250_ps;
	//	else if (!strcmp(name,"cp437.ps"))
	//		dump = prologue_cp437_ps;
	//	else if (!strcmp(name,"cp850.ps"))
	//		dump = prologue_cp850_ps;
	//	else if (!strcmp(name,"cp852.ps"))
	//		dump = prologue_cp852_ps;
	//	else if (!strcmp(name,"koi8r.ps"))
	//		dump = prologue_koi8r_ps;
	//	else if (!strcmp(name,"koi8u.ps"))
	//		dump = prologue_koi8u_ps;
	//	else if (!strcmp(name,"utf-8.ps"))
	//		dump = prologue_utf_8_ps;
	//	else if (!strcmp(name,"prologue.ps"))
	//		dump = prologue_prologue_ps;
	//	else
	//		int_warn(NO_CARET,"Requested Postscript prologue %s not found",name);
	//
	//	if (dump) {
	//		for (i = 0; dump[i] != NULL; ++i)
	//		fprintf(gppsfile, "%s", dump[i]);
	//	}
	//	return NULL;
	///#endif // GNUPLOT_PS_DIR 
	//    }
	//
	//    fullname = gp_alloc(strlen(ps_prologue_dir) + strlen(name) + 4,"Prolog name");
	//    strcpy(fullname,ps_prologue_dir);
	///#if defined(_Windows) || defined(OS2)
	//    if (fullname[strlen(fullname)-1] != '\\')
	//	strcat(fullname,"\\");
	///#elif !defined(VMS)
	//    if (fullname[strlen(fullname)-1] != '/')
	//	strcat(fullname,"/");
	///#endif
	//    strcat(fullname,name);
	//    prologue_fd = fopen(fullname,"r");
	///#if defined(_Windows) || defined(OS2)
	//    if (getenv("GNUPLOT_PS_DIR") == NULL)
	//	free(ps_prologue_dir);
	///#endif
	//    if (!prologue_fd)
	//	prologue_fd = loadpath_fopen(name,"r");
	//    if (!prologue_fd) {
	//	fprintf(stderr,"Can't find PostScript prologue file %s\n", fullname);
	//	loadpath_handler(ACTION_SHOW,NULL);
	//	free(fullname);
	//	fprintf(stderr,"Please copy %s to one of the above directories\n",name);
	//	fprintf(stderr,"or set the loadpath appropriately\n");
	//	fprintf(stderr,"or set the environmental variable GNUPLOT_PS_DIR\n");
	//	int_error(NO_CARET,"Plot failed!");
	//    }
	//    free(fullname);
	//    return prologue_fd;
	//}
	//    
	//static void
	//PS_dump_prologue_file(char *name)
	//{
	//    char buf[256];
	//    FILE *prologue_fd = PS_open_prologue_file(name);
	//
	//    if (prologue_fd) {
	//	while (fgets(buf, sizeof(buf), prologue_fd))
	//	    fputs(buf, gppsfile);
	//	fclose(prologue_fd);
	//    }
	//}
	//
	//static void
	//PS_load_glyphlist()
	//{
	//    char buf[256];
	//    char *next = NULL;
	//    unsigned int code;
	//    int  len;
	//    char glyph_name[32];
	//    FILE *prologue_fd = PS_open_prologue_file("aglfn.txt");
	//    
	//    if (!prologue_fd)
	//	return;
	//
	//    while (fgets(buf, sizeof(buf), prologue_fd)) {
	//	if (*buf == '#' || *buf == '\n')
	//	    continue;
	//	code = strtol(buf,&next,16);
	//
	// /* User control over whether Adobe glyph names are used for unicode   */
	// /* entries above 0x0100.  I.e. when we see a UTF-8 alpha, do we write */
	// /* /alpha rather than /uni03B1?   Some fonts want one or the other.   */
	// /* This is controlled by 'set term post adobeglyphnames'.             */
	//	if (code >= 0x0100 && !ps_params->adobeglyphnames)
	//	    continue;
	//	
	//	next++;
	//	len = strchr(next,';') - next;
	//	strncpy(glyph_name, next, len);
	//	glyph_name[len] = '\0';
	//	FPRINTF((stderr, "%04X   %s\n", code, glyph_name));
	//	if (aglist_size + sizeof(ps_glyph) > aglist_alloc) {
	//	    aglist_alloc += 2048;
	//	    aglist = gp_realloc(aglist, aglist_alloc, "aglist");
	//	}
	//	aglist[psglyphs].unicode = code;
	//	aglist[psglyphs].glyphname = gp_strdup(glyph_name);
	//	aglist_size += sizeof(ps_glyph);
	//	psglyphs++;
	//    }
	//
	//    fclose(prologue_fd);
	//}
	//
	//TERM_PUBLIC void
	//PS_path(int p)
	//{
	//    switch (p) {
	//	case 0:	// Start new path 
	//		PS_FLUSH_PATH;
	//		PS_newpath = TRUE;
	//		break;
	//
	//	case 1: // Close path 
	//		fprintf(gppsfile, "Z ");
	//		PS_FLUSH_PATH;
	//		break;
	//    }
	//
	//}
	//
	//TERM_PUBLIC void
	//PS_layer(t_termlayer syncpoint)
	//{
	//    static int plotno = 0;
	//
	// /* We must ignore all syncpoints that we don't recognize */
	//    switch (syncpoint) {
	//
	//	default:
	//		break;
	//	
	//	case TERM_LAYER_BEFORE_PLOT:
	//		fprintf(gppsfile, "%% Begin plot #%d\n", ++plotno);
	//		break;
	//	
	//	case TERM_LAYER_AFTER_PLOT:
	//		fprintf(gppsfile, "%% End plot #%d\n", plotno);
	//		break;
	//	
	//	case TERM_LAYER_RESET:
	//		plotno = 0;
	//		break;
	//
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(post_driver)
	//    "postscript",
	//    "PostScript graphics, including EPSF embedded files (*.eps)",
	//    PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, 
	//    PS_VTIC, PS_HTIC, PS_options, PS_init, PS_reset, 
	//    PS_text, null_scale, PS_graphics, PS_move, PS_vector, 
	//    PS_linetype, PS_put_text, PS_text_angle, 
	//    PS_justify_text, PS_point, PS_arrow, PS_set_font, PS_pointsize,
	//    TERM_BINARY|TERM_IS_POSTSCRIPT|TERM_CAN_CLIP|TERM_CAN_DASH|TERM_MONOCHROME|TERM_LINEWIDTH, 
	//    0 //suspend
	//, 0 //resume
	//, PS_fillbox, PS_linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0 // no mouse support for postscript 
	///#endif
	//    , PS_make_palette,
	//    PS_previous_palette, // write grestore 
	//    PS_set_color,
	//    PS_filled_polygon
	//    , PS_image
	//    , ENHPS_OPEN, ENHPS_FLUSH, ENHPS_WRITEC
	//    , PS_layer		// used only to insert comments 
	//    , PS_path
	//    , PS_SC		// terminal to pixel coord scale factor 
	//TERM_TABLE_END(post_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM post_driver
	//
	///#endif // TERM_TABLE 

	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	// /* This is a pseudo help section that is labeled with 00psglobal to be
	//  * sure that it is sorted in before `post', `epslatex', and `pslatex'.
	//  * This section just defines commonly used text snippets for all three
	//  * help sections defined in this file. Defining PS_COMMON_OPTS1,
	//  * PS_COMMON_OPTS2, and PS_COMMON_DOC1 outside START_HELP()...END_HELP()
	//  * does not work.
	//  * The last line before the END_HELP(00psglobal) contains one single line
	//  * of "text" that is necessary to avoid errors.
	//  */
	//START_HELP(00psglobal)
	///#define PS_COMMON_OPTS1 "                               {level1 | leveldefault}","                               {color | colour | monochrome}","                               {solid | dashed}","                               {dashlength | dl <DL>}","                               {linewidth | lw <LW>}","                               {rounded | butt}","                               {clip | noclip}","                               {palfuncparam <samples>{,<maxdeviation>}}","                               {size <XX>{unit},<YY>{unit}}",
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	///#define PS_COMMON_OPTS2 "                               {blacktext | colortext | colourtext}","                               {{font} \"fontname{,fontsize}\" {<fontsize>}}",
	//ignore
	//ignore
	///#define PS_COMMON_PROLOG_INFO " If you see the error message","       \"Can't find PostScript prologue file ... \""," Please see and follow the instructions in `postscript prologue`.","",
	//ignore
	//ignore
	//ignore
	//ignore
	///#define PS_COMMON_DOC1 " The option `color` enables color, while `monochrome` prefers black and white"," drawing elements. Further, `monochrome` uses gray `palette` but it does not"," change color of objects specified with an explicit `colorspec`."""," `solid` draws all plots with solid lines, overriding any dashed patterns."," `dashlength` or `dl` scales the length of the dashed-line segments by <DL>,"," which is a floating-point number greater than zero."," `linewidth` or `lw` scales all linewidths by <LW>.",""," By default the generated PostScript code uses language features that were"," introduced in PostScript Level 2, notably filters and pattern-fill of"," irregular objects such as filledcurves.  PostScript Level 2 features are"," conditionally protected so that PostScript Level 1 interpreters do not issue"," errors but, rather, display a message or a PostScript Level 1 approximation."," The `level1` option substitutes PostScript Level 1 approximations of these"," features and uses no PostScript Level 2 code.  This may be required by some"," old printers and old versions of Adobe Illustrator.  The flag `level1` can be", " toggled later by editing a single line in the PostScript output file to force"," PostScript Level 1 interpretation.  In the case of files containing level 2"," code, the above features will not appear or will be replaced by a note when"," this flag is set or when the interpreting program does not indicate that it"," understands level 2 PostScript or higher.",""," `rounded` sets line caps and line joins to be rounded; `butt` is the"," default, butt caps and mitered joins.",""," `clip` tells PostScript to clip all output to the bounding box;"," `noclip` is the default.",""," `palfuncparam` controls how `set palette functions` are encoded as gradients"," in the output. Analytic color component functions (set via"," `set palette functions`) are encoded as linear interpolated gradients in the"," postscript output:  The color component functions are sampled at <samples>"," points and all points are removed from this gradient which can be removed"," without changing the resulting colors by more than <maxdeviation>. For"," almost every useful palette you may savely leave the defaults of"," <samples>=2000 and <maxdeviation>=0.003 untouched.",""," The default size for postscript output is 10 inches x 7 inches. The default"," for eps output is 5 x 3.5 inches.  The `size` option changes this to"," whatever the user requests. By default the X and Y sizes are taken to be in"," inches, but other units are possibly (currently only cm). The BoundingBox"," of the plot is correctly adjusted to contain the resized image."," Screen coordinates always run from 0.0 to 1.0 along the full length of the"," plot edges as specified by the `size` option."," NB: `this is a change from the previously recommended method of using the"," set size command prior to setting the terminal type`.  The old method left"," the BoundingBox unchanged and screen coordinates did not correspond to the"," actual limits of the plot.","",
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//""
	//END_HELP(00psglobal)
	//
	//START_HELP(epslatex)
	//"1 epslatex",
	//"?commands set terminal epslatex",
	//"?set terminal epslatex",
	//"?set term epslatex",
	//"?terminal epslatex",
	//"?term epslatex",
	//"?epslatex",
	//" The `epslatex` driver generates output for further processing by LaTeX.",
	//"",
	//" Syntax:",
	//"       set terminal epslatex   {default}",
	//"       set terminal epslatex   {standalone | input}",
	//"                               {oldstyle | newstyle}",
	//PS_COMMON_OPTS1
	//"                               {header <header> | noheader}",
	//PS_COMMON_OPTS2
	//"",
	//" The epslatex terminal prints a plot as `terminal postscript eps`",
	//" but transfers the texts to LaTeX instead of including in the PostScript",
	//" code. Thus, many options are the same as in the `postscript terminal`.",
	//"",
	//" The appearance of the epslatex terminal changed between versions 4.0 and 4.2",
	//" to reach better consistency with the postscript terminal:",
	//" The plot size has been changed from 5 x 3 inches to 5 x 3.5 inches;",
	//" the character width is now estimated to be 60% of the font size",
	//" while the old epslatex terminal used 50%;  now, the larger number of",
	//" postscript linetypes and symbols are used.  To reach an appearance that is",
	//" nearly identical to the old one specify the option `oldstyle`. (In fact",
	//" some small differences remain: the symbol sizes are slightly different, the",
	//" tics are half as large as in the old terminal which can be changed using",
	//" `set tics scale`, and the arrows have all features as in the postscript",
	//" terminal.)",
	//"",
	//PS_COMMON_PROLOG_INFO
	//PS_COMMON_DOC1
	//" `blacktext` forces all text to be written in black even in color mode;",
	//"",
	//" The epslatex driver offers a special way of controlling text positioning:",
	//" (a) If any text string begins with '{', you also need to include a '}' at the",
	//" end of the text, and the whole text will be centered both horizontally",
	//" and vertically by LaTeX.  (b) If the text string begins with '[', you need",
	//" to continue it with: a position specification (up to two out of t,b,l,r,c),",
	//" ']{', the text itself, and finally, '}'. The text itself may be anything",
	//" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
	//" See also the documentation for the `pslatex` terminal driver.",
	//" To create multiline labels, use \\shortstack, for example",
	//"    set ylabel '[r]{\\shortstack{first line \\\\ second line}}' ",
	//"",
	//" The `back` option of `set label` commands is handled slightly different",
	//" than in other terminals. Labels using 'back' are printed behind all other",
	//" elements of the plot while labels using 'front' are printed above ",
	//" everything else.",
	//"",
	//" The driver produces two different files, one for the eps part of the figure",
	//" and one for the LaTeX part. The name of the LaTeX file is taken from the",
	//" `set output` command. The name of the eps file is derived by replacing",
	//" the file extension (normally `.tex`) with `.eps` instead.  There is no",
	//" LaTeX output if no output file is given!  Remember to close the",
	//" `output file` before next plot unless in `multiplot` mode.",
	//"",
	//" In your LaTeX documents use '\\input{filename}' to include the figure.",
	//" The `.eps` file is included by the command \\includegraphics{...}, so you",
	//" must also include \\usepackage{graphicx} in the LaTeX preamble.  If you",
	//" want to use coloured text (option `textcolour`) you also have to include",
	//" \\usepackage{color} in the LaTeX preamble.",
	//"",
	//" Pdf files can be made from the eps file using 'epstopdf'. If the graphics",
	//" package is properly configured, the LaTeX files can also be processed by",
	//" pdflatex without changes, using the pdf files instead of the eps files."
	//"",
	//" The behaviour concerning font selection depends on the header mode.",
	//" In all cases, the given font size is used for the calculation of proper",
	//" spacing. When not using the `standalone` mode the actual LaTeX font and",
	//" font size at the point of inclusion is taken, so use LaTeX commands for",
	//" changing fonts. If you use e.g. 12pt as font size for your LaTeX",
	//" document, use '\"\" 12' as options. The font name is ignored. If using",
	//" `standalone` the given font and font size are used, see below for a",
	//" detailed description.",
	//"",
	//" If text is printed coloured is controlled by the TeX booleans \\ifGPcolor",
	//" and \\ifGPblacktext. Only if \\ifGPcolor is true and \\ifGPblacktext is",
	//" false, text is printed coloured. You may either change them in the",
	//" generated TeX file or provide them globally in your TeX file, for example",
	//" by using",
	//"    \\newif\\ifGPblacktext",
	//"    \\GPblacktexttrue",
	//" in the preamble of your document. The local assignment is only done if no",
	//" global value is given.",
	//"",
	//" When using the epslatex terminal give the name of the TeX file in the",
	//" `set output` command including the file extension (normally \".tex\").",
	//" The eps filename is generated by replacing the extension by \".eps\".",
	//"",
	//" If using the `standalone` mode a complete LaTeX header is added to the",
	//" LaTeX file; and \"-inc\" is added to the filename of the eps file.",
	//" The `standalone` mode generates a TeX file that produces",
	//" output with the correct size when using dvips, pdfTeX, or VTeX.",
	//" The default, `input`, generates a file that has to be included into a",
	//" LaTeX document using the \\input command.",
	//"",
	//" If a font other than \"\" or \"default\" is given it is interpreted as",
	//" LaTeX font name.  It contains up to three parts, separated by a comma:",
	//" 'fontname,fontseries,fontshape'.  If the default fontshape or fontseries",
	//" are requested, they can be omitted.  Thus, the real syntax for the fontname",
	//" is '[fontname][,fontseries][,fontshape]'.  The naming convention for all",
	//" parts is given by the LaTeX font scheme.  The fontname is 3 to 4 characters",
	//" long and is built as follows: One character for the font vendor, two",
	//" characters for the name of the font, and optionally one additional",
	//" character for special fonts, e.g., 'j' for fonts with old-style numerals",
	//" or 'x' for expert fonts. The names of many fonts is described in",
	//"^ <a href=\"http://www.tug.org/fontname/fontname.pdf\">",
	//"           http://www.tug.org/fontname/fontname.pdf",
	//"^ </a>",
	//" For example, 'cmr' stands for Computer Modern Roman, 'ptm' for Times-Roman,",
	//" and 'phv' for Helvetica.  The font series denotes the thickness of the",
	//" glyphs, in most cases 'm' for normal (\"medium\") and 'bx' or 'b' for bold",
	//" fonts.  The font shape is 'n' for upright, 'it' for italics, 'sl' for",
	//" slanted, or 'sc' for small caps, in general.  Some fonts may provide",
	//" different font series or shapes.",
	//"",
	//" Examples:",
	//"",
	//" Use Times-Roman boldface (with the same shape as in the surrounding text):",
	//"       set terminal epslatex 'ptm,bx'",
	//" Use Helvetica, boldface, italics:",
	//"       set terminal epslatex 'phv,bx,it'",
	//" Continue to use the surrounding font in slanted shape:",
	//"       set terminal epslatex ',,sl'",
	//" Use small capitals:",
	//"       set terminal epslatex ',,sc'",
	//"",
	//" By this method, only text fonts are changed. If you also want to change",
	//" the math fonts you have to use the \"gnuplot.cfg\" file or the `header`",
	//" option, described below.",
	//"",
	//" In standalone mode, the font size is taken from the given font size in the",
	//" `set terminal` command. To be able to use a specified font size, a file",
	//" \"size<size>.clo\" has to reside in the LaTeX search path.  By default,",
	//" 10pt, 11pt, and 12pt are supported.  If the package \"extsizes\" is",
	//" installed, 8pt, 9pt, 14pt, 17pt, and 20pt are added.",
	//"",
	//" The `header` option takes a string as argument.  This string is written",
	//" into the generated LaTeX file.  If using the `standalone` mode, it is ",
	//" written into the preamble, directly before the \\begin{document} command.",
	//" In the `input` mode, it is placed directly after the \\begingroup command",
	//" to ensure that all settings are local to the plot.",
	//"",
	//" Examples:",
	//"",
	//" Use T1 fontencoding, change the text and math font to Times-Roman as well",
	//" as the sans-serif font to Helvetica:",
	//"     set terminal epslatex standalone header \\",
	//"     \"\\\\usepackage[T1]{fontenc}\\n\\\\usepackage{mathptmx}\\n\\\\usepackage{helvet}\"",
	//" Use a boldface font in the plot, not influencing the text outside the plot:",
	//"     set terminal epslatex input header \"\\\\bfseries\"",
	//"",
	//" If the file \"gnuplot.cfg\" is found by LaTeX it is input in the preamble",
	//" the LaTeX document, when using `standalone` mode.  It can be used for",
	//" further settings, e.g., changing the document font to Times-Roman,",
	//" Helvetica, and Courier, including math fonts (handled by \"mathptmx.sty\"):",
	//"       \\usepackage{mathptmx}",
	//"       \\usepackage[scaled=0.92]{helvet}",
	//"       \\usepackage{courier}",
	//" The file \"gnuplot.cfg\" is loaded before the header information given",
	//" by the `header` command.  Thus, you can use `header` to overwrite some of",
	//" settings performed using \"gnuplot.cfg\"",
	//""
	//END_HELP(epslatex)
	//
	//START_HELP(pslatex)
	//"1 pslatex and pstex",
	//"?commands set terminal pslatex",
	//"?set terminal pslatex",
	//"?set term pslatex",
	//"?terminal pslatex",
	//"?term pslatex",
	//"?pslatex",
	//"?commands set terminal pstex",
	//"?set terminal pstex",
	//"?set term pstex",
	//"?terminal pstex",
	//"?term pstex",
	//"?pstex",
	//" The `pslatex` driver generates output for further processing by LaTeX,",
	//" while the `pstex` driver generates output for further processing by",
	//" TeX. `pslatex` uses \\specials understandable by dvips and xdvi. Figures",
	//" generated by `pstex` can be included in any plain-based format (including",
	//" LaTeX).",
	//"",
	//" Syntax:",
	//"       set terminal [pslatex | pstex] {default}",
	//"       set terminal [pslatex | pstex]",
	//"                               {rotate | norotate}",
	//"                               {oldstyle | newstyle}",
	//"                               {auxfile | noauxfile}",
	//PS_COMMON_OPTS1
	//"                               {<font_size>}",
	//"",
	//PS_COMMON_PROLOG_INFO
	//PS_COMMON_DOC1
	//" if `rotate` is specified, the y-axis label is rotated.",
	//" <font_size> is the size (in pts) of the desired font.",
	//"",
	//" If `auxfile` is specified, it directs the driver to put the PostScript",
	//" commands into an auxiliary file instead of directly into the LaTeX file.",
	//" This is useful if your pictures are large enough that dvips cannot handle",
	//" them.  The name of the auxiliary PostScript file is derived from the name of",
	//" the TeX file given on the `set output` command; it is determined by replacing",
	//" the trailing `.tex` (actually just the final extent in the file name) with",
	//" `.ps` in the output file name, or, if the TeX file has no extension, `.ps`",
	//" is appended.  The `.ps` is included into the `.tex` file by a",
	//" \\special{psfile=...} command.  Remember to close the `output file` before",
	//" next plot unless in `multiplot` mode.",
	//"",
	//" Gnuplot versions prior to version 4.2 generated plots of the size",
	//" 5 x 3 inches using the ps(la)tex terminal while the current version generates",
	//" 5 x 3.5 inches to be consistent with the postscript eps terminal.  In",
	//" addition, the character width is now estimated to be 60% of the font size",
	//" while the old epslatex terminal used 50%. To reach the old format specify",
	//" the option `oldstyle`.",
	//"",
	//" The pslatex driver offers a special way of controlling text positioning: ",
	//" (a) If any text string begins with '{', you also need to include a '}' at the",
	//" end of the text, and the whole text will be centered both horizontally",
	//" and vertically by LaTeX.  (b) If the text string begins with '[', you need",
	//" to continue it with: a position specification (up to two out of t,b,l,r),",
	//" ']{', the text itself, and finally, '}'. The text itself may be anything",
	//" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
	//"",
	//" The options not described here are identical to the `Postscript terminal`.",
	//" Look there if you want to know what they do.",
	//"",
	//" Examples:",
	//"       set term pslatex monochrome dashed rotate       # set to defaults",
	//" To write the PostScript commands into the file \"foo.ps\":",
	//"       set term pslatex auxfile",
	//"       set output \"foo.tex\"; plot ...; set output",
	//" About label positioning:",
	//" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
	//"        set title '\\LaTeX\\ -- $ \\gamma $'",
	//" Force centering both horizontally and vertically:",
	//"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
	//" Specify own positioning (top here):",
	//"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
	//" The other label -- account for long ticlabels:",
	//"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'",
	//"",
	//" Linewidths and pointsizes may be changed with `set style line`."
	//""
	//END_HELP(pslatex)
	//
	//START_HELP(post)
	//"1 postscript",
	//"?commands set terminal postscript",
	//"?set terminal postscript",
	//"?set term postscript",
	//"?terminal postscript",
	//"?term postscript",
	//"?postscript",
	//" Several options may be set in the `postscript` driver.",
	//"",
	//" Syntax:",
	//"       set terminal postscript {default}",
	//"       set terminal postscript {landscape | portrait | eps}",
	//"                               {enhanced | noenhanced}",
	//"                               {defaultplex | simplex | duplex}",
	//"                               {fontfile [add | delete] \"<filename>\"",
	//"                                | nofontfiles} {{no}adobeglyphnames}",
	//PS_COMMON_OPTS1
	//PS_COMMON_OPTS2
	//PS_COMMON_PROLOG_INFO
	//"",
	//" `landscape` and `portrait` choose the plot orientation.",
	//" `eps` mode generates EPS (Encapsulated PostScript) output, which is just",
	//" regular PostScript with some additional lines that allow the file to be",
	//" imported into a variety of other applications.  (The added lines are",
	//" PostScript comment lines, so the file may still be printed by itself.)  To",
	//" get EPS output, use the `eps` mode and make only one plot per file.  In `eps`",
	//" mode the whole plot, including the fonts, is reduced to half of the default",
	//" size.",
	//"",
	//" `enhanced` enables enhanced text mode features (subscripts,",
	//" superscripts and mixed fonts). See `enhanced` for more information.",
	//" `blacktext` forces all text to be written in black even in color mode;",
	//"",
	//" Duplexing in PostScript is the ability of the printer to print on both",
	//" sides of the same sheet of paper.  With `defaultplex`, the default setting",
	//" of the printer is used; with `simplex` only one side is printed; `duplex`",
	//" prints on both sides (ignored if your printer can't do it).",
	//"",
	//" `\"<fontname>\"` is the name of a valid PostScript font; and `<fontsize>` is",
	//" the size of the font in PostScript points.",
	//" In addition to the standard postscript fonts, an oblique version of the",
	//" Symbol font, useful for mathematics, is defined. It is called",
	//" \"Symbol-Oblique\".",
	//"",
	//" `default` sets all options to their defaults: `landscape`, `monochrome`,",
	//" `dashed`, `dl 1.0`, `lw 1.0`, `defaultplex`, `noenhanced`, \"Helvetica\" and",
	//" 14pt.  Default size of a PostScript plot is 10 inches wide and 7 inches high.",
	//PS_COMMON_DOC1
	//" Fonts listed by `fontfile` or `fontfile add` encapsulate the font",
	//" definitions of the listed font from a postscript Type 1 or TrueType font",
	//" file directly into the gnuplot output postscript file.  Thus, the enclosed",
	//" font can be used in labels, titles, etc.  See the section",
	//" `postscript fontfile` for more details.  With `fontfile delete`, a fontfile",
	//" is deleted from the list of embedded files.  `nofontfiles` cleans the list",
	//" of embedded fonts.",
	//"",
	//" Examples:",
	//"       set terminal postscript default       # old postscript",
	//"       set terminal postscript enhanced      # old enhpost",
	//"       set terminal postscript landscape 22  # old psbig",
	//"       set terminal postscript eps 14        # old epsf1",
	//"       set terminal postscript eps 22        # old epsf2",
	//"       set size 0.7,1.4; set term post portrait color \"Times-Roman\" 14",
	//"       set term post \"VAGRoundedBT_Regular\" 14 fontfile \"bvrr8a.pfa\"",
	//"",
	//" Linewidths and pointsizes may be changed with `set style line`.",
	//"",
	//" The `postscript` driver supports about 70 distinct pointtypes, selectable",
	//" through the `pointtype` option on `plot` and `set style line`.",
	//"",
	//" Several possibly useful files about `gnuplot`'s PostScript are included",
	//" in the /docs/psdoc subdirectory of the `gnuplot` distribution and at the",
	//" distribution sites.  These are \"ps_symbols.gpi\" (a `gnuplot` command file",
	//" that, when executed, creates the file \"ps_symbols.ps\" which shows all the",
	//" symbols available through the `postscript` terminal), \"ps_guide.ps\" (a",
	//" PostScript file that contains a summary of the enhanced syntax and a page",
	//" showing what the octal codes produce with text and symbol fonts),",
	//" \"ps_file.doc\" (a text file that contains a discussion of the organization",
	//" of a PostScript file written by `gnuplot`), and \"ps_fontfile_doc.tex\"",
	//" (a LaTeX file which contains a short documentation concerning the",
	//" encapsulation of LaTeX fonts with a glyph table of the math fonts).",
	//"",
	//" A PostScript file is editable, so once `gnuplot` has created one, you are",
	//" free to modify it to your heart's desire.  See the `editing postscript`",
	//" section for some hints.",
	//"2 editing postscript",
	//"?commands set terminal postscript editing",
	//"?set terminal postscript editing",
	//"?set term postscript editing",
	//"?terminal postscript editing",
	//"?term postscript editing",
	//"?editing_postscript",
	//"?editing postscript",
	//" The PostScript language is a very complex language---far too complex to",
	//" describe in any detail in this document.  Nevertheless there are some things",
	//" in a PostScript file written by `gnuplot` that can be changed without risk of",
	//" introducing fatal errors into the file.",
	//"",
	//" For example, the PostScript statement \"/Color true def\" (written into the",
	//" file in response to the command `set terminal postscript color`), may be",
	//" altered in an obvious way to generate a black-and-white version of a plot.",
	//" Similarly line colors, text colors, line weights and symbol sizes can also be",
	//" altered in straight-forward ways.  Text (titles and labels) can be edited to",
	//" correct misspellings or to change fonts.  Anything can be repositioned, and",
	//" of course anything can be added or deleted, but modifications such as these",
	//" may require deeper knowledge of the PostScript language.",
	//"",
	//" The organization of a PostScript file written by `gnuplot` is discussed in",
	//" the text file \"ps_file.doc\" in the docs/ps subdirectory of the gnuplot",
	//" source distribution.",
	//"2 postscript fontfile",
	//"?commands set terminal postscript fontfile",
	//"?set terminal postscript fontfile",
	//"?set term postscript fontfile",
	//"?terminal postscript fontfile",
	//"?term postscript fontfile",
	//"?postscript fontfile",
	//"?fontfile",
	//" The `fontfile` or `fontfile add` option takes one file name as argument",
	//" and encapsulates this file into the postscript output in order to make",
	//" this font available for text elements (labels, tic marks, titles, etc.).",
	//" The `fontfile delete` option also takes one file name as argument. It",
	//" deletes this file name from the list of encapsulated files.",
	//"",
	//" The postscript terminal understands some",
	//" font file formats: Type 1 fonts in ASCII file format (extension \".pfa\"),",
	//" Type 1 fonts in binary file format (extension \".pfb\"), and TrueType",
	//" fonts (extension \".ttf\"). Pfa files are understood directly, pfb and ttf",
	//" files are converted on the fly if appropriate conversion tools are",
	//" installed (see below). You have to specify the full filename including the",
	//" extension. Each `fontfile` option takes exact one font file name. This",
	//" option can be used multiple times in order to include more than one font",
	//" file.",
	//"",
	//" The font file is searched in the working directory and in all directories",
	//" listed in the fontpath which is determined by `set fontpath`.",
	//" In addition, the fontpath can be set using the environment variable",
	//" GNUPLOT_FONTPATH. If this is not set a system dependent default search",
	//" list is used. See `set fontpath` for more details.",
	//"",
	//" For using the encapsulated font file you have to specify the font name",
	//" (which normally is not the same as the file name). When embedding a",
	//" font file by using the `fontfile` option in interactive mode, the ",
	//" font name is printed on the screen. E.g.",
	//"    Font file 'p052004l.pfb' contains the font 'URWPalladioL-Bold'. Location:",
	//"    /usr/lib/X11/fonts/URW/p052004l.pfb",
	//"",
	//" When using pfa or pfb fonts, you can also find it out by looking into the",
	//" font file. There is a line similar to \"/FontName /URWPalladioL-Bold def\".",
	//" The middle string without the slash is the fontname, here",
	//" \"URWPalladioL-Bold\".",
	//" For TrueType fonts, this is not so easy since the font name is stored in a",
	//" binary format. In addition, they often have spaces in the font names which",
	//" is not supported by Type 1 fonts (in which a TrueType is converted on the",
	//" fly). The font names are changed in order to eliminate the spaces in the",
	//" fontnames. The easiest way to find out which font name is generated for",
	//" use with gnuplot, start gnuplot in interactive mode and type in",
	//" \"set terminal postscript fontfile '<filename.ttf>'\".",
	//"",
	//" For converting font files (either ttf or pfb) to pfa format, the conversion",
	//" tool has to read the font from a file and write it to standard output. If",
	//" the output cannot be written to standard output, on-the-fly conversion is",
	//" not possible.",
	//"",
	//" For pfb files \"pfbtops\" is a tool which can do this. If this program",
	//" is installed on your system the on the fly conversion should work.",
	//" Just try to encapsulate a pfb file. If the compiled in program call does",
	//" not work correctly you can specify how this program is called by",
	//" defining the environment variable GNUPLOT_PFBTOPFA e.g. to",
	//" \"pfbtops %s\". The `%s` will be replaced by the font file name and thus",
	//" has to exist in the string.",
	//"",
	//" If you don't want to do the conversion on the fly but get a pfa file of",
	//" the font you can use the tool \"pfb2pfa\" which is written in simple c",
	//" and should compile with any c compiler.",
	//" It is available from many ftp servers, e.g.",
	//"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/\">",
	//"           ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/",
	//"^ </a>",
	//" In fact, \"pfbtopfa\" and \"pfb2ps\" do the same job. \"pfbtopfa\" puts",
	//" the resulting pfa code into a file, whereas \"pfbtops\" writes it to",
	//" standard output.",
	//"",
	//" TrueType fonts are converted into Type 1 pfa format, e.g.",
	//" by using the tool \"ttf2pt1\" which is available from",
	//"^ <a href=\"http://ttf2pt1.sourceforge.net/\">",
	//"           http://ttf2pt1.sourceforge.net/",
	//"^ </a>",
	//" If the builtin conversion does not",
	//" work, the conversion command can be changed by the environment variable",
	//" GNUPLOT_TTFTOPFA. For usage with ttf2pt1 it may be set to",
	//" \"ttf2pt1 -a -e -W 0 %s - \". Here again, `%s` stands for the",
	//" file name.",
	//"",
	//" For special purposes you also can use a pipe (if available for your",
	//" operating system). Therefore you start the file name definition with ",
	//" the character \"<\" and append a program call. This program has ",
	//" to write pfa data to standard output. Thus, a pfa file may be accessed",
	//" by `set fontfile \"< cat garamond.pfa\"`.",
	//"",
	//" For example, including Type 1 font files can be used for including the",
	//" postscript output in LaTeX documents. The \"european computer modern\"",
	//" font (which is a variant of the \"computer modern\" font) is available",
	//" in pfb format from any CTAN server, e.g.",
	//"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/\">",
	//"           ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/",
	//"^ </a>",
	//" For example, the file \"sfrm1000.pfb\" contains the normal upright fonts",
	//" with serifs in the design size 10pt (font name \"SFRM1000\").",
	//" The computer modern fonts, which are still necessary for mathematics,",
	//" are available from",
	//"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky\">",
	//"           ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky",
	//"^ </a>",
	//" With these you can use any character available in TeX. However, the",
	//" computer modern fonts have a strange encoding. (This is why you should not",
	//" use cmr10.pfb for text, but sfrm1000.pfb instead.)",
	//" The usage of TeX fonts is shown in one of the demos.",
	//" The file \"ps_fontfile_doc.tex\" in the /docs/psdoc subdirectory of the",
	//" `gnuplot` source distribution contains a table with glyphs of the TeX",
	//" mathfonts.",
	//"",
	//" If the font \"CMEX10\" is embedded (file \"cmex10.pfb\") gnuplot defines",
	//" the additional font \"CMEX10-Baseline\". It is shifted vertically in order",
	//" to fit better to the other glyphs (CMEX10 has its baseline at the top of",
	//" the symbols).",
	//"2 postscript prologue",
	//"?commands set terminal postscript prologue",
	//"?set terminal postscript prologue",
	//"?terminal postscript prologue",
	//"?postscript prologue",
	//"?prologue",
	//" Each PostScript output file includes a %%Prolog section and possibly some",
	//" additional user-defined sections containing, for example, character",
	//" encodings. These sections are copied from a set of PostScript prologue files",
	//" which are either compiled in the gnuplot executable or stored elsewhere on your",
	//" computer. This behaviour and the default directory where these files live are",
	//" controlled at the time gnuplot is built. However, you can control this",
	//" either by defining an environment variable GNUPLOT_PS_DIR or by using the",
	//" gnuplot command `set loadpath`. See `set loadpath`.",
	//"2 postscript adobeglyphnames",
	//"?commands set terminal postscript adobeglyphnames",
	//"?set terminal postscript adobeglyphnames",
	//"?terminal postscript adobeglyphnames",
	//"?postscript adobeglyphnames",
	//"?adobeglyphnames",
	//"=UTF-8",
	//" This setting is only relevant to PostScript output with UTF-8 encoding.",
	//" It controls the names used to describe characters with Unicode entry points",
	//" higher than 0x00FF.  That is, all characters outside of the Latin1 set.",
	//" In general unicode characters do not have a unique name; they have only a",
	//" unicode identification code.  However, Adobe have a recommended scheme for",
	//" assigning names to certain ranges of characters (extended Latin, Greek, etc).",
	//" Some fonts use this scheme, others do not.  By default, gnuplot will use",
	//" the Adobe glyph names.  E.g. the lower case Greek letter alpha will be called",
	//" /alpha.  If you specific `noadobeglyphnames` then instead gnuplot will use",
	//" /uni03B1 to describe this character.  If you get this setting wrong, the",
	//" character may not be found even if it is present in the font.",
	//" It is probably always correct to use the default for Adobe fonts, but for",
	//" other fonts you may have to try both settings.  See also `fontfile`.",
	//"",
	//""
	//END_HELP(post)
	///#endif // TERM_HELP 

	///#endif

	/* QMS laser printers */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: qms.trm,v 1.12 2006/07/21 02:35:48 sfeam Exp $
	 *
	 */

	/* GNUPLOT - qms.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  QMS laser printers
	 *
	 * AUTHORS
	 *  Colin Kelley, Thomas Williams, Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(qms)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void QMS_init __PROTO((void));
	//TERM_PUBLIC void QMS_graphics __PROTO((void));
	//TERM_PUBLIC void QMS_text __PROTO((void));
	//TERM_PUBLIC void QMS_linetype __PROTO((int linetype));
	//TERM_PUBLIC void QMS_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void QMS_vector __PROTO((unsigned int x2, unsigned int y2));
	//TERM_PUBLIC void QMS_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void QMS_reset __PROTO((void));
	//
	///#define QMS_XMAX 9000
	///#define QMS_YMAX 6000
	//
	///#define QMS_XLAST (QMS_XMAX - 1)
	///#define QMS_YLAST (QMS_YMAX - 1)
	//
	///#define QMS_VCHAR		120
	///#define QMS_HCHAR		70
	///#define QMS_VTIC		70
	///#define QMS_HTIC		70
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static int qms_line = 0;	// to remember current line type 
	//
	//TERM_PUBLIC void
	//QMS_init()
	//{
	// /* This was just ^IOL, but at Rutgers at least we need some more stuff */
	//    fputs("^PY^-\n^IOL\n^ISYNTAX00000^F^IB11000^IJ00000^IT00000\n", gpoutfile);
	// /*     ^ QUIC on    ^set defaults  ^ set botttom,top,left margins
	//  *            ^landscape         ^free format
	//  */
	//
	// /* set defaults are: implicit decimal point, units in inches,
	//  * numbers left justified, units in 1/1000 inch, do not ignore spaces
	//  * margins are in 1/1000 inch units
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_graphics()
	//{
	//    fputs("^IGV\n", gpoutfile);
	// /*     ^enter graphics vector mode */
	//}
	//
	//
	//
	//TERM_PUBLIC void
	//QMS_text()
	//{
	// /* added ^-, because ^, after an ^I command doesn't actually print a page */
	// /* Did anybody try this code out?  [uhh...-cdk] */
	//    fputs("^IGE\n^-^,", gpoutfile);
	// /*     ^exit graphics vector mode
	//  *           ^pass terminator
	//  *             ^print page
	//  */
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_linetype(int linetype)
	//{
	//    static int width[2 + 9] = { 7, 3, 3, 3, 3, 5, 5, 5, 7, 7, 7 };
	//    static int type[2 + 9] = { 0, 1, 0, 2, 3, 0, 2, 3, 0, 2, 3 };
	// /*
	//  * I don't know about Villanova, but on our printer, using ^V without
	//  * previously setting up a pattern crashes the microcode.
	//  * [nope, doesn't crash here. -cdk]
	//  * [it generates a controller error here on dotted lines. - rjl]
	//  */
	// /* Code to define patterns added by rjl
	//  * According to the manual it should work - but it doesn't
	//  */
	//    qms_line = linetype;
	//    if (linetype >= 9)
	//	linetype %= 9;
	//
	//    fprintf(gpoutfile, "^PW%02d\n", width[linetype + 2]);
	// /*	                 ^width in dots */
	//
	//    switch (type[linetype + 2]) {
	//    case 1:			// short dash 
	//	fputs("^PV102025^G\n^V1\n", gpoutfile);
	// /* ^PV = define pattern vector, 1 = pattern number,
	//  * 02 = number of pen downs and ups, 025 = .025" length of ups/downs
	//  */
	//	break;
	//    case 2:			// medium dash 
	//	fputs("^PV202050^G\n^V2\n", gpoutfile);
	//	break;
	//    case 3:			// long dash 
	//	fputs("^PV302100^G\n^V3\n", gpoutfile);
	//	break;
	//    default:
	//    case 0:
	//	fputs("^V0\n", gpoutfile);
	//	break;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_move(unsigned int x, unsigned int y)
	//{
	//    fprintf(gpoutfile, "^U%05d:%05d\n", 1000 + x, QMS_YLAST + 1000 - y);
	// /*                   ^pen up vector*/
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_vector(unsigned int x2, unsigned int y2)
	//{
	//    fprintf(gpoutfile, "^D%05d:%05d\n", 1000 + x2, QMS_YLAST + 1000 - y2);
	// /*                  ^pen down vector*/
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    char ch;
	//    QMS_move(x, y + QMS_VCHAR / 3);
	//    fputs("^IGE\n", gpoutfile);
	//    ch = *str++;
	//    while (ch != NUL) {
	//	if (ch == '^')
	//	    putc('^', gpoutfile);
	//	putc(ch, gpoutfile);
	//	ch = *str++;
	//    }
	//    fputs("\n^IGV\n", gpoutfile);
	//    QMS_linetype(qms_line);	// restore line type 
	//}
	//
	//
	//TERM_PUBLIC void
	//QMS_reset()
	//{
	//    fputs("^PN^-\n", gpoutfile);
	// /*     ^QUIC off */
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START(qms_driver)
	//    "qms", "QMS/QUIC Laser printer (also Talaris 1200 and others)",
	//    QMS_XMAX, QMS_YMAX, QMS_VCHAR, QMS_HCHAR,
	//    QMS_VTIC, QMS_HTIC, options_null, QMS_init, QMS_reset,
	//    QMS_text, null_scale, QMS_graphics, QMS_move, QMS_vector,
	//    QMS_linetype, QMS_put_text, null_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null
	//TERM_TABLE_END(qms_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM qms_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(qms)
	//"1 qms",
	//"?commands set terminal qms",
	//"?set terminal qms",
	//"?set term qms",
	//"?terminal qms",
	//"?term qms",
	//"?qms",
	//" The `qms` terminal driver supports the QMS/QUIC Laser printer, the Talaris",
	//" 1200 and others.  It has no options."
	//END_HELP(qms)
	///#endif


	/* W3C Scalable Vector Graphics file */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: svg.trm,v 1.101.2.3 2010/03/04 17:16:38 sfeam Exp $
	 */

	/*------------------------------------------------------------------------------------------------------------------------------------
		GNUPLOT - svg.trm
	
		This file is included by ../term.c.
	
		This terminal driver supports:
			W3C Scalable Vector Graphics
	
		AUTHOR
	
			Amedeo Farello
			afarello@libero.it
	
		HEAVILY MODIFIED by
	
			Hans-Bernhard Br"oker
			broeker@physik.rwth-aachen.de
	
	------------------------------------------------------------------------------------------------------------------------------------*/

	/* PM3D support by Johannes Zellner <johannes@zellner.org>, May-16-2002 */
	/* set_color fixes by Petr Mikulik <mikulik@physics.muni.cz>, June-10-2002 */
	/* ISO-Latin encoding, Font selection fixes, option "fixed|dynamic" by
	 * Wilhelm Braunschober <Wilhelm.Braunschober@t-online.de>, Feb-21-2002 */

	/*
	 * Additional code for gnuplot versions 4.2 and 4.3
	 *
	 *   Tweaked code for compatibility with Sodipodi svg viewer/editor.
	 *   Added enhanced text support.
	 *   Additional line properties.
	 *   Increase resolution by adding a coordinate scale factor.
	 *   CODDLE_NONCOMPLIANT_VIEWERS
	 *   Support dashed lines, TC_* color model.
	 *   Change path markup from    style='attribute: foo'  to   attribute='foo'
	 *
	 * Ethan Merritt  <merritt@u.washington.edu>
	 */


	///#ifdef TERM_REGISTER
	//register_term(svg)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void SVG_options __PROTO ((void));
	//TERM_PUBLIC void SVG_init __PROTO ((void));
	//TERM_PUBLIC void SVG_graphics __PROTO ((void));
	//TERM_PUBLIC void SVG_text __PROTO ((void));
	//TERM_PUBLIC void SVG_linetype __PROTO ((int linetype));
	//TERM_PUBLIC void SVG_move __PROTO ((unsigned int x, unsigned int y));
	//TERM_PUBLIC void SVG_vector __PROTO ((unsigned int x, unsigned int y));
	//TERM_PUBLIC void SVG_put_text __PROTO ((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void SVG_reset __PROTO ((void));
	//TERM_PUBLIC int SVG_justify_text __PROTO ((enum JUSTIFY mode));
	//TERM_PUBLIC int SVG_text_angle __PROTO ((int ang));
	//TERM_PUBLIC void SVG_point __PROTO ((unsigned int x, unsigned int y, int pointstyle));
	//TERM_PUBLIC int SVG_set_font __PROTO ((const char *font));
	// /* TERM_PUBLIC void SVG_pointsize __PROTO((double pointsize)); */
	//TERM_PUBLIC void SVG_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
	//TERM_PUBLIC void SVG_linewidth __PROTO ((double linewidth));
	//TERM_PUBLIC int SVG_make_palette __PROTO((t_sm_palette *));
	//TERM_PUBLIC void SVG_previous_palette __PROTO((void));
	//TERM_PUBLIC void SVG_set_color __PROTO((t_colorspec *));
	//TERM_PUBLIC void SVG_filled_polygon __PROTO((int, gpiPoint *));
	//TERM_PUBLIC void SVG_layer __PROTO((t_termlayer syncpoint));
	//
	//TERM_PUBLIC void ENHsvg_OPEN __PROTO((char *, double, double, TBOOLEAN, TBOOLEAN, int));
	//TERM_PUBLIC void ENHsvg_FLUSH __PROTO((void));
	//TERM_PUBLIC void ENHsvg_put_text __PROTO((unsigned int, unsigned int, const char *));
	//TERM_PUBLIC void ENHsvg_writec __PROTO((int));
	//
	//TERM_PUBLIC void SVG_path __PROTO((int p));
	//
	///#define SVG_SCALE	10.
	///#define Y(y) ((float)((int)term->ymax - (int)y) / SVG_SCALE)
	///#define X(x) ((float)(x) / SVG_SCALE)
	//
	///#define SVG_XMAX	(600 * SVG_SCALE)
	///#define SVG_YMAX	(480 * SVG_SCALE)
	//
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static t_sm_palette SVG_palette;
	//static unsigned char SVG_red = 0;
	//static unsigned char SVG_green = 0;
	//static unsigned char SVG_blue = 0;
	//static unsigned char SVG_color_mode = TC_DEFAULT;
	//static char *SVG_linecolor = NULL;
	//
	//static TBOOLEAN SVG_groupFilledIsOpen = FALSE; // open pm3d group flag
	//
	//struct SVG_PEN
	//{
	//    double width;
	//    char color[8];
	//};
	//
	//static unsigned int SVG_xSize = SVG_XMAX; // plot horizontal size 
	//static unsigned int SVG_ySize = SVG_YMAX; // plot vertical size
	//static TBOOLEAN SVG_fixed_size = TRUE;  // make SVG viewer size fixed 
	//
	//static unsigned int SVG_xLast = UINT_MAX; // current pen horizontal position
	//static unsigned int SVG_yLast = UINT_MAX;	// current pen vertical position
	//
	//static int SVG_LineType = LT_NODRAW;	// current line type
	//static double SVG_LineWidth = 1.0; // current line width
	//static double SVG_linewidth_factor = 1.0; // Multiplier for linewidths 
	//static TBOOLEAN SVG_rounded = FALSE; // linejoin and linecap 
	//static int SVG_TextAngle = 0;	// current text orientation
	//static enum JUSTIFY SVG_TextJust = LEFT; // current text justification
	//
	// /* default text font family: */
	//static char *SVG_fontNameDef = NULL;
	//static double SVG_fontSizeDef = 12;	// default text size
	// /* current text font family: */
	//static char *SVG_fontNameCur = NULL;
	//static double SVG_fontSizeCur = 12;	// current text size
	//static TBOOLEAN SVG_groupIsOpen = FALSE; // open group flag
	//static TBOOLEAN SVG_pathIsOpen = FALSE; // open path flag
	//static unsigned int SVG_path_count = 0;	// size of current path
	//static struct SVG_PEN SVG_pens[16];	// pen descriptors
	//
	//static int SVG_fillPattern = -1; // active fill pattern (-1 == undefined) 
	//static unsigned int SVG_fillPatternIndex = 0;
	//
	//static int SVG_fontAscent = 0;	// estimated current font ascent
	//static int SVG_fontDescent = 0;	// estimated current font descent
	//static int SVG_fontLeading = 0;	// estimated current font leading
	//static int SVG_fontAvWidth = 0;	// estimated current font char average width
	//
	//static short SVG_Pen_RealID __PROTO ((int));
	//static void SVG_PathOpen __PROTO ((void));
	//static void SVG_PathClose __PROTO ((void));
	//static void SVG_PathLimit __PROTO ((void));
	//static void SVG_GroupOpen __PROTO ((void));
	//static void SVG_GroupClose __PROTO ((void));
	//static void SVG_SetFont __PROTO ((const char *name, double size));
	//static void SVG_GroupFilledOpen __PROTO ((void));
	//static void SVG_GroupFilledClose __PROTO ((void));
	//static void SVG_StyleColor __PROTO((const char*));
	//static void SVG_StyleFillColor __PROTO((void));
	//static void SVG_local_reset __PROTO((void));
	//static void SVG_DefineFillPattern __PROTO((int fillpat));
	//static void SVG_MoveForced __PROTO((unsigned int x, unsigned int y));
	//
	// /* Points to source of requested embedded font */
	//static char *SVG_embedded_font = NULL;
	//static void SVG_load_fontfile __PROTO((char *fontfile));
	//
	// /* Stuff for enhanced text mode */
	//static int ENHsvg_string_state = 0;
	//static double ENHsvg_x_offset = 0;
	//static TBOOLEAN ENHsvg_preserve_spaces = FALSE;
	///#define CODDLE_NONCOMPLIANT_VIEWERS 1	// Use pt rather than em spacing 
	//
	// /* Support for dashed lines */
	///#define SVG_dashtypes 5
	//static TBOOLEAN SVG_dashed = FALSE;
	//static char *SVG_dashpattern[SVG_dashtypes] = {
	//    "", " 5,8", " 1,4", " 8,4,2,4", " 9,4,1,4,1,4"
	//    };
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_Pen_RealID
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static short
	//SVG_Pen_RealID (int inPenCode)
	//{
	//    if (inPenCode >= 13)
	//	inPenCode %= 13;	// normalize pen code
	//    inPenCode += 3;
	//    if (inPenCode < 0)
	//	inPenCode = 0;		// LT_NODRAW or LT_BACKGROUND should use background color 
	//
	//    return (inPenCode);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_GroupOpen
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_GroupOpen ()
	//{
	//    SVG_GroupFilledClose();
	//    if (!SVG_groupIsOpen) {
	//
	//	fprintf (gpoutfile, "<g style=\"fill:none; color:%s; stroke:",
	//		 SVG_pens[SVG_Pen_RealID (SVG_LineType)].color);
	//
	//	if (SVG_color_mode == TC_RGB)
	//	    fprintf(gpoutfile, "rgb(%3d, %3d, %3d)", SVG_red, SVG_green, SVG_blue);
	//	else if (SVG_color_mode == TC_LT)
	//	    fprintf(gpoutfile, "%s", SVG_linecolor);
	//	else
	//	    fprintf(gpoutfile, "currentColor");
	//
	//	fprintf (gpoutfile, "; stroke-width:%.2f; stroke-linecap:%s; stroke-linejoin:%s",
	//		 SVG_pens[SVG_Pen_RealID (SVG_LineType)].width * SVG_linewidth_factor,
	//		 SVG_rounded ? "round" : "butt",
	//		 SVG_rounded ? "round" : "miter");
	//
	//	fprintf (gpoutfile, "\">\n");
	//
	//	SVG_groupIsOpen = TRUE;
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_GroupClose
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_GroupClose ()
	//{
	//    SVG_GroupFilledClose();
	//    if (SVG_groupIsOpen) {
	//	  fputs ("</g>\n", gpoutfile);
	//	  SVG_groupIsOpen = FALSE;
	//	  SVG_fillPattern = -1;
	//      }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_PathOpen
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_PathOpen ()
	//{
	//    if (!SVG_pathIsOpen) {
	//	SVG_GroupFilledClose();
	//	    
	//	fputs ("\t<path ", gpoutfile);
	//
	// /* Line color */
	//	if (SVG_color_mode == TC_RGB)
	//	    fprintf(gpoutfile, "stroke='rgb(%3d, %3d, %3d)' ",
	//		    SVG_red, SVG_green, SVG_blue);
	//	else if (SVG_color_mode == TC_LT)
	//	    fprintf(gpoutfile, "stroke='%s' ", SVG_linecolor);
	//	
	// /* Dash patterns */
	//	if (SVG_dashed && SVG_LineType % SVG_dashtypes > 0)
	//	    fprintf(gpoutfile, "stroke-dasharray='%s' ",
	//	 	    SVG_dashpattern[SVG_LineType % SVG_dashtypes]);
	//	
	//	fputs (" d='", gpoutfile);
	//
	//	SVG_pathIsOpen = TRUE;
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_PathClose
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_PathClose ()
	//{
	//    if (SVG_pathIsOpen) {
	//	SVG_GroupFilledClose();
	//	fputs ("'></path>\n", gpoutfile);
	//	SVG_path_count = 0;
	//	SVG_pathIsOpen = FALSE;
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_PathLimit
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_PathLimit ()
	//{
	//    if (SVG_path_count % 8 == 0)	// avoid excessive line length
	//	fputs ("\n\t\t", gpoutfile);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_SetFont
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//static void
	//SVG_SetFont (const char *name, double size)
	//{
	//    if (name != SVG_fontNameCur) {
	//	free(SVG_fontNameCur);
	//	SVG_fontNameCur = gp_strdup(name);
	//    }
	//    SVG_fontSizeCur = size;
	//
	// /* since we cannot interrogate SVG about text properties and according
	//  * to SVG 1.0 W3C Candidate Recommendation 2 August 2000 the
	//  * "line-height" of the 'text' element is defined to be equal to the
	//  * 'font-size' (!), we have to to define font properties in a less
	//  * than optimal way */
	//
	//    SVG_fontAscent = (int) (SVG_fontSizeCur * 1.00 * SVG_SCALE); // estimated current font ascent
	//    SVG_fontDescent = (int) (SVG_fontSizeCur * 0.25 * SVG_SCALE); // estimated current font descent
	//    SVG_fontLeading = (int) (SVG_fontSizeCur * 0.25 * SVG_SCALE); // estimated current font leading
	//    SVG_fontAvWidth = (int) (SVG_fontSizeCur * 0.70 * SVG_SCALE); // estimated current font char average width
	//}
	//
	//static void
	//SVG_GroupFilledOpen()
	//{
	//    if (!SVG_groupFilledIsOpen) {
	//	SVG_PathClose();
	//	fputs("\t<g style = 'stroke:none; shape-rendering:crispEdges'>\n",
	//	      gpoutfile);
	//	SVG_groupFilledIsOpen = TRUE;
	//    }
	//}
	//
	//static void
	//SVG_GroupFilledClose()
	//{
	//    if (SVG_groupFilledIsOpen) {
	//	fputs("\t</g>\n", gpoutfile);
	//	SVG_groupFilledIsOpen = FALSE;
	//    }
	//}
	//
	//static void
	//SVG_StyleColor(const char* paint)
	//{
	//    if (SVG_color_mode == TC_RGB)
	//	fprintf(gpoutfile, "%s = 'rgb(%3d, %3d, %3d)'", paint, SVG_red, SVG_green, SVG_blue);
	//    else if (SVG_color_mode == TC_LT)
	//	fprintf(gpoutfile, "%s = '%s'", paint, SVG_linecolor);
	//    else
	//	fprintf(gpoutfile, "%s = 'currentColor'", paint);
	//}
	//
	//static void
	//SVG_StyleFillColor()
	//{
	//    SVG_StyleColor("fill");
	//}
	//
	//static void
	//SVG_DefineFillPattern(int fillpat)
	//{
	//    char *path;
	//    char *style="stroke";
	//
	//    fillpat %= 8;
	//    if (fillpat != SVG_fillPattern) {
	//	SVG_fillPattern = fillpat;
	//	SVG_PathClose();
	//	SVG_fillPatternIndex++;
	//
	//	fprintf(gpoutfile,
	//	    "\t<defs>\n"
	//	    "\t\t<pattern id='gpPat%d' patternUnits='userSpaceOnUse' x='0' y='0' width='8' height='8'>\n",
	//	    SVG_fillPatternIndex);
	//	switch (fillpat) {
	//	    default:
	//	    case 0:
	//		    path="";
	//		    break;
	//	    case 1:
	//		    path="M0,0 L8,8 M0,8 L8,0";
	//		    break;
	//	    case 2:
	//		    path="M0,0 L8,8 M0,8 L8,0 M0,4 L4,8 L8,4 L4,0 L0,4";
	//		    break;
	//	    case 3:
	//		    path="M0,0 L0,8 L8,8 L8,0 L0,0";
	//		    style="fill";
	//		    break;
	//	    case 4:
	//		    path="M-4,0 L8,12 M0,-4 L12,8";
	//		    break;
	//	    case 5:
	//		    path="M-4,8 L8,-4 M0,12 L12,0";
	//		    break;
	//	    case 6:
	//		    path="M-2,8 L4,-4 M0,12 L8,-4 M4,12 L10,0";
	//		    break;
	//	    case 7:
	//		    path="M-2,0 L4,12 M0,-4 L8,12 M4,-4 L10,8";
	//		    break;
	//	}
	//	if (*path) {
	//	    if (SVG_color_mode == TC_RGB)
	//		fprintf(gpoutfile,"\t\t\t<path style='fill:none; %s:rgb(%d,%d,%d)' d='%s'/>\n",
	//			style, SVG_red, SVG_green, SVG_blue, path);
	//	    else if (SVG_color_mode == TC_LT)
	//		fprintf(gpoutfile, "\t\t\t<path style = '%s:%s' d= '%s'/>\n",
	//			style, SVG_linecolor, path);
	//	    else
	//		fprintf(gpoutfile, "\t\t\t<path style = '%s:currentColor' d='%s'/>\n",
	//			style, path);
	//	}
	//	fputs("\t\t</pattern>\n" "\t</defs>\n", gpoutfile);
	//    }
	//}
	//
	//static void
	//SVG_MoveForced(unsigned int x, unsigned int y)
	//{
	//    if (SVG_path_count > 512)
	//	SVG_PathClose();
	//
	//    SVG_PathOpen ();
	//
	//    fprintf (gpoutfile, "M%.1f,%.1f ", X(x), Y(y));
	//    SVG_path_count++;
	//
	//    SVG_PathLimit ();
	//
	//    SVG_xLast = x;
	//    SVG_yLast = y;
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_options
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_options ()
	//{
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we have already initialized the terminal settings.         */
	//    if (c_token != 2)
	//	SVG_local_reset();
	//
	//    while (!END_OF_COMMAND) {
	//	if (almost_equals(c_token, "s$ize")) {
	//	    double value;
	//
	//	    c_token++;
	//
	//	    if (END_OF_COMMAND)
	//		int_error(c_token,"expecting x size");
	//	    value = real_expression();
	//	    if (value < 2 || value > 8192)
	//		int_error(c_token,"x size out of range");
	//	    SVG_xSize = value * SVG_SCALE;
	//
	//	    if (equals(c_token,","))
	//		c_token++;
	//	    if (END_OF_COMMAND)
	//		int_error(c_token,"expecting y size");
	//	    value = real_expression();
	//	    if (value < 2 || value > 8192)
	//		int_error(c_token,"y size out of range");
	//	    SVG_ySize = value * SVG_SCALE;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "d$ynamic")) {
	//	    c_token++;
	//	    SVG_fixed_size = FALSE;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "fi$xed")){
	//	    c_token++;
	//	    SVG_fixed_size = TRUE;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "enh$anced")) {
	//	    c_token++;
	//	    term->put_text = ENHsvg_put_text;
	//	    term->flags |= TERM_ENHANCED_TEXT;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "noenh$anced")) {
	//	    c_token++;
	//	    term->put_text = SVG_put_text;
	//	    term->flags &= ~TERM_ENHANCED_TEXT;
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "fn$ame") || almost_equals(c_token, "font"))  {
	//	    char *s, *comma;
	//	    c_token++;
	//
	//	    if (!(s = try_to_get_string()))
	//		int_error(c_token,"expecting font name");
	//	    comma = strrchr(s,',');
	//	    if (comma && (1 == sscanf(comma + 1, "%lf", &SVG_fontSizeDef)))
	//		*comma = '\0';
	//	    if (*s) {
	//		free(SVG_fontNameDef);
	//		SVG_fontNameDef = s;
	//	    } else
	//		free(s);
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "fs$ize")) {
	//	    c_token++;
	//
	//	    if (END_OF_COMMAND)
	//		int_error(c_token,"fsize: expecting font size");
	//	    SVG_fontSizeDef = real_expression();
	//	    continue;
	//	}
	//
	//	if (almost_equals(c_token, "fontfile")) {
	//	    char *fontfile_name;
	//	    c_token++;
	//
	//	    fontfile_name = try_to_get_string();
	//	    if (!fontfile_name)
	//                int_error(c_token, "Font filename expected");
	//	    gp_expand_tilde(&fontfile_name);
	///#if defined(PIPES)
	//	    if ( *fontfile_name == '<' ) {
	//		SVG_embedded_font = fontfile_name;
	//	    } else
	///#endif
	//		SVG_embedded_font = fontpath_fullname(fontfile_name);
	//	    if (!SVG_embedded_font)
	//		int_error(c_token, "Font file '%s' not found", fontfile_name);
	//
	//            continue;
	//	}
	//
	//	if (almost_equals(c_token, "linew$idth") || equals(c_token, "lw")) {
	//	    c_token++;
	//	    SVG_linewidth_factor = real_expression();
	//	    if (SVG_linewidth_factor <= 0.0)
	//		SVG_linewidth_factor = 1.0;
	//	    continue;
	//	}
	//									
	//	if (almost_equals (c_token, "round$ed")) {
	//	    c_token++;
	//	    SVG_rounded = TRUE;
	//	    continue;
	//	}
	//									
	//	if (equals (c_token, "butt")) {
	//	    c_token++;
	//	    SVG_rounded = FALSE;
	//	    continue;
	//	}
	//
	//	if (equals(c_token, "solid")) {
	//	    c_token++;
	//	    SVG_dashed = FALSE;
	//	    continue;
	//	}
	//									
	//	if (almost_equals(c_token, "dash$ed")) {
	//	    c_token++;
	//	    SVG_dashed = TRUE;
	//	    continue;
	//	}
	//									
	//	int_error(c_token, "unrecognized terminal option");
	//    }
	//
	// /* I don't think any error checks on font name are possible; just set it */
	//    SVG_set_font("");
	//
	// /* Save options back into options string in normalized format */
	//    sprintf(term_options, "size %d,%d%s %s fname '%s'  fsize %g ",
	//	    (int)(SVG_xSize/SVG_SCALE), (int)(SVG_ySize/SVG_SCALE),
	//        SVG_fixed_size ? " fixed": " dynamic",
	//	term->put_text == ENHsvg_put_text ? "enhanced" : "",
	//        SVG_fontNameCur, SVG_fontSizeCur);
	//
	//    if (SVG_embedded_font) {
	//	sprintf(term_options + strlen(term_options),
	//	    "fontfile \"%s\" ", SVG_embedded_font);
	//    }
	//
	//    sprintf(term_options + strlen(term_options),
	//	SVG_rounded ? "rounded " : "butt ");
	//
	//    sprintf(term_options + strlen(term_options),
	//	SVG_dashed ? "dashed " : "solid ");
	//
	//    if (SVG_linewidth_factor != 1.0) {
	//	sprintf(term_options + strlen(term_options),
	//	    "linewidth %3.1f ", SVG_linewidth_factor);
	//    }
	//
	//}
	//
	//static void
	//SVG_local_reset()
	//{
	//    SVG_xSize      = SVG_XMAX;
	//    SVG_ySize      = SVG_YMAX;
	//    SVG_fixed_size = TRUE;
	//    free(SVG_fontNameDef);
	//    SVG_fontNameDef = gp_strdup("Arial");
	//    SVG_fontSizeDef  = 12;
	//    if (SVG_embedded_font)
	//	free(SVG_embedded_font);
	//    SVG_embedded_font = NULL;
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_init
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_init ()
	//{
	//    double stroke_width;
	//    char *svg_encoding = "";
	//
	// /* setup pens*/
	//    SVG_pens[0].width = SVG_LineWidth;
	//    strcpy (SVG_pens[0].color, "white"); // should really be background 
	//    SVG_pens[1].width = SVG_LineWidth;
	//    strcpy(SVG_pens[1].color, "black");
	//    SVG_pens[2].width = SVG_LineWidth;
	//    strcpy(SVG_pens[2].color, "gray");
	//    SVG_pens[3].width = SVG_LineWidth;
	//    strcpy(SVG_pens[3].color, "red");
	//    SVG_pens[4].width = SVG_LineWidth;
	//    strcpy(SVG_pens[4].color, "green");
	//    SVG_pens[5].width = SVG_LineWidth;
	//    strcpy(SVG_pens[5].color, "blue");
	//    SVG_pens[6].width = SVG_LineWidth;
	//    strcpy(SVG_pens[6].color, "cyan");
	//    SVG_pens[7].width = SVG_LineWidth;
	//    sprintf(SVG_pens[7].color, "#%2.2X%2.2X%2.2X", 21, 117, 69); // pine green
	//    SVG_pens[8].width = SVG_LineWidth;
	//    sprintf (SVG_pens[8].color, "#%2.2X%2.2X%2.2X", 0, 0, 148);	// navy
	//    SVG_pens[9].width = SVG_LineWidth;
	//    sprintf (SVG_pens[9].color, "#%2.2X%2.2X%2.2X", 255, 153, 0); // orange
	//    SVG_pens[10].width = SVG_LineWidth;
	//    sprintf (SVG_pens[10].color, "#%2.2X%2.2X%2.2X", 0, 153, 161); // green blue
	//    SVG_pens[11].width = SVG_LineWidth;
	//    sprintf (SVG_pens[11].color, "#%2.2X%2.2X%2.2X", 214, 214, 69); // olive
	//    SVG_pens[12].width = SVG_LineWidth;
	//    sprintf (SVG_pens[12].color, "#%2.2X%2.2X%2.2X", 163, 145, 255); // cornflower
	//    SVG_pens[13].width = SVG_LineWidth;
	//    sprintf (SVG_pens[13].color, "#%2.2X%2.2X%2.2X", 255, 204, 0); // gold
	//    SVG_pens[14].width = SVG_LineWidth;
	//    sprintf (SVG_pens[14].color, "#%2.2X%2.2X%2.2X", 214, 0, 120); // mulberry
	//    SVG_pens[15].width = SVG_LineWidth;
	//    sprintf (SVG_pens[15].color, "#%2.2X%2.2X%2.2X", 171, 214, 0); // green yellow
	//
	//    SVG_LineType = LT_NODRAW;
	//
	// /* set xmax, ymax*/
	//
	//    term->xmax = SVG_xSize;
	//    term->ymax = SVG_ySize;
	//
	// /* set current font*/
	//
	//    SVG_SetFont (SVG_fontNameCur, SVG_fontSizeCur);
	//
	// /* set h_char, v_char*/
	//
	//    term->h_char = SVG_fontAvWidth;
	//    term->v_char = (SVG_fontAscent + SVG_fontDescent + SVG_fontLeading);
	//
	// /* set h_tic, v_tic*/
	//
	//    term->h_tic = term->v_char / 2;
	//    term->v_tic = term->v_char / 2;
	//
	// /* write file header*/
	//
	//    switch (encoding) {
	//	case S_ENC_ISO8859_1:	svg_encoding = "encoding=\"iso-8859-1\" "; break;
	//	case S_ENC_ISO8859_2:	svg_encoding = "encoding=\"iso-8859-2\" "; break;
	//	case S_ENC_ISO8859_9:	svg_encoding = "encoding=\"iso-8859-9\" "; break;
	//	case S_ENC_ISO8859_15:	svg_encoding = "encoding=\"iso-8859-15\" "; break;
	//	case S_ENC_CP850:	svg_encoding = "encoding=\"ibm-850\" "; break;
	//	case S_ENC_CP852:	svg_encoding = "encoding=\"ibm-852\" "; break;
	//	case S_ENC_CP1250:	svg_encoding = "encoding=\"windows-1250\" "; break;
	//	case S_ENC_KOI8_R:	svg_encoding = "encoding=\"koi8-r\" "; break;
	//	case S_ENC_KOI8_U:	svg_encoding = "encoding=\"koi8-u\" "; break;
	//	case S_ENC_CP437:	svg_encoding = ""; break;
	//	default: // UTF-8 
	//				svg_encoding = "encoding=\"utf-8\" ";
	//				break;
	//    }
	//
	//    fprintf (gpoutfile,
	//	     "<?xml version=\"1.0\" %s standalone=\"no\"?>\n"
	//	     "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \n"
	//	     " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
	//	     "<svg ", svg_encoding);
	//
	//    if (SVG_fixed_size)
	//        fprintf (gpoutfile, "width=\"%u\" height=\"%u\" ",
	//		 (unsigned int) (term->xmax / SVG_SCALE),
	//		 (unsigned int) (term->ymax / SVG_SCALE));
	//
	//    fprintf (gpoutfile, "viewBox=\"0 0 %u %u\"\n",
	//	     (unsigned int) (term->xmax / SVG_SCALE),
	//	     (unsigned int) (term->ymax / SVG_SCALE));
	//    fprintf (gpoutfile, " xmlns=\"http://www.w3.org/2000/svg\"\n");
	//    fprintf (gpoutfile, " xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n");
	///#if (0)
	// /* This should be required, but Firefox gets it totally wrong */
	//    fprintf (gpoutfile, " xml:space=\"preserve\"\n");
	///#endif
	//    fprintf (gpoutfile, ">\n\n");
	//
	//    fprintf (gpoutfile,
	//	     "<desc>Produced by GNUPLOT %s patchlevel %s </desc>\n\n",
	//	     gnuplot_version, gnuplot_patchlevel);
	//
	// /* Start prologue section of output file, and load fonts if requested */
	//    fprintf(gpoutfile,"<defs>\n");
	//    if (SVG_embedded_font)
	//	SVG_load_fontfile(SVG_embedded_font);
	//
	// /* definitions of point symbols */
	// /* FIXME: SVG scales linewidth along with the marker itself, and
	//  * there seems to be no way to avoid that without copying the
	//  * marker definition into the file, rather than referencing a
	//  * defined one :-( That would make for much larger files */
	// /* "\t<path id='gpPt3' stroke-width='%.3f' d='M-1,-1 h2 v2 h-2 z'/>\n" */
	//
	//    stroke_width = 2.0 *SVG_SCALE / term->h_tic;
	//    fprintf (gpoutfile,
	//	     "\n"
	// /* dot: */
	//	     "\t<circle id='gpDot' r='0.5' stroke-width='0.5'/>\n"
	// /*  0 plus */
	//	     "\t<path id='gpPt0' stroke-width='%.3f' stroke='currentColor' d='M-1,0 h2 M0,-1 v2'/>\n"
	// /*  1 X */
	//	     "\t<path id='gpPt1' stroke-width='%.3f' stroke='currentColor' d='M-1,-1 L1,1 M1,-1 L-1,1'/>\n"
	// /*  2 star */
	//	     "\t<path id='gpPt2' stroke-width='%.3f' stroke='currentColor' d='M-1,0 L1,0 M0,-1 L0,1 M-1,-1 L1,1 M-1,1 L1,-1'/>\n"
	// /*  3 box */
	//	     "\t<rect id='gpPt3' stroke-width='%.3f' stroke='currentColor' x='-1' y='-1' width='2' height='2'/>\n"
	// /*  4 box                   filled */
	//	     "\t<rect id='gpPt4' stroke-width='%.3f' stroke='currentColor' fill='currentColor' x='-1' y='-1' width='2' height='2'/>\n"
	// /*  5 circle */
	//	     "\t<circle id='gpPt5' stroke-width='%.3f' stroke='currentColor' cx='0' cy='0' r='1'/>\n"
	// /*  6 circle (disk)         filled */
	//	     "\t<use xlink:href='#gpPt5' id='gpPt6' fill='currentColor' stroke='none'/>\n"
	// /*  7 triangle */
	//	     "\t<path id='gpPt7' stroke-width='%.3f' stroke='currentColor' d='M0,-1.33 L-1.33,0.67 L1.33,0.67 z'/>\n"
	// /*  8 triangle  filled */
	//	     "\t<use xlink:href='#gpPt7' id='gpPt8' fill='currentColor' stroke='none'/>\n"
	// /*  9 upside down triangle */
	//	     "\t<use xlink:href='#gpPt7' id='gpPt9' stroke='currentColor' transform='rotate(180)'/>\n"
	// /*  10 upside down triangle filled */
	//	     "\t<use xlink:href='#gpPt9' id='gpPt10' fill='currentColor' stroke='none'/>\n"
	// /* 11 diamond */
	//	     "\t<use xlink:href='#gpPt3' id='gpPt11' stroke='currentColor' transform='rotate(45)'/>\n"
	// /* 12 diamond               filled */
	//	     "\t<use xlink:href='#gpPt11' id='gpPt12' fill='currentColor' stroke='none'/>\n"
	//
	// /* NOTE: Fill patterns must be defined after the stroke color has been
	//  * set to use the correct (current) stroke color. Therefore we can't
	//  * define fill patterns here. */
	//
	//	     "</defs>\n"
	//	     , stroke_width
	//	     , stroke_width
	//	     , stroke_width
	//	     , stroke_width
	//	     , stroke_width
	//	     , stroke_width
	//	     , stroke_width
	//	);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_graphics
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_graphics ()
	//{
	// /* EAM 5-May-2004 We must force a new group with fill:none in order for  */
	// /* multiple plots per page to work. Otherwise new plots are black-filled */
	//    SVG_GroupOpen();
	//
	//    SVG_fillPattern = -1;
	//    SVG_fillPatternIndex = 0;
	//    SVG_groupFilledIsOpen = FALSE;
	//    SVG_color_mode = TC_DEFAULT;
	//    SVG_pathIsOpen = FALSE;
	//
	// /* reset position*/
	//
	//    SVG_xLast = SVG_yLast = UINT_MAX;
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_text
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_text ()
	//{
	//    SVG_PathClose ();
	//    SVG_GroupClose ();
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_reset
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_reset ()
	//{
	//    fputs("</svg>\n\n", gpoutfile);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_linetype
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_linetype (int linetype)
	//{
	//    SVG_color_mode = TC_DEFAULT;
	//    if (linetype != SVG_LineType) {
	//	SVG_PathClose ();
	//	SVG_GroupClose ();
	//	SVG_LineType = linetype;
	//	SVG_GroupOpen ();
	//    }
	//}
	//
	//TERM_PUBLIC void
	//SVG_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
	//{
	//    gpiPoint corner[4];
	//
	//	corner[0].x = x1;        corner[0].y = y1;
	//	corner[1].x = x1+width;  corner[1].y = y1;
	//	corner[2].x = x1+width;  corner[2].y = y1+height;
	//	corner[3].x = x1;        corner[3].y = y1+height;
	//	corner->style = style;
	//
	//	SVG_filled_polygon(4, corner);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_linewidth - verificare
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_linewidth (double linewidth)
	//{
	//    if (linewidth != SVG_LineWidth) {
	//	short k;
	//
	//	SVG_LineWidth = linewidth;
	//
	//	for (k = 0; k < 16; k++)
	//	    SVG_pens[k].width = SVG_LineWidth;
	//
	//	SVG_PathClose ();
	//	SVG_GroupClose ();
	//	SVG_GroupOpen ();
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_move
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_move (unsigned int x, unsigned int y)
	//{
	//    if (x != SVG_xLast || y != SVG_yLast)  {
	//	SVG_MoveForced(x, y);
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_vector
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_vector (unsigned int x, unsigned int y)
	//{
	//    if (x != SVG_xLast || y != SVG_yLast) {
	//
	//	if (!SVG_pathIsOpen) {
	// /* The SVG 'path' MUST have a 'moveto' as first command. */
	//	    SVG_MoveForced(SVG_xLast, SVG_yLast);
	//	}
	//
	//	fprintf (gpoutfile, "L%.1f,%.1f ", X(x), Y(y));
	//	SVG_path_count++;
	//
	//	SVG_PathLimit ();
	//
	//	SVG_xLast = x;
	//	SVG_yLast = y;
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_point
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_point (unsigned int x, unsigned int y, int number)
	//{
	//    char color_spec[0x40];
	//    if (SVG_color_mode == TC_RGB)
	//   	sprintf(color_spec, " color='rgb(%3d, %3d, %3d)'",
	//		SVG_red, SVG_green, SVG_blue);
	//    else if (SVG_color_mode == TC_LT)
	//	sprintf(color_spec, " color='%s'", SVG_linecolor);
	//    else
	//	*color_spec = '\0';
	//
	//    SVG_PathClose ();
	//
	//    if (number < 0) {		// do dot 
	//	fprintf (gpoutfile, "
	//\t<use xlink:href='#gpDot' x='%.1f' y='%.1f'%s/>\n",
	//		 X(x), Y(y), color_spec);
	//    } else {			// draw a point symbol 
	//	fprintf (gpoutfile, "
	//\t<use xlink:href='#gpPt%u' transform='translate(%.1f,%.1f) scale(%.2f)'%s/>
	//\n",
	//		 number % 13, X(x), Y(y),
	//		 term_pointsize * term->h_tic / (2 * SVG_SCALE),
	//		 color_spec);
	//    }
	//    SVG_xLast = x;
	//    SVG_yLast = y;
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_justify_text
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC int
	//SVG_justify_text (enum JUSTIFY mode)
	//{
	//    SVG_TextJust = mode;
	//    return (TRUE);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_text_angle
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC int
	//SVG_text_angle (int ang)
	//{
	// /* Can only do pure horizontal or vertical */
	//    SVG_TextAngle = ang;
	//    return (TRUE);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_put_text
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_put_text (unsigned int x, unsigned int y, const char *str)
	//{
	//    char *alignment;
	//    int h = x, v = y;
	//
	//    SVG_PathClose ();
	//
	// /* horizontal justification*/
	//
	//    switch (SVG_TextJust) {
	//    case LEFT:
	//	alignment = "start";
	//	break;
	//    case CENTRE:
	//	alignment = "middle";
	//	break;
	//    case RIGHT:
	//    default:   // can't happen, just to make gcc happy 
	//	alignment = "end";
	//	break;
	//    }
	//
	// /* vertical justification*/
	//
	//    if (SVG_TextAngle % 180) {
	// /* vertical text */
	//	h += (SVG_fontAscent - SVG_fontDescent) / 2;
	//    } else {
	// /* horizontal text */
	//	v -= (SVG_fontAscent - SVG_fontDescent) / 2;
	//    }
	//
	// /* define text position and attributes */
	//
	//    fprintf (gpoutfile, "\t<g transform=\"translate(%.1f,%.1f)", X(h), Y(v));
	//    if (SVG_TextAngle)
	//	fprintf (gpoutfile, " rotate(%i)", -SVG_TextAngle);
	//    fprintf (gpoutfile, "\" style=\"stroke:none; fill:");
	//
	//    if (SVG_color_mode == TC_RGB)
	//	fprintf (gpoutfile, "rgb(%d,%d,%d)", SVG_red, SVG_green, SVG_blue);
	//    else if (SVG_color_mode == TC_LT)
	//	fprintf (gpoutfile, "%s", SVG_linecolor);
	//    else
	//	fprintf (gpoutfile, "%s", SVG_pens[SVG_Pen_RealID (SVG_LineType)].color);
	//
	//    fprintf (gpoutfile,
	//	     "; font-family:%s; font-size:%.2fpt; text-anchor:%s\">\n",
	//	     SVG_fontNameCur, SVG_fontSizeCur, alignment);
	//
	// /* output text (unless the enhanced_text processing is in action) */
	//
	//    if (strstr(str,"  "))
	//	fputs ("\t\t<text xml:space=\"preserve\">", gpoutfile);
	//    else
	//	fputs ("\t\t<text>", gpoutfile);
	//
	//    if (!ENHsvg_string_state) {
	//
	//	while (*str) {
	// /* Escape SVG reserved characters */
	//	    switch (*str) {
	//	    case '<':
	//		fputs("&lt;", gpoutfile);
	//		break;
	//	    case '&':
	//		if (str[1] == '#' && str[2] == 'x')
	//		    fputc(*str, gpoutfile);
	//		else
	//		    fputs("&amp;", gpoutfile);
	//		break;
	//	    default:
	//		fputc(*str, gpoutfile);
	//		break;
	//	    }
	//
	//	    str++;
	//	}
	//	fputs("</text>\n\t</g>\n", gpoutfile);
	//    }
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_set_font
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC int
	//SVG_set_font (const char *font)
	//{
	//
	//    if (!font || !(*font)) {
	//	free(SVG_fontNameCur);
	//	SVG_fontNameCur = gp_strdup(SVG_fontNameDef);
	//	SVG_fontSizeCur = SVG_fontSizeDef;
	//    } else {
	//	int sep = strcspn(font,",");
	//	if (sep > 0) {
	//	    free(SVG_fontNameCur);
	//	    SVG_fontNameCur = gp_strdup(font);
	//	    SVG_fontNameCur[sep] = NUL;
	//	}
	//	if (font[sep] == ',')
	//	    sscanf(font + sep + 1, "%lf", &SVG_fontSizeCur);
	//    }
	//
	//    return (TRUE);
	//}
	//
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_make_palette
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC int
	//SVG_make_palette(t_sm_palette *palette)
	//{
	//    SVG_GroupFilledClose();
	//    if (palette == NULL) {
	// /* svg can do continuous colors */
	//	return 0;
	//    }
	//
	// /* save mapping formulae needed if SMPAL_COLOR_MODE_RGB */
	//    SVG_palette.colorMode = palette->colorMode;
	//    SVG_palette.formulaR = palette->formulaR;
	//    SVG_palette.formulaG = palette->formulaG;
	//    SVG_palette.formulaB = palette->formulaB;
	//    SVG_palette.positive = palette->positive;
	//
	//    return 0;
	//}
	//
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_set_color
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_set_color(t_colorspec *colorspec)
	//{
	//    rgb255_color rgb255;
	//
	//    if (colorspec->type == TC_LT) {
	//	SVG_linecolor = SVG_pens[SVG_Pen_RealID (colorspec->lt)].color;
	//	SVG_color_mode = TC_LT;
	//	return;
	//    } else if (colorspec->type == TC_FRAC)
	//	rgb255maxcolors_from_gray( colorspec->value, &rgb255 );
	//    else if (colorspec->type == TC_RGB) {
	//	rgb255.r = colorspec->lt >> 16;
	//	rgb255.g = colorspec->lt >> 8 & 0xff;
	//	rgb255.b = colorspec->lt & 0xff;
	//    } else
	//	return;
	//
	//    SVG_color_mode = TC_RGB;
	//
	//    if (rgb255.r != SVG_red || rgb255.g != SVG_green || rgb255.b != SVG_blue) {
	// /* pm3d color has changed. We've to start a new path
	//  * with a different line color. This is necessary when
	//  * using "linetype palette". */
	//	SVG_PathClose();
	//	SVG_red = rgb255.r;
	//	SVG_green = rgb255.g;
	//	SVG_blue = rgb255.b;
	//    }
	//
	//    return;
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_previous_palette
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_previous_palette()
	//{
	//    SVG_GroupFilledClose();
	//}
	//
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_filled_polygon
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_filled_polygon(int points, gpiPoint* corners)
	//{
	//    int i;
	//    int fillpar = corners->style >> 4;
	//    int style = corners->style &= 0xf;
	//
	//    if (style == FS_PATTERN || style == FS_TRANSPARENT_PATTERN) {
	// /* make sure the pattern is defined (with the current stroke color)
	//  * must be defined AFTER the current group is opened with the color
	//  * attribute set, as the patterns use 'currentColor' */
	//	SVG_DefineFillPattern(fillpar);
	//    }
	//
	//    SVG_GroupFilledOpen();
	//    fputs("\t\t<polygon ", gpoutfile);
	//
	//    switch (style) {
	//	case FS_EMPTY: // fill with background color 
	// /* TODO: and what if the background color is not white ? */
	//	    fputs(" fill = 'white'", gpoutfile);
	//	    break;
	//	case FS_SOLID: // solid fill 
	//	case FS_TRANSPARENT_SOLID:
	//	    SVG_StyleFillColor();
	//	    if (fillpar >= 0 && fillpar < 100)
	//		fprintf(gpoutfile, " fill-opacity = '%f'", fillpar * 0.01);
	//	    break;
	//	case FS_PATTERN: // pattern fill 
	//	case FS_TRANSPARENT_PATTERN:
	//	    fprintf(gpoutfile, " fill = 'url(#gpPat%d)'",
	//		    SVG_fillPatternIndex);
	//	    break;
	//	default:
	//	    SVG_StyleFillColor();
	//	    break;
	//    }
	//
	//    fputs(" points = '", gpoutfile);
	//    for (i = 0; i < points; i++)
	//        fprintf(gpoutfile, "%.1f,%.1f%s",
	//		X(corners[i].x), Y(corners[i].y),
	//		i % 16 == 15 ? "\n" : " ");
	//    fputs("'/>\n", gpoutfile);
	//}
	//
	// /*------------------------------------------------------------------------------------------------------------------------------------
	// 	SVG_layer
	// ------------------------------------------------------------------------------------------------------------------------------------*/
	//TERM_PUBLIC void
	//SVG_layer(t_termlayer syncpoint)
	//{
	//    static int plotno = 0;
	//
	// /* We must ignore all syncpoints that we don't recognize */
	//    switch (syncpoint) {
	//
	//    	default:
	//		break;
	//
	//	case TERM_LAYER_BEFORE_PLOT:
	//		SVG_PathClose();
	//		SVG_GroupClose();
	//		fprintf(gpoutfile, "\t<a xlink:title=\"Plot #%d\">\n", ++plotno);
	//		SVG_LineType = LT_UNDEFINED; // Force a new group on next stroke 
	//		break;
	//
	//	case TERM_LAYER_AFTER_PLOT:
	//		SVG_PathClose();
	//		SVG_GroupClose();
	//		fprintf(gpoutfile, "\t</a>\n");
	//		SVG_LineType = LT_UNDEFINED; // Force a new group on next stroke 
	//		break;
	//
	//	case TERM_LAYER_RESET:
	//		plotno = 0;
	//		break;
	//    }
	//}
	//
	//
	// /* Enhanced text mode support starts here */
	//
	//static double ENHsvg_base = 0.0;
	//static TBOOLEAN ENHsvg_opened_string = FALSE;
	//static int ENHsvg_charcount = 0;
	//
	//TERM_PUBLIC void
	//ENHsvg_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* overprint = 1 means print the base text (leave position in center)
	//  * overprint = 2 means print the overlying text
	//  * overprint = 3 means save current position
	//  * overprint = 4 means restore saved position
	//  * EAM FIXME - Unfortunately I can find no way in the svg spec to do this.
	//  * The best I can come up with is to count characters from here and then
	//  * try to back up over them.
	//  */
	//    switch (overprint) {
	//    case 2:
	///#ifdef CODDLE_NONCOMPLIANT_VIEWERS
	//	fprintf(gpoutfile, "<tspan dx=\"-%.1fpt\" dy=\"%.1fpt\">", 
	//		0.3 * ENHsvg_charcount * 1.1*SVG_fontSizeCur, ENHsvg_base-base);
	///#else
	//	fprintf(gpoutfile, "<tspan dx=\"-%.1fem\" dy=\"%.1fpt\">", 
	//		0.3 * ENHsvg_charcount, ENHsvg_base-base);
	///#endif
	//	ENHsvg_base = base;
	//	ENHsvg_x_offset = 0.0;
	//	enhanced_cur_text = enhanced_text;
	//	ENHsvg_charcount = 0;
	//	ENHsvg_opened_string = TRUE;
	//	break;
	//    case 3:
	//	ENHsvg_charcount = 0;
	//	return;
	//    case 4:
	// /* Defer setting the offsets until the text arrives */
	//	ENHsvg_x_offset = -0.6 * ENHsvg_charcount;
	//	ENHsvg_base -= base;
	//	ENHsvg_charcount = 0;
	//	return;
	//    default:
	//	break;
	//    }
	//
	//    if (!ENHsvg_opened_string) {
	//	ENHsvg_opened_string = TRUE;
	//	enhanced_cur_text = enhanced_text;
	//
	// /* Start a new textspan fragment */
	//	fputs("<tspan", gpoutfile);
	//	if (strcmp(SVG_fontNameCur, fontname)) {
	//	    free(SVG_fontNameCur);
	//	    SVG_fontNameCur = gp_strdup(fontname);
	//	    fprintf(gpoutfile, " style=\"font-family:%s\" ", SVG_fontNameCur);
	//	}
	//	if (SVG_fontSizeCur != fontsize) {
	//	    SVG_fontSizeCur = fontsize;
	//	    fprintf(gpoutfile, " font-size=\"%.1fpt\"", SVG_fontSizeCur);
	//	}
	//	if (ENHsvg_x_offset != 0) {
	///#ifdef CODDLE_NONCOMPLIANT_VIEWERS
	//	    fprintf(gpoutfile, " dx=\"%.2fpt\"",
	//				ENHsvg_x_offset * 1.1*SVG_fontSizeCur);
	///#else
	//	    fprintf(gpoutfile, " dx=\"%.2fem\"", ENHsvg_x_offset);
	///#endif
	//	    ENHsvg_x_offset = 0.0;
	//	}
	//	if (ENHsvg_base != base) {
	//	    fprintf(gpoutfile, " dy=\"%.2fpt\"", ENHsvg_base-base);
	//	    ENHsvg_base = base;
	//	}
	//	if (!showflag) {
	//	    fprintf(gpoutfile, " fill=\"none\"");
	//	}
	//	if (ENHsvg_preserve_spaces) {
	//	    fprintf(gpoutfile, " xml:space=\"preserve\"");
	//	}
	//	fputs(">", gpoutfile);
	//    }
	//
	//}
	//
	//TERM_PUBLIC void
	//ENHsvg_FLUSH()
	//{
	//    if (ENHsvg_opened_string) {
	//	ENHsvg_opened_string = FALSE;
	//	*enhanced_cur_text = '\0';
	//	fprintf(gpoutfile, "%s</tspan>\n\t\t", enhanced_text);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHsvg_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//
	// /* We need local copies of the starting font properties */
	//    double fontsize = SVG_fontSizeCur;
	//    static char *fontname = NULL;
	//
	//    free(fontname);
	//    fontname = gp_strdup(SVG_fontNameCur);
	//
	// /* We need the full set of tags for text, just as normal. But in */
	// /* the case of enhanced text ENHsvg_string_state == 1 tells the  */
	// /* SVG_put_text() to return without actually putting the text.   */
	//    if (ignore_enhanced_text) {
	//	ENHsvg_string_state = 0;
	//	SVG_put_text(x, y, str);
	//	return;
	//    } else {
	//	ENHsvg_string_state = 1;
	//	SVG_put_text(x, y, str);
	//	ENHsvg_string_state = 0;
	//    }
	//
	// /* EAM FIXME - This is a total hack, to make up for the fact that all  */
	// /* svg viewers I have tried fail to pick up the xml:space setting from */
	// /* the environment. So it has to be set all over again for each text   */
	// /* fragment. Without this, all whitespace is collapsed to a single ' '.*/
	//    if (strstr(str,"  "))
	//	ENHsvg_preserve_spaces = TRUE;
	//
	// /* Set up global variables needed by enhanced_recursion() */
	//    ENHsvg_charcount = 0;
	//    enhanced_fontscale = 1.0;
	//    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
	//
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//			fontname, fontsize, 0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//	enh_err_check(str);
	//	if (!*++str)
	//	    break; // end of string 
	//    }
	//
	// /* Make sure we leave with the same font properties as on entry */
	//    free(SVG_fontNameCur);
	//    SVG_fontNameCur = fontname;
	//    fontname = NULL;
	//    if (SVG_fontSizeCur != fontsize || ENHsvg_base != 0) {
	//	fprintf(gpoutfile, "<tspan font-size=\"%.1fpt\" dy=\"%.2fpt\"></tspan>",
	//		fontsize, ENHsvg_base);
	//	SVG_fontSizeCur = fontsize;
	//	ENHsvg_base = 0;
	//    }
	//    ENHsvg_preserve_spaces = FALSE;
	//
	// /* Close the text section */
	//    fputs("</text>\n\t</g>\n", gpoutfile);
	//
	//    return;
	//}
	//
	//TERM_PUBLIC void
	//ENHsvg_writec(int c)
	//{
	// /* Kludge for phantom box accounting */
	//    ENHsvg_charcount++;
	//
	// /* Escape SVG reserved characters. Are there any besides '<' and '&' ? */
	//    switch (c) {
	//    case '<':
	//		*enhanced_cur_text++ = '&';
	//		*enhanced_cur_text++ = 'l';
	//		*enhanced_cur_text++ = 't';
	//		*enhanced_cur_text++ = ';';
	//		break;
	//    case '&':
	//		*enhanced_cur_text++ = '&';
	//		*enhanced_cur_text++ = 'a';
	//		*enhanced_cur_text++ = 'm';
	//		*enhanced_cur_text++ = 'p';
	//		*enhanced_cur_text++ = ';';
	//		break;
	//    case '\376':
	// /* This is an illegal UTF-8 byte; we use it to escape the reserved '&' */
	//		if (encoding == S_ENC_DEFAULT) {
	//		    *enhanced_cur_text++ = '&';
	//		    break;
	//		} // else fall through 
	//    default:
	//		*enhanced_cur_text++ = c;
	//		break;
	//    }
	//}
	//
	//static void
	//SVG_load_fontfile(char *fontfile)
	//{
	//    if (fontfile) {
	//	unsigned int linesread = 0;
	//	FILE *ffont = NULL;
	//	char line[256];
	//	char *fontname = NULL;
	///#if defined(PIPES)
	//	TBOOLEAN ispipe = FALSE;
	///#endif
	//
	///#if defined(PIPES)
	//	if ( *fontfile == '<' ) {
	//	    ispipe = TRUE;
	//	    ffont = popen(fontfile + 1, "r" );
	//	    if ( !ffont )
	//		int_error(NO_CARET, "Could not execute pipe '%s'",
	//			  fontfile + 1 );
	//	} else
	///#endif
	//	{
	//	    ffont = fopen(fontfile, "r");
	//	    if (!ffont)
	//		int_error(NO_CARET, "Font file '%s' not found", fontfile);
	//	}
	//
	// /* read the file */
	//	while (fgets(line,255,ffont)) {
	// /* Echo fontname to terminal */
	//	    if ((fontname = strstr(line,"font-family"))) {
	//		fprintf(stderr, "Font file '%s' contains the font '%s'\n",
	//				fontfile, fontname);
	//	    }
	//
	// /* Copy contents into output file */
	//	    fputs(line,gpoutfile);
	//
	//	    ++linesread;
	//	}
	///#if defined(PIPES)
	//	if ( ispipe ) {
	//	    int exitcode;
	//	    if ( (exitcode = pclose(ffont)) != 0 )
	//		int_error(NO_CARET, "Command '%s' generated error exitcode %d",
	//			  fontfile + 1, exitcode);
	//	} else
	///#endif
	//	    fclose(ffont);
	//
	//	if (linesread == 0) {
	///#if defined(PIPES)
	//	    if ( ispipe )
	//		int_error(NO_CARET,
	//		    "Command '%s' generates empty output", fontfile + 1);
	//	    else
	///#endif
	//		int_error(NO_CARET, "Font file '%s' is empty", fontfile);
	//	}
	//
	//    }
	//}
	//
	//TERM_PUBLIC void
	//SVG_path(int p)
	//{
	//    switch (p) {
	//	case 1: // Close path 
	//		fputs("Z ", gpoutfile);
	//		SVG_PathClose();
	//		break;
	//	case 0:
	//		break;
	//    }
	//}
	//
	//
	///#undef Y
	///#undef X
	///#undef CODDLE_NONCOMPLIANT_VIEWERS
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START (svg_driver)
	//    "svg", "W3C Scalable Vector Graphics driver",
	//    0 // xmax 
	// , 0 // ymax 
	// , 0 // vchar 
	// , 0 // hchar 
	// ,
	//    0 // vtic 
	// , 0 // htic 
	// ,
	//    SVG_options, SVG_init, SVG_reset, SVG_text, null_scale, SVG_graphics,
	//    SVG_move, SVG_vector, SVG_linetype, SVG_put_text, SVG_text_angle,
	//    SVG_justify_text, SVG_point, do_arrow, SVG_set_font, do_pointsize,
	//    TERM_CAN_MULTIPLOT | TERM_BINARY | TERM_CAN_DASH | TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
	//    0 // suspend 
	//, 0 // resume 
	// , SVG_fillbox, SVG_linewidth
	///#ifdef USE_MOUSE
	//   , 0, 0, 0, 0, 0 // no mouse support for svg 
	///#endif
	//   , SVG_make_palette,
	//   SVG_previous_palette,
	//   SVG_set_color,
	//   SVG_filled_polygon
	//    , NULL	// image 
	//   , ENHsvg_OPEN, ENHsvg_FLUSH, ENHsvg_writec
	//   , SVG_layer	// layer 
	//   , SVG_path 	// path 
	//   , SVG_SCALE	// pixel oversampling scale 
	//TERM_TABLE_END (svg_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM svg_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(svg)
	//"1 svg",
	//"?commands set terminal svg",
	//"?set terminal svg",
	//"?set term svg",
	//"?terminal svg",
	//"?term svg",
	//"?svg",
	//" This terminal produces files in the W3C Scalable Vector Graphics format.",
	//"",
	//" Syntax:",
	//"       set terminal svg {size <x>,<y> {|fixed|dynamic}}",
	//"                        {{no}enhanced}",
	//"                        {fname \"<font>\"} {fsize <fontsize>}",
	//"                        {font \"<fontname>{,<fontsize>}\"}",
	//"                        {fontfile <filename>}",
	//"                        {rounded|butt} {solid|dashed} {linewidth <lw>}",
	//"",
	//" where <x> and <y> are the size of the SVG plot to generate,",
	//" `dynamic` allows a svg-viewer to resize plot, whereas the default",
	//" setting, `fixed`, will request an absolute size.",
	//"",
	//" `linewidth <w>` increases the width of all lines used in the figure",
	//" by a factor of <w>.",
	//"",
	//" <font> is the name of the default font to use (default Arial) and",
	//" <fontsize> is the font size (in points, default 12). SVG viewing",
	//" programs may substitute other fonts when the file is displayed.",
	//"",
	//" The svg terminal supports an enhanced text mode, which allows font",
	//" and other formatting commands to be embedded in labels and other text",
	//" strings. The enhanced text mode syntax is shared with other gnuplot",
	//" terminal types. See `enhanced` for more details.",
	//"",
	//" SVG allows you to embed fonts directly into an SVG document, or to",
	//" provide a hypertext link to the desired font. The `fontfile` option",
	//" specifies a local file which is copied into the <defs> section of the",
	//" resulting SVG output file.  This file may either itself contain a font,",
	//" or may contain the records necessary to create a hypertext reference to",
	//" the desired font. Gnuplot will look for the requested file using the",
	//" directory list in the GNUPLOT_FONTPATH environmental variable.",
	//" NB: You must embed an svg font, not a TrueType or PostScript font."
	//END_HELP(svg)
	///#endif


	/* x11 tgif tool */
	/* Hello, Emacs, this is -*-C-*- */
	/* $Id: tgif.trm,v 1.45.2.3 2009/09/13 17:54:09 sfeam Exp $ */

	/* GNUPLOT - tgif.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*                                       */
	/* This file is included by ../term.c.                                     */
	/*                                                                         */
	/* This terminal driver supports:                                          */
	/*     TGIF                                                                */
	/*                                                                         */
	/* AUTHORS:                                                                */
	/*  Werner Geppert and Andreas Kuhlewind                                   */
	/*  March, 21st 1995                                                       */
	/*                                                                         */
	/* send your comments or suggestions to werner@mez.ruhr-uni-bochum.de      */
	/*                                                                         */
	/*                                                                         */
	/* MODIFIED May, 11st 1997 by NOVK Levente (novakl@tigris.klte.hu):       */
	/*                                                                         */
	/*          - Modified the default linewidth for borders from 3 to 2       */
	/*          - Modified the default size of markers' bounding box           */
	/*            to allow nicer shapes                                        */
	/*          - Slightly modified the markers and added several new ones,    */
	/*            now we have 64 different pointtypes, the same as for the     */
	/*            PostScript terminal                                          */
	/*          - I left the %.1f format for pixel positions, but I think      */
	/*            Tgif does only calculate with integer positions              */
	/*                                                                         */
	/* Modified  07 July 2000 by Ian MacPhedran                                */
	/*          - added PM3D support                                           */
	/*                                                                         */
	/* Modified  04 February 2002 by Levente Novk                             */
	/*          - break long "polygon()" directives into lines, as it made     */
	/*            Tgif fail polygons had >8 sides                              */
	/*            (e.g. when using "filledcurves")                             */
	/*                                                                         */
	/* Modified  29 November 2004  Shigeharu TAKENO <shige@iee.niit.ac.jp>     */
	/*          - add linewidth and monochrome options                         */
	/*            update option parsing to be order-independent                */
	/*                                                                         */
	/***************************************************************************/

	/*}}}  */
	/***************************************************************************/

	///#ifdef TERM_REGISTER
	//register_term(tgif)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void TGIF_options __PROTO((void));
	//TERM_PUBLIC void TGIF_init __PROTO((void));
	//TERM_PUBLIC void TGIF_reset __PROTO((void));
	//TERM_PUBLIC void TGIF_text __PROTO((void));
	//TERM_PUBLIC void TGIF_graphics __PROTO((void));
	//TERM_PUBLIC void TGIF_move __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void TGIF_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void TGIF_linetype __PROTO((int linetype));
	//TERM_PUBLIC void TGIF_put_text __PROTO((unsigned int ux, unsigned int uy, const char *str));	// ref point and text 
	//TERM_PUBLIC int TGIF_text_angle __PROTO((int ang));
	//TERM_PUBLIC int TGIF_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void TGIF_point __PROTO((unsigned int ux, unsigned int uy, int number));
	//TERM_PUBLIC void TGIF_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
	//TERM_PUBLIC int TGIF_set_font __PROTO((const char *font));
	//TERM_PUBLIC void TGIF_set_pointsize __PROTO((double size));
	//TERM_PUBLIC void TGIF_set_linewidth __PROTO((double size));
	//TERM_PUBLIC int TGIF_make_palette (t_sm_palette *);
	//TERM_PUBLIC void TGIF_previous_palette (void);
	//TERM_PUBLIC void TGIF_set_color (t_colorspec *);
	//TERM_PUBLIC void TGIF_fillbox(int style, unsigned int x1, unsigned int y1, 
	//			      unsigned int width, unsigned int height);
	//TERM_PUBLIC void TGIF_FillSolid(char *curcolor,int fillpar);
	//TERM_PUBLIC void TGIF_filled_polygon (int, gpiPoint *);
	// /*}}}  */
	// /* default length for static strings */
	///#define TGIF_STRLEN_MAX 255
	//
	// /* standard x/y plot size in portrait mode */
	///#define TGIF_XMAX 950
	///#define TGIF_YMAX 634
	//
	// /* total available plotting area */
	///#define TGIF_XTOT 950
	///#define TGIF_YTOT 1400
	//
	// /* Offset  */
	///#define TGIF_XOFF 50
	///#define TGIF_YOFF 50
	//
	///#define TGIF_XSHIFT 1030	// 80 points skip 
	///#define TGIF_YSHIFT 714
	//
	///#define TGIF_VCHAR 18		// default is 18 pt       
	///#define TGIF_HCHAR (18*6/10)
	//
	///#define TGIF_VTIC (TGIF_YMAX/80)
	///#define TGIF_HTIC (TGIF_YMAX/80)
	//
	///#define TGIF_MAXPOLY 100
	// /*}}}  */
	///#define GOT_TGIF_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	// /* tgif driver by Werner Geppert, werner@mez.ruhr-uni-bochum.de */
	// /***************************************************************************/
	// /* Variables:                                                              */
	//static unsigned int uLastTgifX, uLastTgifY;	// last Coordinate         
	//
	//static unsigned int uActNr;	// current elementnumber                   
	//static unsigned int uActPage;	// current pagenumber                      
	//static unsigned int uActResolution=100;	// resolution in percent           
	//static unsigned int uActZoom;	// zoom factor                             
	//static unsigned int uActAngle;	// current textangle                       
	//static unsigned int uActThick;	// actual linethickness                    
	//static unsigned int uActPointSize;	// point size                      
	//static unsigned int uActStyle;	// actual linestyle                        
	//static unsigned int uActJust;	// actual textjustification                
	//static unsigned int uXshift;	// actual shift x                          
	//static unsigned int uYshift;	// actual shift y                          
	//static unsigned int uTgifPlotCount;	// counts number of plots          
	//static unsigned int uTgifPlotRow=1, uTgifPlotCol=1;		// actual plot row and col   
	//static unsigned int uTgif_win_horiz=1, // number of plots in x and  
	//    uTgif_win_verti=1;	//      y direction [x,y]         
	//
	//static double dActThick_factor=1.0;  // linewidth factor 
	//static double dActThick_default=1.0; // default linewidth factor 
	//static TBOOLEAN TgifUseColor = TRUE;
	//
	//static char sActColor[TGIF_STRLEN_MAX];		// current color         
	//static unsigned int uDefaultFontSize = 18;	// default font size         
	//static unsigned int uActFontSize = 18;	// current font size         
	//static char sDefaultFont[TGIF_STRLEN_MAX] = "Helvetica";	// default font          
	//static char sActFont[TGIF_STRLEN_MAX] = "Helvetica";	// current font          
	// /* static char          sActPointString[TGIF_STRLEN_MAX]; HBB: unused */
	//
	//static TBOOLEAN TgifSolid = FALSE;
	//static TBOOLEAN TgifPortrait = TRUE;
	//
	//static unsigned int uTgifPlotsPerPage = 1;
	//
	// /*
	//  * 10 different pointtypes need 10 different linetypes
	//  */
	//
	// /* NL: Modified first value to 2 from 3 */
	//static unsigned int uLineThick[] = { 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
	//static unsigned int uLineStyle[] = { 0, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0 };
	//static const char *psColors[] = {
	//    "black", "black",		// border and x/y-zero-axes       
	//    "red", "green", "blue", "magenta", "cyan", "yellow",
	//    "DarkSeaGreen", "HotPink", "black", "coral"
	//};
	// /* for color density */
	//static const rgb255_color psColorcomp[] = {
	//    {0,0,0}, {0,0,0},
	//    {255,0,0}, {0,255,0}, {0,0,255}, {255,0,255}, {0,255,255}, {255,255,0},
	//    {143,188,143}, {255,105,180}, {0,0,0}, {255,127,80}
	//};
	//static rgb255_color rgbActColor;
	//
	//static unsigned int uFillPattern[] = { 2, 3, 5, 1, 20, 26, 21, 27, 14, 15 };
	///#define TGIF_fillpatterns 10
	//
	//static int iTgifPolyCount;
	//static unsigned int uBuffX[TGIF_MAXPOLY], uBuffY[TGIF_MAXPOLY];
	//
	//enum eState {
	//    NEWPOLY = 100, INPOLY
	//};
	//static enum eState eTgifState = NEWPOLY;
	//
	//static void TGIF_flush_poly __PROTO((void));
	//
	//
	//
	// /*}}}  */
	// /***************************************************************************/
	//static void
	//TGIF_flush_poly()
	//{
	//    int i;
	//
	//
	//    if (eTgifState == INPOLY) {
	//	fprintf(gpoutfile, "poly('%s',%d,[\n\t", sActColor, iTgifPolyCount);
	//
	//	for (i = 0; i < iTgifPolyCount - 1; i++) {
	//	    fprintf(gpoutfile, "%u,%u,", uBuffX[i], uBuffY[i]);
	//	    if ((i + 1) % 8 == 0)
	//		fputs("\n\t", gpoutfile);
	//	}
	//
	//	fprintf(gpoutfile, "%u,%u],0,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
	//		uBuffX[iTgifPolyCount - 1], uBuffY[iTgifPolyCount - 1],
	//		uActThick, uActNr, uActStyle);
	//
	//	uActNr++;
	//
	//	eTgifState = NEWPOLY;
	//	iTgifPolyCount = 0;
	//	if (gpoutfile != (FILE *) NULL)
	//	    fflush(gpoutfile);
	//    }
	//}				// TGIF_flush_poly 
	// /*}}}  */
	// /***************************************************************************/
	//
	//enum TGIF_id {
	//    TGIF_MONOCHROME, TGIF_COLOR,
	//    TGIF_LINEWIDTH,
	//    TGIF_PORTRAIT, TGIF_LANDSCAPE,
	//    TGIF_GRAPHS,
	//    TGIF_SOLID, TGIF_DASHED,
	//    TGIF_FONT,
	//    TGIF_OTHER,
	//    TGIF_DEFAULT
	//};
	//
	//static struct gen_table TGIF_opts[] =
	//{
	//    {"mo$nochrome", TGIF_MONOCHROME},
	//    {"c$olor", TGIF_COLOR},
	//    {"c$olour", TGIF_COLOR},
	//    {"linew$idth", TGIF_LINEWIDTH},
	//    {"lw", TGIF_LINEWIDTH},
	//    {"p$ortrait", TGIF_PORTRAIT},
	//    {"l$andscape", TGIF_LANDSCAPE},
	//    {"[", TGIF_GRAPHS},
	//    {"s$olid", TGIF_SOLID},
	//    {"d$ashed", TGIF_DASHED},
	//    {"font", TGIF_FONT},
	//    {"default", TGIF_DEFAULT},
	//    {NULL, TGIF_OTHER}
	//};
	//
	//TERM_PUBLIC void
	//TGIF_options()
	//{
	//
	//    struct value a, b;
	//    double dscaleH, dscaleV;
	//    int option;
	//
	//    while (!END_OF_COMMAND) {
	//	option = lookup_table(&TGIF_opts[0],c_token);
	//	switch(option) {
	//	case TGIF_DEFAULT:
	//	    strcpy(sActFont, "Helvetica");
	//	    strcpy(sDefaultFont, "Helvetica");
	//	    uActFontSize = 18;
	//	    uDefaultFontSize = 18;
	//	    term->v_char = (unsigned int) (uActFontSize);
	//	    term->h_char = (unsigned int) (uActFontSize * 6 / 10);
	//
	//	    TgifPortrait = TRUE;
	//	    TgifUseColor = TRUE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    TgifSolid = FALSE;
	//	    uTgifPlotsPerPage = 1;
	//	    uTgifPlotRow = 1;
	//	    uTgifPlotCol = 1;
	//	    uTgif_win_horiz = 1;
	//	    uTgif_win_verti = 1;
	//	    uActResolution = 100;
	//	    dActThick_factor = 1.0;
	//	    dActThick_default = 1.0;
	//	    c_token++;
	//	    break;
	//	case TGIF_MONOCHROME:
	//	    TgifUseColor = FALSE;
	//	    term->flags |= TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case TGIF_COLOR:
	//	    TgifUseColor = TRUE;
	//	    term->flags &= ~TERM_MONOCHROME;
	//	    c_token++;
	//	    break;
	//	case TGIF_LINEWIDTH:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "linewidth: width is not specified.");
	//	    } else {
	//		if((dActThick_default = real(const_express(&a)))<=0.0){
	//		    int_error(c_token-1,"linewidth: out of range");
	//		    dActThick_default = 1.0;
	//		}
	//	    }
	//	    break;
	//	case TGIF_PORTRAIT:
	//	    TgifPortrait = TRUE;
	//	    c_token++;
	//	    break;
	//	case TGIF_LANDSCAPE:
	//	    TgifPortrait = FALSE;
	// /* uActResolution = 140;
	// */
	//	    c_token++;
	//	    break;
	//	case TGIF_GRAPHS:
	//	    c_token++;
	//	    if (END_OF_COMMAND) {
	//		int_error(c_token, "no. windows: [horizontal,vertical] expected");
	//	    } else if (!equals(c_token, ",")) {
	//		uTgif_win_horiz = (int) real(const_express(&a));
	//	    }
	//	    if (!equals(c_token, ","))
	//		int_error(c_token, "',' expected");
	//	    c_token++;
	//	    if (!equals(c_token, "]")) {
	//		uTgif_win_verti = (int) real(const_express(&a));
	//	    }
	//	    if (!equals(c_token, "]"))
	//		int_error(c_token, "expecting ']'");
	//	    c_token++;
	//	    uTgifPlotsPerPage = uTgif_win_verti * uTgif_win_horiz;
	//	    break;
	//	case TGIF_SOLID:
	//	    TgifSolid = TRUE;
	//	    c_token++;
	//	    break;
	//	case TGIF_DASHED:
	//	    TgifSolid = FALSE;
	//	    c_token++;
	//	    break;
	//	case TGIF_FONT:
	//	    c_token++;
	// /* Fall through */
	//	case TGIF_OTHER:
	//	default:
	//	{
	//	    char *s;
	//	    if ((s = try_to_get_string())) {
	//		double fontsize;
	//		int sep = strcspn(s,",");
	//		if (s[sep] == ',' && (1 == sscanf(&s[sep+1],"%lf",&fontsize)))
	//		    uActFontSize =  (int)(fontsize+0.5);
	//		if (sep > 0) {
	//		    strncpy(sActFont, s, sizeof(sActFont));
	//		    sActFont[sep] = NUL;
	//		}
	//		strcpy(sDefaultFont, sActFont);
	//		free(s);
	//	    } else if (option == TGIF_FONT) {
	//		int_error(c_token,"Expecting font name ");
	//	    } else {
	// /* We have font size specified */
	//		uActFontSize = (unsigned int) real(const_express(&b));
	//		uDefaultFontSize = uActFontSize;
	//		term->v_char = (unsigned int) (uActFontSize);
	//		term->h_char = (unsigned int) (uActFontSize * 6 / 10);
	//	    }
	//	    break;
	//	}
	//	}
	//    }
	//    if (TgifPortrait) {
	//	dscaleH = (double) 100.0 *(TGIF_XTOT) / (xsize * (TGIF_XMAX + (uTgif_win_horiz - 1) * TGIF_XSHIFT));
	//	dscaleV = (double) 100.0 *(TGIF_YTOT) / (ysize * (TGIF_YMAX + (uTgif_win_verti - 1) * TGIF_YSHIFT));
	//	uActResolution = (int) GPMIN(dscaleH, dscaleV);
	//	switch (uTgif_win_verti) {
	//	case 1:
	//	    uActZoom = 0;
	//	    break;
	//
	//	case 2:
	//	    uActZoom = 1;
	//	    break;
	//	default:
	//	    uActZoom = 2;
	//	    break;
	//
	//	}
	//    } else {
	//	dscaleH = (double) 100.0 *(TGIF_YTOT) / (xsize * (TGIF_XMAX + (uTgif_win_horiz - 1) * TGIF_XSHIFT));
	//	dscaleV = (double) 100.0 *(TGIF_XTOT) / (ysize * (TGIF_YMAX + (uTgif_win_verti - 1) * TGIF_YSHIFT));
	//	uActResolution = (unsigned int) GPMIN(dscaleH, dscaleV);
	//
	//	switch (uTgif_win_verti) {
	//	case 1:
	//	    uActZoom = 0;
	//	    break;
	//
	//	case 2:
	//	    uActZoom = 1;
	//	    break;
	//	default:
	//	    uActZoom = 2;
	//	    break;
	//
	//	}
	//    }
	//
	//    sprintf(&(term_options[strlen(term_options)]), "%s [%u,%u]",
	//	    TgifPortrait ? "portrait" : "landscape",
	//	    uTgif_win_horiz, uTgif_win_verti);
	//
	//    strcat(term_options, TgifUseColor ? " color" : " monochrome");
	//    sprintf(&(term_options[strlen(term_options)]), " linewidth %f", 
	//	    dActThick_default);
	//    sprintf(&(term_options[strlen(term_options)]), " %s \"%s\" %u",
	//	    TgifSolid ? "solid" : "dashed",
	//	    sActFont, uActFontSize);
	//}
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_init()
	//{
	//
	//    if (multiplot) {
	// /* uActResolution= TgifPortrait ? (unsigned int)100 : (unsigned int)145 ; */
	//	uActResolution = (unsigned int) 100;
	//
	//	if (uTgifPlotsPerPage > 1) {
	//	    fputs("warning: using standard multiplot\n", stderr);
	//	    uTgifPlotsPerPage = 1;
	//	}
	//	uActZoom = 1;
	//    }
	//    fprintf(gpoutfile, "
	//%%TGIF 2.15-p7\n
	//state(%d,30,%u,0,0,%u,16,1,9,1,1,0,0,0,0,1,0,'%s',0,%u,0,0,1,10,0,0,1,1,0,16,0,0,1,1,1).\n
	//%%\n
	//%% @(#)Creator: gnuplot %s patchlevel %s\n
	//%% %%W%%\n
	//%%\n
	//page(1,\"\").\n",
	//	    TgifPortrait ? 0 : 1, uActResolution, uActZoom, sActFont, uActFontSize,
	//	    gnuplot_version, gnuplot_patchlevel);
	//    eTgifState = NEWPOLY;
	//    iTgifPolyCount = 0;
	//    uTgifPlotCount = 0;
	//    uActPage = 1;
	//}				// TGIF_init 
	// /*}}}  */
	//
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_graphics()
	//{
	//
	//    TGIF_flush_poly();
	//
	//    if (multiplot) {
	//
	//	term->xmax = (TgifPortrait) ? TGIF_XTOT : TGIF_YTOT;
	//	term->ymax = (TgifPortrait) ? TGIF_YTOT : TGIF_XTOT;
	//	uLastTgifX = (TgifPortrait) ? TGIF_XOFF : TGIF_YOFF;
	//	uLastTgifY = (TgifPortrait) ? TGIF_YTOT + TGIF_YOFF : TGIF_XTOT + TGIF_XOFF;
	//
	//	uYshift = uLastTgifY;
	//	uXshift = uLastTgifX;
	//
	//    } else {
	//	if (uTgifPlotCount < uTgifPlotsPerPage)
	//	    uTgifPlotCount++;
	//	else {
	//	    fputs("error: number of plots > plots per page\n", stderr);
	//	    return;
	//	}
	//
	//	uXshift = (unsigned int) TGIF_XOFF *100 / uActResolution + (xsize * (uTgifPlotCol - 1) * TGIF_XSHIFT);
	//	uYshift = (unsigned int) TGIF_YOFF *100 / uActResolution + (ysize * (TGIF_YMAX +
	//									     (uTgifPlotRow - 1) * TGIF_YSHIFT));
	//
	//	if (uTgifPlotCount % uTgif_win_horiz == 0) {
	//	    uTgifPlotCol = 1;
	//	    uTgifPlotRow++;
	//	} else {
	//	    uTgifPlotCol++;
	//	}
	//
	//	uLastTgifX = uXshift;
	//	uLastTgifY = uYshift;
	//
	//    }
	//
	//
	//
	//
	//
	// /* default settings for each plot */
	//    iTgifPolyCount = 0;
	//    uActNr = 0;
	//    uActAngle = 0;
	//    uActThick = 1;
	//    uActStyle = 0;
	//    uActJust = LEFT;
	//    strcpy(sActColor,psColors[0]); // black 
	//    rgbActColor = psColorcomp[0];
	//
	//}				// TGIF_graphics 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_text()
	//{
	//    TGIF_flush_poly();
	//
	//
	//}				// TGIF_text 
	//
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_reset()
	//{
	//    TGIF_flush_poly();
	//    iTgifPolyCount = 0;
	//    uTgifPlotCount = 0;
	//    uTgifPlotRow = 1;
	//    uTgifPlotCol = 1;
	//
	//
	//    if (gpoutfile != (FILE *) NULL)
	//	fflush(gpoutfile);
	//
	//}				// TGIF_reset 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_linetype(int linetype)
	//{
	//    unsigned int ult;
	//
	//
	//    TGIF_flush_poly();
	//
	//
	//    if (linetype >= 0)
	//	ult = 2 + linetype % 10;
	//    else if (linetype < -2)
	//	ult = 0;
	//    else
	//	ult = linetype + 2;
	//
	//    if (TgifUseColor == FALSE) {
	//	strcpy(sActColor,"black");
	//	rgbActColor = psColorcomp[0];
	//    }
	//    else{
	//	strcpy(sActColor, psColors[ult]);
	//	rgbActColor = psColorcomp[ult];
	//    }
	//    uActThick = dActThick_factor * dActThick_default * uLineThick[ult]+0.5;
	//    if (!TgifSolid)
	//	uActStyle = uLineStyle[ult];
	//    else {
	//	if (ult == 1)		// grid 
	//	    uActStyle = uLineStyle[ult];
	//	else
	//	    uActStyle = uLineStyle[2];
	//
	//    }
	//
	//}				// TGIF_linetype 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_move(unsigned int ux, unsigned int uy)
	//{
	//
	//    uLastTgifX = ux + uXshift;
	//    uLastTgifY = uYshift - uy;
	//
	//    if (eTgifState == INPOLY)
	//	TGIF_flush_poly();
	//
	//
	//
	//}				// TGIF_move 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_vector(unsigned int ux, unsigned int uy)
	//{
	//
	//    ux = ux + uXshift;
	//    uy = uYshift - uy;
	//
	//
	//
	//    if (eTgifState == NEWPOLY) {
	//	uBuffX[0] = uLastTgifX;
	//	uBuffY[0] = uLastTgifY;
	//	iTgifPolyCount = 1;
	//	eTgifState = INPOLY;
	//    }
	//    uBuffX[iTgifPolyCount] = ux;
	//    uBuffY[iTgifPolyCount] = uy;
	//    uLastTgifX = ux;
	//    uLastTgifY = uy;
	//    iTgifPolyCount++;
	//    eTgifState = INPOLY;
	//
	//    if (iTgifPolyCount == TGIF_MAXPOLY) {
	//	TGIF_flush_poly();
	//
	//    }
	//}				// TGIF_vector 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//
	//    TGIF_flush_poly();
	//
	//    sx = sx + uXshift;
	//    ex = ex + uXshift;
	//    sy = uYshift - sy;
	//    ey = uYshift - ey;
	//
	//
	//    if (head) {
	//	fprintf(gpoutfile, "
	//poly('%s',%d,[\n
	//\t%u,%u,%u,%u],1,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
	//		sActColor, 2, sx, sy, ex, ey, uActThick, uActNr, uActStyle);
	//    } else {
	//	fprintf(gpoutfile, "
	//poly('%s',%d,[\n
	//\t%u,%u,%u,%u],1,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
	//		sActColor, 2, sx, sy, ex, ey, uActThick, uActNr, uActStyle);
	//    }
	//
	//    uActNr++;
	//
	//
	//
	//    uLastTgifX = ex;
	//    uLastTgifY = ey;
	//
	//}				// TGIF_arrow 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_put_text(unsigned int ux, unsigned int uy, const char *str)
	//{
	//
	//    unsigned int x, y;
	//    struct termentry *t = term;
	//
	//    TGIF_flush_poly();
	//
	//    x = ux + uXshift;
	//    y = uYshift - uy - t->v_char / 2;
	//
	//    if (strlen(str) == 0)
	//	return;
	//
	//    fprintf(gpoutfile, "
	//text('%s',%u,%u,'%s',0,%u,1,%u,%u,1,55,119,%u,0,15,4,0,0,0,0,[\n\t\"%s\"]).\n",
	//	    sActColor, x, y, sActFont, uActFontSize,
	//	    (uActAngle ? CENTRE : uActJust), uActAngle,
	//	    uActNr, str);
	//
	//    uActNr += 2;
	//
	//
	//}				// TGIF_put_text 
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC int
	//TGIF_text_angle(int ang)
	//{
	//    switch (ang) {
	//	case   90:	uActAngle = 3; break;
	//	case  180:
	//	case -180:	uActAngle = 2; break;
	//	case  -90:
	//	case  270:	uActAngle = 1; break;
	//	default:	uActAngle = 0; break;
	//    }
	//    return (TRUE);
	//}				// TGIF_text_angle 
	//
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC int
	//TGIF_justify_text(enum JUSTIFY mode)
	//{
	//    uActJust = mode;
	//    return (TRUE);
	//}				// TGIF_justify_text 
	//
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_point(unsigned int ux, unsigned int uy, int number)
	//{
	//    double p;		// all pointtypes fit in a (x +/-p)x(y +/-p) box 
	//
	//    double x, y;
	//
	//
	//
	//    x = (double) (ux + uXshift);
	//    y = (double) (uYshift - uy);
	//
	//    p = pointsize * 8.0;	// NL: Increased the bounding box (p value) from 4.0 to 8.0 
	//    if (p == (double) 0.0)
	//	p = 0.1;
	//
	//    TGIF_flush_poly();
	//
	//    if (number != -1)
	//	number = number % 63;
	//    switch (number) {
	//    case -1:
	// /* HBB: corrected format string, shuts up gcc -Wall */
	//	fprintf(gpoutfile, "
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,1,1,%u,0,0,0,0,8,3,0,[\n]).\n",
	//		sActColor, x, y, x + 1, y + 1, uActNr++);
	//	break;
	//    case 0:
	// /* plus */
	// /* taking thickness 2 for cross & plus & star */
	//	fprintf(gpoutfile, "
	//group([\n
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]),\n
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n])\n",
	//		sActColor, x, y - p - 1, x, y + p + 1, uActNr+1,
	//		sActColor, x - p - 1, y, x + p + 1, y, uActNr+2);
	//	uActNr += 4;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 1:
	// /* cross */
	// /* taking thickness 2 for cross & plus & star */
	//	fprintf(gpoutfile, "
	//group([\n
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr+1,
	//		sActColor, x - p, y + p, x + p, y - p, uActNr+2);
	//	uActNr += 4;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 2:
	// /* star */
	// /* taking thickness 2 for cross & plus & star */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]),\n",
	//		sActColor, x, y - p - 1, x, y + p + 1, uActNr++);
	//	fprintf(gpoutfile, "
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n])\n",
	//		sActColor, x - p - 1, y, x + p + 1, y, uActNr++);
	//	fprintf(gpoutfile, "
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y + p, x + p, y - p, uActNr++);
	//	uActNr += 4;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 3:
	// /* box */
	//	fprintf(gpoutfile, "
	//box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 4:
	// /* filled box */
	//	fprintf(gpoutfile, "
	//box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 5:
	// /* circle */
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 6:
	// /* filled circle */
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 7:
	// /* triangle up */
	//	fprintf(gpoutfile, "
	//polygon('%s',4,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y + 0.75 * p, x - p, y + 0.75 * p,
	//		x, y - p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 8:
	// /* filled triangle up */
	//	fprintf(gpoutfile, "
	//polygon('%s',4,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y + 0.75 * p, x - p, y + 0.75 * p,
	//		x, y - p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 9:
	// /* triangle down */
	//	fprintf(gpoutfile, "
	//polygon('%s',4,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x - p, y - 0.75 * p, x + p, y - 0.75 * p,
	//		x, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 10:
	// /* filled triangle down */
	//	fprintf(gpoutfile, "
	//polygon('%s',4,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x - p, y - 0.75 * p, x + p, y - 0.75 * p,
	//		x, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 11:
	// /* diamond */
	//	fprintf(gpoutfile, "
	//polygon('%s',5,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n
	//]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p,
	//		uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 12:
	// /* filled diamond */
	//	fprintf(gpoutfile, "
	//polygon('%s',5,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n
	//]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p,
	//		uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 13:
	// /* pentagon */
	//	fprintf(gpoutfile, "
	//polygon('%s',6,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y - p / 4, x + 0.625 * p, y + p,
	//		x - 0.625 * p, y + p, x - p, y - p / 4, x, y - p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 14:
	// /* filled pentagon */
	//	fprintf(gpoutfile, "
	//polygon('%s',6,[\n
	//%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y - p / 4, x + 0.625 * p, y + p,
	//		x - 0.625 * p, y + p, x - p, y - p / 4, x, y - p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 15:
	// /* circle1 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n
	//]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,4480,2560,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x + p * 0.342, y - p * 0.94,
	//		x - p * 0.342, y - p * 0.94, 2 * p, 2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 16:
	// /* circle2 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x + p, y, x, y - p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 17:
	// /* circle3 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y - p, x - p, y, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 18:
	// /* circle4 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,11520,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x + p, y, x - p, y, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 19:
	// /* circle5 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x - p, y, x, y + p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 20:
	// /* circle6 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x + p, y, x, y - p, 2 * p,
	//		2 * p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x - p, y, x, y + p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 21:
	// /* circle7 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,11520,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y - p, x, y + p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 22:
	// /* circle8 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,17280,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x + p, y, x, y + p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 23:
	// /* circle9 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y + p, x + p, y, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 24:
	// /* circle10 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,11520,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y + p, x, y - p, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 25:
	// /* circle11 */
	//	fputs("group([\n", gpoutfile);
	//	fprintf(gpoutfile, "
	//oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y - p, x - p, y, 2 * p,
	//		2 * p, uActNr++);
	//	fprintf(gpoutfile, "
	//arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,5760,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y + p, x + p, y, 2 * p,
	//		2 * p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 26:
	// /* circle12 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile,
	//		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,17280,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y + p, x - p, y, 2 * p, 2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 27:
	// /* circle13 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile,
	//		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,11520,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x - p, y, x + p, y, 2 * p, 2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 28:
	// /* circle14 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile,
	//		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,17280,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x - p, y, x, y - p, 2 * p, 2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 29:
	// /* circle15 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile,
	//		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,17280,%u,0,0,8,3,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, x, y - p, x + p, y, 2 * p, 2 * p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 30:
	// /* circle16 */
	//	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 31:
	// /* box1 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p / 4, y - p, x + p / 4, y, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 32:
	// /* box2 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 33:
	// /* box3 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 34:
	// /* box4 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 35:
	// /* box5 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y + p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 36:
	// /* box6 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 37:
	// /* box7 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y + p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 38:
	// /* box8 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 39:
	// /* box9 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y, x + p, y + p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 40:
	// /* box10 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y + p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 41:
	// /* box11 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y, x + p, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 42:
	// /* box12 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y, x + p, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 43:
	// /* box13 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x + p, y + p, uActNr++);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 44:
	// /* box14 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x, y - p, x + p, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x + p, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 45:
	// /* box15 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x, y, uActNr++);
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x + p, y + p, uActNr++);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 46:
	// /* box16 */
	//	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
	//		sActColor, x - p, y - p, x + p, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//    case 47:
	// /* diamond1 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - 0.625 * p, y - 0.375 * p, x - 0.375 * p, y - 0.625 * p, x + p / 8,
	//		y - p / 8, x - p / 8, y + p / 8, x - 0.625 * p, y - 0.375 * p, uActNr);
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	uActNr += 2;
	//	break;
	// /*}}}  */
	//    case 48:
	// /* diamond2 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y - p / 2, x, y - p, x + p / 2, y - p / 2, x, y, x - p / 2,
	//		y - p / 2, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 49:
	// /* diamond3 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x - p / 2, y + p / 2, x - p, y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 50:
	// /* diamond4 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y - p, x + p / 2, y - p / 2, x - p / 2, y + p / 2, x - p,
	//		y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 51:
	// /* diamond5 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y + p / 2, x, y, x + p / 2, y + p / 2, x, y + p, x - p / 2,
	//		y + p / 2, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 52:
	// /* diamond6 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y - p / 2, x, y - p, x + p / 2, y - p / 2, x, y, x - p / 2,
	//		y - p / 2, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y + p / 2, x, y, x + p / 2, y + p / 2, x, y + p, x - p / 2,
	//		y + p / 2, uActNr);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 53:
	// /* diamond7 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x - p / 2, y - p / 2, x + p / 2, y + p / 2, x, y + p, x - p,
	//		y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 54:
	// /* diamond8 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y - p, x + p / 2, y - p / 2, x, y, x + p / 2, y + p / 2,
	//		x, y + p, x - p, y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 55:
	// /* diamond9 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y, x + p / 2, y - p / 2, x + p, y, x + p / 2, y + p / 2, x, y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 56:
	// /* diamond10 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y - p / 2, x, y - p, x + p, y, x + p / 2, y + p / 2, x - p /
	//		2, y - p / 2, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 57:
	// /* diamond11 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x - p / 2, y + p / 2, x - p, y, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y, x + p / 2, y - p / 2, x + p, y, x + p / 2, y + p / 2, x, y, uActNr);
	//	uActNr += 3;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 58:
	// /* diamond12 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x, y - p, x + p, y, x + p / 2, y + p / 2, x, y, x - p / 2, y
	//		+ p / 2, x - p, y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 59:
	// /* diamond13 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y + p / 2, x + p / 2, y - p / 2, x + p, y, x, y + p, x - p /
	//		2, y + p / 2, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 60:
	// /* diamond14 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p / 2, y - p / 2, x, y - p, x + p, y, x, y + p, x - p / 2, y + p /
	//		2, x, y, x - p / 2, y - p / 2, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 61:
	// /* diamond15 */
	//	fprintf(gpoutfile, "group([\n");
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	fprintf(gpoutfile,
	//		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x + p / 2, y - p / 2, x + p, y,
	//		x, y + p, x - p, y, uActNr);
	//	uActNr += 2;
	//	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
	//	break;
	// /*}}}  */
	//    case 62:
	// /* diamond16 */
	//	fprintf(gpoutfile,
	//		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
	//		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
	//	uActNr++;
	//	break;
	// /*}}}  */
	//
	//    }				// switch 
	//}				// TGIF_point 
	//
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC void
	//TGIF_set_pointsize(double size)
	//{
	//    uActPointSize = size < 0. ? 1. : size;
	//}
	//
	//TERM_PUBLIC void
	//TGIF_set_linewidth(double size)
	//{
	//    dActThick_factor = size < 0. ? 1. : size;
	//}
	//
	// /*}}}  */
	// /***************************************************************************/
	//TERM_PUBLIC int
	//TGIF_set_font(const char *font)
	//{
	//    int sep;
	//
	//    if (!font || !(*font))
	//        font = sDefaultFont;
	//    sep = strcspn(font, ",");
	//    if (sep > 0) {
	//	strncpy(sActFont, font, sep);
	//	sActFont[sep] = NUL;
	//    }
	//    sscanf(&(font[sep + 1]), "%d", &uActFontSize);
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC int
	//TGIF_make_palette(t_sm_palette *palette)
	//{
	//    return 0; 
	// /* can do continuous colors */
	//}
	//
	//TERM_PUBLIC void 
	//TGIF_previous_palette(void)
	//{
	// /* do nothing */
	//}
	//
	//TERM_PUBLIC void
	//TGIF_set_color(t_colorspec *colorspec)
	//{
	//    if (colorspec->type == TC_LT) {
	//	TGIF_linetype(colorspec->lt);
	//    } else if (colorspec->type == TC_FRAC) {
	//	rgb255maxcolors_from_gray(colorspec->value, &rgbActColor);
	//	sprintf(sActColor, "#%.2x%.2x%.2x", 
	//		rgbActColor.r, rgbActColor.g, rgbActColor.b);
	//    } else if (colorspec->type == TC_RGB) {
	//	rgbActColor.r = colorspec->lt >> 16 & 0xff;
	//	rgbActColor.g = colorspec->lt >> 8 & 0xff;
	//	rgbActColor.b = colorspec->lt & 0xff;
	//	sprintf(sActColor, "#%.2x%.2x%.2x", 
	//		rgbActColor.r, rgbActColor.g, rgbActColor.b);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//TGIF_fillbox(int style, unsigned int x1, unsigned int y1, 
	//	     unsigned int width, unsigned int height)
	//{
	//    gpiPoint corner[4];
	//
	//	corner[0].x = x1;        corner[0].y = y1;
	//	corner[1].x = x1+width;  corner[1].y = y1;
	//	corner[2].x = x1+width;  corner[2].y = y1+height;
	//	corner[3].x = x1;        corner[3].y = y1+height;
	//	corner->style = style;
	//
	//	TGIF_filled_polygon(4, corner);
	//}
	//
	//TERM_PUBLIC void
	//TGIF_FillSolid(char *curcolor,int fillpar)
	//{
	//    int red, green, blue;
	//    double fact = (double)(100 - fillpar) * 0.01;
	//
	//    if (fact < 0.0) fact = 0.0;
	//    else if (fact > 1.0) fact = 1.0;
	//    red   = rgbActColor.r + (0xff - rgbActColor.r) * fact;
	//    green = rgbActColor.g + (0xff - rgbActColor.g) * fact;
	//    blue  = rgbActColor.b + (0xff - rgbActColor.b) * fact;
	//    sprintf(curcolor,"#%.2x%.2x%.2x", red, green, blue);
	//}
	//
	//TERM_PUBLIC void
	//TGIF_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int i,pattern;
	//    int fillpar = corners->style >> 4;
	//    int style = corners->style & 0xf;
	//    char curcolor[TGIF_STRLEN_MAX];
	//
	//    if (eTgifState == INPOLY)
	//	TGIF_flush_poly(); // Clean up current data 
	//
	//    switch (style) {
	//    case FS_EMPTY:
	//	pattern=uFillPattern[0];
	//	strcpy(curcolor,"white");
	//	break;
	//    case FS_TRANSPARENT_PATTERN:
	//    case FS_PATTERN:
	//	pattern=uFillPattern[fillpar % TGIF_fillpatterns];
	//	strcpy(curcolor,sActColor);
	//	break;
	//    case FS_TRANSPARENT_SOLID:
	//    case FS_SOLID:
	//	pattern=1;
	//	TGIF_FillSolid(curcolor,fillpar);
	//	break;
	//    default:
	//	pattern=1;
	//	strcpy(curcolor,sActColor);
	//    }
	//
	//    fprintf(gpoutfile, "polygon('%s',%d,[\n\t",curcolor,points+1);
	// /* loop through points, do the first one last as well as first */
	//    fprintf(gpoutfile,"%u,%u,", corners[0].x+uXshift, uYshift-corners[0].y);
	//    for (i = 1; i < points; i++) {
	//	fprintf(gpoutfile, "%u,%u,",
	//		corners[i].x+uXshift, uYshift-corners[i].y);
	// /* LN: Break long lines as Tgif is rather picky about them */
	//        if ((i + 1) % 8 == 0)
	//	    fputs("\n\t", gpoutfile);
	//    }
	//    fprintf(gpoutfile, "%u,%u", corners[0].x+uXshift, uYshift-corners[0].y);
	//    fprintf(gpoutfile, "],%d,1,0,0,%u,0,0,0,0,[\n]).\n", pattern, uActNr);
	//    uActNr++;
	//}
	//
	// /*}}}  */
	// /***************************************************************************/
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(tgif_driver)
	//    "tgif",
	//    "TGIF X11 [mode] [x,y] [dashed] [\042font\042 [fontsize]]",
	//    TGIF_XMAX, TGIF_YMAX, TGIF_VCHAR, TGIF_HCHAR,
	//    TGIF_VTIC, TGIF_HTIC, TGIF_options, TGIF_init, TGIF_reset,
	//    TGIF_text, null_scale, TGIF_graphics, TGIF_move, TGIF_vector,
	//    TGIF_linetype, TGIF_put_text, TGIF_text_angle,
	//    TGIF_justify_text, TGIF_point, TGIF_arrow, TGIF_set_font,
	//    TGIF_set_pointsize, 
	//    TERM_CAN_MULTIPLOT|TERM_CAN_DASH|TERM_LINEWIDTH, 
	//    0, 0, TGIF_fillbox,
	//    TGIF_set_linewidth
	///#ifdef USE_MOUSE
	//    ,0, 0, 0, 0, 0 // no mouse support for the tgif terminal 
	///#endif
	//    , TGIF_make_palette, TGIF_previous_palette, TGIF_set_color, 
	//    TGIF_filled_polygon
	//TERM_TABLE_END(tgif_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM tgif_driver
	//
	///#endif // TERM_TABLE 

	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(tgif)
	//"1 tgif",
	//"?commands set terminal tgif",
	//"?set terminal tgif",
	//"?set term tgif",
	//"?terminal tgif",
	//"?term tgif",
	//"?tgif",
	//" Tgif is an X11-based drawing tool---it has nothing to do with GIF.",
	//"",
	//" The `tgif` driver supports different pointsizes (with `set pointsize`),",
	//" different label fonts and font sizes (e.g. `set label \"Hallo\" at x,y font",
	//" \"Helvetica,34\"`) and multiple graphs on the page.  The proportions of the",
	//" axes are not changed.",
	//"",
	//" Syntax:",
	//"       set terminal tgif {portrait | landscape | default} {<[x,y]>}",
	//"                         {monochrome | color}",
	//"                         {{linewidth | lw} <LW>}",
	//"                         {solid | dashed}",
	//"                         {font \"<fontname>\"} {<fontsize>}",
	//"",
	//" where <[x,y]> specifies the number of graphs in the x and y directions on the",
	//" page, `color` enables color, `linewidth` scales all linewidths by <LW>,",
	//" \"<fontname>\" is the name of a valid PostScript font, and <fontsize>",
	//" specifies the size of the PostScript font.",
	//" `defaults` sets all options to their defaults: `portrait`, `[1,1]`, `color`,",
	//" `linwidth 1.0`, `dashed`, `\"Helvetica\"`, and `18`.",
	//"",
	//" The `solid` option is usually prefered if lines are colored, as they often",
	//" are in the editor.  Hardcopy will be black-and-white, so `dashed` should be",
	//" chosen for that.",
	//"",
	//" Multiplot is implemented in two different ways.",
	//"",
	//" The first multiplot implementation is the standard gnuplot multiplot feature:",
	//"",
	//"       set terminal tgif",
	//"       set output \"file.obj\"",
	//"       set multiplot",
	//"       set origin x01,y01",
	//"       set size  xs,ys",
	//"       plot ...",
	//"            ...",
	//"       set origin x02,y02",
	//"       plot ...",
	//"       unset multiplot",
	//"",
	//" See `set multiplot` for further information.",
	//"",
	//" The second version is the [x,y] option for the driver itself.  The advantage",
	//" of this implementation is that everything is scaled and placed automatically",
	//" without the need for setting origins and sizes; the graphs keep their natural",
	//" x/y proportions of 3/2 (or whatever is fixed by `set size`).",
	//"",
	//" If both multiplot methods are selected, the standard method is chosen and a",
	//" warning message is given.",
	//"",
	//" Examples of single plots (or standard multiplot):",
	//"       set terminal tgif                  # defaults",
	//"       set terminal tgif \"Times-Roman\" 24",
	//"       set terminal tgif landscape",
	//"       set terminal tgif landscape solid",
	//"",
	//" Examples using the built-in multiplot mechanism:",
	//"       set terminal tgif portrait [2,4]  # portrait; 2 plots in the x-",
	//"                                         # and 4 in the y-direction",
	//"       set terminal tgif [1,2]           # portrait; 1 plot in the x-",
	//"                                         # and 2 in the y-direction",
	//"       set terminal tgif landscape [3,3] # landscape; 3 plots in both",
	//"                                         # directions"
	//END_HELP(tgif)
	///#endif
	/*{{{}}}*/


	/* tcl/tk with perl extensions */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: tkcanvas.trm,v 1.28 2006/08/27 22:10:46 sfeam Exp $
	 *
	 */

	/* GNUPLOT - tkcanvas.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  Tk/Tcl canvas widgets
	 *
	 * AUTHORS - original dxy.trm
	 *  Martin Yii, eln557h@monu3.OZ
	 *  Further modified Jan 1990 by Russell Lang, rjl@monu1.cc.monash.oz
	 *
	 * Port to the Tk/Tcl canvas widget
	 *  D. Jeff Dionne, July 1995 jeff@ryeham.ee.ryerson.ca
	 *  Alex Woo, woo@playfair.stanford.edu
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Alex Woo (Sept. 1996)
	 */

	/*
	 * extended interactive Tk/Tcl capabilities
	 * Thomas Sefzick, March 1999, t.sefzick@fz-juelich.de
	 *
	 * added the perltk.trm code written by Slaven Rezic <eserte@cs.tu-berlin.de>,
	 * the variable 'tk_perl' switches between tcl/tk and perltk code.
	 * 'linewidth' and 'justify text' added, ends of plotted lines are now rounded.
	 * Thomas Sefzick, May 1999, t.sefzick@fz-juelich.de
	 *
	 * scale plot to fit into the actual size of the canvas as reported by
	 * the window manager (the canvas itself doesn't report its real size).
	 * Matt Willis, October 1999, mattbwillis@my-deja.com
	 */


	///#ifdef TERM_REGISTER
	//register_term(tkcanvas)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void TK_options __PROTO((void));
	//TERM_PUBLIC void TK_init __PROTO((void));
	//TERM_PUBLIC void TK_graphics __PROTO((void));
	//TERM_PUBLIC void TK_text __PROTO((void));
	//TERM_PUBLIC void TK_linetype __PROTO((int linetype));
	//TERM_PUBLIC void TK_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TK_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TK_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void TK_reset __PROTO((void));
	//TERM_PUBLIC int TK_justify_text __PROTO((enum JUSTIFY));
	//TERM_PUBLIC int TK_set_font __PROTO((const char *font));
	//TERM_PUBLIC void TK_linewidth __PROTO((double linewidth));
	//
	///#define TK_XMAX 1000
	///#define TK_YMAX 1000
	//
	///#define TK_XLAST (TK_XMAX - 1)
	///#define TK_YLAST (TK_XMAX - 1)
	//
	///#define TK_VCHAR	(25)	// double actual height of characters 
	///#define TK_HCHAR	(16)	// actual width including spacing 
	///#define TK_VTIC	(18)
	///#define TK_HTIC	(18)
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	// /* axis.c */
	// /* FIXME HBB 20000725: "Never use extern in a source file". This needs
	//  * to be fixed.  As is, this driver causes the terminal layer to
	//  * depend on several other core modules. The lack of proper #include's
	//  * partly hides this, but it's still a design bug. "term" is supposed
	//  * a 'frontier' layer: it should not be dependant on any other code
	//  * inside gnuplot */
	//extern AXIS axis_array[];
	// /* command.c */
	//extern TBOOLEAN is_3d_plot;
	//
	// /* static int tk_angle = 0; unused, for now */
	//static int tk_lastx;
	//static int tk_lasty;
	//static int tk_color = 0;
	//static char tk_anchor[7] = "w";
	//static double tk_linewidth = 1.0;
	//static int tk_perl = 0;
	//static int tk_interactive = 0;
	//static const char *tk_colors[] = {
	//    "black", "gray", "red", "blue", "green", "brown", "magenta", "cyan"
	//};
	//
	//enum TK_id { TK_PERLTK, TK_INTERACTIVE, TK_OTHER };
	//
	//static struct gen_table TK_opts[] =
	//{
	//    { "p$erltk", TK_PERLTK },
	//    { "i$nteractive", TK_INTERACTIVE },
	//    { NULL, TK_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//TK_options()
	//{
	//    tk_perl = 0;
	//    tk_interactive = 0;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&TK_opts[0],c_token)) {
	//	case TK_PERLTK:
	//	    tk_perl = 1;
	//	    c_token++;
	//	    break;
	//	case TK_INTERACTIVE:
	//	    tk_interactive = 1;
	//	    c_token++;
	//	    break;
	//	case TK_OTHER:
	//	default:
	//	    c_token++;
	//	    break;
	//	}
	//    }
	//
	//    sprintf(term_options, "%s %s",
	//	    tk_perl ? "perltk" : "",
	//	    tk_interactive ? "interactive" : "");
	//}
	//
	//TERM_PUBLIC void
	//TK_init()
	//{
	//}
	//
	//TERM_PUBLIC void
	//TK_graphics()
	//{
	// /*
	//  * the resulting tcl or perl code takes the actual width and height
	//  * of the defined canvas and scales the plot to fit.
	//  * => NOTE: this makes 'set size' useless !!!
	//  * unless the original width and height is taken into account
	//  * by some tcl or perl code, that's why the 'gnuplot_plotarea' and
	//  * 'gnuplot_axisranges' procedures are supplied.
	//  */
	//    if (tk_perl) {
	//	fputs("
	//sub {\n
	//my($can) = @_;\n
	//$can->delete('all');\n
	//my $cmx = $can->width - 2 * $can->cget(-border) - 2 * $can->cget(-highlightthickness);\n
	//if ($cmx <= 1) {\n$cmx = ($can->cget(-width));\n}\n
	//my $cmy = $can->height - 2 * $can->cget(-border) - 2 * $can->cget(-highlightthickness);\n
	//if ($cmy <= 1) {\n$cmy = ($can->cget(-height));\n}\n",
	//	      gpoutfile);
	//    } else {
	//	fputs("
	//proc gnuplot can {\n
	//$can delete all\n
	//set cmx [expr [winfo width $can]-2*[$can cget -border]-2*[$can cget -highlightthickness]]\n
	//if {$cmx <= 1} {set cmx [$can cget -width]}\n
	//set cmy [expr [winfo height $can]-2*[$can cget -border]-2*[$can cget -highlightthickness]]\n
	//if {$cmy <= 1} {set cmy [$can cget -height]}\n",
	//	      gpoutfile);
	//    }
	//    tk_lastx = tk_lasty = tk_color = 0;
	//}
	//
	//TERM_PUBLIC void
	//TK_reset()
	//{
	//}
	//
	//TERM_PUBLIC void
	//TK_linetype(int linetype)
	//{
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    tk_color = (linetype + 2) & 7;
	//}
	//
	//TERM_PUBLIC void
	//TK_linewidth(double linewidth)
	//{
	//    tk_linewidth = linewidth;
	//}
	//
	//TERM_PUBLIC void
	//TK_move(unsigned int x, unsigned int y)
	//{
	//    tk_lastx = x;
	//    tk_lasty = 1000 - y;
	//}
	//
	// /* FIXME HBB 20000725: should use AXIS_UNDO_LOG() macro... */
	///#define TK_REAL_VALUE(value,axis)				(axis_array[axis].log)						    ? pow(axis_array[axis].base, axis_array[axis].min			  + value*(axis_array[axis].max-axis_array[axis].min))		: axis_array[axis].min					          + value*(axis_array[axis].max-axis_array[axis].min)
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	///#define TK_X_VALUE(value)  (double)(value-plot_bounds.xleft)/(double)(plot_bounds.xright-plot_bounds.xleft)
	//ignore
	//
	///#define TK_Y_VALUE(value)  (double)((TK_YMAX-value)-plot_bounds.ybot)/(double)(plot_bounds.ytop-plot_bounds.ybot)
	//ignore
	//
	//TERM_PUBLIC void
	//TK_vector(unsigned int x, unsigned int y)
	//{
	// /*
	//  * this is the 1st part of the wrapper around the 'create line' command
	//  * used to bind some actions to a line segment:
	//  * bind {
	//  *      normal create line command
	//  *      } gnuplot_xy(some coordinates)
	//  */
	//    if (tk_interactive && !is_3d_plot) {
	//	if (tk_perl)
	//	    fprintf(gpoutfile, "$can->bind(");
	//	else
	//	    fprintf(gpoutfile, "$can bind [\n");
	//    }
	// /*
	//  * end of 1st part of wrapper
	//  */
	//    y = 1000 - y;
	// /*
	//  * here is the basic well-known command for plotting a line segment
	//  */
	//    if (tk_perl) {
	//	fprintf(gpoutfile,"
	//$can->createLine(
	//$cmx * %d / 1000,
	//$cmy * %d / 1000,
	//$cmx * %d / 1000,
	//$cmy * %d / 1000, -fill => q{%s}, -width => %f, -capstyle => q{round})",
	//		tk_lastx, tk_lasty, x, y, tk_colors[tk_color], tk_linewidth);
	//    } else {
	//	fprintf(gpoutfile,"
	//$can create line
	//[expr $cmx * %d /1000]
	//[expr $cmy * %d /1000]
	//[expr $cmx * %d /1000]
	//[expr $cmy * %d /1000] -fill %s -width %f -capstyle round\n",
	//		tk_lastx, tk_lasty, x, y, tk_colors[tk_color], tk_linewidth);
	//    }
	//
	// /*
	//  * this is the 2nd part of the wrapper around the 'create line'
	// * command it generates a mechanism which calls 'gnuplot_xy' for
	// * the line segment pointed to by the mouse cursor when a mouse
	// * button is pressed
	//  */
	//    if (tk_interactive && !is_3d_plot) {
	//	if (tk_perl) {
	// /* Ev('W') not needed here, supplied anyhow, WHY ??? */
	//	    fprintf(gpoutfile,"
	//, '<Button>' =>
	//[\\&gnuplot_xy, %f, %f, %f, %f, %f, %f, %f, %f,",
	//		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), FIRST_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), FIRST_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), SECOND_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), SECOND_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(x), FIRST_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(y), FIRST_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(x), SECOND_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(y), SECOND_Y_AXIS));
	//	    if (axis_array[FIRST_X_AXIS].log) {
	//		fprintf(gpoutfile, " %f,",
	//			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), FIRST_X_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " \"\",");
	//	    }
	//	    if (axis_array[FIRST_Y_AXIS].log) {
	//		fprintf(gpoutfile, " %f,",
	//			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), FIRST_Y_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " \"\",");
	//	    }
	//	    if (axis_array[SECOND_X_AXIS].log) {
	//		fprintf(gpoutfile, " %f,",
	//			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), SECOND_X_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " \"\",");
	//	    }
	//	    if (axis_array[SECOND_Y_AXIS].log) {
	//		fprintf(gpoutfile, " %f",
	//			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), SECOND_Y_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " \"\"");
	//	    }
	//	    fprintf(gpoutfile, "]);\n");
	//	} else {
	//	    fprintf(gpoutfile,"
	//] <Button>
	//\"gnuplot_xy %%W %f %f %f %f %f %f %f %f",
	//		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), FIRST_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), FIRST_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), SECOND_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), SECOND_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(x), FIRST_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(y), FIRST_Y_AXIS),
	//		    TK_REAL_VALUE(TK_X_VALUE(x), SECOND_X_AXIS),
	//		    TK_REAL_VALUE(TK_Y_VALUE(y), SECOND_Y_AXIS));
	//	    if (axis_array[FIRST_X_AXIS].log) {
	//		fprintf(gpoutfile, " %f",
	//			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), FIRST_X_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " {}");
	//	    }
	//	    if (axis_array[FIRST_Y_AXIS].log) {
	//		fprintf(gpoutfile, " %f",
	//			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), FIRST_Y_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " {}");
	//	    }
	//	    if (axis_array[SECOND_X_AXIS].log) {
	//		fprintf(gpoutfile, " %f",
	//			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), SECOND_X_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " {}");
	//	    }
	//	    if (axis_array[SECOND_Y_AXIS].log) {
	//		fprintf(gpoutfile, " %f",
	//			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), SECOND_Y_AXIS));
	//	    } else {
	//		fprintf(gpoutfile, " {}");
	//	    }
	//	    fprintf(gpoutfile, "\"\n");
	//	}
	//    } else {
	//	if (tk_perl) {
	//	    fprintf(gpoutfile, ";\n");
	//	}
	//    }
	// /*
	//  * end of the wrapper
	//  */
	//    tk_lastx = x;
	//    tk_lasty = y;
	//}
	//
	///#undef TK_REAL_VALUE
	///#undef TK_X_VALUE
	///#undef TK_Y_VALUE
	//
	//TERM_PUBLIC void
	//TK_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    y = 1000 - y;
	//    if (tk_perl) {
	//	fprintf(gpoutfile,"
	//$can->createText($cmx * %d / 1000, $cmy * %d / 1000, -text => q{%s},
	//-fill => q{%s}, -anchor => '%s', (defined $font ? (-font => $font) : ()));\n",
	//		x, y, str, tk_colors[tk_color], tk_anchor);
	//    } else {
	// /* Have to quote-protect '[' and ']' characters */
	//        int i, newsize = 0;
	//        char *quoted_str;
	//
	//        for (i=0; str[i] != '\0'; i++) {
	//            if ((str[i] == '[') || (str[i] == ']'))
	//                newsize++;
	//            newsize++;
	//        }
	//        quoted_str = gp_alloc(newsize + 1, "TK_put_text: quoted string");
	//
	//        for (i=0, newsize = 0; str[i] != '\0'; i++) {
	//            if ((str[i] == '[') || (str[i] == ']'))
	//                quoted_str[newsize++] = '\\';
	//            quoted_str[newsize++] = str[i];
	//        }
	//        quoted_str[newsize] = '\0';
	//	fprintf(gpoutfile,"
	//eval $can create text
	//[expr $cmx * %d /1000]
	//[expr $cmy * %d /1000]
	//-text \\{%s\\} -fill %s -anchor %s
	// [expr [info exists font]?\"-font \\$font\":{}]\n",
	//		x, y, quoted_str, tk_colors[tk_color], tk_anchor);
	//       free(quoted_str);
	//    } // else (!tk_perl) 
	//}
	//
	//TERM_PUBLIC int
	//TK_justify_text(enum JUSTIFY anchor)
	//{
	//    int return_value;
	//
	//    switch (anchor) {
	//    case RIGHT:
	//	strcpy(tk_anchor, "e");
	//	return_value = TRUE;
	//	break;
	//    case CENTRE:
	//	strcpy(tk_anchor, "center");
	//	return_value = TRUE;
	//	break;
	//    case LEFT:
	//	strcpy(tk_anchor, "w");
	//	return_value = TRUE;
	//	break;
	//    default:
	//	strcpy(tk_anchor, "w");
	//	return_value = FALSE;
	//    }
	//    return return_value;
	//}
	//
	//TERM_PUBLIC int
	//TK_set_font(const char *font)
	//{
	//    if (!font || *font == NUL) {
	//	if (tk_perl)
	//	    fputs("undef $font;\n", gpoutfile);
	//	else
	//	    fputs("catch {unset $font}\n", gpoutfile);
	//    } else {
	//	char *name;
	//	int size = 0;
	//	size_t sep = strcspn(font, ",");
	//
	//	name = malloc(sep + 1);
	//	if (!name)
	//	    return FALSE;
	//	strncpy(name, font, sep);
	//	name[sep] = NUL;
	//	if (sep < strlen(font))
	//	    sscanf(&(font[sep + 1]), "%d", &size);
	//	if (tk_perl) {
	//	    fprintf(gpoutfile,"
	//if ($can->can('fontCreate')) {\n
	//$font = $can->fontCreate(-family => q{%s}",
	//		    name);
	//	    if (size)
	//		fprintf(gpoutfile, ", -size => %d", size);
	//	    fputs(");\n}\n", gpoutfile);
	//	} else {
	//	    fprintf(gpoutfile, "set font [font create -family %s", name);
	//	    if (size)
	//		fprintf(gpoutfile, " -size %d", size);
	//	    fputs("]\n", gpoutfile);
	//	}
	//	free(name);
	//    }
	//    return TRUE;
	//}
	//
	//TERM_PUBLIC void
	//TK_text()
	//{
	// /*
	//  * when switching back to text mode some procedures are generated which
	//  * return important information about plotarea size and axis ranges:
	//  * 'gnuplot_plotarea' returns the plotarea size in tkcanvas units
	//  * 'gnuplot_axisranges' returns the min. and max. values of the axis
	//  * these are essentially needed to set the size of the canvas when the
	//  * axis scaling is important.
	//  * moreover, a procedure 'gnuplot_xy' is created which contains the
	//  * actions bound to line segments (see the above 'TK_vector' code):
	//  * if the user has defined a procedure named 'user_gnuplot_coordinates'
	//  * then 'gnuplot_xy' calls this procedure, otherwise is writes the
	//  * coordinates of the line segment the mouse cursor is pointing to
	//  * to standard output.
	//  */
	//    if (tk_perl) {
	//	fputs("};\n", gpoutfile);
	//	if (!is_3d_plot) {
	//	    fputs("sub gnuplot_plotarea {\n", gpoutfile);
	//	    fprintf(gpoutfile,
	//		    "return (%d, %d, %d, %d);\n",
	//		    plot_bounds.xleft, plot_bounds.xright, 1000 - plot_bounds.ytop, 1000 - plot_bounds.ybot);
	//	    fputs("};\n", gpoutfile);
	//	    fputs("sub gnuplot_axisranges {\n", gpoutfile);
	//	    fprintf(gpoutfile,
	//		    "return (%f, %f, %f, %f, %f, %f, %f, %f);\n",
	//		    axis_array[FIRST_X_AXIS].min, axis_array[FIRST_X_AXIS].max,
	//		    axis_array[FIRST_Y_AXIS].min, axis_array[FIRST_Y_AXIS].max,
	//		    axis_array[SECOND_X_AXIS].min, axis_array[SECOND_X_AXIS].max,
	//		    axis_array[SECOND_Y_AXIS].min, axis_array[SECOND_Y_AXIS].max);
	//	    fputs("};\n", gpoutfile);
	//	    if (tk_interactive) {
	//		fputs("sub gnuplot_xy {\n",
	//		      gpoutfile);
	//		fputs("my ($win, $x1s, $y1s, $x2s, $y2s, $x1e, $y1e, $x2e, $y2e, $x1m, $y1m, $x2m, $y2m) = @_;\n",
	//		      gpoutfile);
	//		fputs("if (defined &user_gnuplot_coordinates) {\n",
	//		      gpoutfile);
	//		fputs("my $id = $win->find('withtag', 'current');\n",
	//		      gpoutfile);
	//		fputs("user_gnuplot_coordinates $win, $id, $x1s, $y1s, $x2s, $y2s, $x1e, $y1e, $x2e, $y2e, $x1m, $y1m, $x2m, $y2m\n",
	//		      gpoutfile);
	//		fputs("} else {\n",
	//		      gpoutfile);
	//		fputs("if (length($x1m)>0) {print \" $x1m\";} else {print \" \", 0.5*($x1s+$x1e);}\n",
	//		      gpoutfile);
	//		fputs("if (length($y1m)>0) {print \" $y1m\";} else {print \" \", 0.5*($y1s+$y1e);}\n",
	//		      gpoutfile);
	//		fputs("if (length($x2m)>0) {print \" $x2m\";} else {print \" \", 0.5*($x2s+$x2e);}\n",
	//		      gpoutfile);
	//		fputs("if (length($y2m)>0) {print \" $y2m\";} else {print \" \", 0.5*($y2s+$y2e);}\n",
	//		      gpoutfile);
	//		fputs("print \"\\n\"\n",
	//		      gpoutfile);
	//		fputs("}\n",
	//		      gpoutfile);
	//		fputs("};\n", gpoutfile);
	//	    }
	//	}
	//    } else {
	//	fputs("}\n", gpoutfile);
	//	if (!is_3d_plot) {
	//	    fputs("proc gnuplot_plotarea {} {\n", gpoutfile);
	//	    fprintf(gpoutfile,
	//		    "return {%d %d %d %d}\n",
	//		    plot_bounds.xleft, plot_bounds.xright, 1000 - plot_bounds.ytop, 1000 - plot_bounds.ybot);
	//	    fputs("}\n", gpoutfile);
	//	    fputs("proc gnuplot_axisranges {} {\n", gpoutfile);
	//	    fprintf(gpoutfile,
	//		    "return {%f %f %f %f %f %f %f %f}\n",
	//		    axis_array[FIRST_X_AXIS].min, axis_array[FIRST_X_AXIS].max,
	//		    axis_array[FIRST_Y_AXIS].min, axis_array[FIRST_Y_AXIS].max,
	//		    axis_array[SECOND_X_AXIS].min, axis_array[SECOND_X_AXIS].max,
	//		    axis_array[SECOND_Y_AXIS].min, axis_array[SECOND_Y_AXIS].max);
	//	    fputs("}\n", gpoutfile);
	//	    if (tk_interactive) {
	//		fputs("proc gnuplot_xy {win x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m} {\n",
	//		      gpoutfile);
	//		fputs("if {([llength [info commands user_gnuplot_coordinates]])} {\n",
	//		      gpoutfile);
	//		fputs("set id [$win find withtag current]\n",
	//		      gpoutfile);
	//		fputs("user_gnuplot_coordinates $win $id $x1s $y1s $x2s $y2s $x1e $y1e $x2e $y2e $x1m $y1m $x2m $y2m\n",
	//		      gpoutfile);
	//		fputs("} else {\n", gpoutfile);
	//		fputs("if {[string length $x1m]>0} {puts -nonewline \" $x1m\"} else {puts -nonewline \" [expr 0.5*($x1s+$x1e)]\"}\n",
	//		      gpoutfile);
	//		fputs("if {[string length $y1m]>0} {puts -nonewline \" $y1m\"} else {puts -nonewline \" [expr 0.5*($y1s+$y1e)]\"}\n",
	//		      gpoutfile);
	//		fputs("if {[string length $x2m]>0} {puts -nonewline \" $x2m\"} else {puts -nonewline \" [expr 0.5*($x2s+$x2e)]\"}\n",
	//		      gpoutfile);
	//		fputs("if {[string length $y2m]>0} {puts \" $y2m\"} else {puts \" [expr 0.5*($y2s+$y2e)]\"}\n",
	//		      gpoutfile);
	//		fputs("}\n", gpoutfile);
	//		fputs("}\n", gpoutfile);
	//	    }
	//	}
	//    }
	//    fflush(gpoutfile);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(tkcanvas)
	//    "tkcanvas", "Tk/Tcl canvas widget [perltk] [interactive]",
	//    TK_XMAX, TK_YMAX, TK_VCHAR, TK_HCHAR,
	//    TK_VTIC, TK_HTIC, TK_options, TK_init, TK_reset,
	//    TK_text, null_scale, TK_graphics, TK_move, TK_vector,
	//    TK_linetype, TK_put_text, null_text_angle,
	//    TK_justify_text, do_point, do_arrow, TK_set_font,
	//    NULL, 0, NULL, NULL, NULL, TK_linewidth
	//TERM_TABLE_END(tkcanvas)
	///#undef LAST_TERM
	///#define LAST_TERM tkcanvas
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(tkcanvas)
	//"1 tkcanvas",
	//"?commands set terminal tkcanvas",
	//"?set terminal tkcanvas",
	//"?set term tkcanvas",
	//"?terminal tkcanvas",
	//"?term tkcanvas",
	//"?tkcanvas",
	//" This terminal driver generates Tk canvas widget commands based on Tcl/Tk",
	//" (default) or Perl.  To use it, rebuild `gnuplot` (after uncommenting or",
	//" inserting the appropriate line in \"term.h\"), then",
	//"",
	//"  gnuplot> set term tkcanvas {perltk} {interactive}",
	//"  gnuplot> set output 'plot.file'",
	//"",
	//" After invoking \"wish\", execute the following sequence of Tcl/Tk commands:",
	//"",
	//"  % source plot.file",
	//"  % canvas .c",
	//"  % pack .c",
	//"  % gnuplot .c",
	//"",
	//" Or, for Perl/Tk use a program like this:",
	//"",
	//"  use Tk;",
	//"  my $top = MainWindow->new;",
	//"  my $c = $top->Canvas->pack;",
	//"  my $gnuplot = do \"plot.pl\";",
	//"  $gnuplot->($c);",
	//"  MainLoop;",
	//"",
	//" The code generated by `gnuplot` creates a procedure called \"gnuplot\"",
	//" that takes the name of a canvas as its argument.  When the procedure is",
	//" called, it clears the canvas, finds the size of the canvas and draws the plot",
	//" in it, scaled to fit.",
	//"",
	//" For 2-dimensional plotting (`plot`) two additional procedures are defined:",
	//" \"gnuplot_plotarea\" will return a list containing the borders of the plotting",
	//" area \"xleft, xright, ytop, ybot\" in canvas screen coordinates, while the ranges",
	//" of the two axes \"x1min, x1max, y1min, y1max, x2min, x2max, y2min, y2max\" in plot",
	//" coordinates can be obtained calling \"gnuplot_axisranges\".",
	//" If the \"interactive\" option is specified, mouse clicking on a line segment",
	//" will print the coordinates of its midpoint to stdout. Advanced actions",
	//" can happen instead if the user supplies a procedure named",
	//" \"user_gnuplot_coordinates\", which takes the following arguments:",
	//" \"win id x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m\",",
	//" the name of the canvas and the id of the line segment followed by the",
	//" coordinates of its start and end point in the two possible axis ranges; the",
	//" coordinates of the midpoint are only filled for logarithmic axes.",
	//"",
	//" The current version of `tkcanvas` supports neither `multiplot` nor `replot`."
	//END_HELP(tkcanvas)
	///#endif


	/* Vectrix 384 printer, also Tandy colour */
	/* #include "v384.trm" */

	/* wire printers */
	/* Epson LX-800, Star NL-10, NX-1000 and lots of others */
	///#define EPSONP

	/* Epson-style 60-dot per inch printers */
	///#define EPS60

	/* Epson-style 180-dot per inch (24 pin) printers */
	///#define EPS180

	///#define NEC
	///#define OKIDATA
	///#define STARC

	/* Seiko DPU-414 thermal printer */
	///#define DPU414

	/* Tandy DMP-130 series 60-dot per inch graphics */
	///#define TANDY60

	/* the common driver file for all of these */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: epson.trm,v 1.25 2008/05/31 20:23:44 sfeam Exp $
	 *
	 */

	/* GNUPLOT - epson.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *  epson_lx800, nec_cp6, starc,
	 *  epson_60dpi, tandy_60dpi
	 *  epson_180dpi
	 *  dpu414
	 *
	 * AUTHORS
	 *  Russell Lang
	 *  William Wilson
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (1995)
	 */


	///#ifdef TERM_REGISTER
	///#ifdef EPS180
	//register_term(epson_180dpi)
	///#endif // EPS180 
	///#ifdef EPS60
	//register_term(epson_60dpi)
	///#endif // EPS60 
	///#ifdef EPSONP
	//register_term(epson_lx800)
	///#endif // EPSONP 
	///#ifdef NEC
	//register_term(nec_cp6)
	///#endif // NEC 
	///#ifdef OKIDATA
	//register_term(okidata)
	///#endif // OKIDATA 
	///#ifdef STARC
	//register_term(starc)
	///#endif // STARC 
	///#ifdef TANDY60
	//register_term(tandy_60dpi)
	///#endif // TANDY60 
	///#ifdef DPU414
	//register_term(dpu414)
	///#endif // DPU414 
	///#endif // TERM_REGISTER 

	///#ifdef TERM_PROTO
	//
	//TERM_PUBLIC void EPSON_reset __PROTO((void));
	//
	///#if defined(EPS180) || defined(EPS60) || defined(EPSONP) || defined(TANDY60) || defined(OKIDATA)
	//TERM_PUBLIC void EPSON_init __PROTO((void));
	//
	///#if defined(EPS60) || defined(EPSONP) || defined(TANDY60) || defined(OKIDATA)
	///#define EPSONVCHAR		FNT5X9_VCHAR
	///#define EPSONHCHAR		FNT5X9_HCHAR
	///#define EPSONVTIC		6
	///#define EPSONHTIC		6
	//
	///#ifdef EPSONP
	///#define EPSONXMAX	512
	///#define EPSONYMAX	384
	//TERM_PUBLIC void EPSON_graphics __PROTO((void));
	//TERM_PUBLIC void EPSON_text __PROTO((void));
	///#endif // EPSONP 
	///#endif // four drivers 
	///#endif // all five 
	//
	///#ifdef EPS180
	//TERM_PUBLIC void EPS180_graphics __PROTO((void));
	//TERM_PUBLIC void EPS180_text __PROTO((void));
	///#define EPSON180VCHAR		FNT13X25_VCHAR
	///#define EPSON180HCHAR		FNT13X25_HCHAR
	///#define EPSON180VTIC		18
	///#define EPSON180HTIC		18
	// /* make the total dimensions 8 inches by 6 inches */
	///#define EPS180XMAX	1260
	///#define EPS180YMAX	1080
	///#endif // EPS180 
	//
	///#if defined(EPS60) || defined(TANDY60) || defined(OKIDATA)
	// /* make the total dimensions 8 inches by 5 inches */
	///#define EPS60XMAX	480
	///#define EPS60YMAX	360
	//TERM_PUBLIC void EPS60_graphics __PROTO((void));
	///#ifdef TANDY60
	//TERM_PUBLIC void TANDY60_text __PROTO((void));
	///#endif // TANDY60 
	///#ifdef OKIDATA
	//TERM_PUBLIC void OKIDATA_text __PROTO((void));
	///#endif // OKIDATA 
	///#ifdef EPS60
	//TERM_PUBLIC void EPS60_text __PROTO((void));
	///#endif // EPS60 
	///#endif // all three 
	//
	///#ifdef NEC
	//TERM_PUBLIC void NEC_options __PROTO((void));
	//TERM_PUBLIC void NEC_init __PROTO((void));
	//TERM_PUBLIC void NEC_graphics __PROTO((void));
	//TERM_PUBLIC void NEC_text __PROTO((void));
	//TERM_PUBLIC void NEC_linetype __PROTO((int linetype));
	///#define NECXMAX	400
	///#define NECYMAX	320
	///#define NECVCHAR		FNT5X9_VCHAR
	///#define NECHCHAR		FNT5X9_HCHAR
	///#define NECVTIC		6
	///#define NECHTIC		6
	///#endif // NEC 
	//
	///#ifdef STARC
	//TERM_PUBLIC void STARC_init __PROTO((void));
	//TERM_PUBLIC void STARC_graphics __PROTO((void));
	//TERM_PUBLIC void STARC_text __PROTO((void));
	//TERM_PUBLIC void STARC_linetype __PROTO((int linetype));
	///#define STARCXMAX	512
	///#define STARCYMAX	384
	///#define STARCVCHAR		FNT5X9_VCHAR
	///#define STARCHCHAR		FNT5X9_HCHAR
	///#define STARCVTIC		6
	///#define STARCHTIC		6
	///#endif // STARC 
	//
	///#ifdef DPU414
	//TERM_PUBLIC void DPU414_options __PROTO((void));
	//TERM_PUBLIC void DPU414_init __PROTO((void));
	//TERM_PUBLIC void DPU414_graphics __PROTO((void));
	//TERM_PUBLIC void DPU414_text __PROTO((void));
	//TERM_PUBLIC void DPU414_setfont __PROTO((void));
	///#define DPU414XMAX	(640)
	///#define DPU414YMAX	(480)
	///#define DPU414VCHAR	FNT5X9_VCHAR
	///#define DPU414HCHAR	FNT5X9_HCHAR
	///#define DPU414VTIC	FNT5X9_HBITS
	///#define DPU414HTIC	FNT5X9_HBITS
	///#endif // DPU414 
	//
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//
	//TERM_PUBLIC void
	//EPSON_reset()
	//{
	///#ifdef VMS
	//    fflush_binary();
	///#endif
	//}
	//
	//
	///#ifdef EPSONP
	//
	// /* The following epson lx800 driver uses generic bit mapped graphics
	//    routines to build up a bit map in memory. */
	// /* by Russell Lang, rjl@monu1.cc.monash.edu.au */
	// /* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
	// /* EPSON_init changes gpoutfile to binary mode on PC's */
	//
	//static void epson_dump __PROTO((void));
	//
	///#define EPSONXLAST (EPSONXMAX - 1)
	///#define EPSONYLAST (EPSONYMAX - 1)
	//
	//TERM_PUBLIC void
	//EPSON_init()
	//{
	//}
	//
	//TERM_PUBLIC void
	//EPSON_graphics()
	//{
	//    b_charsize(FNT5X9);
	//    b_makebitmap((unsigned int) (EPSONXMAX * xsize),
	//		 (unsigned int) (EPSONYMAX * ysize), 1);
	//}
	//
	//
	//TERM_PUBLIC void
	//EPSON_text()
	//{
	//    epson_dump();
	//    b_freebitmap();
	//}
	//
	//
	// /* output file must be binary mode for epson_dump */
	//static void
	//epson_dump()
	//{
	//    register unsigned int x;
	//    int j;
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	// /* select plotter graphics mode (square pixels) */
	//	fputs("\033J\030", gpoutfile);	// line feed 8/72" = 8 dots 
	//	fputs("\r\033*\005", gpoutfile);
	//	(void) fputc((char) (b_xsize % 256), gpoutfile);
	//	(void) fputc((char) (b_xsize / 256), gpoutfile);
	//	for (x = 0; x < b_xsize; x++) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	}
	//    }
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // EPSONP 
	//
	//
	// /* The following NEC CP6 Pinwriter driver uses generic bit mapped graphics
	//    routines to build up a bit map in memory. */
	// /* by Russell Lang, rjl@monu1.cc.monash.edu.au */
	// /* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
	// /* NEC_init changes gpoutfile to binary mode for PC's */
	//
	// /* Add a Monochrome NEC printer (for faster speed and line types) jdc */
	//
	///#ifdef NEC
	//
	//static void nec_dump __PROTO((void));
	//static void nec_draft_dump __PROTO((void));
	//
	///#define NECXLAST (NECXMAX - 1)
	///#define NECYLAST (NECYMAX - 1)
	//
	//
	// /* plane 0=black, 1=cyan(blue), 2=magenta(red), 3=yellow */
	//static unsigned int neccolor[] = { 1, 8, 4, 2, 10, 12, 6, 14 };
	//static unsigned int necpcolor[] = { 0, 2, 1, 4 };
	//
	//static int NECmode;
	//
	//enum NEC_id { NEC_MONOCHROME, NEC_COLOR, NEC_DRAFT, NEC_OTHER };
	//
	//static struct gen_table NEC_opts[] =
	//{
	//    { "m$onochrome", NEC_MONOCHROME },
	//    { "c$olor", NEC_COLOR },
	//    { "c$olour", NEC_COLOR },
	//    { "d$raft", NEC_DRAFT },
	//    { NULL, NEC_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//NEC_options()
	//{
	// /* default */
	//    if (END_OF_COMMAND) {
	//	strcpy(term_options, "monochrome");
	//	NECmode = 'm';
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&NEC_opts[0],c_token)) {
	//	case NEC_MONOCHROME:
	//	    c_token++;
	//	    strcpy(term_options, "monochrome");
	//	    NECmode = 'm';
	//	    break;
	//	case NEC_COLOR:
	//	    c_token++;
	//	    strcpy(term_options, "color");
	//	    NECmode = 'c';
	// 	    break;
	//	case NEC_DRAFT:
	//	    c_token++;
	//	    strcpy(term_options, "draft");
	//	    NECmode = 'd';
	//	    break;
	//	case NEC_OTHER:
	//	default:
	// /* FIXME - not the most sensible thing to do */
	// /* error, but since the terminal is already set, default to mono */
	//	    strcpy(term_options, "monochrome");
	//	    NECmode = 'm';
	//	    int_error(c_token, "modes: color, monochrome, draft");
	//	    break;
	//	}
	//    }
	//
	//}
	//
	//TERM_PUBLIC void
	//NEC_init()
	//{
	//}
	//
	//TERM_PUBLIC void
	//NEC_graphics()
	//{
	//    b_charsize(FNT5X9);
	//    b_makebitmap((unsigned int) (NECXMAX * xsize),
	//		 (unsigned int) (NECYMAX * ysize), (NECmode == 'c' ? 4 : 1));
	//}
	//
	//TERM_PUBLIC void
	//NEC_text()
	//{
	//    if (NECmode == 'd') {
	//	nec_draft_dump();
	//    } else {
	//	nec_dump();
	//    }
	//    b_freebitmap();
	//}
	//
	//TERM_PUBLIC void
	//NEC_linetype(int linetype)
	//{
	//    if (NECmode == 'c') {
	//	if (linetype >= 6)
	//	    linetype %= 6;
	//	b_setvalue(neccolor[linetype + 2]);
	//    } else {
	//	b_setlinetype(linetype);
	//    }
	//}
	//
	//
	//
	// /* output file must be binary mode for nec_dump */
	//static void
	//nec_dump()
	//{
	//    unsigned int x;
	//    unsigned int plane, offset;
	//    int j;
	//    unsigned int column8;
	//    unsigned long column24;
	//    char column3, column2, column1;
	//    fputs("\033P\033l\005", gpoutfile);	// 10cpi, left margin 5 char 
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	//	fputs("\033J\030", gpoutfile);	// 24/180" line feed 
	//	for (plane = 0; plane < b_planes; plane++) {
	//	    offset = plane * b_psize;
	//	    if (b_planes > 1) {
	// /* select colour for plane */
	//		fputs("\033r", gpoutfile);
	//		(void) fputc((char) necpcolor[plane], gpoutfile);
	//	    }
	// /* select plotter graphics mode (square pixels) */
	//	    fputs("\r\033*\047", gpoutfile);
	//	    (void) fputc((char) ((b_xsize * 3) % 256), gpoutfile);
	//	    (void) fputc((char) ((b_xsize * 3) / 256), gpoutfile);
	//	    for (x = 0; x < b_xsize; x++) {
	//		column8 = (unsigned int) (*((*b_p)[j + offset] + x));
	//		column24 = 0;
	//		if (column8 & 0x01)
	//		    column24 |= (long) 0x000007;
	//		if (column8 & 0x02)
	//		    column24 |= (long) 0x000038;
	//		if (column8 & 0x04)
	//		    column24 |= (long) 0x0001c0;
	//		if (column8 & 0x08)
	//		    column24 |= (long) 0x000e00;
	//		if (column8 & 0x10)
	//		    column24 |= (long) 0x007000;
	//		if (column8 & 0x20)
	//		    column24 |= (long) 0x038000;
	//		if (column8 & 0x40)
	//		    column24 |= (long) 0x1c0000;
	//		if (column8 & 0x80)
	//		    column24 |= (long) 0xe00000;
	//		column1 = (char) (column24 & (long) 0xff);
	//		column2 = (char) ((column24 >> 8) & (long) 0xff);
	//		column3 = (char) ((column24 >> 16) & (long) 0xff);
	//		(void) fputc(column3, gpoutfile);
	//		(void) fputc(column2, gpoutfile);
	//		(void) fputc(column1, gpoutfile);
	//		(void) fputc(column3, gpoutfile);
	//		(void) fputc(column2, gpoutfile);
	//		(void) fputc(column1, gpoutfile);
	//		(void) fputc(column3, gpoutfile);
	//		(void) fputc(column2, gpoutfile);
	//		(void) fputc(column1, gpoutfile);
	//	    }
	//	}
	//    }
	//    fputs("\r\033l", gpoutfile);
	//    (void) fputc('\0', gpoutfile);	// set left margin to 0 
	//    if (b_planes > 1) {
	//	fprintf(gpoutfile, "\033r");
	//	(void) fputc('\0', gpoutfile);	// set color to black 
	//    }
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	///#ifdef VMS
	//    fflush_binary();
	///#endif
	//}
	//
	// /* output file must be binary mode for nec_dump */
	//static void
	//nec_draft_dump()
	//{
	//    unsigned int x;
	//    unsigned int plane, offset;
	//    int j;
	//    fputs("\033P\033l\005\r", gpoutfile);	// 10cpi, left margin 5 char 
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	//	fputs("\033J\030", gpoutfile);	// 24/180" line feed 
	//	for (plane = 0; plane < b_planes; plane++) {
	//	    offset = plane * b_psize;
	//	    if (b_planes > 1) {
	// /* select colour for plane */
	//		fputs("\033r", gpoutfile);
	//		(void) fputc((char) necpcolor[plane], gpoutfile);
	//	    }
	// /* select plotter graphics mode (square pixels) */
	//	    fputs("\r\033*", gpoutfile);
	//	    (void) fputc('\0', gpoutfile);
	//	    (void) fputc((char) (b_xsize % 256), gpoutfile);
	//	    (void) fputc((char) (b_xsize / 256), gpoutfile);
	//	    for (x = 0; x < b_xsize; x++) {
	//		(void) fputc((char) (*((*b_p)[j + offset] + x)), gpoutfile);
	//	    }
	//	}
	//    }
	//    fputs("\r\033l", gpoutfile);
	//    (void) fputc('\0', gpoutfile);	// set left margin to 0 
	//    if (b_planes > 1) {
	//	fputs("\033r", gpoutfile);
	//	(void) fputc('\0', gpoutfile);	// set color to black 
	//    }
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", gpoutfile);
	///#endif
	//}
	//
	///#endif // NEC 
	//
	///#ifdef STARC
	// /* The following Star color driver uses generic bit mapped graphics
	//    routines to build up a bit map in memory. */
	// /* Star Color changes made by William Wilson, wew@naucse.cse.nau.edu */
	// /* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
	// /* STARC_init changes gpoutfile to binary mode on PC's */
	//
	//static void STARC_dump __PROTO((void));
	//
	///#define STARCXLAST (STARCXMAX - 1)
	///#define STARCYLAST (STARCYMAX - 1)
	//
	//
	// /* plane 0=black, 1=cyan(blue), 2=magenta(red), 3=yellow */
	//static unsigned int STARCcolor[] = { 1, 8, 4, 2, 10, 12, 6, 14 };
	//static unsigned int STARCpcolor[] = { 0, 2, 1, 4 };
	//
	//TERM_PUBLIC void
	//STARC_init()
	//{
	//}
	//
	//TERM_PUBLIC void
	//STARC_graphics()
	//{
	//    b_charsize(FNT5X9);
	//    b_makebitmap((unsigned int) (STARCXMAX * xsize),
	//		 (unsigned int) (STARCYMAX * ysize), 4);
	//}
	//
	//
	//TERM_PUBLIC void
	//STARC_text()
	//{
	//    STARC_dump();
	//    b_freebitmap();
	//}
	//
	//TERM_PUBLIC void
	//STARC_linetype(int linetype)
	//{
	//    if (linetype >= 6)
	//	linetype %= 6;
	//    b_setvalue(STARCcolor[linetype + 2]);
	//}
	//
	//
	//
	// /* output file must be binary mode for STARC_dump */
	//static void
	//STARC_dump()
	//{
	//    unsigned int x;
	//    unsigned int plane, offset;
	//    int j;
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	//	fputs("\033J\030", gpoutfile);	// line feed 8/72" = 8 dots 
	//	for (plane = 0; plane < b_planes; plane++) {
	//	    offset = plane * b_psize;
	//	    if (b_planes > 1) {
	// /* select colour for plane */
	//		fputs("\033r", gpoutfile);
	//		(void) fputc((char) STARCpcolor[plane], gpoutfile);
	//	    }
	// /* select plotter graphics mode (square pixels) */
	//	    fputs("\r\033*\005", gpoutfile);
	//	    (void) fputc((char) (b_xsize % 256), gpoutfile);
	//	    (void) fputc((char) (b_xsize / 256), gpoutfile);
	//	    for (x = 0; x < b_xsize; x++) {
	//		(void) fputc((char) (*((*b_p)[j + offset] + x)), gpoutfile);
	//	    }
	//	}
	//    }
	//    if (b_planes > 1) {
	//	fputs("\033r", gpoutfile);
	//	(void) fputc('\0', gpoutfile);	// set color to black 
	//    }
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // STARC 
	//
	//
	///#ifdef EPS180
	//
	//static void eps180_dump __PROTO((void));
	//
	///#define EPS180XLAST (EPS180XMAX - 1)
	///#define EPS180YLAST (EPS180YMAX - 1)
	//
	//TERM_PUBLIC void
	//EPS180_graphics()
	//{
	//    b_charsize(FNT13X25);
	//    b_makebitmap((unsigned int) (EPS180XMAX * xsize),
	//		 (unsigned int) (EPS180YMAX * ysize), 1);
	//}
	//
	//
	//TERM_PUBLIC void
	//EPS180_text()
	//{
	//    eps180_dump();
	//    b_freebitmap();
	//}
	//
	//
	//
	// /* output file must be binary mode for eps180_dump */
	//static void
	//eps180_dump()
	//{
	//    register unsigned int x;
	//    int j;
	//
	// /* reset, set line spacing to 24/180", and move left margin */
	//    fputs("\033@\033+\060\033l\005", gpoutfile);
	//    for (j = (b_ysize / 8) - 1; j >= 0;) {
	// /* select printer graphics mode '39' */
	//	fputs("\r\n\033*'", gpoutfile);
	//	(void) fputc((char) (b_xsize % 256), gpoutfile);
	//	(void) fputc((char) (b_xsize / 256), gpoutfile);
	//	for (x = 0; x < b_xsize; x++) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	    (void) fputc((char) (*((*b_p)[j - 1] + x)), gpoutfile);
	//	    (void) fputc((char) (*((*b_p)[j - 2] + x)), gpoutfile);
	//	}
	//	j -= 3;
	//    }
	//    fputs("\r\n\033@\r\n", gpoutfile);	// reset printer 
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // EPS180 
	//
	///#ifdef EPS60
	//
	//static void eps60_dump __PROTO((void));
	//
	///#define EPS60XLAST (EPS60XMAX - 1)
	///#define EPS60YLAST (EPS60YMAX - 1)
	//
	//TERM_PUBLIC void
	//EPS60_graphics()
	//{
	//    b_charsize(FNT5X9);
	//    b_makebitmap((unsigned int) (EPS60XMAX * xsize),
	//		 (unsigned int) (EPS60YMAX * ysize), 1);
	//}
	//
	//
	//TERM_PUBLIC void
	//EPS60_text()
	//{
	//    eps60_dump();
	//    b_freebitmap();
	//}
	//
	//
	//
	// /* output file must be binary mode for eps60_dump */
	//static void
	//eps60_dump()
	//{
	//    register unsigned int x;
	//    int j;
	//    fprintf(gpoutfile, "\033%c\030", '3');	// set line spacing 24/216" = 8 dots 
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	// /* select printer graphics mode 'K' */
	//	fputs("\r\n\033K", gpoutfile);
	//	(void) fputc((char) (b_xsize % 256), gpoutfile);
	//	(void) fputc((char) (b_xsize / 256), gpoutfile);
	//	for (x = 0; x < b_xsize; x++) {
	//	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//	}
	//    }
	//    fprintf(gpoutfile, "\033%c\044\r\n", '3');	// set line spacing 36/216" = 1/6" 
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // EPS60 
	//
	///#ifdef TANDY60
	//
	// /* The only difference between TANDY60 and EPS60 is the inclusion
	//    of codes to swap the Tandy printer into IBM mode and back
	//    into Tandy mode.  For a Tandy already in IBM mode, use EPS60. */
	//
	//
	//TERM_PUBLIC void
	//TANDY60_text()
	//{
	///#ifdef PC
	//    fputs("Inserting Tandy/IBM mode conversion codes\n", stderr);
	///#endif
	// /* Switch to IBM mode, and leave 3 inches above the plot so as
	//    to get rough vertical centring on the page.  Perform the
	//    centring by setting 1" line feeds and issuing 3 of them. */
	//    fprintf(gpoutfile, "\033!\033%c%c\n\n\n", '3', 216);
	//    eps60_dump();
	//    b_freebitmap();
	// /* A form feed must be sent before switching back to Tandy mode,
	//    or else the form setting will be messed up. */
	//    fputs("\f\033!", gpoutfile);
	//}
	//
	//
	///#endif // TANDY60 
	//
	///#ifdef OKIDATA
	//
	//static void okidata_dump __PROTO((void));
	//
	//TERM_PUBLIC void
	//OKIDATA_text()
	//{
	//    okidata_dump();
	//    b_freebitmap();
	//}
	//
	//static int OKIDATAbitrev_tbl[] =
	//{
	//    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	//    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	//    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	//    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	//    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	//    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	//    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	//    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	//    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	//    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	//    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	//    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	//    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	//    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	//    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	//    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	//    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	//    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	//    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	//    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	//    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	//    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	//    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	//    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	//    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	//    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	//    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	//    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	//    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	//    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	//    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	//    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
	//};
	//
	// /* output file must be binary mode for okidata_dump */
	//static void
	//okidata_dump()
	//{
	//    register unsigned int x;
	//    int j;
	//    char cur_char;
	//    int prev_char;
	//
	//    prev_char = 0;
	// /* set line spacing 16/144" = 8 dots, turn on single density
	//  * graphics mode: */
	//    fprintf(gpoutfile, "\033%c%c\020\033*eP:\003", '%', '9');
	//    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	//	fputs("\003\016", gpoutfile);
	// /*		(void) fputc((char)(b_xsize%256),gpoutfile); */
	// /*		(void) fputc((char)(b_xsize/256),gpoutfile); */
	//	for (x = 0; x < b_xsize; x++) {
	//	    if ((cur_char = (char)
	//		 (OKIDATAbitrev_tbl[(int) (*((*b_p)[j] + x))])) == '\003') {
	//		fputs("\003\003", gpoutfile);
	//	    } else {
	//		(void) fputc((char) cur_char, gpoutfile);
	//	    }
	//	}
	//    }
	//    fprintf(gpoutfile, "\003\002\033%c%c\030\r\n", '%', '9');	// Turned off graphics mode: set line spacing 24/144" = 1/6" 
	///#ifdef PC
	//    fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // OKIDATA 
	//
	///#ifdef DPU414
	//
	//static void DPU414_dump __PROTO((void));
	//
	//static int DPU414_font = 2; // medium font 
	//static int DPU414_quality = 1; // normal 
	//
	//enum DPU414_id {
	//	DPU414_SMALL, DPU414_MEDIUM, DPU414_LARGE,
	//	DPU414_NORMAL, DPU414_DRAFT,
	//	DPU414_OTHER
	//};
	//
	//static struct gen_table DPU414_opts[] =
	//{
	//	{ "s$mall", DPU414_SMALL },
	//	{ "m$edium", DPU414_MEDIUM },
	//	{ "l$arge", DPU414_LARGE },
	//	{ "n$ormal", DPU414_NORMAL },
	//	{ "d$raft", DPU414_DRAFT },
	//	{ NULL, DPU414_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//DPU414_options()
	//{
	//	DPU414_font = 2;
	//	DPU414_quality = 1;
	//	term_options[0] = NUL;
	//
	//	while (!END_OF_COMMAND) {
	//		switch(lookup_table(&DPU414_opts[0],c_token)) {
	//			case DPU414_SMALL:
	//				DPU414_font = 1;
	//				c_token++;
	//				break;
	//			case DPU414_MEDIUM:
	//				DPU414_font = 2;
	//				c_token++;
	//				break;
	//			case DPU414_LARGE:
	//				DPU414_font = 3;
	//				c_token++;
	//				break;
	//			case DPU414_NORMAL:
	//				DPU414_quality = 1;
	//				c_token++;
	//				break;
	//			case DPU414_DRAFT:
	//				DPU414_quality = 2;
	//				c_token++;
	//				break;
	//			case DPU414_OTHER:
	//			default:
	// /* reset to default, since term is already set */
	//				DPU414_font = 2;
	//				DPU414_quality = 1;
	//				int_error(c_token, "expecting: {small, medium, large} {normal, draft}");
	//				break;
	//		}
	//	}
	//
	//	term->v_tic = (term->xmax < term->ymax) ? term->xmax/100 : term->ymax/100;
	//	if (term->v_tic < 1)
	//		term->v_tic = 1;
	//	term->h_tic = term->v_tic;
	//
	// /* setup options string */
	//	switch (DPU414_font) {
	//		case 1:
	//			strcat(term_options, "small");
	//			break;
	//		case 2:
	//			strcat(term_options, "medium");
	//			break;
	//		case 3:
	//			strcat(term_options, "large");
	//			break;
	//	}
	//	switch (DPU414_quality) {
	//		case 1:
	//			strcat(term_options, " normal");
	//			term->xmax = DPU414XMAX;
	//			term->ymax = DPU414YMAX;
	//			break;
	//		case 2:
	//			strcat(term_options, " draft");
	//			term->xmax = DPU414XMAX / 2;
	//			term->ymax = DPU414YMAX / 2;
	//			break;
	//	}
	//}
	//
	//TERM_PUBLIC void
	//DPU414_init()
	//{
	//	DPU414_setfont();
	//}
	//
	//TERM_PUBLIC void
	//DPU414_setfont()
	//{
	//	switch (DPU414_font) {
	//	case 1:
	//		b_charsize(FNT5X9);
	//		term->v_char = FNT5X9_VCHAR;
	//		term->h_char = FNT5X9_HCHAR;
	//		break;
	//	case 2:
	//		b_charsize(FNT9X17);
	//		term->v_char = FNT9X17_VCHAR;
	//		term->h_char = FNT9X17_HCHAR;
	//		break;
	//	case 3:
	//		b_charsize(FNT13X25);
	//		term->v_char = FNT13X25_VCHAR;
	//		term->h_char = FNT13X25_HCHAR;
	//		break;
	//	}
	//}
	//
	//TERM_PUBLIC void
	//DPU414_graphics()
	//{
	//	switch (DPU414_quality) {
	//	case 1:
	//		b_makebitmap((unsigned int) (DPU414XMAX * xsize),
	//		             (unsigned int) (DPU414YMAX * ysize), 1);
	//		break;
	//	case 2:
	//		term->xmax = DPU414XMAX / 2;
	//		term->ymax = DPU414YMAX / 2;
	//		b_makebitmap((unsigned int) (DPU414XMAX / 2 * xsize),
	//		             (unsigned int) (DPU414YMAX / 2 * ysize), 1);
	//		break;
	//	}
	//}
	//
	//TERM_PUBLIC void
	//DPU414_text()
	//{
	//	DPU414_dump();
	//	b_freebitmap();
	//}
	//
	//static void
	//DPU414_dump()
	//{
	//	register unsigned int x;
	//	int j;
	//
	//	fputs("\r", gpoutfile);	// carriage return 
	//	fprintf(gpoutfile, "\033%c", 'U');	// unidirectional printing 
	//	(void) fputc((char) 0, gpoutfile);
	//
	//	switch (DPU414_quality) {
	//	case 1:
	//		for (j = (b_ysize / 8) - 1; j >= 0; j-=2) {
	// /* select 120-dpi, emulated 16-pin printer graphics mode */
	// /* in reality it's 640/(89.6mm/25.4mm) = 181 dpi = appr. 180 dpi */
	//			fputs("\033^\001", gpoutfile);
	//			(void) fputc((char) (b_xsize % 256), gpoutfile);
	//			(void) fputc((char) (b_xsize / 256), gpoutfile);
	//			for (x = 0; x < b_xsize; x++) {
	//				(void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//				(void) fputc((char) (*((*b_p)[j-1] + x)), gpoutfile);
	//			}
	//			fprintf(gpoutfile, "\033%c\x10\r", 'J');	// advance 16 halfdots, carriage return 
	//		}
	//		break;
	//	case 2:
	//		for (j = (b_ysize / 8) - 1; j >= 0; j--) {
	// /* select 60-dpi, 8-pin printer graphics mode */
	// /* in reality it's 320/(89.6mm/25.4mm) = 91 dpi = appr. 90 dpi */
	//			fputs("\033K", gpoutfile);
	//			(void) fputc((char) (b_xsize % 256), gpoutfile);
	//			(void) fputc((char) (b_xsize / 256), gpoutfile);
	//			for (x = 0; x < b_xsize; x++) {
	//				(void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
	//			}
	//			fprintf(gpoutfile, "\033%c\x10\r", 'J');	// advance 16 halfdots, carriage return 
	//		}
	//		break;
	//	}
	//	fputs("\r\n\033@\r\n", gpoutfile);	// reset printer 
	///#ifdef PC
	//	fputs("Print using: COPY /B\n", stderr);
	///#endif
	//}
	//
	///#endif // DPU414 
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	///#ifdef EPS180
	//TERM_TABLE_START(epson180_driver)
	//    "epson_180dpi", "Epson LQ-style 180-dot per inch (24 pin) printers",
	//    EPS180XMAX, EPS180YMAX, EPSON180VCHAR, EPSON180HCHAR,
	//    EPSON180VTIC, EPSON180HTIC, options_null, EPSON_init, EPSON_reset,
	//    EPS180_text, null_scale, EPS180_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(epson180_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM epson180_driver
	///#endif // EPS180 
	//
	///#ifdef EPS60
	//TERM_TABLE_START(epson60_driver)
	//    "epson_60dpi", "Epson-style 60-dot per inch printers",
	//    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
	//    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
	//    EPS60_text, null_scale, EPS60_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(epson60_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM epson60_driver
	///#endif // EPS60 
	//
	///#ifdef EPSONP
	//TERM_TABLE_START(epsonlx_driver)
	//    "epson_lx800", "Epson LX-800, Star NL-10, NX-1000, PROPRINTER ...",
	//    EPSONXMAX, EPSONYMAX, EPSONVCHAR, EPSONHCHAR,
	//    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
	//    EPSON_text, null_scale, EPSON_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(epsonlx_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM epsonlx_driver
	///#endif // EPSONP 
	//
	///#ifdef NEC
	//    TERM_TABLE_START(nec_driver)
	//    "nec_cp6", "NEC printer CP6, Epson LQ-800 [monocrome color draft]",
	//    NECXMAX, NECYMAX, NECVCHAR, NECHCHAR,
	//    NECVTIC, NECHTIC, NEC_options, NEC_init, EPSON_reset,
	//    NEC_text, null_scale, NEC_graphics, b_move, b_vector,
	//    NEC_linetype, b_put_text, b_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(nec_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM nec_driver
	///#endif // NEC 
	//
	///#ifdef OKIDATA
	//TERM_TABLE_START(okidata_driver)
	//    "okidata", "OKIDATA 320/321 Standard",
	//    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
	//    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
	//    OKIDATA_text, null_scale, EPS60_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(okidata_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM okidata_driver
	///#endif // OKIDATA 
	//
	///#ifdef STARC
	//TERM_TABLE_START(starc_driver)
	//    "starc", "Star Color Printer",
	//    STARCXMAX, STARCYMAX, STARCVCHAR, STARCHCHAR,
	//    STARCVTIC, STARCHTIC, options_null, STARC_init, EPSON_reset,
	//    STARC_text, null_scale, STARC_graphics, b_move, b_vector,
	//    STARC_linetype, b_put_text, b_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(starc_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM starc_driver
	///#endif // STARC 
	//
	///#ifdef TANDY60
	//TERM_TABLE_START(tandy60_driver)
	//    "tandy_60dpi", "Tandy DMP-130 series 60-dot per inch graphics",
	//    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
	//    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
	//    TANDY60_text, null_scale, EPS60_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(tandy60_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM tandy60_driver
	///#endif // TANDY60 
	//
	///#ifdef DPU414
	//TERM_TABLE_START(dpu414_driver)
	//    "dpu414", "Seiko DPU-414 thermal printer [small medium large]",
	//    DPU414XMAX, DPU414YMAX, DPU414VCHAR, DPU414HCHAR,
	//    DPU414VTIC, DPU414HTIC, DPU414_options, DPU414_init, EPSON_reset,
	//    DPU414_text, null_scale, DPU414_graphics, b_move, b_vector,
	//    b_setlinetype, b_put_text, b_text_angle,
	//    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
	//    0, 0, b_boxfill
	//TERM_TABLE_END(dpu414_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM dpu414_driver
	///#endif // DPU414 
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(epson_180dpi)
	//"1 epson_180dpi",
	//"?commands set terminal epson_180dpi",
	//"?set terminal epson_180dpi",
	//"?set term epson_180dpi",
	//"?terminal epson_180dpi",
	//"?term epson_180dpi",
	//"?epson_180dpi",
	//"?commands set terminal epson_60dpi",
	//"?set terminal epson_60dpi",
	//"?set term epson_60dpi",
	//"?terminal epson_60dpi",
	//"?term epson_60dpi",
	//"?epson_60dpi",
	//"?commands set terminal epson_lx800",
	//"?set terminal epson_lx800",
	//"?set term epson_lx800",
	//"?terminal epson_lx800",
	//"?term epson_lx800",
	//"?epson_lx800",
	//"?commands set terminal nec_cp6",
	//"?set terminal nec_cp6",
	//"?set term nec_cp6",
	//"?terminal nec_cp6",
	//"?term nec_cp6",
	//"?nec_cp6",
	//"?commands set terminal okidata",
	//"?set terminal okidata",
	//"?set term okidata",
	//"?terminal okidata",
	//"?term okidata",
	//"?okidata",
	//"?commands set terminal starc",
	//"?set terminal starc",
	//"?set term starc",
	//"?terminal starc",
	//"?term starc",
	//"?starc",
	//"?commands set terminal tandy_60dpi",
	//"?set terminal tandy_60dpi",
	//"?set term tandy_60dpi",
	//"?terminal tandy_60dpi",
	//"?term tandy_60dpi",
	//"?tandy_60dpi",
	//"?commands set terminal dpu414",
	//"?set terminal dpu414",
	//"?set term dpu414",
	//"?terminal dpu414",
	//"?term dpu414",
	//"?dpu414",
	//" This driver supports a family of Epson printers and derivatives.",
	//"",
	//" `epson_180dpi` and `epson_60dpi` are drivers for Epson LQ-style 24-pin",
	//" printers with resolutions of 180 and 60 dots per inch, respectively.",
	//"",
	//" `epson_lx800` is a generic 9-pin driver appropriate for printers like the",
	//" Epson LX-800, the Star NL-10 and NX-1000, the PROPRINTER, and so forth.",
	//"",
	//" `nec_cp6` is generic 24-pin driver that can be used for printers like the",
	//" NEC CP6 and the Epson LQ-800.",
	//"",
	//" The `okidata` driver supports the 9-pin OKIDATA 320/321 Standard printers.",
	//"",
	//" The `starc` driver is for the Star Color Printer.",
	//"",
	//" The `tandy_60dpi` driver is for the Tandy DMP-130 series of 9-pin, 60-dpi",
	//" printers.",
	//"",
	//" The `dpu414` driver is for the Seiko DPU-414 thermal printer.",
	//"",
	//" `nec_cp6` has the options:",
	//"",
	//" Syntax:",
	//"       set terminal nec_cp6 {monochrome | colour | draft}",
	//"",
	//" which defaults to monochrome.",
	//"",
	//" `dpu414` has the options:",
	//"",
	//" Syntax:",
	//"       set terminal dpu414 {small | medium | large} {normal | draft}",
	//"",
	//" which defaults to medium (=font size) and normal.",
	//" Preferred combinations are `medium normal` and `small draft`.",
	///#ifdef MSDOS
	//"",
	//" With each of these drivers, a binary copy is required on a PC to print.",
	//" Do not use `print`---use instead `copy file /b lpt1:`.",
	///#endif
	//""
	//END_HELP(epson_180dpi)
	///#endif // TERM_HELP 



	/* TeX related terminals */
	///#define EMTEX
	///#define EEPIC

	/* latex and emtex */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: latex.trm,v 1.34.2.1 2009/10/10 06:07:05 sfeam Exp $
	 *
	 */

	/* GNUPLOT - latex.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   LaTeX pictures (latex).
	 *   LaTeX pictures with emTeX specials (emtex).
	 *
	 * AUTHORS
	 *   David Kotz, Russell Lang
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/* modified to optimize use of \rule for long lines */
	/* TLDC: modified to have nice line types */

	/* the following LATEX driver has been modified by
	   Russell Lang, eln272v@monu1.cc.monash.oz from the
	   GnuTeX 1.3 driver by David Kotz, David.Kotz@Dartmouth.edu.
	   Since then it has been further extended by David Kotz.
	   EmTeX driver by Russell Lang. */

	/*  9 Dec 1992  LATEX_put_text rewritten to handle \\ newlines
	                Daniel S. Lewart (d-lewart@uiuc.edu) */

	/* Since it took me a little while to figure out what is happening,
	 * I may as well write it down.
	 *  There are three length scales of interest: inches, points
	 * and dots. inches are obvious. points are the usual typesetting
	 * thing (ie approx 72 points per inch). This driver works in
	 * units of dots, which corresponds to pixels on a 300 DPI printer.
	 * We do a \setlength{unitlength}{...pt} to make teX work in
	 * terms of dots.  The ... is called LATEX_UNIT in here.
	 *   The reason I had to get involved in all of this is because
	 * font size (in pts) was not being scaled up by DOTS_PER_POINT
	 * - drd, Sept 1996
	 */

	/* E A Merritt Feb 2007 - change sequence of point types to match
	 * PostScript and other terminals. Uses symbols from amssymb package.
	 */

	/* T.Sefzick Oct 2009 - rotate text when option 'rotated' is given.
	 * needs graphics or graphicx package.
	 */

	///#ifdef TERM_REGISTER
	//register_term(latex)
	///#ifdef EMTEX
	//register_term(emtex)
	///#endif
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void LATEX_options __PROTO((void));
	//TERM_PUBLIC void LATEX_init __PROTO((void));
	//TERM_PUBLIC void LATEX_graphics __PROTO((void));
	//TERM_PUBLIC void LATEX_text __PROTO((void));
	//TERM_PUBLIC void LATEX_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void LATEX_linetype __PROTO((int linetype));
	//TERM_PUBLIC void LATEX_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void LATEX_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void LATEX_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void LATEX_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
	//TERM_PUBLIC int LATEX_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int LATEX_text_angle __PROTO((int ang));
	//TERM_PUBLIC void LATEX_reset __PROTO((void));
	//TERM_PUBLIC void LATEX_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, 
	//					unsigned int width, unsigned int height));
	//
	///#ifdef EMTEX
	//TERM_PUBLIC void EMTEX_init __PROTO((void));
	//TERM_PUBLIC void EMTEX_reset __PROTO((void));
	//TERM_PUBLIC void EMTEX_text __PROTO((void));
	///#endif
	//
	///#ifdef EEPIC
	//TERM_PUBLIC void EEPIC_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void EEPIC_vector __PROTO((unsigned int ux, unsigned int uy));
	///#endif
	//
	///#define TINY_STEP 0.5		// tiny steps for high quality lines 
	//
	///#define LATEX_PTS_PER_INCH (72.27)
	///#define DOTS_PER_INCH (300)	// resolution of printer we expect to use 
	///#define LATEX_UNIT (LATEX_PTS_PER_INCH/DOTS_PER_INCH)	// dot size in pt 
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define LATEX_XMAX (5*DOTS_PER_INCH)	// (LATEX_PTS_PER_INCH/LATEX_UNIT*5.0) 
	///#define LATEX_YMAX (3*DOTS_PER_INCH)	// (LATEX_PTS_PER_INCH/LATEX_UNIT*3.0) 
	//
	///#define LATEX_HTIC (5*DOTS_PER_INCH/72)		// (5 pts) 
	///#define LATEX_VTIC (5*DOTS_PER_INCH/72)		// (5 pts) 
	///#define LATEX_HCHAR (DOTS_PER_INCH*53/10/72)	// (5.3 pts) 
	///#define LATEX_VCHAR (DOTS_PER_INCH*11/72)	// (11 pts) 
	///#endif


	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static int LATEX_posx;
	//static int LATEX_posy;
	//static int LATEX_fontsize = 10;
	//static char LATEX_font[MAX_ID_LEN+1] = "doc";
	//static enum JUSTIFY latex_justify = LEFT;
	//static int latex_angle = 0;
	//static TBOOLEAN latex_rotate = FALSE;
	//
	//static TBOOLEAN latex_explicit_size = FALSE;
	//static size_units latex_explicit_units = INCHES;
	//
	// /* Default line-drawing character */
	// /* the definition of plotpoint varies with linetype */
	///#define LATEX_DOT "\\usebox{\\plotpoint}"
	///#define LATEX_TINY_DOT "\\rule{1pt}{1pt}"	// for dots plot style 
	//
	// /* POINTS */
	///#define LATEX_POINT_TYPES 15	// we supply more point types 
	//
	//static const char GPFAR *GPFAR LATEX_points[] = {
	//    "\\makebox(0,0){$+$}",
	//    "\\makebox(0,0){$\\times$}",
	//    "\\makebox(0,0){$\\ast$}",
	//    "\\raisebox{-.8pt}{\\makebox(0,0){$\\Box$}}",
	//    "\\makebox(0,0){$\\blacksquare$}",
	//    "\\makebox(0,0){$\\circ$}",
	//    "\\makebox(0,0){$\\bullet$}",
	//    "\\makebox(0,0){$\\triangle$}",
	//    "\\makebox(0,0){$\\blacktriangle$}",
	//    "\\makebox(0,0){$\\triangledown$}",
	//    "\\makebox(0,0){$\\blacktriangledown$}",
	//    "\\makebox(0,0){$\\lozenge$}",
	//    "\\makebox(0,0){$\\blacklozenge$}",
	//    "\\makebox(0,0){$\\heartsuit$}",
	//    "\\makebox(0,0){$\\spadesuit$}",
	//};
	//
	// /* LINES */
	//static float LATEX_size = 0;	// current thick of line in points 
	//static float LATEX_dotspace = 0;	// current dotspace of line in points 
	///#define LATEX_LINE_TYPES 6	// number of line types below 
	///#define LATEX_THIN_LINE 0	// the thinnest solid line type 
	//static struct {
	//    float size;			// size of dot, or thick of line in points 
	//    float dotspace;		// inter-dot space in points; 0 for lines 
	//} GPFAR LATEX_lines[] =
	//
	//{
	//    {0.4, 0.0},			// thin solid line 
	//    {0.4, 5.0},			// thin dotted line 
	//    {0.8, 0.0},			// thick solid line 
	//    {1.0, 5.0},			// thick dotted line 
	//    {1.2, 0.0},			// Thick solid line 
	//    {1.0, 10.0},		// thick widely dotted line 
	//};
	//
	// /* for drawing dotted and solid lines */
	//static void LATEX_dot_line __PROTO((int x1, int x2, int y1, int y2));
	//static void LATEX_solid_line __PROTO((int x1, int x2, int y1, int y2));
	//static void LATEX_rule __PROTO((int code, double x, double y, double width, double height));
	//static void LATEX_flushdot __PROTO((void));
	///#define LATEX_flushrule() LATEX_rule(2, 0.,0.,0.,0.)	// flush old rule 
	//static TBOOLEAN LATEX_moved = TRUE;	// pen is up after move 
	//static float LATEX_dotsize;	// size of LATEX_DOT in units 
	//static TBOOLEAN LATEX_needsdot = FALSE;		// does dotted line need termination? 
	//
	///#ifdef EMTEX
	//static TBOOLEAN emtex = FALSE;		// not currently using emtex 
	//static void EMTEX_solid_line __PROTO((int x1, int x2, int y1, int y2));
	///#endif
	//
	// /* ARROWS */
	// /* the set of non-vertical/non-horizontal LaTeX vector slopes */
	// /* except negatives - they are handled specially */
	//static struct vslope {
	//    int dx, dy;
	//} GPFAR LATEX_slopes[] =
	//
	//{
	//    {1, 1},
	//    {1, 2},
	//    {1, 3},
	//    {1, 4},
	//    {2, 1},
	//    {2, 3},
	//    {3, 1},
	//    {3, 2},
	//    {3, 4},
	//    {4, 1},
	//    {4, 3},
	//    {0, 0}			// terminator 
	//};
	//
	// /* figure out the best arrow */
	//static void best_latex_arrow __PROTO((int, int, int, int, int, int));
	//
	//enum LATEX_id { LATEX_COURIER, LATEX_ROMAN, LATEX_DEFAULT, LATEX_SIZE, LATEX_ROTATE, LATEX_NOROTATE, LATEX_OTHER };
	//
	//static struct gen_table LATEX_opts[] =
	//{
	//    { "c$ourier", LATEX_COURIER },
	//    { "r$oman", LATEX_ROMAN },
	//    { "d$efault", LATEX_DEFAULT },
	//    { "si$ze", LATEX_SIZE },
	//    { "rot$ate", LATEX_ROTATE },
	//    { "no$rotate", LATEX_NOROTATE },
	//    { NULL, LATEX_OTHER }
	//};
	//
	//
	//TERM_PUBLIC void
	//LATEX_options()
	//{
	//    latex_explicit_size = FALSE;
	//
	//    while (!END_OF_COMMAND) {
	//	switch(lookup_table(&LATEX_opts[0],c_token)) {
	//	case LATEX_COURIER:
	//	    strcpy(LATEX_font, "cmtt");
	//	    c_token++;
	//	    break;
	//	case LATEX_ROMAN:
	//	    strcpy(LATEX_font, "cmr");
	//	    c_token++;
	//	    break;
	//	case LATEX_DEFAULT:
	//	    strcpy(LATEX_font, "doc");
	//	    c_token++;
	//	    break;
	//	case LATEX_SIZE:
	//	    {
	//	    float xmax_t = 5., ymax_t = 3.;
	//	    c_token++;
	//	    latex_explicit_size = TRUE;
	//	    latex_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
	//	    term->xmax = xmax_t * DOTS_PER_INCH/72;
	//	    term->ymax = ymax_t * DOTS_PER_INCH/72;
	//	    break;
	//	    }
	//	case LATEX_ROTATE:
	//	    latex_rotate = TRUE;
	//	    c_token++;
	//	    break;
	//	case LATEX_NOROTATE:
	//	    latex_rotate = FALSE;
	//	    c_token++;
	//	    break;
	//	case LATEX_OTHER:
	//	default:
	// /* if isannumber? */
	//	    LATEX_fontsize = int_expression();
	//	}
	//    }
	//
	// /* tell gnuplot core about char. sizes. Horizontal spacing
	//  * is about half the text pointsize
	//  */
	//    term->v_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 72);
	//    term->h_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 144);
	//
	//    if (strcmp(LATEX_font, "doc")==0)
	//	strncpy(term_options, "(document specific font)",MAX_LINE_LEN);
	//    else
	//	sprintf(term_options, "%s %d",
	//		LATEX_font[2] == 't' ? "courier" : "roman", LATEX_fontsize);
	//
	//    if (latex_explicit_size) {
	//	if (latex_explicit_units == CM)
	//	    sprintf(&(term_options[strlen(term_options)]), "size %.2fcm, %.2fcm ",
	//		2.54*(float)term->xmax/(DOTS_PER_INCH),
	//		2.54*(float)term->ymax/(DOTS_PER_INCH));
	//	else
	//	    sprintf(&(term_options[strlen(term_options)]), "size %.2fin, %.2fin ",
	//		(float)term->xmax/(DOTS_PER_INCH),
	//		(float)term->ymax/(DOTS_PER_INCH));
	//    }
	//
	//    if (latex_rotate) {
	//	sprintf(&(term_options[strlen(term_options)]), " rotate");
	//    } else {
	//	sprintf(&(term_options[strlen(term_options)]), " norotate");
	//    }
	//
	//}
	//
	//
	//TERM_PUBLIC void
	//LATEX_init()
	//{
	///#ifdef EMTEX
	//    emtex = FALSE;
	///#endif
	//    LATEX_posx = LATEX_posy = 0;
	//
	//    fprintf(gpoutfile, "
	//%% GNUPLOT: LaTeX picture\n
	//\\setlength{\\unitlength}{%fpt}\n
	//\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n",
	//	    LATEX_UNIT);
	//
	//    LATEX_linetype(LT_AXIS);
	//    LATEX_size = 0;
	//}
	//
	//TERM_PUBLIC void
	//LATEX_graphics()
	//{
	//    int xscale, yscale;
	//
	// /* set size of canvas */
	//    if (!latex_explicit_size) {
	//	term->xmax = LATEX_XMAX;
	//	term->ymax = LATEX_YMAX;
	//    }
	//
	// /* bounding box */
	//    xscale = xsize * term->xmax;
	//    yscale = ysize * term->ymax;
	//
	//    fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)\n", xscale, yscale);
	//    if (strcmp(LATEX_font, "doc") != 0) {
	//        fprintf(gpoutfile, "
	//\\font\\gnuplot=%s10 at %dpt\n
	//\\gnuplot\n",
	//		LATEX_font, LATEX_fontsize);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//LATEX_text()
	//{
	//    LATEX_flushrule();
	//    LATEX_flushdot();
	//    fputs("\\end{picture}\n", gpoutfile);
	//    LATEX_posx = LATEX_posy = 0;	// current position 
	//    LATEX_moved = TRUE;		// pen is up after move 
	//}
	//
	//TERM_PUBLIC void
	//LATEX_linetype(int linetype)
	//{
	//    float size;
	//
	//    if (linetype >= LATEX_LINE_TYPES)
	//	linetype %= LATEX_LINE_TYPES;
	//
	///#ifdef EMTEX
	//    if (!emtex)
	///#endif
	//	LATEX_flushrule();
	//    LATEX_flushdot();
	//
	// /* Find the new desired line thickness. */
	// /* negative linetypes (for axes) use a thin line */
	// /* only relevant for drawing axes/border in 3d */
	//    size = (linetype >= 0 ? LATEX_lines[linetype].size
	//	    : LATEX_lines[LATEX_THIN_LINE].size);
	//
	// /* If different from current size, redefine \plotpoint */
	//    if (size != LATEX_size) {
	//	fprintf(gpoutfile,
	//		"\\sbox{\\plotpoint}{\\rule[%.3fpt]{%.3fpt}{%.3fpt}}%%\n",
	//		-size / 2, size, size);
	///#ifdef EMTEX
	//	if (emtex)		// change line width 
	//	    fprintf(gpoutfile, "\\special{em:linewidth %.1fpt}%%\n", size);
	///#endif
	//    }
	//    LATEX_size = size;
	//    LATEX_dotsize = size / LATEX_UNIT;
	//    LATEX_dotspace = (linetype >= 0) ? LATEX_lines[linetype].dotspace : 0;
	//    LATEX_moved = TRUE;		// reset 
	//}
	//
	//TERM_PUBLIC void
	//LATEX_move(unsigned int x, unsigned int y)
	//{
	//    LATEX_flushdot();
	//
	//    LATEX_posx = x;
	//    LATEX_posy = y;
	//    LATEX_moved = TRUE;		// reset 
	//}
	//
	//
	//TERM_PUBLIC void
	//LATEX_point(unsigned int x, unsigned int y, int number)
	//{
	//    LATEX_move(x, y);
	//
	// /* Print the character defined by 'number'; number < 0 means
	//    to use a dot, otherwise one of the defined points. */
	//    fprintf(gpoutfile, "\\put(%d,%d){%s}\n", x, y,
	//	    (number < 0 ? LATEX_TINY_DOT
	//	     : LATEX_points[number % LATEX_POINT_TYPES]));
	//}
	//
	//
	//TERM_PUBLIC void
	//LATEX_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (LATEX_dotspace == 0.0) {
	// /* solid line */
	///#ifdef EMTEX
	//	if (emtex)
	//	    EMTEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	//	else
	///#endif
	//	    LATEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	//    } else
	// /* dotted line */
	//	LATEX_dot_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	//
	//    LATEX_posx = ux;
	//    LATEX_posy = uy;
	//}
	//
	//static void
	//LATEX_solid_line(int x1, int x2, int y1, int y2)
	//{
	//    float slope;
	//    int inc;
	//    float dx, dy, x, y;
	//    float offset, length;
	//    int code;			// possibly combine with previous rule 
	//
	// /* we draw a solid line using the current line thickness (size) */
	// /* we do it with lots of \\rules */
	//
	//    if (x1 == x2 && y1 == y2) {	// zero-length line - just a dot 
	//	if (LATEX_moved) {
	//	    LATEX_flushrule();
	// /* plot a dot */
	//	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
	//	}
	//    } else {
	//	code = (LATEX_moved ? 0 : 1);	// no combine after move 
	//	LATEX_moved = FALSE;
	//	if (x1 == x2)		// vertical line - special case 
	//	    LATEX_rule(code, (double) x1, (double) y1,
	//		       LATEX_dotsize, (double) y2 - y1);
	//	else if (y1 == y2)	// horizontal line - special case 
	//	    LATEX_rule(code, (double) x1, (double) y1, (double) x2 - x1,
	//		       LATEX_dotsize);
	//	else {
	//	    dx = (float) x2 - x1;
	//	    dy = (float) y2 - y1;
	//	    slope = dy / dx;
	//	    if (ABS(slope) <= 1.0) {
	// /* longer than high */
	//		x = GPMIN(ABS(dx), (0.25 + 1.0 / ABS(slope)) * LATEX_dotsize);
	//		offset = sign(dy) * GPMIN(LATEX_dotsize, ABS(dy));
	//		dy = dy - offset;
	//		length = x * LATEX_UNIT;
	//		inc = (x == ABS(dx) ? 1 : GPMAX(1, ABS(dy) / TINY_STEP + 0.5));
	//		if (inc == 1) {
	//		    fprintf(gpoutfile, "\\put(%u,%.2f){\\rule{%.3fpt}{%.3fpt}}\n",
	//			    (x2 >= x1 ? x1 : x2), ((float) y1 + y2 - LATEX_dotsize) / 2,
	//			    length, LATEX_dotsize * LATEX_UNIT);
	//		} else {
	//		    dy = dy / inc;
	//		    dx = (dx - sign(dx) * x) / (inc - 1);
	//		    fprintf(gpoutfile,
	//			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
	//			    (dx >= 0.0 ? (float) x1 : x1 - x),
	//			    (float) y1 - (ABS(dy) - offset) / 2,
	//			    dx, dy, inc, length, ABS(dy) * LATEX_UNIT);
	//		}
	// /* done with one section, now smooth it */
	//		x = x / 2;
	//		dx = sign(dx) * x;
	//		dx = (float) x2 - x1 - dx;
	//		dy = (float) y2 - y1;
	//		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
	//			(dx >= 0.0 ? (float) x1 : x1 - x), (float) y1 - LATEX_dotsize / 2,
	//			dx, dy, x * LATEX_UNIT, LATEX_dotsize * LATEX_UNIT);
	//		LATEX_moved = TRUE;
	//	    } else {
	// /* higher than long */
	//		y = GPMIN(ABS(dy), (0.25 + ABS(slope)) * LATEX_dotsize);
	//		offset = sign(dx) * GPMIN(LATEX_dotsize, ABS(dx));
	//		dx = dx - offset;
	//		length = y * LATEX_UNIT;
	//		inc = (y == ABS(dy) ? 1 : GPMAX(1, ABS(dx) / TINY_STEP + 0.5));
	//		if (inc == 1) {
	//		    fprintf(gpoutfile, "\\put(%.2f,%u){\\rule{%.3fpt}{%.3fpt}}\n",
	//			    ((float) x1 + x2 - LATEX_dotsize) / 2, (y2 >= y1 ? y1 : y2),
	//			    LATEX_dotsize * LATEX_UNIT, length);
	//		} else {
	//		    dx = dx / inc;
	//		    dy = (dy - sign(dy) * y) / (inc - 1);
	//		    fprintf(gpoutfile,
	//			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
	//			    (float) x1 - (ABS(dx) - offset) / 2,
	//			    (dy >= 0 ? (float) y1 : y1 - y),
	//			    dx, dy, inc, ABS(dx) * LATEX_UNIT, length);
	//		}
	// /* done with one section, now smooth it */
	//		y = y / 2;
	//		dx = (float) x2 - x1;
	//		dy = sign(dy) * y;
	//		dy = (float) y2 - y1 - dy;
	//		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
	//			(float) x1 - LATEX_dotsize / 2, (dy >= 0.0 ? (float) y1 : y1 - y),
	//			dx, dy, LATEX_dotsize * LATEX_UNIT, y * LATEX_UNIT);
	//		LATEX_moved = TRUE;
	//	    }
	//	}
	//    }
	//}
	//
	// /* Draw a \rule. Width or height may be negative; we can correct.
	//  * The rule is never output immediately. The previous rule is output
	//  * as-is if code is 0, and the previous rule is
	//  * combined with the current rule (if possible) if code is 1.
	//  * The previous rule is output, and the new one ignored, if code is 2.
	//  */
	//static void
	//LATEX_rule(
	//    int code,			// how do we treat this rule? 
	//    double x, double y,
	//    double width,
	//    double height)
	//{
	//    static float lastx, lasty;
	//    static float lastw, lasth;
	//    static TBOOLEAN isvalid = FALSE;	// is 'last' data valid? 
	//    TBOOLEAN combine = (code == 1);
	//    TBOOLEAN flush = (code == 2);
	//
	//    if (!flush)
	//	if (width == 0 || height == 0)
	//	    return;		// ignore this rule 
	//
	//    if (isvalid && combine) {
	// /* try to combine new rule with old rule */
	//	if ((int) lastx == (int) x && lastw == width) {		// vertical rule 
	//	    if (lasth * height >= 0) {	// same sign 
	//		lasth += height;
	//		return;
	//	    }
	//	} else if ((int) lasty == (int) y && lasth == height) {		// horiz rule 
	//	    if (lastw * width >= 0) {	// same sign 
	//		lastw += width;
	//		return;
	//	    }
	//	}
	// /* oh well, output last and remember the new one */
	//    }
	//    if (isvalid) {
	// /* output the rule */
	//	if (lastw < 0) {
	//	    lastx += lastw;
	//	    lastw = -lastw;
	//	}
	//	if (lasth < 0) {
	//	    lasty += lasth;
	//	    lasth = -lasth;
	//	}
	// /* if very small use canned dot */
	//	if (lastw < LATEX_dotsize || lasth < LATEX_dotsize)
	//	    fprintf(gpoutfile, "\\put(%.1f,%.1f){%s}\n",
	//		    lastx, lasty, LATEX_DOT);
	//	else
	//	    fprintf(gpoutfile, "\\put(%.1f,%.1f){\\rule[%.3fpt]{%.3fpt}{%.3fpt}}\n",
	//		    lastx, lasty, -LATEX_dotsize * LATEX_UNIT / 2,
	//		    lastw * LATEX_UNIT, lasth * LATEX_UNIT);
	//    }
	//    if (flush) {
	//	isvalid = FALSE;
	//    } else {
	//	lastx = x;
	//	lasty = y;
	//	lastw = width;
	//	lasth = height;
	//	isvalid = TRUE;
	//    }
	//}
	//
	//static void
	//LATEX_dot_line(int x1, int x2, int y1, int y2)
	//{
	//    static float LATEX_left;	// fraction of space left after last dot 
	//
	// /* we draw a dotted line using the current dot spacing */
	//
	//    if (LATEX_moved)
	//	LATEX_left = 1.0;	// reset after a move 
	//
	// /* zero-length line? */
	//    if (x1 == x2 && y1 == y2) {
	//	if (LATEX_moved)
	// /* plot a dot */
	//	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
	//    } else {
	//	float dotspace = LATEX_dotspace / LATEX_UNIT;
	//	float x, y;		// current position 
	//	float xinc, yinc;	// increments 
	//	float slope;		// slope of line 
	//	float lastx = -1;	// last x point plotted 
	//	float lasty = -1;	// last y point plotted 
	//	int numdots = 0;	// number of dots in this section 
	//
	// /* first, figure out increments for x and y */
	//	if (x2 == x1) {
	//	    xinc = 0.0;
	//	    yinc = (y2 - y1 > 0) ? dotspace : -dotspace;
	//	} else {
	//	    slope = ((float) y2 - y1) / ((float) x2 - x1);
	//	    xinc = dotspace / sqrt(1 + slope * slope) * sign(x2 - x1);
	//	    yinc = slope * xinc;
	//	}
	//
	// /* now draw the dotted line */
	// /* we take into account where we last placed a dot */
	//	for (x = x1 + xinc * (1 - LATEX_left), y = y1 + yinc * (1 - LATEX_left);
	//	     (x2 - x) * xinc >= 0 && (y2 - y) * yinc >= 0;	// same sign or zero 
	//	     lastx = x, x += xinc,
	//	     lasty = y, y += yinc)
	//	    numdots++;
	//	if (numdots == 1)
	//	    fprintf(gpoutfile, "\\put(%.2f,%.2f){%s}\n",
	//		    lastx, lasty, LATEX_DOT);
	//	else if (numdots > 0)
	//	    fprintf(gpoutfile, "\\multiput(%u,%u)(%.3f,%.3f){%u}{%s}\n",
	//		    x1, y1, xinc, yinc, numdots, LATEX_DOT);
	//
	// /* how much is left over, as a fraction of dotspace? */
	//	if (xinc != 0.0) {	// xinc must be nonzero 
	//	    if (lastx >= 0)
	//		LATEX_left = ABS(x2 - lastx) / ABS(xinc);
	//	    else
	//		LATEX_left += ABS(x2 - x1) / ABS(xinc);
	//	} else
	//	    if (lasty >= 0)
	//		LATEX_left = ABS(y2 - lasty) / ABS(yinc);
	//	    else
	//		LATEX_left += ABS(y2 - y1) / ABS(yinc);
	//    }
	//
	//    LATEX_needsdot = (LATEX_left > 0);
	//
	//    LATEX_moved = FALSE;
	//}
	//
	//static void
	//LATEX_flushdot()
	//{
	//    if (LATEX_needsdot)
	//	fprintf(gpoutfile, "\\put(%d,%d){%s}\n",
	//		LATEX_posx, LATEX_posy, LATEX_DOT);
	//    LATEX_needsdot = FALSE;
	//}
	//
	//TERM_PUBLIC void
	//LATEX_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    best_latex_arrow(sx, sy, ex, ey, 1, head);
	//
	//    LATEX_posx = ex;
	//    LATEX_posy = ey;
	//}
	//
	//static void
	//best_latex_arrow(
	//    int sx, int sy, int ex, int ey, // start and end points 
	//    int who,			// 1=LATEX, 2=EEPIC 
	//    int head)
	//{
	//    int dx = ex - sx;
	//    int dy = ey - sy;
	//    float m;			// slope of line 
	//    float arrowslope;		// slope of arrow 
	//    float minerror = 0;		// best-case error 
	//    struct vslope *slope;	// one of the slopes 
	//    struct vslope *bestslope;	// the slope with min error 
	//
	// /* We try to draw a real arrow (ie, \vector). If we can't get
	//    * a slope that is close, we draw a bent arrow.
	//  */
	//
	//    if (dx == 0) {
	// /* vertical arrow */
	//	fprintf(gpoutfile, "\\put(%d,%d){\\%s(0,%d){%d}}\n",
	//		sx, sy, head ? "vector" : "line",
	//		sign(ey - sy), ABS(ey - sy));
	//    } else if (dy == 0) {
	// /* horizontal arrow */
	//	fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,0){%d}}\n",
	//		sx, sy, head ? "vector" : "line",
	//		sign(ex - sx), ABS(ex - sx));
	//    } else {
	// /* Slanted arrow. We'll give it a try.
	//  * we try to find the closest-slope arrowhead.
	//  */
	//	bestslope = NULL;
	//	minerror = 0;		// to shut up turbo C 
	//	m = ABS((float) dy / dx);	// the slope we want 
	//	for (slope = LATEX_slopes; slope->dx != 0.0; slope++) {
	// /* find the slope of the arrow */
	//	    arrowslope = (float) slope->dy / slope->dx;
	//	    if (bestslope == NULL || ABS(m - arrowslope) < minerror) {
	//		minerror = ABS(m - arrowslope);
	//		bestslope = slope;
	//	    }
	//	}
	//
	// /* now we have the best slope arrow */
	// /* maybe it's exactly the right slope! */
	//	if (minerror == 0.0)	// unlikely but possible 
	//	    fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,%d){%d}}\n",
	//		    sx, sy, head ? "vector" : "line",
	//		    bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy),
	//		    ABS(ex - sx));
	//	else {
	// /* we draw the line the usual way, with thin lines */
	///#ifdef EMTEX
	//	    if (emtex) {
	//		LATEX_linetype(LATEX_THIN_LINE);
	//		EMTEX_solid_line(sx, ex, sy, ey);
	//	    } else
	///#endif
	//	    if (who == 1) {
	//		LATEX_linetype(LATEX_THIN_LINE);
	//		LATEX_solid_line(sx, ex, sy, ey);
	//	    }
	///#ifdef EEPIC
	//	    else {
	//		EEPIC_move(sx, sy);
	//		EEPIC_vector(ex, ey);
	//	    }
	///#endif // EEPIC 
	// /* and then draw an arrowhead (a short vector) there */
	//	    if (head)
	//		fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
	//			ex, ey,
	//			bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy));
	//	}
	//    }
	//}
	//
	//TERM_PUBLIC void
	//LATEX_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    static const char *justify[] = { "[l]", "", "[r]" };
	//    int flag, i;
	//
	// /* ignore empty strings */
	//    if (str[0] == NUL)
	//	return;
	//
	//    if (!latex_rotate)
	//    for (flag = FALSE, i = 0; str[i] && !flag;)
	//	flag = (str[i++] == '\\') && (str[i++] == '\\');
	//
	//    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
	//    if (latex_rotate && latex_angle)
	//    	fprintf (gpoutfile, "{\\rotatebox{%d}", latex_angle);
	//    if ((str[0] == '{') || (str[0] == '[')) {
	//	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
	//    } else if (flag)
	//	fprintf(gpoutfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
	//		justify[latex_justify], str);
	//    else
	//	fprintf(gpoutfile, "{\\makebox(0,0)%s{%s}}\n",
	//		justify[latex_justify], str);
	//    if (latex_rotate && latex_angle)
	//    	fprintf (gpoutfile, "}");
	//}
	//
	//TERM_PUBLIC int
	//LATEX_justify_text(enum JUSTIFY mode)
	//{
	//    latex_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//LATEX_text_angle(int ang)
	//{
	// /* we can't really write text vertically, but this will
	//    put the ylabel centred at the left of the plot, and
	//    then we'll make a \shortstack */
	// /* latex_angle is not used elsewhere, so we use it for
	//    'real' text rotation using '\rotatebox' */
	//    latex_angle = ang;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//LATEX_reset()
	//{
	//    LATEX_posx = LATEX_posy = 0;	// current position 
	//    LATEX_moved = TRUE;		// pen is up after move 
	//}
	//
	//
	//TERM_PUBLIC void
	//LATEX_fillbox(int style, unsigned int x1, unsigned int y1, unsigned
	//int width, unsigned int height)
	//{
	// /* TODO: Something other than black/white */
	//    if ((style & 0xf) == FS_EMPTY)
	//	return;
	//    if ((style & 0xf) == FS_SOLID && (style >> 4) < 50)
	//	return;
	//    if ((style & 0xf) == FS_PATTERN && ((style >> 4) & 1) == 0)
	//	return;
	//
	//    fprintf(gpoutfile, "\\put(%d,%d){\\rule{%gpt}{%gpt}}\n", x1, y1,
	//	    width*LATEX_UNIT, height*LATEX_UNIT);
	//}
	//
	//
	///#ifdef EMTEX
	//
	//TERM_PUBLIC void
	//EMTEX_init()
	//{
	//    emtex = TRUE;
	//    LATEX_posx = LATEX_posy = 0;
	//    fprintf(gpoutfile, "
	//%% GNUPLOT: LaTeX picture with emtex specials\n
	//\\setlength{\\unitlength}{%fpt}\n
	//\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n",
	//	    LATEX_UNIT);
	//    LATEX_linetype(LT_AXIS);
	//}
	//
	//
	//TERM_PUBLIC void
	//EMTEX_reset()
	//{
	//    emtex = FALSE;
	//    LATEX_posx = LATEX_posy = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//EMTEX_text()
	//{
	//    fputs("\\end{picture}\n", gpoutfile);
	//}
	//
	//
	//static void
	//EMTEX_solid_line(int x1, int x2, int y1, int y2)
	//{
	// /* emtex special solid line */
	//    if (LATEX_moved)
	//	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:moveto}}\n", x1, y1);
	//    if ((x1 != x2) || (y1 != y2))
	//	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:lineto}}\n", x2, y2);
	//    LATEX_posx = x2;
	//    LATEX_posy = y2;
	//    LATEX_moved = FALSE;
	//}
	//
	//
	///#endif // EMTEX 
	//
	///#endif // TERM_BODY 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(latex_driver)
	//    "latex", "LaTeX picture environment",
	//    LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR,
	//    LATEX_VTIC, LATEX_HTIC, LATEX_options, LATEX_init, LATEX_reset,
	//    LATEX_text, null_scale, LATEX_graphics, LATEX_move, LATEX_vector,
	//    LATEX_linetype, LATEX_put_text, LATEX_text_angle,
	//    LATEX_justify_text, LATEX_point, LATEX_arrow, set_font_null,
	//    NULL,      // pointsize 
	//    0,         // flags 
	//    NULL, NULL, // suspend, resume 
	//    LATEX_fillbox, NULL, // linewidth 
	///#ifdef USE_MOUSE
	//    NULL, NULL, NULL, NULL, NULL,
	///#endif
	//    NULL // Color stuff 
	//TERM_TABLE_END(latex_driver)
	// 
	///#undef LAST_TERM
	///#define LAST_TERM latex_driver
	//
	//
	///#ifdef EMTEX
	//TERM_TABLE_START(emtex_driver)
	//    "emtex", "LaTeX picture environment with emTeX specials",
	//    LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR,
	//    LATEX_VTIC, LATEX_HTIC, LATEX_options, EMTEX_init, EMTEX_reset,
	//    EMTEX_text, null_scale, LATEX_graphics, LATEX_move, LATEX_vector,
	//    LATEX_linetype, LATEX_put_text, LATEX_text_angle,
	//    LATEX_justify_text, LATEX_point, LATEX_arrow, set_font_null
	//TERM_TABLE_END(emtex_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM emtex_driver
	//
	///#endif // EMTEX 
	///#endif // TERM_TABLE 


	///#ifdef TERM_HELP
	//START_HELP(latex)
	//"1 latex",
	//"?commands set terminal emtex",
	//"?set terminal emtex",
	//"?set term emtex",
	//"?terminal emtex",
	//"?term emtex",
	//"?emtex",
	//"?commands set terminal latex",
	//"?set terminal latex",
	//"?set term latex",
	//"?terminal latex",
	//"?term latex",
	//"?latex",
	//" Syntax:",
	//"       set terminal {latex | emtex} {default | {courier|roman} {<fontsize>}}",
	//"                    {size <XX>{unit}, <YY>{unit}} {rotate | norotate}",
	//"",
	//" By default the plot will inherit font settings from the embedding document.",
	//" You have the option of forcing either Courier (cmtt) or Roman (cmr) fonts",
	//" instead. In this case you may also specify a fontsize.",
	//" Unless your driver is capable of building fonts at any size (e.g. dvips),",
	//" stick to the standard 10, 11 and 12 point sizes.",
	//"",
	//" METAFONT users beware: METAFONT does not like odd sizes.",
	//"",
	//" All drivers for LaTeX offer a special way of controlling text positioning:",
	//" If any text string begins with '{', you also need to include a '}' at the",
	//" end of the text, and the whole text will be centered both horizontally and",
	//" vertically.  If the text string begins with '[', you need to follow this with",
	//" a position specification (up to two out of t,b,l,r), ']{', the text itself,",
	//" and finally '}'.  The text itself may be anything LaTeX can typeset as an",
	//" LR-box.  '\\rule{}{}'s may help for best positioning.",
	//"",
	//" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",
	//" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",
	//" in the latexsym package, which is part of the base distribution and thus part",
	//" of any LaTeX implementation.  Please do not forget to use this package.",
	//" Other point types use symbols from the amssymb package.",
	//"",
	//" The default size for the plot is 5 inches by 3 inches. The `size` option",
	//" changes this to whatever the user requests. By default the X and Y sizes",
	//" are taken to be in inches, but other units are possible (currently only cm).",
	//"",
	//" If 'rotate' is specified, rotated text, especially a rotated y-axis label,",
	//" is possible (the packages graphics or graphicx are needed). The 'stacked'",
	//" y-axis label mechanism is then deactivated.",
	//"",
	//" Examples:",
	//" About label positioning:",
	//" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
	//"        set title '\\LaTeX\\ -- $ \\gamma $'",
	//" Force centering both horizontally and vertically:",
	//"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
	//" Specify own positioning (top here):",
	//"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
	//" The other label -- account for long ticlabels:",
	//"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
	//END_HELP(latex)
	///#endif // TERM_TABLE 


	/* latex/tex with picture in postscript */
	///#ifdef PSLATEX_DRIVER
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: pslatex.trm,v 1.75 2009/05/11 17:55:20 sfeam Exp $
	 */

	/* GNUPLOT - pslatex.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This file supplies the terminal drivers:
	 *     pslatex  -- LaTeX with embedded postscript
	 *     pstex    -- plain TeX with embedded postscript
	 *     epslatex -- LaTeX using \includegraphics, postscript part in an 
	 *                 external file
	 *
	 * AUTHORS
	 *  George Phillips
	 *  Russell Lang
	 *  David Kotz
	 *
	 *  Petr Mikulik, May 2000: terminal entries for PM3D functionality
	 *
	 *  Dan Sebald, 5 March 2003: terminal entry for image functionality
	 *
	 *  Theo Hopman
	 *      23 May 2003:
	 *              - added epslatex support. Replaces epslatex.trm; pointtype
	 *              and linetypes for epslatex terminal are now identical to
	 *              those of pslatex terminal.
	 *              - added arbitrary text rotations to all [e]ps[la]tex
	 *              terminals.
	 *      27 May 2004:
	 *              - epslatex patch updated for gnuplot 4.0
	 *      
	 *  Harald Harders (h.harders@tu-bs.de), 2005-02-08:
	 *  - Merged functionality of postscript, pslatex, pstex, and
	 *    epslatex terminals. Therefore deleted epslatex.trm.
	 *  - Added a standalone mode to the epslatex mode for standalone use without
	 *    an additional LaTeX document.
	 *  - Fixed text rotation of ps(la)tex terminals.
	 *
	 * Send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 */


	///#ifdef TERM_REGISTER
	//register_term(pslatex)
	//register_term(pstex)
	//register_term(epslatex)
	///#endif

	///#ifdef TERM_PROTO
	// /* Common functions for epslatex and ps(la)tex */
	// /* All these routines begin with PSLATEX_ */
	//TERM_PUBLIC void PSLATEX_reset __PROTO((void));
	//
	// /* Functions for ps(la)tex */
	// /* All these routines begin with PSTEX_ */
	//TERM_PUBLIC void PSTEX_reopen_output __PROTO((void));
	//TERM_PUBLIC void PSTEX_common_init __PROTO((void));
	//TERM_PUBLIC void PSTEX_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void PSTEX_text __PROTO((void));
	//
	// /* Functions for epslatex */
	// /* All these routines begin with EPSLATEX_ */
	//TERM_PUBLIC void EPSLATEX_reopen_output __PROTO((void));
	//TERM_PUBLIC void EPSLATEX_common_init __PROTO((void));
	//TERM_PUBLIC void EPSLATEX_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void EPSLATEX_linetype __PROTO((int linetype));
	//TERM_PUBLIC void EPSLATEX_layer __PROTO((t_termlayer syncpoint));
	//
	// /* additional LaTeX header information for epslatex terminal */
	//TERM_PUBLIC char *epslatex_header = NULL;
	//
	///#endif // TERM_PROTO 


	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "post.h"
	//
	//struct pstex_text_command {
	//    int x, y, angle, justify;
	//    char *label;
	//    struct pstex_text_command *next;
	//};
	//
	//static struct pstex_text_command *pstex_labels = NULL;
	//static int epslatex_text_layer = 0;
	//
	// /* Support for optimization of set_color */
	//static t_colorspec tex_previous_colorspec = {-1, 0, 0.0};  // Initialize to invalid type 
	//static char tex_current_color[64];
	//static TBOOLEAN tex_color_synced = FALSE;
	//
	///#define EPSLATEX_sync_color     do { 	if (!tex_color_synced) { 	    fputs(tex_current_color,gpoutfile); 	    tex_color_synced = TRUE; 	}     } while (0)
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//ignore
	//
	// /* Common functions for epslatex and ps(la)tex */
	//
	//TERM_PUBLIC void
	//PSLATEX_reset()
	//{
	//    switch (ps_params->terminal) {
	//    case PSTERM_EPSLATEX:
	//        PS_reset();
	//        if (gpoutfile) {
	//	    fprintf(gpoutfile, "
	//    \\gplbacktext\n
	//    \\put(0,0){\\includegraphics{%s}}%%\n
	//    \\gplfronttext\n
	//  \\end{picture}%%\n
	//\\endgroup\n", pslatex_auxname);
	//            if (ps_params->epslatex_standalone)
	//                fputs("\\end{document}\n", gpoutfile);
	//        }
	//        break;
	//    case PSTERM_PSLATEX:
	//        fputs("
	//\\end{picture}%\n
	//\\endgroup\n
	//\\endinput\n", gpoutfile);
	//        break;
	//    case PSTERM_PSTEX:
	//        fputs("
	//\\endGNUPLOTpicture\n
	//\\endgroup\n
	//\\endinput\n", gpoutfile);
	//        break;
	//    default:; // do nothing, just avoid a compiler warning 
	//    }
	//
	//    if (pslatex_auxname) {
	//        free(pslatex_auxname);
	//        pslatex_auxname = NULL;
	//    }
	//    if (gppsfile && (gppsfile != gpoutfile)) {
	//        fclose(gppsfile);
	//        gppsfile = NULL;
	//    }
	//}
	//
	//
	// /* Functions for ps(la)tex */
	//
	//TERM_PUBLIC void
	//PSTEX_reopen_output()
	//{
	//    if (outstr) {
	//        char *dotIndex;
	//
	// /* if there's no extension, append ".ps" */
	//        if ((dotIndex = strrchr(outstr, '.')) == NULL)
	//            dotIndex = strchr(outstr, NUL);
	//
	// /* try to open the auxiliary file for the postscript parts. */
	//        if (ps_params->useauxfile) {
	// /* length of outstr plus ('.' or '\0') plus "eps" plus '\0' */
	//            pslatex_auxname = gp_realloc(pslatex_auxname,dotIndex - outstr + 5,
	//                                          "pslatex aux filename");
	//            if (pslatex_auxname) {
	// /* include period or '\0' */
	//                strncpy(pslatex_auxname, outstr, (dotIndex - outstr) + 1);
	// /* period or '\0' is overwritten with period, and "ps" appended */
	//                strcpy(pslatex_auxname + (dotIndex - outstr), ".ps");
	//                gppsfile = fopen(pslatex_auxname, "w");
	//                if (gppsfile  == (FILE *) NULL) {
	//                    fprintf(stderr, "Cannot open aux file %s for output. Switching off auxfile option.\n",
	//                            pslatex_auxname);
	//                    free(pslatex_auxname);
	//                    pslatex_auxname = NULL;
	//                    ps_params->useauxfile = FALSE;
	//                    gppsfile = gpoutfile;
	//                }
	//            } else {
	//                fprintf(stderr, "Cannot make PostScript file name from %s\n",
	//                        outstr);
	//                fprintf(stderr, "Turning off auxfile option\n");
	//                ps_params->useauxfile = FALSE;
	//                gppsfile = gpoutfile;
	//            }
	//        } else
	//            gppsfile = gpoutfile;
	//    } else {
	//        if (ps_params->useauxfile) {
	//            fprintf(stderr, "Cannot use aux file on stdout. Switching off auxfile option.\n");
	//            ps_params->useauxfile = FALSE;
	//        }
	//        gppsfile = gpoutfile;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTEX_common_init()
	//{
	//    switch (ps_params->terminal) {
	//    case PSTERM_PSLATEX:
	//        fprintf(gpoutfile,"
	//%% GNUPLOT: LaTeX picture with Postscript\n
	//\\begingroup%%\n
	//\\makeatletter%%\n
	//\\newcommand{\\GNUPLOTspecial}{%%\n
	//  \\@sanitize\\catcode`\\%%=14\\relax\\special}%%\n
	//\\setlength{\\unitlength}{%.4fbp}%%\n", 1.0 / (2*PS_SC));
	//        fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)%%\n",
	//                (int) (xsize * term->xmax), (int) (ysize * term->ymax));
	//        break;
	//    case PSTERM_PSTEX:
	// /* write plain TeX header */
	//        fprintf(gpoutfile, "
	//%% GNUPLOT: plain TeX with Postscript\n
	//\\begingroup\n
	//\\catcode`\\@=11\\relax\n
	//\\def\\GNUPLOTspecial{%%\n
	//  \\def\\do##1{\\catcode`##1=12\\relax}\\dospecials\n
	//  \\catcode`\\{=1\\catcode`\\}=2\\catcode\\%%=14\\relax\\special}%%\n
	//%%\n
	//\\expandafter\\ifx\\csname GNUPLOTpicture\\endcsname\\relax\n
	//  \\csname newdimen\\endcsname\\GNUPLOTunit\n
	//  \\gdef\\GNUPLOTpicture(#1,#2){\\vbox to#2\\GNUPLOTunit\\bgroup\n
	//    \\def\\put(##1,##2)##3{\\unskip\\raise##2\\GNUPLOTunit\n
	//      \\hbox to0pt{\\kern##1\\GNUPLOTunit ##3\\hss}\\ignorespaces}%%\n
	//    \\def\\ljust##1{\\vbox to0pt{\\vss\\hbox to0pt{##1\\hss}\\vss}}%%\n
	//    \\def\\cjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1\\hss}\\vss}}%%\n
	//    \\def\\rjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1}\\vss}}%%\n
	//    \\def\\stack##1{\\let\\\\=\\cr\\tabskip=0pt\\halign{\\hfil ####\\hfil\\cr ##1\\crcr}}%%\n
	//    \\def\\lstack##1{\\hbox to0pt{\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n
	//    \\def\\cstack##1{\\hbox to0pt{\\hss\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n
	//    \\def\\rstack##1{\\hbox to0pt{\\vbox to0pt{\\stack{##1}\\vss}\\hss}}%%\n
	//    \\vss\\hbox to#1\\GNUPLOTunit\\bgroup\\ignorespaces}%%\n
	//  \\gdef\\endGNUPLOTpicture{\\hss\\egroup\\egroup}%%\n
	//\\fi\n
	//\\GNUPLOTunit=%.4fbp\n", 1.0 / (2*PS_SC));
	//        fprintf(gpoutfile, "\\GNUPLOTpicture(%d,%d)\n",
	//                (int) (xsize * term->xmax), (int) (ysize * term->ymax));
	//        break;
	//    default:; // do nothing, just avoid a compiler warning 
	//    }
	//
	//    if (gppsfile != gpoutfile) {
	// /* these are taken from the post.trm file computation
	//  * of the bounding box, but without the X_OFF and Y_OFF */
	//        int urx = (int) (xsize * term->xmax / (2*PS_SC) + 0.5);
	//        int ury = (int) (ysize * term->ymax / (2*PS_SC) + 0.5);
	// /* moved this code here from beginning of the function
	//  * pslatex_auxname is only != NULL with the `auxfile' option */
	//        char *psfile_basename = strrchr(pslatex_auxname, DIRSEP1);
	//
	// /* If pslatex_auxname is not a simple file name, but a path,
	//  * we need to strip the path off the auxiliary file name,
	//  * because tex file and ps aux file end up in the same directory! */
	//        if (psfile_basename)
	//            psfile_basename++;
	//        else {
	///#if DIRSEP2 != NUL
	//	    psfile_basename = strrchr(pslatex_auxname, DIRSEP2);
	//	    if (psfile_basename)
	//		psfile_basename++;
	//	    else
	//		psfile_basename = pslatex_auxname;
	///#else
	//	    psfile_basename = pslatex_auxname;
	///#endif
	//	}
	//
	// /* generate special which xdvi and dvips can handle */
	//        fprintf(gpoutfile,
	//                "  \\special{psfile=%s llx=0 lly=0 urx=%d ury=%d rwi=%d}\n",
	//                psfile_basename, urx, ury, 10 * urx);
	//    } else
	//        fputs("  {\\GNUPLOTspecial{\"\n", gpoutfile);
	//
	// /* HH: really necessary?
	// ps_ang = 0;
	// ps_justify = 0;
	// */
	//    pstex_labels = (struct pstex_text_command *) NULL;
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTEX_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    struct pstex_text_command *tc;
	//
	// /* ignore empty strings */
	//    if (str[0] == NUL)
	//        return;
	//
	// /* Save the text for later printing after the core graphics */
	//    tc = (struct pstex_text_command *) gp_alloc(sizeof(struct pstex_text_command),
	//                                                term->name);
	//    tc->x = x;
	//    tc->y = y;
	//    tc->label = (char *) gp_alloc(strlen(str) + 1, term->name);
	//    strcpy(tc->label, str);
	//    tc->justify = ps_justify;
	//    tc->angle = ps_ang;
	//
	//    tc->next = pstex_labels;
	//    pstex_labels = tc;
	//}
	//
	//TERM_PUBLIC void
	//PSTEX_text()
	//{
	//    struct pstex_text_command *tc;
	//
	//    PS_text();
	//    if (gppsfile == gpoutfile)
	//        fputs("  }}%\n", gpoutfile);
	//
	//    if (ps_params->fontsize) {
	//        if (ps_params->terminal == PSTERM_PSLATEX)
	//            fprintf(gpoutfile, "\\fontsize{%g}{\\baselineskip}\\selectfont\n",
	//                    ps_params->fontsize);
	// /* Should have an else clause here to handle pstex equivalent */
	//    }
	//
	//    for (tc = pstex_labels;
	//         tc != (struct pstex_text_command *) NULL;
	//         tc = tc->next) {
	//        fprintf(gpoutfile, "  \\put(%d,%d){", tc->x, tc->y);
	//        if ((ps_params->rotate) && (tc->angle != 0))
	//            fprintf(gpoutfile, "
	//%%\n  \\special{ps: gsave currentpoint currentpoint translate\n
	//%d rotate neg exch neg exch translate}%%\n  ", 360 - tc->angle);
	//        if ((ps_params->terminal == PSTERM_PSLATEX) &&
	//            ((tc->label[0] == '{') || (tc->label[0] == '['))) {
	//            fprintf(gpoutfile, "\\makebox(0,0)%s", tc->label);
	//        } else
	//            switch (tc->justify) {
	//            case LEFT:
	//                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
	//                                    ? "\\makebox(0,0)[l]{\\strut{}%s}"
	//                                    : "\\ljust{\\strut{}%s}"), tc->label);
	//                break;
	//            case CENTRE:
	//                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
	//                                    ? "\\makebox(0,0){\\strut{}%s}"
	//                                    : "\\cjust{\\strut{}%s}"), tc->label);
	//                break;
	//            case RIGHT:
	//                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
	//                                    ? "\\makebox(0,0)[r]{\\strut{}%s}"
	//                                    : "\\rjust{\\strut{}%s}"), tc->label);
	//                break;
	//            }
	//        if ((ps_params->rotate) && (tc->angle != 0))
	//            fputs("%\n  \\special{ps: currentpoint grestore moveto}%\n  ",
	//                  gpoutfile);
	//        fputs("}%\n", gpoutfile);
	//    }
	//
	//    while (pstex_labels) {
	//        tc = pstex_labels->next;
	//        free(pstex_labels->label);
	//        free(pstex_labels);
	//        pstex_labels = tc;
	//    }
	//
	//}
	//
	//
	// /* Functions for epslatex */
	//
	// /* the common init function for the epslatex driver */
	//TERM_PUBLIC void
	//EPSLATEX_common_init()
	//{
	//    char *fontfamily = NULL;
	//    char *fontseries = NULL;
	//    char *fontshape = NULL;
	//
	//    if (!gpoutfile) {
	//        char *temp = gp_alloc(strlen(outstr) + 1, "temp file string");
	//        if (temp) {
	//            strcpy(temp, outstr);
	//            term_set_output(temp);  // will free outstr 
	//            if (temp != outstr) {
	//                if (temp)
	//                    free(temp);
	//                temp = outstr;
	//            }
	//        } else
	//            os_error(c_token, "Cannot reopen output files");
	//    }
	//    if (!outstr)
	//        os_error(c_token,
	//                 "epslatex terminal cannot write to standard output");
	//    if (gpoutfile) {
	//        char *inputenc = NULL;
	//
	//        fprintf(gpoutfile, "%% GNUPLOT: LaTeX picture with Postscript\n");
	//
	//        switch(encoding) {
	//        case S_ENC_DEFAULT:
	//            break;
	//        case S_ENC_ISO8859_1:
	//            inputenc = "latin1";
	//            break;
	//        case S_ENC_ISO8859_2:
	//            inputenc = "latin2";
	//            break;
	//        case S_ENC_ISO8859_9:	// ISO8859-9 is Latin5 
	//            inputenc = "latin5";
	//            break;
	//        case S_ENC_ISO8859_15:	// ISO8859-15 is Latin9 
	//            inputenc = "latin9";
	//            break;
	//        case S_ENC_CP437:
	//            inputenc = "cp437de";
	//            break;
	//        case S_ENC_CP850:
	//            inputenc = "cp850";
	//            break;
	//        case S_ENC_CP852:
	//            inputenc = "cp852";
	//            break;
	//        case S_ENC_CP1250:
	//            inputenc = "cp1250";
	//            break;
	//        case S_ENC_KOI8_R:
	//            inputenc = "koi8-r";
	//            break;
	//        case S_ENC_KOI8_U:
	//            inputenc = "koi8-u";
	//            break;
	//        case S_ENC_INVALID:
	//            int_error(NO_CARET, "invalid input encoding used");
	//            break;
	//        default:
	// /* do nothing */
	//            break;
	//        }
	//
	// /* Clear previous state */
	//	tex_previous_colorspec.type = -1;
	//
	// /* Clear any leftover text-layering state */
	//	EPSLATEX_layer(TERM_LAYER_RESET);
	//
	// /* Analyse LaTeX font name 'family,series,shape' */
	//        if ((strlen(ps_params->font) > 0) &&
	//            (strcmp(ps_params->font,"default") != 0)) {
	//            char *comma = NULL;
	//            fontfamily = gp_alloc(strlen(ps_params->font)+1,
	//                                  "EPSLATEX_common_init");
	//            fontseries = gp_alloc(strlen(ps_params->font)+1,
	//                                  "EPSLATEX_common_init");
	//            fontshape = gp_alloc(strlen(ps_params->font)+1,
	//                                 "EPSLATEX_common_init");
	//            strcpy(fontfamily,ps_params->font);
	//            *fontseries = '\0';
	//            *fontshape = '\0';
	//            if ((comma = strchr(fontfamily, ',')) != NULL) {
	//                *comma = '\0';
	//                strcpy(fontseries,comma+1);
	//                if ((comma = strchr(fontseries, ',')) != NULL) {
	//                    *comma = '\0';
	//                    strcpy(fontshape,comma+1);
	//                }
	//            }
	//        }
	//            
	//        if (ps_params->epslatex_standalone) {
	//            fprintf(gpoutfile, "
	//\\documentclass{minimal}\n
	//%% Set font size\n
	//\\makeatletter\n
	//\\def\\@ptsize{%d}\n
	//\\InputIfFileExists{size%d.clo}{}{%%\n
	//   \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n
	//      Gnuplot Error: File `size%d.clo' not found! Could not set font size%%\n
	//   }{See the gnuplot documentation for explanation.%%\n
	//   }{For using a font size a file `size<fontsize>.clo' has to exist.\n
	//        Falling back ^^Jto default fontsize 10pt.}%%\n
	//  \\def\\@ptsize{0}\n
	//  \\input{size10.clo}%%\n
	//}%%\n
	//\\makeatother\n",
	//                    (int)(ps_params->fontsize-10),
	//                    (int)(ps_params->fontsize),
	//                    (int)(ps_params->fontsize));
	//
	//            if (fontfamily && strlen(fontfamily) > 0)
	//                fprintf(gpoutfile, "\\renewcommand*\\rmdefault{%s}%%\n",
	//                        fontfamily);
	//            if (fontseries && strlen(fontseries) > 0)
	//                fprintf(gpoutfile, "\\renewcommand*\\mddefault{%s}%%\n",
	//                        fontseries);
	//            if (fontshape && strlen(fontshape) > 0)
	//                fprintf(gpoutfile, "\\renewcommand*\\updefault{%s}%%\n",
	//                        fontshape);
	//
	//            fputs("
	//% Load packages\n
	//\\usepackage{graphicx}\n
	//\\usepackage{color}\n", gpoutfile);
	//
	//            if (inputenc)
	//                fprintf(gpoutfile, "\\usepackage[%s]{inputenc}\n", inputenc);
	//
	//            fprintf(gpoutfile, "
	//\\makeatletter\n
	//%% Select an appropriate default driver (from TeXLive graphics.cfg)\n
	//\\begingroup\n
	//  \\chardef\\x=0 %%\n
	//  %% check pdfTeX\n
	//  \\@ifundefined{pdfoutput}{}{%%\n
	//    \\ifcase\\pdfoutput\n
	//    \\else\n
	//      \\chardef\\x=1 %%\n
	//    \\fi\n
	//  }%%\n
	//  %% check VTeX\n
	//  \\@ifundefined{OpMode}{}{%%\n
	//    \\chardef\\x=2 %%\n
	//  }%%\n
	//\\expandafter\\endgroup\n
	//\\ifcase\\x\n
	//  %% default case\n
	//  \\PassOptionsToPackage{dvips}{geometry}\n
	//\\or\n
	//  %% pdfTeX is running in pdf mode\n
	//  \\PassOptionsToPackage{pdftex}{geometry}\n
	//\\else\n
	//  %% VTeX is running\n
	//  \\PassOptionsToPackage{vtex}{geometry}\n
	//\\fi\n
	//\\makeatother\n
	//%% Set papersize\n
	//\\usepackage[papersize={%.2fbp,%.2fbp},text={%.2fbp,%.2fbp}]{geometry}\n
	//%% No page numbers and no paragraph indentation\n
	//\\pagestyle{empty}\n
	//\\setlength{\\parindent}{0bp}%%\n
	//%% Load configuration file\n
	//\\InputIfFileExists{gnuplot.cfg}{%%\n
	//  \\typeout{Using configuration file gnuplot.cfg}%%\n
	//}{%%\n
	// \\typeout{No configuration file gnuplot.cfg found.}%%\n
	//}%%\n
	//%s\n
	//\\begin{document}\n",
	//                    term->xmax * xsize / (2.0*PS_SC),
	//                    term->ymax * ysize / (2.0*PS_SC),
	//                    term->xmax * xsize / (2.0*PS_SC),
	//                    term->ymax * ysize / (2.0*PS_SC),
	//                    epslatex_header ? epslatex_header : "%" );
	//        }
	//
	//        fputs("\\begingroup\n", gpoutfile);
	//        
	//        if (inputenc)
	//            fprintf(gpoutfile, "
	//  %% Encoding inside the plot.  In the header of your document, this encoding\n
	//  %% should to defined, e.g., by using\n
	//  %% \\usepackage[%s,<other encodings>]{inputenc}\n
	//  \\inputencoding{%s}%%\n", inputenc, inputenc);
	//
	//        if (!ps_params->epslatex_standalone) {
	//            if (fontfamily && strlen(fontfamily) > 0)
	//                fprintf(gpoutfile, "  \\fontfamily{%s}%%\n",
	//                        fontfamily);
	//            if (fontseries && strlen(fontseries) > 0)
	//                fprintf(gpoutfile, "  \\fontseries{%s}%%\n",
	//                        fontseries);
	//            if (fontshape && strlen(fontshape) > 0)
	//                fprintf(gpoutfile, "  \\fontshape{%s}%%\n",
	//                        fontshape);
	//            if (fontfamily || fontseries || fontshape)
	//                fputs("  \\selectfont\n", gpoutfile);
	//            if (epslatex_header)
	//                fprintf(gpoutfile, "%s\n", epslatex_header );
	//        }
	//
	//        fprintf(gpoutfile, "
	//  \\makeatletter\n
	//  \\providecommand\\color[2][]{%%\n
	//    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n
	//      Package color not loaded in conjunction with\n
	//      terminal option `colourtext'%%\n
	//    }{See the gnuplot documentation for explanation.%%\n
	//    }{Either use 'blacktext' in gnuplot or load the package\n
	//      color.sty in LaTeX.}%%\n
	//    \\renewcommand\\color[2][]{}%%\n
	//  }%%\n
	//  \\providecommand\\includegraphics[2][]{%%\n
	//    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n
	//      Package graphicx or graphics not loaded%%\n
	//    }{See the gnuplot documentation for explanation.%%\n
	//    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}%%\n
	//    \\renewcommand\\includegraphics[2][]{}%%\n
	//  }%%\n
	//  \\providecommand\\rotatebox[2]{#2}%%\n
	//  \\@ifundefined{ifGPcolor}{%%\n
	//    \\newif\\ifGPcolor\n
	//    \\GPcolor%s\n
	//  }{}%%\n
	//  \\@ifundefined{ifGPblacktext}{%%\n
	//    \\newif\\ifGPblacktext\n
	//    \\GPblacktext%s\n
	//  }{}%%\n
	//  %% define a \\g@addto@macro without @ in the name:\n
	//  \\let\\gplgaddtomacro\\g@addto@macro\n
	//  %% define empty templates for all commands taking text:\n
	//  \\gdef\\gplbacktext{}%%\n
	//  \\gdef\\gplfronttext{}%%\n
	//  \\makeatother\n",
	//                (ps_params->color?"true":"false"),
	//                (ps_params->blacktext?"true":"false") );
	//
	// /* use \expandafter\def\csname LT0\endcsname{...} 
	//  * instead of \def\LT0{...} because digits may not be part of
	//  * \... sequences */
	//        fputs("
	//  \\ifGPblacktext\n
	//    % no textcolor at all\n
	//    \\def\\colorrgb#1{}%\n
	//    \\def\\colorgray#1{}%\n
	//  \\else\n
	//    % gray or color?\n
	//    \\ifGPcolor\n
	//      \\def\\colorrgb#1{\\color[rgb]{#1}}%\n
	//      \\def\\colorgray#1{\\color[gray]{#1}}%\n
	//      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}%\n
	//      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}%\n",
	//              gpoutfile);
	//        if (ps_params->oldstyle) {
	//            fputs("
	//      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}%\n
	//      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,0,1}}%\n
	//      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,1,1}}%\n
	//      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}%\n",
	//                  gpoutfile);
	//        } else {
	//            fputs("
	//      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}%\n
	//      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}%\n
	//      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}%\n
	//      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}%\n
	//      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}%\n
	//      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}%\n
	//      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}%\n
	//      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}%\n
	//      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}%\n",
	//                  gpoutfile);
	//        }
	//        fputs("
	//    \\else\n
	//      % gray\n
	//      \\def\\colorrgb#1{\\color{black}}%\n
	//      \\def\\colorgray#1{\\color[gray]{#1}}%\n
	//      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}%\n
	//      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}%\n
	//      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}%\n
	//    \\fi\n
	//  \\fi\n", gpoutfile);
	//
	//        fprintf(gpoutfile,"
	//  \\setlength{\\unitlength}{%.4fbp}%%\n
	//  \\begin{picture}(%.2f,%.2f)%%\n",
	//                1.0 / (2*PS_SC), term->xmax * xsize, term->ymax * ysize);
	//    }
	//
	//    if (fontfamily)
	//        free(fontfamily);
	//    if (fontseries)
	//        free(fontseries);
	//    if (fontshape)
	//        free(fontshape);
	//}
	//
	//
	//TERM_PUBLIC void
	//EPSLATEX_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    if (gpoutfile) {
	//	EPSLATEX_sync_color;
	//	fprintf(gpoutfile, "      \\put(%d,%d){", x, y);
	//        if (ps_ang)
	//            fprintf(gpoutfile,"\\rotatebox{%d}{", ps_ang);
	//        if (((str[0] == '{') || (str[0] == '['))) {
	//            fprintf(gpoutfile, "\\makebox(0,0)%s", str);
	//        } else
	//            switch (ps_justify) {
	//            case LEFT:
	//                fprintf(gpoutfile, "\\makebox(0,0)[l]{\\strut{}%s}", str);
	//                break;
	//            case CENTRE:
	//                fprintf(gpoutfile, "\\makebox(0,0){\\strut{}%s}", str);
	//                break;
	//            case RIGHT:
	//                fprintf(gpoutfile, "\\makebox(0,0)[r]{\\strut{}%s}", str);
	//                break;
	//            }
	//        if (ps_ang) {
	//            fputs("}", gpoutfile);
	//        }
	//        fputs("}%\n", gpoutfile);
	//    }
	//}
	//
	//
	// /* assigns dest to outstr, so it must be allocated or NULL
	//  * and it must not be outstr itself !
	//  */
	//void
	//EPSLATEX_reopen_output()
	//{
	//    char *psoutstr = NULL;
	//
	//    if (outstr) {
	//        unsigned int outstrlen = strlen(outstr);
	//        if (strrchr(outstr, '.') != &outstr[outstrlen-4] ) {
	//            int_error(NO_CARET,
	//                      "epslatex outputfile may not have dots inside %s",
	//                      "their filenames before the extension .tex or .eps");
	//        }
	//
	// /* copy filename to postsript output */
	//        psoutstr = gp_alloc(outstrlen+5, "epslatex eps filename");
	//        strcpy( psoutstr, outstr);
	//
	//        if ((!strncmp( &outstr[outstrlen-4], ".eps", 4 )) ||
	//            (!strncmp( &outstr[outstrlen-4], ".EPS", 4 ))) {
	//            if (ps_params->epslatex_standalone)
	//                int_error(NO_CARET,
	//                          "For epslatex standalone mode, you have to %s",
	//                          "give the tex filename as output");
	// /* rename primary output (tex) */
	//            strncpy( &outstr[outstrlen-4], ".tex", 4);
	// /* redirect FILE stream */
	//            gppsfile = gpoutfile;
	//            gpoutfile = fopen(outstr,"w");
	//            int_warn(NO_CARET, "Resetting primary output file to %s,\n
	//                  PostScript output to %s", outstr, psoutstr);
	//            if (!gpoutfile)
	//                int_error(NO_CARET, "--- reopen failed");
	//        } else {
	//            if (ps_params->epslatex_standalone)
	//                strncpy( &psoutstr[outstrlen-4], "-inc.eps", 9);
	//            else
	//                strncpy( &psoutstr[outstrlen-4], ".eps", 4);
	//            gppsfile = fopen(psoutstr,"w");
	//        }
	//        if (!gppsfile)
	//            int_error(NO_CARET, "open of postscipt output file %s failed",
	//                      psoutstr);
	//
	// /* set the name for the \includegraphics command */
	//        pslatex_auxname = gp_alloc(strlen(psoutstr)-3,
	//                                   "epslatex TeX filename");
	//        strncpy( pslatex_auxname, psoutstr, strlen(psoutstr)-4 );
	//        pslatex_auxname[strlen(psoutstr)-4] = '\0';
	//
	//        free(psoutstr);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//EPSLATEX_set_color(t_colorspec *colorspec)
	//{
	//    double gray;
	//
	// /* EAM Jul 2006 - Filter out duplicate requests */
	//    if (!memcmp(&tex_previous_colorspec, colorspec, sizeof(t_colorspec)))
	//	return;
	//    else
	//	memcpy(&tex_previous_colorspec, colorspec, sizeof(t_colorspec));
	//
	// /* Fancy footwork to deal with mono/grayscale plots */
	//    if (colorspec->type == TC_LT && !ps_params->color)
	//	PS_linetype(colorspec->lt);
	//    else
	//	PS_set_color(colorspec);
	//
	// /* Many [most? all?] of the set_color commands only affect the *.eps     */
	// /* output stream.  So rather than printing them all to the *.tex stream, */
	// /* we update the current color and set a flag to say it has changed.     */
	// /* Only when some TeX object is output do we sync the current color by   */
	// /* writing it out.                                                       */
	//    tex_color_synced = FALSE;
	//
	//    if (colorspec->type == TC_RGB) {
	//        double r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
	//        double g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
	//        double b = (double)(colorspec->lt & 255) / 255.;
	//	sprintf(tex_current_color, "      \\colorrgb{%3.2f,%3.2f,%3.2f}%%\n",r,g,b);
	//    }
	//
	//    if (colorspec->type == TC_LT) {
	//        int linetype = colorspec->lt;
	//        if (ps_params->oldstyle)
	//            linetype = (linetype % 4) + 3;
	//        else
	//            linetype = (linetype % 9) + 3;
	//
	//	sprintf(tex_current_color, "      \\csname LT%c\\endcsname%%\n",
	//                "wba012345678"[linetype]);
	//    }
	//
	//    if (colorspec->type != TC_FRAC)
	//        return;
	//
	// /* map [0;1] to gray/colors */
	//    gray = colorspec->value;
	//
	//    if (ps_params->blacktext) {
	//	if (gray <= 0)
	//	    sprintf(tex_current_color, "      \\color{black}%%\n");
	//	else if (gray >= 1)
	//	    sprintf(tex_current_color, "      \\color{white}%%\n");
	//        else
	//	    sprintf(tex_current_color, "      \\colorgray{%s}%%\n",save_space(gray));
	//    } else {
	//	rgb_color color;
	//	rgb1_from_gray( colorspec->value, &color );
	//	sprintf(tex_current_color, "      \\colorrgb{%3.2f,%3.2f,%3.2f}%%\n",color.r,color.g,color.b);
	//    }
	//}
	//
	//TERM_PUBLIC void
	//EPSLATEX_linetype(int linetype)
	//{
	//    t_colorspec tempcol = {TC_LT, 0, 0.0};
	//    tempcol.lt = linetype;
	//    PS_linetype(linetype);
	//
	// /* This leads to redundant *.eps output */
	//    EPSLATEX_set_color(&tempcol);
	//}
	//
	// /*
	//  * The TERM_LAYER mechanism is used here to signal a difference between
	//  * "front" text and "back" text.
	//  */
	//TERM_PUBLIC void
	//EPSLATEX_layer(t_termlayer syncpoint)
	//{
	//    switch (syncpoint) {
	//
	//    case TERM_LAYER_RESET:        // Start of plot; reset flag 
	//	epslatex_text_layer = 0;
	//	break;
	//
	//    case TERM_LAYER_BACKTEXT: // Start of "back" text layer 
	//	if (epslatex_text_layer == 1)
	//	    break;
	//	if (epslatex_text_layer == 2)
	//	    fputs("    }%\n", gpoutfile);
	//	epslatex_text_layer = 1;
	//	fputs("    \\gplgaddtomacro\\gplbacktext{%\n", gpoutfile);
	//	break;
	//
	//    case TERM_LAYER_FRONTTEXT:// Start of "front" text layer 
	//	if (epslatex_text_layer == 2)
	//	    break;
	//	if (epslatex_text_layer == 1)
	//	    fputs("    }%\n", gpoutfile);
	//	epslatex_text_layer = 2;
	//	fputs("    \\gplgaddtomacro\\gplfronttext{%\n", gpoutfile);
	//	break;
	//
	//    case TERM_LAYER_END_TEXT:     // Close off front or back macro before leaving 
	//	if (epslatex_text_layer == 1 || epslatex_text_layer == 2)
	//	    fputs("    }%\n", gpoutfile);
	//	epslatex_text_layer = 0;
	//	break;
	//
	//    default:
	//	break;
	//    }
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	///#ifndef GOT_POST_PROTO
	///#define TERM_PROTO_ONLY
	///#include "post.trm"
	///#undef TERM_PROTO_ONLY
	///#endif // GOT_POST_PROTO 
	//
	//TERM_TABLE_START(epslatex_driver)
	//    "epslatex", "LaTeX picture environment using graphicx package",
	//    PS_XMAX, PS_YMAX, EPSLATEX_VCHAR, EPSLATEX_HCHAR,
	//    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
	//    PS_text, null_scale, PS_graphics, PS_move,
	//    PS_vector, EPSLATEX_linetype, EPSLATEX_put_text, PS_text_angle,
	//    PS_justify_text, PS_point, do_arrow, PS_set_font,
	//    PS_pointsize, TERM_BINARY|TERM_IS_POSTSCRIPT|TERM_CAN_CLIP //flags 
	//,
	//    0 //suspend 
	//, 0 //resume 
	//,
	//    PS_fillbox, PS_linewidth,
	///#ifdef USE_MOUSE
	//    0, 0, 0, 0, 0, // no mouse support for postscript 
	///#endif
	//    PS_make_palette, PS_previous_palette,
	//    EPSLATEX_set_color, PS_filled_polygon,
	//    PS_image,
	//    0, 0, 0, // Enhanced text mode not used 
	//    EPSLATEX_layer, // Used to signal front/back text 
	//    PS_path
	//TERM_TABLE_END(epslatex_driver)
	///#undef LAST_TERM
	///#define LAST_TERM epslatex_driver
	//
	//TERM_TABLE_START(pslatex_driver)
	//    "pslatex", "LaTeX picture environment with PostScript \\specials",
	//    PS_XMAX, PS_YMAX, PSTEX_VCHAR, PSTEX_HCHAR,
	//    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
	//    PSTEX_text, null_scale, PS_graphics, PS_move,
	//    PS_vector, PS_linetype, PSTEX_put_text, PS_text_angle,
	//    PS_justify_text, PS_point, PS_arrow, set_font_null,
	//    PS_pointsize, TERM_CAN_CLIP //flags 
	// , 0 //suspend 
	//    , 0 //resume 
	// ,
	//    PS_fillbox, PS_linewidth
	///#ifdef USE_MOUSE
	//   , 0, 0, 0, 0, 0 // no mouse support for postscript 
	///#endif
	//   , PS_make_palette,
	//   PS_previous_palette, // write grestore 
	//   PS_set_color,
	//   PS_filled_polygon
	//    , PS_image
	//    , 0, 0, 0	// No enhanced text mode because this is LaTeX 
	//    , 0         // layer 
	//    , PS_path
	//TERM_TABLE_END(pslatex_driver)
	///#undef LAST_TERM
	///#define LAST_TERM pslatex_driver
	//
	//TERM_TABLE_START(pstex_driver)
	//    "pstex", "plain TeX with PostScript \\specials",
	//    PS_XMAX, PS_YMAX, PSTEX_VCHAR, PSTEX_HCHAR,
	//    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
	//    PSTEX_text, null_scale, PS_graphics, PS_move,
	//    PS_vector, PS_linetype, PSTEX_put_text, PS_text_angle,
	//    PS_justify_text, PS_point, PS_arrow, set_font_null,
	//    PS_pointsize, TERM_CAN_CLIP //flags 
	// , 0 //suspend 
	//    , 0 //resume 
	// ,
	//    PS_fillbox, PS_linewidth
	///#ifdef USE_MOUSE
	//   , 0, 0, 0, 0, 0 // no mouse support for postscript 
	///#endif
	//   , PS_make_palette,
	//   PS_previous_palette, // write grestore 
	//   PS_set_color,
	//   PS_filled_polygon
	//    , PS_image
	//    , 0, 0, 0	// No enhanced text mode because this is LaTeX 
	//    , 0         // layer 
	//    , PS_path
	//TERM_TABLE_END(pstex_driver)
	///#undef LAST_TERM
	///#define LAST_TERM pstex_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 



	///#endif

	/* EEPIC-extended LaTeX driver, for EEPIC users */
	/* Hello, Emacs! This is -*-C-*- !*/
	/*
	 * $Id: eepic.trm,v 1.30 2008/02/24 19:49:38 sfeam Exp $
	 *
	 */

	/* GNUPLOT - eepic.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   The EEPIC macros for LaTeX.
	 *
	 * AUTHORS
	 *   David Kotz
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */
	/*
	 *  This file contains the eepic terminal driver, intended for use with the
	 *  eepic.sty macro package for LaTeX. This is an alternative to the
	 *  latex driver. You need eepic.sty, epic.sty, and a printer driver that
	 *  supports the tpic \specials.
	 *
	 * Although dotted and dashed lines are possible with EEPIC, and are
	 * tempting, they do not work well for high-sample-rate curves, mushing
	 * the dashes all together into a solid line. For now anyway, the EEPIC
	 * driver will have only solid lines. Anyone got a solution?
	 *
	 * LATEX must also be defined.
	 */
	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */
	/* Additions by Gabriel Zachmann (Gabriel.Zachmann@gmx.net), Nov 2000:
	 * - little bug fix in stacked (faked rotated) text
	 * - color support
	 * - true rotated text
	 * - augmented line types set with dashed lines
	 * - optionally small or tiny point symbols
	 * - font size
	 */



	///#ifdef TERM_REGISTER
	//register_term(eepic)
	///#endif

	///#ifdef TERM_PROTO
	//
	///#include <ctype.h>
	//
	//TERM_PUBLIC void EEPIC_init __PROTO((void));
	//TERM_PUBLIC void EEPIC_graphics __PROTO((void));
	//TERM_PUBLIC void EEPIC_text __PROTO((void));
	//TERM_PUBLIC void EEPIC_linetype __PROTO((int linetype));
	//TERM_PUBLIC void EEPIC_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void EEPIC_point __PROTO((unsigned int x, unsigned int y,
	//				      int number));
	//TERM_PUBLIC void EEPIC_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void EEPIC_arrow __PROTO((unsigned int sx, unsigned int sy,
	//				      unsigned int ex, unsigned int ey,
	//				      int head));
	//TERM_PUBLIC void EEPIC_put_text __PROTO((unsigned int x, unsigned int y,
	//					 const char str[]));
	//TERM_PUBLIC int EEPIC_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int EEPIC_text_angle __PROTO((int ang));
	//TERM_PUBLIC void EEPIC_reset __PROTO((void));
	//TERM_PUBLIC void EEPIC_options __PROTO((void));
	//
	///#define EEPIC_PTS_PER_INCH 72.27
	// /* resolution of printer we expect to use */
	///#define EEPIC_DOTS_PER_INCH 600
	// /* dot size in pt */
	///#define EEPIC_UNIT (EEPIC_PTS_PER_INCH/EEPIC_DOTS_PER_INCH)
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define EEPIC_XMAX (EEPIC_PTS_PER_INCH/EEPIC_UNIT*5.0)
	///#define EEPIC_YMAX (EEPIC_PTS_PER_INCH/EEPIC_UNIT*3.0)
	//
	///#define EEPIC_HTIC (5.0/EEPIC_UNIT)
	///#define EEPIC_VTIC (5.0/EEPIC_UNIT)
	///#define EEPIC_VCHAR (10.0/EEPIC_UNIT)
	///#define EEPIC_HCHAR (EEPIC_VCHAR/2.0)
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static unsigned int EEPIC_posx;
	//static unsigned int EEPIC_posy;
	//static enum JUSTIFY eepic_justify = LEFT;
	//static int eepic_angle = 0;
	//static int eepic_color_on = FALSE;		// use \color 
	//static int eepic_true_rotate = FALSE;		// use \rotatebox 
	//static int fontsize_set = FALSE;
	//
	// /* for DOTS point style */
	///#define EEPIC_TINY_DOT "\\rule{.1pt}{.1pt}"
	//
	// /* POINTS */
	//static int eepic_num_point_types[] = { 12, 10, 8 };
	//static int eepic_pointsize = 0;
	//static const char GPFAR *GPFAR EEPIC_points[][12] =
	//{
	//	{
	//		"\\makebox(0,0){$\\Diamond$}",
	//		"\\makebox(0,0){$+$}",
	//		"\\makebox(0,0){$\\Box$}",
	//		"\\makebox(0,0){$\\times$}",
	//		"\\makebox(0,0){$\\triangle$}",
	//		"\\makebox(0,0){$\\star$}",
	//		"\\circle{12}", "\\circle{18}", "\\circle{24}",
	//		"\\circle*{12}", "\\circle*{18}", "\\circle*{24}"
	//	},
	//	{
	//		"\\makebox(0,0){$\\scriptstyle\\Diamond$}",
	//		"\\makebox(0,0){$\\scriptstyle +$}",
	//		"\\makebox(0,0){$\\scriptstyle\\Box$}",
	//		"\\makebox(0,0){$\\scriptstyle\\times$}",
	//		"\\makebox(0,0){$\\scriptstyle\\triangle$}",
	//		"\\makebox(0,0){$\\scriptstyle\\star$}",
	//		"\\circle{12}", "\\circle{18}",
	//		"\\circle*{12}", "\\circle*{18}",
	//	},
	//	{
	//		"\\makebox(0,0){$\\scriptscriptstyle\\Diamond$}",
	//		"\\makebox(0,0){$\\scriptscriptstyle +$}",
	//		"\\makebox(0,0){$\\scriptscriptstyle\\Box$}",
	//		"\\makebox(0,0){$\\scriptscriptstyle\\times$}",
	//		"\\makebox(0,0){$\\scriptscriptstyle\\triangle$}",
	//		"\\makebox(0,0){$\\scriptscriptstyle\\star$}",
	//		"\\circle{12}",
	//		"\\circle*{12}",
	//	}
	//};
	//
	// /* LINES */
	//static int eepic_numlines[] = { 5, 7, 8 };	// number of linetypes below 
	///#define EEPIC_MAX_NUMLINES 8				// max of eepic_numlines[] 
	//static int eepic_lineset = 0;
	//static char GPFAR *GPFAR EEPIC_lines[][EEPIC_MAX_NUMLINES] =
	//{
	//	{
	//		"\\thicklines \\path",	// -2 border 
	//		"\\thinlines \\drawline[-50]",	// -1 axes 
	//		"\\thinlines \\path",	//  0 solid thin  
	//		"\\thicklines \\path",	//  1 solid thick 
	//		"\\Thicklines \\path"	//  2 solid Thick 
	//	},
	//	{
	//		"\\thicklines \\path",	// -2 border 
	//		"\\thinlines \\drawline[-50]",	// -1 axes 
	//		"\\thinlines \\path",	//  0 solid thin  
	//		"\\thinlines \\dashline[90]{10}",
	//		"\\thinlines \\dottedline{10}",
	//		"\\thinlines \\dashline[60]{20}",
	//		"\\thinlines \\dottedline{20}"
	//	},
	//	{
	//		"\\thicklines \\path",	// -2 border 
	//		"\\thinlines \\drawline[-50]",	// -1 axes 
	//		"\\thinlines \\path",
	//		"\\thinlines \\path",
	//		"\\thinlines \\path",
	//		"\\thinlines \\path",
	//		"\\thinlines \\path",
	//		"\\thinlines \\path"
	//	}
	//};
	//static int EEPIC_type;		// current line type 
	//static TBOOLEAN EEPIC_inline = FALSE;	// are we in the middle of a line 
	//static void EEPIC_endline __PROTO((void)); // terminate any line in progress 
	//static int EEPIC_linecount = 0;	// number of points in line so far 
	///#define EEPIC_LINEMAX 50	// max value for linecount 
	//
	///#define EEPIC_NUM_COLORS 7
	//static int eepic_color = 0;
	//static char GPFAR *GPFAR eepic_colors[EEPIC_NUM_COLORS] =
	//{
	//	"\\color{black}\n",	// border and axes (must be black!) 
	//	"\\color{red}\n",
	//	"\\color{blue}\n",
	//	"\\color{green}\n",
	//	"\\color{magenta}\n",
	//	"\\color{cyan}\n",
	//	"\\color{yellow}\n"
	//};
	//
	// /* ARROWS */
	// /* we use the same code as for LATEX */
	// /* figure out the best arrow */
	//static void best_latex_arrow __PROTO((int sx, int sy, int ex, int ey, int who, int head));
	//
	//TERM_PUBLIC void
	//EEPIC_init()
	//{
	//    EEPIC_posx = EEPIC_posy = 0;
	//	EEPIC_type = 0;
	//	EEPIC_linecount = 0;
	//	EEPIC_inline = FALSE;
	//	eepic_color = 0;
	//    fprintf(gpoutfile, "
	//%% GNUPLOT: LaTeX picture using EEPIC macros\n
	//\\setlength{\\unitlength}{%fpt}\n",
	//	    EEPIC_UNIT);
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_graphics()
	//{
	//    register struct termentry *t = term;
	//
	// /* HBB 20001027: respect 'size' and 'offset' settings to modify
	//  * picture box size and position */
	//    fprintf(gpoutfile, "\\begin{picture}(%d,%d)(%d,%d)\n",
	//	    (int) (t->xmax * xsize),
	//	    (int) (t->ymax * ysize),
	//	    (int) (t->xmax * xoffset),
	//	    (int) (t->ymax * xoffset));
	//    if (fontsize_set) {
	//	float x = t->v_char * EEPIC_UNIT + 0.5;
	//
	//	fprintf(gpoutfile, "\\fontsize{%d}{%g}\\selectfont\n",
	//		(int) x,  1.2 * x );
	//    } else
	//	fprintf(gpoutfile,"\\footnotesize\n" );
	//
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_text()
	//{
	//    EEPIC_endline();
	//    fputs("\\end{picture}\n", gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_linetype(int linetype)
	//{
	//    EEPIC_endline();
	//
	//    EEPIC_type = linetype % (eepic_numlines[eepic_lineset] - 2);
	//
	//	if ( eepic_color_on )
	//	{
	//		eepic_color = linetype;
	//		if ( eepic_color < 0 )
	//			eepic_color = 0;
	//		else
	//		{
	//			eepic_color %= EEPIC_NUM_COLORS - 1;
	//			eepic_color += 1;
	//		}
	//		fputs( eepic_colors[eepic_color], gpoutfile );
	//	}
	//}
	//
	//
	//
	//TERM_PUBLIC void
	//EEPIC_move(unsigned int x, unsigned int y)
	//{
	//    EEPIC_endline();
	//
	//    EEPIC_posx = x;
	//    EEPIC_posy = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_point(unsigned int x, unsigned int y, int number)
	//{
	//    EEPIC_move(x, y);
	//
	// /* Print the character defined by 'number'; number < 0 means
	//    to use a dot, otherwise one of the defined points. */
	//    fprintf(gpoutfile, "\\put(%d,%d){%s}\n", x, y,
	//	    (number < 0 ? EEPIC_TINY_DOT
	//	     : EEPIC_points[eepic_pointsize][number % eepic_num_point_types[eepic_pointsize]]));
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (!EEPIC_inline) {
	//	EEPIC_inline = TRUE;
	//
	// /* Start a new line. This depends on line type */
	//	fprintf(gpoutfile, "%s(%u,%u)",
	//		EEPIC_lines[eepic_lineset][EEPIC_type + 2],
	//		EEPIC_posx, EEPIC_posy);
	//	EEPIC_linecount = 1;
	//    } else {
	// /* Even though we are in middle of a path,
	//  * we may want to start a new path command.
	//  * If they are too long then latex will choke.
	//  */
	//	if (EEPIC_linecount++ >= EEPIC_LINEMAX) {
	//	    fprintf(gpoutfile, "\n%s(%u,%u)",
	//		    EEPIC_lines[eepic_lineset][EEPIC_type + 2],
	//		    EEPIC_posx, EEPIC_posy);
	//	    EEPIC_linecount = 1;
	//	}
	//    }
	//    fprintf(gpoutfile, "(%u,%u)", ux, uy);
	//    EEPIC_posx = ux;
	//    EEPIC_posy = uy;
	//}
	//
	//static void
	//EEPIC_endline()
	//{
	//    if (EEPIC_inline) {
	//	putc('\n', gpoutfile);
	//	EEPIC_inline = FALSE;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    best_latex_arrow(sx, sy, ex, ey, 2, head);	// call latex routine 
	//
	//    EEPIC_posx = ex;
	//    EEPIC_posy = ey;
	//}
	//
	//
	//TERM_PUBLIC void
	//EEPIC_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    int i, l;
	//
	//    EEPIC_endline();
	//
	//    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
	//    if ((str[0] == '{') || (str[0] == '[')) {
	//	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
	//    }
	//    else
	//    switch (eepic_angle)
	//    {
	//	case 0:
	//	{
	//	   switch (eepic_justify) {
	//	       case LEFT:
	//		   fputs("{\\makebox(0,0)[l]{",gpoutfile);
	//		   break;
	//	       case CENTRE:
	//		   fputs("{\\makebox(0,0){",gpoutfile);
	//		   break;
	//	       case RIGHT:
	//		   fputs("{\\makebox(0,0)[r]{",gpoutfile);
	//		   break;
	//	   }
	//	   fprintf(gpoutfile,"%s}}\n", str);
	//	   break;
	//	}
	//	case 1:
	//	{
	//	   if ( eepic_true_rotate )
	//	   {
	// /* use \rotatebox */
	//	       switch (eepic_justify) {
	//		   case LEFT:
	//		       fputs("{\\makebox(0,0)[lb]{\\rotatebox[origin=c]{90}{",
	//			     gpoutfile);
	//		       break;
	//		   case CENTRE:
	//		       fputs("{\\makebox(0,0)[l]{\\rotatebox[origin=c]{90}{",
	//			     gpoutfile);
	//		       break;
	//		   case RIGHT:
	//		       fputs("{\\makebox(0,0)[lt]{\\rotatebox[origin=c]{90}{",
	//			     gpoutfile);
	//		       break;
	//	       }
	//	       fprintf(gpoutfile,"%s}}}\n", str);
	//	   }
	//	   else
	//	   {
	// /* put text in a short stack */
	//	       switch (eepic_justify) {
	//		   case LEFT:
	//		       fputs("{\\makebox(0,0)[lb]{\\shortstack{",gpoutfile);
	//		       break;
	//		   case CENTRE:
	//		       fputs("{\\makebox(0,0)[l]{\\shortstack{",gpoutfile);
	//		       break;
	//		   case RIGHT:
	//		       fputs("{\\makebox(0,0)[lt]{\\shortstack{",gpoutfile);
	//		       break;
	//	       }
	//	       l = strlen(str)-1;
	//	       for ( i = 0; i < l; i ++ )
	//		   fprintf(gpoutfile, "%c\\\\", str[i] );
	//	       fputc(str[l],gpoutfile);
	//	       fputs("}}}\n",gpoutfile);
	//	   }
	//	   break;
	//       }
	//    }
	//}
	//
	//
	//
	//TERM_PUBLIC int
	//EEPIC_justify_text(enum JUSTIFY mode)
	//{
	//    eepic_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//EEPIC_text_angle(int ang)
	//{
	//    eepic_angle = (ang ? 1 : 0);
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//EEPIC_reset()
	//{
	//    EEPIC_endline();
	//    EEPIC_posx = EEPIC_posy = 0;
	//}
	//
	//TERM_PUBLIC void
	//EEPIC_options()
	//{
	//    float fontsize = 0;
	//
	//    eepic_color_on =
	//    eepic_true_rotate = FALSE;
	//    eepic_lineset = 0;
	//    eepic_pointsize = 0;
	//
	//    while (!END_OF_COMMAND) {
	//	if (almost_equals(c_token, "de$fault")) {
	//	    fontsize_set = FALSE;
	//	    eepic_color_on = FALSE;
	//	    eepic_true_rotate = FALSE;
	//	    eepic_lineset = 0;
	//	    eepic_pointsize = 0;
	//	    c_token++;
	//	} else if (almost_equals(c_token, "c$olor") ||
	//		   almost_equals(c_token, "c$olour")) {
	//	    eepic_color_on = TRUE;
	//	    eepic_lineset = 2;
	//	    c_token++;
	//	} else if (almost_equals(c_token, "r$otate")) {
	//	    eepic_true_rotate = TRUE;
	//	    c_token++;
	//	} else if (almost_equals(c_token, "da$shed")) {
	//	    if (! eepic_color_on)
	//		eepic_lineset = 1;	// ignore when color is on 
	//	    c_token++;
	//	} else if (almost_equals(c_token, "s$mall")) {
	//	    eepic_pointsize = 1;
	//	    c_token++;
	//	} else if (almost_equals(c_token, "t$iny")) {
	//	    eepic_pointsize = 2;
	//	    c_token++;
	//	} else if (isdigit((unsigned char)
	//			   gp_input_line[token[c_token].start_index])) {
	//	    struct value a;
	//	    fontsize = real(const_express(&a));
	//
	//	    if (fontsize < 1 || fontsize > 100)
	//		int_error(c_token, "font size out of bounds [1..100]");
	//	    else {
	//		fontsize_set = TRUE;
	//		term->v_char = (unsigned int)(fontsize/EEPIC_UNIT);
	//		term->h_char = (unsigned int)((fontsize/EEPIC_UNIT)/2);
	//	    }
	//	} else
	//	    int_error(c_token, "unrecognized option");
	//    } // while(command) 
	//
	//    sprintf(term_options, "default%s%s%s%s",
	//	    eepic_color_on ? " color" : "",
	//	    eepic_lineset == 1 ? " dashed" : "",
	//	    eepic_true_rotate ? " rotate" : "",
	//	    eepic_pointsize == 1 ? " small"
	//	    : eepic_pointsize == 2 ? " tiny" : "" );
	//    if (fontsize_set)
	//	sprintf( term_options+strlen(term_options), " %d", (int) fontsize );
	//}
	//
	///#endif

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(eepic_driver)
	//    "eepic", "EEPIC -- extended LaTeX picture environment",
	//    EEPIC_XMAX, EEPIC_YMAX, EEPIC_VCHAR, EEPIC_HCHAR,
	//    EEPIC_VTIC, EEPIC_HTIC, EEPIC_options, EEPIC_init, EEPIC_reset,
	//    EEPIC_text, null_scale, EEPIC_graphics, EEPIC_move, EEPIC_vector,
	//    EEPIC_linetype, EEPIC_put_text, EEPIC_text_angle,
	//    EEPIC_justify_text, EEPIC_point, EEPIC_arrow, set_font_null,
	//    0, // pointsize 
	//    0, // flags 
	//    0, 0, // suspend, resume 
	//    0, // fillbox 
	//    0  // linewidth 
	//TERM_TABLE_END(eepic_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM eepic_driver
	//
	///#endif
	///#endif

	///#ifdef TERM_HELP
	//START_HELP(eepic)
	//"1 eepic",
	//"?commands set terminal eepic",
	//"?set terminal eepic",
	//"?set term eepic",
	//"?terminal eepic",
	//"?term eepic",
	//"?eepic",
	//" The `eepic` terminal driver supports the extended LaTeX picture environment.",
	//" It is an alternative to the `latex` driver.",
	//"",
	//" The output of this terminal is intended for use with the \"eepic.sty\" macro",
	//" package for LaTeX.  To use it, you need \"eepic.sty\", \"epic.sty\" and a",
	//" printer driver that supports the \"tpic\" \\specials.  If your printer driver",
	//" doesn't support those \\specials, \"eepicemu.sty\" will enable you to use some",
	//" of them.",
	//" dvips and dvipdfm do support the \"tpic\" \\specials.",
	//"",
	//" Syntax:",
	//"    set terminal eepic {color, dashed, rotate, small, tiny, default, <fontsize>}",
	//"",
	//" Options:",
	//" You can give options in any order you wish.",
	//" 'color' causes gnuplot to produce \\color{...} commands so that the graphs are",
	//" colored. Using this option, you must include \\usepackage{color} in the preambel",
	//" of your latex document.",
	//" 'dashed' will allow dashed line types; without this option, only solid lines",
	//" with varying thickness will be used.",
	//" 'dashed' and 'color' are mutually exclusive; if 'color' is specified, then 'dashed'",
	//" will be ignored.",
	//" 'rotate' will enable true rotated text (by 90 degrees). Otherwise, rotated text",
	//" will be typeset with letters stacked above each other. If you use this option",
	//" you must include \\usepackage{graphicx} in the preamble.",
	//" 'small' will use \\scriptsize symbols as point markers (Probably does not work",
	//" with TeX, only LaTeX2e). Default is to use the default math size.",
	//" 'tiny' uses \\scriptscriptstyle symbols.",
	//" 'default' resets all options to their defaults = no color, no dashed lines,",
	//" pseudo-rotated (stacked) text, large point symbols.",
	//" <fontsize> is a number which specifies the font size inside the picture",
	//" environment; the unit is pt (points), i.e., 10 pt equals approx. 3.5 mm.",
	//" If fontsize is not specified, then all text inside the picture will be set",
	//" in \\footnotesize.",
	//"",
	//" Notes:",
	//" Remember to escape the # character (or other chars meaningful to (La-)TeX)",
	//" by \\\\ (2 backslashes).",
	//" It seems that dashed lines become solid lines when the vertices of a plot",
	//" are too close. (I do not know if that is a general problem with the tpic specials,",
	//" or if it is caused by a bug in eepic.sty or dvips/dvipdfm.)",
	//" The default size of an eepic plot is 5x3 inches, which can be scaled ",
	//" by 'set size a,b'.",
	//" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\",",
	//" \"\\Box\", etc.  These commands no longer belong to the LaTeX2e core; they are",
	//" included in the latexsym package, which is part of the base distribution and",
	//" thus part of any LaTeX implementation. Please do not forget to use this package.",
	//" Instead of latexsym, you can also include the amssymb package.",
	//" All drivers for LaTeX offer a special way of controlling text positioning:",
	//" If any text string begins with '{', you also need to include a '}' at the",
	//" end of the text, and the whole text will be centered both horizontally and",
	//" vertically.  If the text string begins with '[', you need to follow this with",
	//" a position specification (up to two out of t,b,l,r), ']{', the text itself,",
	//" and finally '}'.  The text itself may be anything LaTeX can typeset as an",
	//" LR-box.  '\\rule{}{}'s may help for best positioning.",
	//"",
	//" Examples:",
	//" set term eepic",
	//"   output graphs as eepic macros inside a picture environment;",
	//"   \\input the resulting file in your LaTeX document.",
	//" set term eepic color tiny rotate 8",
	//"   eepic macros with \\color macros, \\scripscriptsize point markers,",
	//"   true rotated text, and all text set with 8pt.",
	//"",
	//" About label positioning:",
	//" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
	//"        set title '\\LaTeX\\ -- $ \\gamma $'",
	//" Force centering both horizontally and vertically:",
	//"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
	//" Specify own positioning (top here):",
	//"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
	//" The other label -- account for long ticlabels:",
	//"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
	//END_HELP(eepic)
	///#endif // TERM_HELP 


	/* TPIC specials for TeX */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: tpic.trm,v 1.21 2006/07/21 02:35:48 sfeam Exp $
	 */

	/* GNUPLOT - tpic.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   The tpic \specials (version 2.2) for LaTeX.
	 *
	 * AUTHORS
	 *   Oh-Yeah?   3 Sep. 1992 (closely following eepic.trm by David Kotz)
	 *   A. Woo     5 Oct. 1992 (removed ansi prototypes for braindead compilers)
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */
	/*
	 *  This file contains the tpic terminal driver for use with LaTeX.
	 *  This is an alternative to the latex and eepic drivers. You need
	 *  a printer driver that supports the tpic \specials version 2.2.
	 *
	 * Comparison with the eepic driver (eepic.trm):
	 *  Merits
	 *    - More point and line types
	 *    - Options to change point size, linewidth, dot & dash intervals
	 *    - Dotted and dashed lines for high-sample-rate curves (but may
	 *      depend on tpic (da & dt) implementation of your dvi driver :-)
	 *    - Overlapped points made fancier by tpic shading facility
	 *    - Optional comments for trimming figure margins
	 *    - No need for epic and eepic macros
	 *  Drawback
	 *    - You cannot use eepicemu macro for non-tpic-support dvi drivers
	 *
	 * LATEX must also be defined.
	 */


	/* These parameters can be modified as you like, through options.  Say
	   "set terminal tpic <pointsize> <linewidth> <interval>".  <pointsize>
	   and <linewidth> are integers in milli-inches; <interval> is a float
	   in inches.  If non-positive value is specified, the default (below)
	   is chosen.
	*/

	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 */


	///#ifdef TERM_REGISTER
	//register_term(tpic)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void TPIC_options __PROTO((void));		// get size options 
	//TERM_PUBLIC void TPIC_init __PROTO((void));
	//TERM_PUBLIC void TPIC_reset __PROTO((void));
	//TERM_PUBLIC void TPIC_text __PROTO((void));
	//TERM_PUBLIC void TPIC_graphics __PROTO((void));
	//TERM_PUBLIC void TPIC_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TPIC_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void TPIC_linetype __PROTO((int linetype));
	//TERM_PUBLIC void TPIC_put_text __PROTO((unsigned int x, unsigned int y, const char *str));	// ref point and text 
	//TERM_PUBLIC int TPIC_text_angle __PROTO((int ang));
	//TERM_PUBLIC int TPIC_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC void TPIC_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void TPIC_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
	//
	// /* tpic \specials unit in inches (1 milli-inch) */
	///#define TPIC_UNIT 0.001
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define TPIC_XMAX (unsigned int) (5 / TPIC_UNIT)
	///#define TPIC_YMAX (unsigned int) (3 / TPIC_UNIT)
	///#define TPIC_PTS_PER_UNIT (72.27 * TPIC_UNIT)
	///#define TPIC_HTIC  (unsigned int) ( 5.0 / TPIC_PTS_PER_UNIT)	// 5pt 
	///#define TPIC_VTIC  (unsigned int) ( 5.0 / TPIC_PTS_PER_UNIT)	// 5pt 
	///#define TPIC_HCHAR (unsigned int) ( 5.3 / TPIC_PTS_PER_UNIT)	// 5.3pt 
	///#define TPIC_VCHAR (unsigned int) (11.0 / TPIC_PTS_PER_UNIT)	// 11pt 
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static int tpic_pointsize = 40;	// min point radius   (in milli-inches) 
	//static int tpic_linewidth = 6;	// min line thickness (in milli-inches) 
	//static double tpic_interval = 0.1;	// min dot & dash intervals (in inches) 
	//
	// /* ARROWS: same code as for LATEX */
	// /* figure out the best arrow. in latex.trm */
	//static void best_latex_arrow __PROTO((int sx, int sy, int ex, int ey, int who, int head));
	//
	// /* all prototypes ... */
	//static void tpic_startline __PROTO((void));
	//static void tpic_endline __PROTO((void));
	//static void tpic_pushpath __PROTO((unsigned int x, unsigned int y));
	//static void tpic_scanpath __PROTO((void));
	//static void tpic_diamond __PROTO((int size));
	//static void tpic_plus __PROTO((int size));
	//static void tpic_box __PROTO((int size));
	//static void tpic_times __PROTO((int size));
	//static void tpic_triangle __PROTO((int size));
	//static void tpic_star __PROTO((int size));
	//static void tpic_hexagon __PROTO((int size));
	//static void tpic_circle __PROTO((int size));
	//static void tpic_doublecircle __PROTO((int size));
	//static void tpic_vercircle __PROTO((int size));	// circle with | 
	//static void tpic_horcircle __PROTO((int size));	// circle with - 
	//static void tpic_pluscircle __PROTO((int size));	// circle with + 
	//static void tpic_timescircle __PROTO((int size));	// circle with times 
	//static void tpic_starcircle __PROTO((int size));	// circle with star 
	//static void tpic_dotcircle __PROTO((int size));	// circle with dot (black circle) 
	//static void tpic_diamondcircle __PROTO((int size)); // circle with black diamond 
	//static void tpic_boxcircle __PROTO((int size));	// circle with black box 
	//static void tpic_trianglecircle __PROTO((int size));	// circle with black triangle 
	//static void tpic_hexagoncircle __PROTO((int size));	// circle with black hexagon 
	//static void tpic_plustimescircle __PROTO((int size));	// no more idea ... with plus & times 
	//static void tpic_abspath __PROTO((unsigned int x, unsigned int y));	// absolute coord 
	//static void tpic_path __PROTO((int x, int y));
	//static void tpic_flush __PROTO((void));
	//static void tpic_arc __PROTO((int radius));	// actually, draw a full circle 
	//static void tpic_shade __PROTO((double grayscale));
	//static void tpic_pen __PROTO((int thickness));
	//static void tpic_dottedflush __PROTO((double interval));
	//static void tpic_dashedflush __PROTO((double interval));
	//
	//typedef enum {
	//    tpic_none, tpic_white, tpic_gray, tpic_black
	//} tpic_shadestyle;
	//typedef enum {
	//    tpic_nosize, tpic_small, tpic_medium, tpic_large
	//} tpic_size;
	//typedef void (*tpic_function) __PROTO((int size));
	//
	//typedef struct {
	//    tpic_shadestyle shadestyle;
	//    tpic_size size;
	//    tpic_function function;
	//} tpic_point_info;
	//
	// /* POINTS */
	//static //GPFAR 
	// tpic_point_info GPFAR tpic_point[] =
	//{
	//    {tpic_white, tpic_medium, tpic_diamond},
	//    {tpic_none, tpic_medium, tpic_plus},
	//    {tpic_white, tpic_medium, tpic_box},
	//    {tpic_none, tpic_medium, tpic_times},
	//    {tpic_white, tpic_medium, tpic_triangle},
	//    {tpic_none, tpic_medium, tpic_star},
	//    {tpic_white, tpic_small, tpic_circle},
	//    {tpic_white, tpic_medium, tpic_circle},
	//    {tpic_white, tpic_large, tpic_circle},
	//    {tpic_black, tpic_small, tpic_circle},
	//    {tpic_black, tpic_medium, tpic_circle},
	//    {tpic_black, tpic_large, tpic_circle},
	//    {tpic_black, tpic_medium, tpic_diamond},
	//    {tpic_black, tpic_medium, tpic_box},
	//    {tpic_black, tpic_medium, tpic_triangle},
	//    {tpic_white, tpic_medium, tpic_hexagon},
	//    {tpic_black, tpic_medium, tpic_hexagon},
	//    {tpic_white, tpic_medium, tpic_doublecircle},
	//    {tpic_white, tpic_medium, tpic_vercircle},
	//    {tpic_white, tpic_medium, tpic_horcircle},
	//    {tpic_white, tpic_medium, tpic_pluscircle},
	//    {tpic_white, tpic_medium, tpic_timescircle},
	//    {tpic_white, tpic_medium, tpic_starcircle},
	//    {tpic_black, tpic_medium, tpic_doublecircle},
	//    {tpic_white, tpic_medium, tpic_dotcircle},
	//    {tpic_white, tpic_medium, tpic_diamondcircle},
	//    {tpic_white, tpic_medium, tpic_boxcircle},
	//    {tpic_white, tpic_medium, tpic_trianglecircle},
	//    {tpic_white, tpic_medium, tpic_hexagoncircle},
	//    {tpic_white, tpic_medium, tpic_plustimescircle}
	//};
	//
	//typedef enum {
	//    tpic_solid, tpic_dotted, tpic_dashed,
	//    tpic_dashed_sdot, tpic_dashed_ddot
	//} tpic_linestyle;
	//typedef struct {
	//    tpic_size thickness, interval;
	//    tpic_linestyle linestyle;
	//} tpic_line_info;
	//
	// /* LINES */
	//static //GPFAR 
	// tpic_line_info GPFAR tpic_line[] =
	//{
	//    {tpic_medium, tpic_nosize, tpic_solid},	// -2 border 
	//    {tpic_small, tpic_small, tpic_dashed},	// -1 axes 
	//    {tpic_small, tpic_nosize, tpic_solid},
	//    {tpic_medium, tpic_nosize, tpic_solid},
	//    {tpic_large, tpic_nosize, tpic_solid},
	//    {tpic_small, tpic_small, tpic_dotted},
	//    {tpic_medium, tpic_small, tpic_dotted},
	//    {tpic_large, tpic_small, tpic_dotted},
	//    {tpic_small, tpic_small, tpic_dashed},
	//    {tpic_medium, tpic_small, tpic_dashed},
	//    {tpic_large, tpic_small, tpic_dashed},
	//    {tpic_small, tpic_small, tpic_dashed_sdot},		// dash with single dots 
	//    {tpic_medium, tpic_small, tpic_dashed_sdot},
	//    {tpic_large, tpic_small, tpic_dashed_sdot},
	//    {tpic_small, tpic_small, tpic_dashed_ddot},		// dash with double dots 
	//    {tpic_medium, tpic_small, tpic_dashed_ddot},
	//    {tpic_large, tpic_small, tpic_dashed_ddot},
	//    {tpic_small, tpic_medium, tpic_dotted},
	//    {tpic_medium, tpic_medium, tpic_dotted},
	//    {tpic_large, tpic_medium, tpic_dotted},
	//    {tpic_small, tpic_medium, tpic_dashed},
	//    {tpic_medium, tpic_medium, tpic_dashed},
	//    {tpic_large, tpic_medium, tpic_dashed},
	//    {tpic_small, tpic_medium, tpic_dashed_sdot},
	//    {tpic_medium, tpic_medium, tpic_dashed_sdot},
	//    {tpic_large, tpic_medium, tpic_dashed_sdot},
	//    {tpic_small, tpic_medium, tpic_dashed_ddot},
	//    {tpic_medium, tpic_medium, tpic_dashed_ddot},
	//    {tpic_large, tpic_medium, tpic_dashed_ddot},
	//    {tpic_small, tpic_large, tpic_dotted},
	//    {tpic_medium, tpic_large, tpic_dotted},
	//    {tpic_large, tpic_large, tpic_dotted},
	//    {tpic_small, tpic_large, tpic_dashed},
	//    {tpic_medium, tpic_large, tpic_dashed},
	//    {tpic_large, tpic_large, tpic_dashed},
	//    {tpic_small, tpic_large, tpic_dashed_sdot},
	//    {tpic_medium, tpic_large, tpic_dashed_sdot},
	//    {tpic_large, tpic_large, tpic_dashed_sdot},
	//    {tpic_small, tpic_large, tpic_dashed_ddot},
	//    {tpic_medium, tpic_large, tpic_dashed_ddot},
	//    {tpic_large, tpic_large, tpic_dashed_ddot}
	//};
	//
	//TERM_PUBLIC void
	//TPIC_options()
	//{				// get size options 
	//    struct value a;
	//    int ptsize, linewidth;
	//    double interval;
	//
	//    if (!END_OF_COMMAND) {
	//	ptsize = (int) real(const_express(&a));
	//	if (ptsize > 0)
	//	    tpic_pointsize = ptsize;
	//    }
	//    if (!END_OF_COMMAND) {
	//	linewidth = (int) real(const_express(&a));
	//	if (linewidth > 0)
	//	    tpic_linewidth = linewidth;
	//    }
	//    if (!END_OF_COMMAND) {
	//	interval = (double) real(const_express(&a));
	//	if (interval > 0)
	//	    tpic_interval = interval;
	//    }
	//    sprintf(term_options, "%d %d %f", tpic_pointsize, tpic_linewidth,
	//	    tpic_interval);
	//}
	//
	//static unsigned int tpic_posx;	// current position 
	//static unsigned int tpic_posy;
	//static int tpic_point_types;
	//static int tpic_numlines;
	//
	//TERM_PUBLIC void
	//TPIC_init()
	//{
	//    static char GPFAR tpic1[] = "
	//%% GNUPLOT: LaTeX picture using tpic \\specials\n
	//%%          with %d point types and %d line types\n
	//%% Options: pointsize = %d, linewidth = %d, interval = %f\n
	//%% To change above options, say:\n
	//%% set terminal tpic pointsize_value linewidth_value interval_value\n
	//%% (pointsize and linewidth - integers in milli-inches.\n
	//%%  interval - a float in inches.  If zero is specified, \n
	//%%  the default value is chosen.)\n
	//\\setlength{\\unitlength}{%fin}%%\n";
	//    tpic_point_types = sizeof(tpic_point) / sizeof(tpic_point[0]);
	//    tpic_numlines = sizeof(tpic_line) / sizeof(tpic_line[0]);
	//
	//    tpic_posx = tpic_posy = 0;
	//    TPIC_linetype(-1);
	//    fprintf(gpoutfile, tpic1,
	//	    tpic_point_types, tpic_numlines - 2,
	//	    tpic_pointsize, tpic_linewidth, tpic_interval,
	//	    TPIC_UNIT);
	//}
	//
	//TERM_PUBLIC void
	//TPIC_reset()
	//{
	//    tpic_endline();
	//    tpic_posx = tpic_posy = 0;
	//}
	//
	//TERM_PUBLIC void
	//TPIC_text()
	//{
	//    tpic_endline();
	//    fputs("\\end{picture}\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//TPIC_graphics()
	//{
	//    register struct termentry *t = term;
	//    int left, right, top, bottom;	// margins 
	//    static char GPFAR begin[] = "%s\\begin{picture}(%d,%d)(%d,%d)%% %s\n";
	//
	//    fprintf(gpoutfile, begin, "", t->xmax, t->ymax, 0, 0, "");
	//
	// /* the following is dependent on boundary() function in graphics.c */
	//    left = TPIC_HCHAR * 12;
	//    right = TPIC_HCHAR * 2 + TPIC_HTIC;
	//    bottom = TPIC_VCHAR * 7 / 2 + 1;
	//    top = TPIC_VCHAR * 5 / 2 - 1;
	//    fprintf(gpoutfile, begin, "%% ", t->xmax - left, t->ymax, left, 0,
	//	    "trim left margin");
	//    fprintf(gpoutfile, begin, "%% ", t->xmax - right, t->ymax, 0, 0,
	//	    "trim right margin");
	//    fprintf(gpoutfile, begin, "%% ", t->xmax - left - right, t->ymax, left, 0,
	//	    "trim left & right margins");
	//    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - top, 0, 0,
	//	    "trim top margin");
	//    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - bottom, 0, bottom,
	//	    "trim bottom margin");
	//    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - top - bottom, 0, bottom,
	//	    "trim top & bottom margins");
	//
	//    fputs("\\footnotesize%\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//TPIC_move(unsigned int x, unsigned int y)
	//{
	//    tpic_endline();
	//    tpic_posx = x;
	//    tpic_posy = y;
	//}
	//
	///#define TPIC_LINEMAX 100	// max value for linecount 
	//static TBOOLEAN tpic_inline = FALSE;	// are we in the middle of a line 
	//static int tpic_linecount = 0;	// number of points in line so far 
	//
	//TERM_PUBLIC void
	//TPIC_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (!tpic_inline) {
	//	tpic_startline();
	//    } else if (tpic_linecount >= TPIC_LINEMAX) {
	// /* Even though we are in middle of a path, we may start a new path
	//    command once in a while; if they are too long, latex will choke. */
	//	tpic_endline();
	//	tpic_startline();
	//    }
	//    tpic_pushpath(ux, uy);
	//    tpic_posx = ux;
	//    tpic_posy = uy;
	//}
	//
	//static int tpic_linetype;	// current line type 
	//
	//static void
	//tpic_startline()
	//{				// private 
	//    int thickness = 1;
	//
	//    tpic_inline = TRUE;
	//    switch (tpic_line[tpic_linetype + 2].thickness) {
	//    case tpic_small:
	//	thickness = tpic_linewidth;
	//	break;
	//    case tpic_medium:
	//	thickness = (int) (tpic_linewidth * 3);
	//	break;
	//    case tpic_large:
	//	thickness = (int) (tpic_linewidth * 5);
	//	break;
	//    default:
	//	break;
	//    }
	//    tpic_pen(thickness);
	//    tpic_linecount = 0;
	//    tpic_pushpath(tpic_posx, tpic_posy);
	//    return;
	//}
	//
	//static void
	//tpic_endline()
	//{				// private 
	//    double interval = 1;
	//
	//    if (tpic_inline) {
	//	tpic_scanpath();	// draw actually 
	//	switch (tpic_line[tpic_linetype + 2].interval) {
	//	case tpic_small:
	//	    interval = tpic_interval;
	//	    break;
	//	case tpic_medium:
	//	    interval = tpic_interval * 2;
	//	    break;
	//	case tpic_large:
	//	    interval = tpic_interval * 3;
	//	    break;
	//	case tpic_nosize:
	//	    break;
	//	}
	//	switch (tpic_line[tpic_linetype + 2].linestyle) {
	//	case tpic_solid:
	//	    tpic_flush();
	//	    break;
	//	case tpic_dotted:
	//	    tpic_dottedflush(interval);
	//	    break;
	//	case tpic_dashed:
	//	    tpic_dashedflush(interval);
	//	    break;
	//	case tpic_dashed_sdot:	// dashed with single dots in between 
	//	    tpic_dashedflush(interval);
	//	    tpic_scanpath();	// draw again 
	//	    tpic_dottedflush(interval / 2);
	//	    break;
	//	case tpic_dashed_ddot:	// dashed with double dots in between 
	//	    tpic_dashedflush(interval);
	//	    tpic_scanpath();	// draw again 
	//	    tpic_dottedflush(interval / 3);
	//	    break;
	//	}
	//	tpic_inline = FALSE;
	//    }
	//    return;
	//}
	//
	// /* private: stack functions */
	//static unsigned int pathpoint[TPIC_LINEMAX][2];		// point stack 
	//
	//static void
	//tpic_pushpath(unsigned int x, unsigned int y)
	//{
	//    if (tpic_linecount < TPIC_LINEMAX) {
	//	pathpoint[tpic_linecount][0] = x;
	//	pathpoint[tpic_linecount][1] = y;
	//	tpic_linecount++;
	//    }
	//    return;
	//}
	//
	//static void
	//tpic_scanpath()
	//{
	//    int i;
	//
	//    for (i = 0; i < tpic_linecount; i++)
	//	tpic_abspath(pathpoint[i][0], pathpoint[i][1]);
	//    return;
	//}
	//
	//TERM_PUBLIC void
	//TPIC_linetype(int linetype)
	//{
	//    tpic_endline();
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//    if (linetype >= tpic_numlines - 2)
	//	linetype %= (tpic_numlines - 2);
	//    tpic_linetype = linetype;
	//}
	//
	//static int tpic_angle = 0;	// 0 = horizontal, 1 = vertical 
	//static enum JUSTIFY tpic_justify = LEFT;
	//
	//TERM_PUBLIC void
	//TPIC_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    char *justify = NULL;
	//
	//    tpic_endline();
	//    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
	//
	//    if ((str[0] == '{') || (str[0] == '[')) {
	//	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
	//    } else
	//	switch (tpic_angle) {
	//	case 0:		// horizontal 
	//	    switch (tpic_justify) {
	//	    case LEFT:
	//		justify = "[l]";
	//		break;
	//	    case CENTRE:
	//		justify = "";
	//		break;
	//	    case RIGHT:
	//		justify = "[r]";
	//		break;
	//	    }
	//	    fprintf(gpoutfile, "{\\makebox(0,0)%s{%s}}\n", justify, str);
	//	    break;
	//	case 1:		// vertical 
	// /* we can't really write text vertically, but will put the ylabel
	//    centred at the left of the plot, and then we'll make a \shortstack */
	//	    switch (tpic_justify) {
	//	    case LEFT:
	//		justify = "[lb]";
	//		break;
	//	    case CENTRE:
	//		justify = "[l]";
	//		break;
	//	    case RIGHT:
	//		justify = "[lt]";
	//		break;
	//	    }
	//	    fprintf(gpoutfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
	//		    justify, str);
	//	    break;
	//	}
	//}
	//
	//TERM_PUBLIC int
	//TPIC_text_angle(int ang)
	//{
	//    tpic_angle = (ang ? 1 : 0);
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//TPIC_justify_text(enum JUSTIFY mode)
	//{
	//    tpic_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//TPIC_point(unsigned int x, unsigned int y, int number)
	//{
	//    int size = 0;
	//
	//    TPIC_move(x, y);
	//
	// /* Print the character defined by 'number'; number < 0 means
	//    to use a dot, otherwise one of the defined points. */
	//
	//    fprintf(gpoutfile, "\\put(%d,%d){", x, y);	// start putting 
	//
	//    if (number < 0) {
	//	fputs("\\rule{.1pt}{.1pt}", gpoutfile);	// tiny dot 
	//    } else {
	//	number %= tpic_point_types;
	//	switch (tpic_point[number].shadestyle) {
	//	case tpic_white:
	//	    tpic_pen(tpic_linewidth);	// set it thin 
	//	    tpic_shade(0.0);
	//	    break;
	//	case tpic_gray:
	//	    tpic_pen(tpic_linewidth);
	//	    tpic_shade(0.5);
	//	    break;
	//	case tpic_black:
	//	    tpic_pen(tpic_linewidth);
	//	    tpic_shade(1.0);
	//	    break;
	//	case tpic_none:
	//	    tpic_pen(tpic_linewidth * 3);	// set it thick 
	//	    break;
	//	}
	//	switch (tpic_point[number].size) {
	//	case tpic_small:
	//	    size = tpic_pointsize;
	//	    break;
	//	case tpic_medium:
	//	    size = (int) (tpic_pointsize * 1.4142);
	//	    break;
	//	case tpic_large:
	//	    size = (int) (tpic_pointsize * 2.0);
	//	    break;
	//	default:
	//	    break;
	//	}
	//	(tpic_point[number].function) (size);
	//    }
	//
	//    fputs("}%%\n", gpoutfile);	// end putting 
	//}
	//
	//TERM_PUBLIC void
	//TPIC_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    best_latex_arrow(sx, sy, ex, ey, 1, head);	// call latex routine 
	//    tpic_posx = ex;
	//    tpic_posy = ey;
	//}
	//
	// /* private: draw points with tpic commands */
	//
	//static void
	//tpic_diamond(int size)
	//{
	//    size = (int) (size * 1.4142);	// spread by sqrt(2) 
	//
	//    tpic_path(0, size);
	//    tpic_path(-size, 0);
	//    tpic_path(0, -size);
	//    tpic_path(size, 0);
	//    tpic_path(0, size);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_plus(int size)
	//{
	//    tpic_path(0, size);
	//    tpic_path(0, -size);
	//    tpic_flush();
	//    tpic_path(size, 0);
	//    tpic_path(-size, 0);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_box(int size)
	//{
	//    tpic_path(size, size);
	//    tpic_path(-size, size);
	//    tpic_path(-size, -size);
	//    tpic_path(size, -size);
	//    tpic_path(size, size);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_times(int size)
	//{
	//    size = (int) (size / 1.4142);	// reduce by sqrt(2) 
	//
	//    tpic_path(size, size);
	//    tpic_path(-size, -size);
	//    tpic_flush();
	//    tpic_path(size, -size);
	//    tpic_path(-size, size);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_triangle(int size)
	//{
	//    int x;
	//
	//    size = (int) (size / 1.6119);	// reduce by sqrt(3 * sqrt(3) / 2) 
	//    x = (int) (size * 1.7321);
	//
	//    tpic_path(0, -size * 2);
	//    tpic_path(-x, size);
	//    tpic_path(x, size);
	//    tpic_path(0, -size * 2);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_star(int size)
	//{
	//    int x;
	//
	//    size = (int) (size / 2);	// reduce by 2 
	//    x = (int) (size * 1.7321);
	//
	//    tpic_path(0, size * 2);
	//    tpic_path(0, -size * 2);
	//    tpic_flush();
	//    tpic_path(x, size);
	//    tpic_path(-x, -size);
	//    tpic_flush();
	//    tpic_path(x, -size);
	//    tpic_path(-x, size);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_hexagon(int size)
	//{
	//    int x;
	//
	//    size = (int) (size / 2);	// reduce by 2 
	//    x = (int) (size * 1.7321);
	//
	//    tpic_path(0, size * 2);
	//    tpic_path(-x, size);
	//    tpic_path(-x, -size);
	//    tpic_path(0, -size * 2);
	//    tpic_path(x, -size);
	//    tpic_path(x, size);
	//    tpic_path(0, size * 2);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_circle(int size)
	//{
	//    tpic_arc(size);
	//    return;
	//}
	//
	//static void
	//tpic_doublecircle(int size)
	//{
	//    tpic_arc(size);
	//    tpic_shade(0.0);
	//    tpic_arc(size / 2);
	//    return;
	//}
	//
	//static void
	//tpic_vercircle(int size)			// circle with | 
	//{
	//    tpic_arc(size);
	//    tpic_path(0, size);
	//    tpic_path(0, -size);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_horcircle(int size)			// circle with - 
	//{
	//    tpic_arc(size);
	//    tpic_path(size, 0);
	//    tpic_path(-size, 0);
	//    tpic_flush();
	//    return;
	//}
	//
	//static void
	//tpic_pluscircle(int size)			// circle with + 
	//{
	//    tpic_arc(size);
	//    tpic_plus(size);
	//    return;
	//}
	//
	//static void
	//tpic_timescircle(int size)			// circle with times 
	//{
	//    tpic_arc(size);
	//    tpic_times(size);
	//    return;
	//}
	//
	//static void
	//tpic_starcircle(int size)			// circle with star 
	//{
	//    tpic_arc(size);
	//    tpic_star(size);
	//    return;
	//}
	//
	//static void
	//tpic_dotcircle(int size)			// circle with dot (black circle) 
	//{
	//    tpic_arc(size);
	//    tpic_shade(1.0);
	//    tpic_arc(size / 2);
	//    return;
	//}
	//
	//static void
	//tpic_diamondcircle(int size)			// not enough? circle with black diamond 
	//{
	//    tpic_arc(size);
	//    tpic_shade(1.0);
	//    tpic_diamond((int) (size / 1.5));
	//    return;
	//}
	//
	//static void
	//tpic_boxcircle(int size)			// need more? circle with black box 
	//{
	//    tpic_arc(size);
	//    tpic_shade(1.0);
	//    tpic_box((int) (size / 1.5));
	//    return;
	//}
	//
	//static void
	//tpic_trianglecircle(int size)			// circle with black triangle 
	//{
	//    tpic_arc(size);
	//    tpic_shade(1.0);
	//    tpic_triangle((int) (size / 1.5));
	//    return;
	//}
	//
	//static void
	//tpic_hexagoncircle(int size)			// how about circle with black hexagon? 
	//{
	//    tpic_arc(size);
	//    tpic_shade(1.0);
	//    tpic_hexagon((int) (size / 1.2));
	//    return;
	//}
	//
	//static void
	//tpic_plustimescircle(int size)			// no more idea ... with plus & times 
	//{
	//    tpic_arc(size);
	//    tpic_plus(size);
	//    tpic_times(size);
	//    return;
	//}
	//
	// /* private: draw lines */
	//
	//static void
	//tpic_abspath(unsigned int x, unsigned int y)
	//{
	//    tpic_path(x, -y);
	//    fputs("%\n", gpoutfile);
	//    return;
	//}
	//
	// /* private: tpic primitive functions */
	//
	//static void
	//tpic_path(int x, int y)
	//{
	//    fprintf(gpoutfile, "\\special{pa %d %d}", x, y);
	//    return;
	//}
	//
	//static void
	//tpic_flush()
	//{
	//    fputs("\\special{fp}%\n", gpoutfile);
	//    return;
	//}
	//
	//static void
	//tpic_arc(int radius)
	//{
	// /* actually, draw a full circle */
	//    fprintf(gpoutfile, "\\special{ar 0 0 %d %d 0 7}", radius, radius);
	//    return;
	//}
	//
	//static void
	//tpic_shade(double grayscale)
	//{
	//    fprintf(gpoutfile, "\\special{sh %f}", grayscale);
	//    return;
	//}
	//
	//static void
	//tpic_pen(int thickness)
	//{
	//    fprintf(gpoutfile, "\\special{pn %d}", thickness);
	//    return;
	//}
	//
	//static void
	//tpic_dottedflush(double interval)
	//{
	//    fprintf(gpoutfile, "\\special{dt %f}%%\n", interval);
	//    return;
	//}
	//
	//static void
	//tpic_dashedflush(double interval)
	//{
	//    fprintf(gpoutfile, "\\special{da %f}%%\n", interval);
	//    return;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(tpic_driver)
	//    "tpic", "TPIC -- LaTeX picture environment with tpic \\specials",
	//    TPIC_XMAX, TPIC_YMAX, TPIC_VCHAR, TPIC_HCHAR,
	//    TPIC_VTIC, TPIC_HTIC, TPIC_options, TPIC_init, TPIC_reset,
	//    TPIC_text, null_scale, TPIC_graphics, TPIC_move, TPIC_vector,
	//    TPIC_linetype, TPIC_put_text, TPIC_text_angle,
	//    TPIC_justify_text, TPIC_point, TPIC_arrow, set_font_null
	//TERM_TABLE_END(tpic_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM tpic_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(tpic)
	//"1 tpic",
	//"?commands set terminal tpic",
	//"?set terminal tpic",
	//"?set term tpic",
	//"?terminal tpic",
	//"?term tpic",
	//"?tpic",
	//" The `tpic` terminal driver supports the LaTeX picture environment with tpic",
	//" \\specials.  It is an alternative to the `latex` and `eepic` terminal drivers.",
	//" Options are the point size, line width, and dot-dash interval.",
	//"",
	//" Syntax:",
	//"       set terminal tpic <pointsize> <linewidth> <interval>",
	//"",
	//" where `pointsize` and `linewidth` are integers in milli-inches and `interval`",
	//" is a float in inches.  If a non-positive value is specified, the default is",
	//" chosen: pointsize = 40, linewidth = 6, interval = 0.1.",
	//"",
	//" All drivers for LaTeX offer a special way of controlling text positioning:",
	//" If any text string begins with '{', you also need to include a '}' at the",
	//" end of the text, and the whole text will be centered both horizontally",
	//" and vertically by LaTeX. --- If the text string begins with '[', you need",
	//" to continue it with: a position specification (up to two out of t,b,l,r),",
	//" ']{', the text itself, and finally, '}'. The text itself may be anything",
	//" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
	//"",
	//" Examples:",
	//" About label positioning:",
	//" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
	//"        set title '\\LaTeX\\ -- $ \\gamma $'",
	//" Force centering both horizontally and vertically:",
	//"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
	//" Specify own positioning (top here):",
	//"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
	//" The other label -- account for long ticlabels:",
	//"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
	//END_HELP(tpic)
	///#endif // TERM_TABLE 


	/* LaTeX picture environment with PSTricks macros */
	/* Hey Emacs this is -*- C -*-
	 *
	 * $Id: pstricks.trm,v 1.33 2006/11/18 17:24:26 sfeam Exp $
	 */

	/* GNUPLOT - pstricks.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   The PSTricks macros for LaTeX.
	 *
	 * AUTHORS
	 *   David Kotz
	 *
	 *   Raymond Toy	toy@soho.crd.ge.com
	 *	Modified the eepic.trm file to use PSTricks macros instead.
	 *
	 *	20 Mar 93:
	 *		Utilized many suggestions from Gisli Ottarsson
	 *		(gisli@liapunov.eecs.umich.edu) to create a new version.
	 *		Should also work with TeX as well as LaTeX.
	 *
	 *		If you have PSTricks version 0.91, #define OLD_PST to
	 *		get the right dots.
	 *
	 *		Added a really ugly hack (enabled by default) to print
	 *		"nice" numbers for axis labels.  This should really be at
	 *		a higher level in the code, but I'm lazy right now.
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 *  This file contains the PSTricks terminal driver, intended for use with the
	 *  pstricks.sty macro package for LaTeX. This is an alternative to the
	 *  eepic and latex driver. You need pstricks.sty, and, of course, a printer
	 *  that understands PostScript.  Ghostscript understands Postscript too.
	 *
	 *  PSTricks is available via anonymous ftp from the /pub directory
	 *  at Princeton.EDU.  This driver definitely does not come close to
	 *  using the full capability of the PSTricks package.
	 */
	/*
	 * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
	 *
	 * adapted to support pm3d by Tim Piessens and Petr Mikulik (Jan. 2003)
	 */


	///#ifdef TERM_REGISTER
	//register_term(pstricks)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void PSTRICKS_options __PROTO((void));
	//TERM_PUBLIC void PSTRICKS_init __PROTO((void));
	//TERM_PUBLIC void PSTRICKS_graphics __PROTO((void));
	//TERM_PUBLIC void PSTRICKS_text __PROTO((void));
	//TERM_PUBLIC void PSTRICKS_linetype __PROTO((int linetype));
	//TERM_PUBLIC void PSTRICKS_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void PSTRICKS_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void PSTRICKS_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void PSTRICKS_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
	//TERM_PUBLIC void PSTRICKS_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC int PSTRICKS_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int PSTRICKS_text_angle __PROTO((int ang));
	//TERM_PUBLIC void PSTRICKS_reset __PROTO((void));
	//TERM_PUBLIC int PSTRICKS_make_palette __PROTO((t_sm_palette *));
	//TERM_PUBLIC void PSTRICKS_set_color __PROTO((t_colorspec *));
	//TERM_PUBLIC void PSTRICKS_filled_polygon __PROTO((int, gpiPoint *));
	//
	///#define PSTRICKS_XMAX 10000.0
	///#define PSTRICKS_YMAX 10000.0
	//
	///#define PSTRICKS_HTIC	150
	///#define PSTRICKS_VTIC	200
	///#define PSTRICKS_HCHAR	160
	///#define PSTRICKS_VCHAR	420
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static void PSTRICKS_endline __PROTO((void));
	//static char *PSTRICKS_hack_text __PROTO((const char *s));
	//
	//static float PSTRICKS_posx;
	//static float PSTRICKS_posy;
	//static enum JUSTIFY PSTRICKS_justify = LEFT;
	//static int PSTRICKS_angle = 0;
	//
	// /* if 1 below, then the file size is shorter thanks to a macro for polygon */
	///#define PSTRICKS_SHORTER_FILE 1
	//
	///#ifdef PSTRICKS_SHORTER_FILE
	//static int PSTRICKS_color = 0;
	///#else
	//static char PSTRICKS_color_str[16] = "";
	///#endif
	//static int PSTRICKS_palette_set = FALSE;
	//static int PSTRICKS_palette_size = 128;
	//
	///#define	PSTRICKS_TINY_DOT	0.00025		// A tiny dot 
	//
	// /* POINTS */
	///#define PSTRICKS_POINT_TYPES 12	// we supply more point types 
	//
	//static const char *PSTRICKS_points[] = {
	//    "\\PST@Diamond",
	//    "\\PST@Plus",
	//    "\\PST@Square",
	//    "\\PST@Cross",
	//    "\\PST@Circle",
	//    "\\PST@Triangle",
	//    "\\PST@Pentagon",
	//    "\\PST@Filldiamond",
	//    "\\PST@Fillsquare",
	//    "\\PST@Filltriangle",
	//    "\\PST@Fillcircle",
	//    "\\PST@Fillpentagon"
	//};
	//
	// /* LINES */
	///#define PSTRICKS_NUMLINES 6	// number of linetypes below 
	//
	//static const char *PSTRICKS_lines[] = {
	//    "\\PST@Border",
	//    "\\PST@Axes",
	//    "\\PST@Solid",
	//    "\\PST@Dashed",
	//    "\\PST@Dotted",
	//    "\\PST@LongDash"
	//};
	//
	// /* current line type */
	//static int PSTRICKS_type;
	//
	// /* are we in the middle of a line */
	//static TBOOLEAN PSTRICKS_inline = FALSE;
	//
	// /* terminate any line in progress */
	//static void PSTRICKS_endline __PROTO((void));
	//
	// /* number of points in line so far */
	//static int PSTRICKS_linecount = 0;
	//
	// /* max value for linecount */
	///#define PSTRICKS_LINEMAX 100
	//
	// /*
	//  * Handle options
	//  */
	//
	//static int PST_hack_text = TRUE;	// Hack text on 
	//static int PST_unit_plot = FALSE;	// Unit-sized plot off 
	//
	//TERM_PUBLIC void
	//PSTRICKS_options()
	//{
	//    if (!END_OF_COMMAND) {
	//	if (almost_equals(c_token, "no$hacktext")) {
	//	    PST_hack_text = FALSE;
	//	    c_token++;
	//	} else if (almost_equals(c_token, "u$nit")) {
	//	    PST_unit_plot = TRUE;
	//	    c_token++;
	//	}
	//    }
	//}
	//
	//TERM_PUBLIC void
	//PSTRICKS_init()
	//{
	//    PSTRICKS_posx = PSTRICKS_posy = 0;
	//    PSTRICKS_linetype(-1);
	//    fseek(gpoutfile,0,SEEK_SET);
	//    fputs("% GNUPLOT: LaTeX picture using PSTRICKS macros\n", gpoutfile);
	//    PSTRICKS_palette_set = FALSE;    // PM3D palette set? 
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_graphics()
	//{
	//    fputs("
	//% Define new PST objects, if not already defined\n
	//\\ifx\\PSTloaded\\undefined\n
	//\\def\\PSTloaded{t}\n
	//\\psset{arrowsize=.01 3.2 1.4 .3}\n
	//\\psset{dotsize=.01}\n
	//\\catcode`@=11\n\n", gpoutfile);
	//
	// /* Define line type objects */
	//    fputs("
	//\\newpsobject{PST@Border}{psline}{linewidth=.0015,linestyle=solid}\n
	//\\newpsobject{PST@Axes}{psline}{linewidth=.0015,linestyle=dotted,dotsep=.004}\n
	//\\newpsobject{PST@Solid}{psline}{linewidth=.0015,linestyle=solid}\n
	//\\newpsobject{PST@Dashed}{psline}{linewidth=.0015,linestyle=dashed,dash=.01 .01}\n
	//\\newpsobject{PST@Dotted}{psline}{linewidth=.0025,linestyle=dotted,dotsep=.008}\n
	//\\newpsobject{PST@LongDash}{psline}{linewidth=.0015,linestyle=dashed,dash=.02 .01}\n", gpoutfile);
	//
	// /* Define point objects */
	//
	///#ifdef	OLD_PST
	// /* PSTricks version 0.91 had x and diamond dot types */
	//    fputs("
	//\\newpsobject(PST@Diamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=diamond}\n
	//\\newpsobject(PST@Filldiamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=diamond*}\n
	//\\newpsobject{PST@Cross}{psdots}{linewidth=.001,linestyle=solid,dotstyle=x}\n", gpoutfile);
	///#else
	// /* Newer versions use rotated plus and square to get the x and diamond dots */
	//    fputs("
	//\\newpsobject{PST@Diamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square,dotangle=45}\n
	//\\newpsobject{PST@Filldiamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square*,dotangle=45}\n
	//\\newpsobject{PST@Cross}{psdots}{linewidth=.001,linestyle=solid,dotstyle=+,dotangle=45}\n", gpoutfile);
	///#endif
	//
	//    fputs("
	//\\newpsobject{PST@Plus}{psdots}{linewidth=.001,linestyle=solid,dotstyle=+}\n
	//\\newpsobject{PST@Square}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square}\n
	//\\newpsobject{PST@Circle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=o}\n
	//\\newpsobject{PST@Triangle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=triangle}\n
	//\\newpsobject{PST@Pentagon}{psdots}{linewidth=.001,linestyle=solid,dotstyle=pentagon}\n
	//\\newpsobject{PST@Fillsquare}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square*}\n
	//\\newpsobject{PST@Fillcircle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=*}\n
	//\\newpsobject{PST@Filltriangle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=triangle*}\n
	//\\newpsobject{PST@Fillpentagon}{psdots}{linewidth=.001,linestyle=solid,dotstyle=pentagon*}\n", gpoutfile);
	//
	// /* Define arrow object */
	//    fputs("
	//\\newpsobject{PST@Arrow}{psline}{linewidth=.001,linestyle=solid}\n
	//\\catcode`@=12\n\n
	//\\fi\n", gpoutfile);
	//
	// /* Set the scaled plot size, if it's not a unit plot */
	//    if (!PST_unit_plot) {
	//	fputs("\\psset{unit=5.0in,xunit=5.0in,yunit=3.0in}\n", gpoutfile);
	//    }
	// /* HBB 20001027: fix bounding box bug by letting the currently
	//  * active 'size' and 'offset' setting influence the area used by
	//  * the picture environment */
	//    fprintf(gpoutfile, "
	//\\pspicture(%f,%f)(%f,%f)\n
	//\\ifx\\nofigs\\undefined\n
	//\\catcode`@=11\n\n",
	//	    xoffset,
	//	    yoffset,
	//	    (xoffset + xsize),
	//	    (yoffset + ysize)
	//    );
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_text()
	//{
	//    PSTRICKS_endline();
	//    fputs("
	//\\catcode`@=12\n
	//\\fi\n
	//\\endpspicture\n", gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_linetype(int linetype)
	//{
	//    PSTRICKS_endline();
	//
	//    if (linetype >= PSTRICKS_NUMLINES - 2)
	//	linetype %= (PSTRICKS_NUMLINES - 2);
	//
	//    if (linetype < -2)
	//	linetype = LT_BLACK;
	//
	//    PSTRICKS_type = linetype;
	//}
	//
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_move(unsigned int x, unsigned int y)
	//{
	//    PSTRICKS_endline();
	//
	//    PSTRICKS_posx = x / PSTRICKS_XMAX;
	//    PSTRICKS_posy = y / PSTRICKS_YMAX;
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_point(unsigned int x, unsigned int y, int number)
	//{
	//    PSTRICKS_move(x, y);
	//
	// /* Print the character defined by 'number'; number < 0 means
	//    to use a dot, otherwise one of the defined points. */
	//
	//    if (number < 0) {
	//	fprintf(gpoutfile, "\\qdisk(%.4f,%.4f){%.4f}\n",
	//		x / PSTRICKS_XMAX,
	//		y / PSTRICKS_YMAX,
	//		PSTRICKS_TINY_DOT);
	//    } else {
	//	fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
	//		PSTRICKS_points[number % PSTRICKS_POINT_TYPES],
	//		x / PSTRICKS_XMAX,
	//		y / PSTRICKS_YMAX);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_vector(unsigned ux, unsigned uy)
	//{
	//    if (!PSTRICKS_inline) {
	//	PSTRICKS_inline = TRUE;
	//
	// /* Start a new line. This depends on line type */
	//	fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
	//		PSTRICKS_lines[PSTRICKS_type + 2],
	//		PSTRICKS_posx, PSTRICKS_posy);
	//	PSTRICKS_linecount = 1;
	//    } else {
	// /*
	//  * Even though we are in middle of a path,
	//  * we may want to start a new path command.
	//  * If they are too long then latex will choke.
	//  */
	//	if (PSTRICKS_linecount++ >= PSTRICKS_LINEMAX) {
	// /* fprintf(gpoutfile, "\n"); */
	//	    fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
	//		    PSTRICKS_lines[PSTRICKS_type + 2],
	//		    PSTRICKS_posx, PSTRICKS_posy);
	//	    PSTRICKS_linecount = 1;
	//	}
	//    }
	//    PSTRICKS_posx = ux / PSTRICKS_XMAX;
	//    PSTRICKS_posy = uy / PSTRICKS_YMAX;
	//    fprintf(gpoutfile, "(%.4f,%.4f)\n", PSTRICKS_posx, PSTRICKS_posy);
	//}
	//
	//static void
	//PSTRICKS_endline()
	//{
	//    if (PSTRICKS_inline) {
	//	putc('\n', gpoutfile);
	//	PSTRICKS_inline = FALSE;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    fprintf(gpoutfile, "\\PST@Arrow%s(%.4f,%.4f)(%.4f,%.4f)\n",
	//	    head ? "{->}" : "",
	//	    sx / PSTRICKS_XMAX,
	//	    sy / PSTRICKS_YMAX,
	//	    ex / PSTRICKS_XMAX,
	//	    ey / PSTRICKS_YMAX);
	//
	//    PSTRICKS_posx = ex / PSTRICKS_XMAX;
	//    PSTRICKS_posy = ey / PSTRICKS_YMAX;
	//}
	//
	// /*
	//  * A really ugly hack!!!
	//  *
	//  * This function takes an input string and hacks it up.  If the
	//  * input string starts with a number, it converts the number into a
	//  * TeX style number including exponential notation.  Thus, if
	//  * the input is the string "3.14159e3 is a number", then
	//  * the output is "$3.14159\cdot 10^{3}$ is a number", so that TeX
	//  * will produce something nice.
	//  *
	//  * This is basically meant for producing axis labels that look nice.
	//  *
	//  * What a hack!
	//  */
	//
	//
	//static char *
	//PSTRICKS_hack_text(const char *s)
	//{
	//    double value;
	//    char *ends;
	//    static char hack[BUFSIZ];
	//
	// /*
	//  * Does the string start with a number?
	//  */
	//
	//    value = strtod(s, &ends);
	//
	//    if (s == ends) {
	// /*
	//  * This doesn't start a number, so just copy the string over
	//  */
	//
	//	strcpy(hack, s);
	//    } else {
	//	char *ptr;
	//
	// /*
	//  * We have a number!  Check to see if the number
	//  * is in scientific notation
	//  */
	//
	//	safe_strncpy(hack, s, ends - s + 1);
	// /* hack[ends - s] = '\0'; */
	//
	//	ptr = strchr(hack, 'e');
	//	if (ptr == NULL) {
	//	    ptr = strchr(hack, 'E');
	//	}
	//	if (ptr != NULL) {
	// /*
	//  * Exponential notation!  Let's get the mantissa and exponent separately
	//  */
	//
	//	    double man_val;
	//	    int expo_val;
	//
	//	    *ptr = NUL;
	//
	//	    man_val = atof(hack);
	//	    expo_val = atoi(ptr + 1);
	//
	//	    if (man_val == 0) {
	//		sprintf(hack, "0");
	//	    } else if (man_val == 1) {
	//		sprintf(hack, "$10^{%d}$", expo_val);
	//	    } else if (man_val == (int) man_val) {
	//		if (expo_val == 1) {
	//		    sprintf(hack, "$%d$", (int) man_val);
	//		} else {
	//		    sprintf(hack, "$%d \\times 10^{%d}$", (int) man_val, expo_val);
	//		}
	//	    } else {
	//		if (expo_val == 1) {
	//		    sprintf(hack, "$%f$", man_val);
	//		} else {
	//		    sprintf(hack, "$%f \\times 10^{%d}$", man_val, expo_val);
	//		}
	//	    }
	//	}
	// /*
	//  * Copy anything that's left of the string
	//  */
	//
	//	strcat(hack, ends);
	//    }
	//
	//    return hack;
	//}
	//
	//TERM_PUBLIC void
	//PSTRICKS_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    PSTRICKS_endline();
	//
	// /* Skip this if the string is empty */
	//
	//    if (strlen(str) > 0) {
	//	fputs("\\rput", gpoutfile);
	//
	// /* Set justification */
	//
	//	switch (PSTRICKS_justify) {
	//	case LEFT:
	//	    fputs("[l]", gpoutfile);
	//	    break;
	//	case CENTRE:
	//	    break;
	//	case RIGHT:
	//	    fputs("[r]", gpoutfile);
	//	    break;
	//	}
	//
	// /* Set text angle */
	//
	//	switch (PSTRICKS_angle) {
	//	case 0:
	//	    break;
	//	case 1:
	//	    fputs("{L}", gpoutfile);
	//	    break;
	//	}
	//
	// /* Set reference position and text */
	//
	//	fprintf(gpoutfile, "(%.4f,%.4f)",
	//		x / PSTRICKS_XMAX,
	//		y / PSTRICKS_YMAX);
	//	if (PST_hack_text) {
	//	    char *hack;
	//
	// /* Hack leading numbers to something nice for TeX */
	//
	//	    hack = PSTRICKS_hack_text(str);
	//	    fprintf(gpoutfile, "{%s}\n", hack);
	//	} else {
	//	    fprintf(gpoutfile, "{%s}\n", str);
	//	}
	//    }
	//}
	//
	//
	//
	//TERM_PUBLIC int
	//PSTRICKS_justify_text(enum JUSTIFY mode)
	//{
	//    PSTRICKS_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//PSTRICKS_text_angle(int ang)
	//{
	//    PSTRICKS_angle = (ang ? 1 : 0);
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//PSTRICKS_reset()
	//{
	//    PSTRICKS_endline();
	//    PSTRICKS_posx = PSTRICKS_posy = 0;
	//}
	//
	//
	//TERM_PUBLIC int
	//PSTRICKS_make_palette (t_sm_palette *palette)
	//{
	// /* Query to determine palette size */
	//    if (palette==NULL) {
	//	return PSTRICKS_palette_size;
	//    }
	//
	//    if (PSTRICKS_palette_set == FALSE) {
	//	int i;
	// /* Create new palette */
	//	PSTRICKS_palette_set = TRUE;
	//	if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) {
	// /* Grey palette */
	//	    for (i=0; i < sm_palette.colors; i++) {
	//		double g = i * 1.0 / (sm_palette.colors - 1);
	//		g = 1e-3 * (int)(g * 1000); // round to 3 digits to use %g below 
	//		fprintf(gpoutfile, "\\newgray{PST@COLOR%d}{%g}\n", i, g);
	//	    }
	//	} else
	//	    if (sm_palette.colorMode == SMPAL_COLOR_MODE_RGB) {
	// /* Color palette */
	//		double r, g, b;
	//		for (i=0; i < sm_palette.colors; i++) {
	// /* round to 3 digits to avoid sth like 1e-7 in %g below */
	//		    r = 1e-3 * (int)(palette->color[i].r * 1000);
	//		    g = 1e-3 * (int)(palette->color[i].g * 1000);
	//		    b = 1e-3 * (int)(palette->color[i].b * 1000);
	//		    fprintf(gpoutfile, "\\newrgbcolor{PST@COLOR%d}{%g %g %g}\n", i, r, g, b);
	//		}
	//	    }
	//    }
	// /* use the following macro to shorten the file size */
	//    fprintf(gpoutfile, "\\def\\polypmIIId#1{\\pspolygon[linestyle=none,fillstyle=solid,fillcolor=PST@COLOR#1]}\n\n");
	//    return 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_set_color (t_colorspec *colorspec)
	//{
	//    int new_color;
	//    double gray = colorspec->value;
	//
	//    if (colorspec->type != TC_FRAC)
	//	return;
	//
	//    new_color = (gray <=0) ? 0 : (int)(gray*sm_palette.colors);
	//    if (new_color >= PSTRICKS_palette_size)
	//	new_color = PSTRICKS_palette_size - 1;
	//    if (PSTRICKS_palette_set == FALSE) {
	//	fprintf(stderr, "pstricks: Palette used before set!\n");
	//    }
	///#ifdef PSTRICKS_SHORTER_FILE
	//    PSTRICKS_color = new_color;
	///#else
	//    sprintf(PSTRICKS_color_str, "PST@COLOR%d", new_color);
	///#endif
	//}
	//
	//
	//TERM_PUBLIC void
	//PSTRICKS_filled_polygon (int points, gpiPoint *corners)
	//{
	//    int i;
	//
	///#ifdef PSTRICKS_SHORTER_FILE
	// /* using a macro for an abbreviation */
	//    fprintf(gpoutfile, "\\polypmIIId{%d}", PSTRICKS_color);
	///#else
	//    fprintf(gpoutfile, "\\pspolygon[linestyle=none,fillstyle=solid,fillcolor=%s]", PSTRICKS_color_str);
	///#endif
	//    for (i=0; i < points; i++) {
	//	if (i % 8 == 7) // up to 8 corners per line 
	//	    fprintf(gpoutfile, "\n");
	//	fprintf(gpoutfile,"(%.4g,%.4g)", corners[i].x/PSTRICKS_XMAX, corners[i].y/PSTRICKS_YMAX);
	//    }
	//    fprintf(gpoutfile, "\n");
	//}
	//
	///#endif // TERM_BODY 


	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(pstricks_driver)
	//    "pstricks", "LaTeX picture environment with PSTricks macros",
	//    PSTRICKS_XMAX, PSTRICKS_YMAX, PSTRICKS_VCHAR, PSTRICKS_HCHAR,
	//    PSTRICKS_VTIC, PSTRICKS_HTIC, PSTRICKS_options, PSTRICKS_init, PSTRICKS_reset,
	//    PSTRICKS_text, null_scale, PSTRICKS_graphics, PSTRICKS_move, PSTRICKS_vector,
	//    PSTRICKS_linetype, PSTRICKS_put_text, PSTRICKS_text_angle,
	//    PSTRICKS_justify_text, PSTRICKS_point, PSTRICKS_arrow, set_font_null, 0,
	//    TERM_BINARY //flags
	//, 0 //suspend
	//, 0 //resume
	//, 0 , 0
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0
	///#endif
	//     , PSTRICKS_make_palette, 0,  PSTRICKS_set_color, PSTRICKS_filled_polygon
	//TERM_TABLE_END(pstricks_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM pstricks_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(pstricks)
	//"1 pstricks",
	//"?commands set terminal pstricks",
	//"?set terminal pstricks",
	//"?set term pstricks",
	//"?terminal pstricks",
	//"?term pstricks",
	//"?pstricks",
	//" The `pstricks` driver is intended for use with the \"pstricks.sty\" macro",
	//" package for LaTeX.  It is an alternative to the `eepic` and `latex` drivers.",
	//" You need \"pstricks.sty\", and, of course, a printer that understands",
	//" PostScript, or a converter such as Ghostscript.",
	//"",
	//" PSTricks is available via anonymous ftp from the /pub directory at",
	//" Princeton.edu.  This driver definitely does not come close to using the full",
	//" capability of the PSTricks package.",
	//"",
	//" Syntax:",
	//"       set terminal pstricks {hacktext | nohacktext} {unit | nounit}",
	//"",
	//" The first option invokes an ugly hack that gives nicer numbers; the second",
	//" has to do with plot scaling.  The defaults are `hacktext` and `nounit`."
	//END_HELP(pstricks)
	///#endif // TERM_HELP 


	/* TeXDraw drawing package for LaTeX */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: texdraw.trm,v 1.19 2006/07/21 02:35:48 sfeam Exp $
	 */

	/* GNUPLOT - texdraw.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * This file is included by ../term.c.
	 *
	 * This terminal driver supports:
	 *   The TEXDRAW macros for LaTeX.
	 *
	 * AUTHORS
	 *   Khun Yee Fung. Modified from eepic.trm.
	 *   clipper@csd.uwo.ca
	 *   January 20, 1992
	 *
	 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
	 *
	 */

	/*
	 *  This file contains the texdraw terminal driver, intended for use with the
	 *  texdraw macro package for LaTeX. This is an alternative to the
	 *  latex driver. You need texdraw.sty, and texdraw.tex in the texdraw package.
	 *
	 */

	///#ifdef TERM_REGISTER
	//register_term(texdraw)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void TEXDRAW_init __PROTO((void));
	//TERM_PUBLIC void TEXDRAW_graphics __PROTO((void));
	//TERM_PUBLIC void TEXDRAW_text __PROTO((void));
	//TERM_PUBLIC void TEXDRAW_linetype __PROTO((int linetype));
	//TERM_PUBLIC void TEXDRAW_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void TEXDRAW_point __PROTO((unsigned int x, unsigned int y,
	//					int number));
	//TERM_PUBLIC void TEXDRAW_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void TEXDRAW_arrow __PROTO((unsigned int sx, unsigned int sy,
	//					unsigned int ex, unsigned int ey,
	//					int head));
	//TERM_PUBLIC void TEXDRAW_put_text __PROTO((unsigned int x, unsigned int y,
	//					   const char str[]));
	//TERM_PUBLIC int TEXDRAW_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int TEXDRAW_text_angle __PROTO((int ang));
	//TERM_PUBLIC void TEXDRAW_reset __PROTO((void));
	//
	///#define TEXDRAW_PTS_PER_INCH (72.27)
	// /* resolution of printer we expect to use */
	///#define DOTS_PER_INCH (300)
	// /* dot size in pt */
	///#define TEXDRAW_UNIT (TEXDRAW_PTS_PER_INCH/DOTS_PER_INCH)
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define TEXDRAW_XMAX (5*DOTS_PER_INCH)
	///#define TEXDRAW_YMAX (3*DOTS_PER_INCH)
	//
	///#define TEXDRAW_HTIC (5*DOTS_PER_INCH/72)	// (5./TEXDRAW_UNIT) 
	///#define TEXDRAW_VTIC (5*DOTS_PER_INCH/72)	// (5./TEXDRAW_UNIT) 
	///#define TEXDRAW_HCHAR (DOTS_PER_INCH*53/10/72)	// (5.3/TEXDRAW_UNIT) 
	///#define TEXDRAW_VCHAR (DOTS_PER_INCH*11/72)	// (11./TEXDRAW_UNIT) 
	//
	///#define GOT_TEXDRAW_PROTO
	///#endif

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//static void TEXDRAW_endline __PROTO((void));
	//static unsigned int TEXDRAW_posx;
	//static unsigned int TEXDRAW_posy;
	//static enum JUSTIFY TEXDRAW_justify = LEFT;
	//static enum JUSTIFY TEXDRAW_last_justify = LEFT;
	//static int TEXDRAW_angle = 0;
	//static float TEXDRAW_scalefactor = 0.2409;
	//static double TEXDRAW_xscale = 1.0, TEXDRAW_yscale = 1.0;
	//
	// /* for DOTS point style */
	///#define TEXDRAW_TINY_DOT "\\htext{$\\cdot$}"
	//
	// /* POINTS */
	///#define TEXDRAW_POINT_TYPES 12	// we supply more point types 
	//
	//static const char GPFAR *GPFAR TEXDRAW_points[] = {
	//    "\\rmove(0 4)\\htext{$\\Diamond$}",
	//    "\\htext{$+$}",
	//    "\\rmove(0 4)\\htext{$\\Box$}",
	//    "\\htext{$\\times$}",
	//    "\\htext{$\\triangle$}",
	//    "\\htext{$\\star$}",
	//    "\\lcir r:9",
	//    "\\lcir r:12",
	//    "\\lcir r:16",
	//    "\\fcir f:0.9 r:9",
	//    "\\fcir f:0.9 r:12",
	//    "\\fcir f:0.9 r:16"
	//};
	//
	// /* LINES */
	///#define TEXDRAW_NUMLINES 5	// number of linetypes below 
	//
	//static const int TEXDRAW_lines[] = {
	//    4,				// -2 border 
	//    3,				// -1 axes 
	//    3,				//  0 solid thin  
	//    4,				//  1 solid thick 
	//    6,				//  2 solid Thick 
	//};
	//
	// /* The line type selected most recently */
	//static int TEXDRAW_last_type = 0;
	// /* current line type */
	//static int TEXDRAW_type;
	// /* are we in the middle of a line */
	//static TBOOLEAN TEXDRAW_inline = FALSE;
	// /* terminate any line in progress */
	//static void TEXDRAW_endline __PROTO((void));
	// /* number of points in line so far */
	//static int TEXDRAW_linecount = 0;
	// /* max value for linecount */
	///#define TEXDRAW_LINEMAX 5
	//
	//TERM_PUBLIC void
	//TEXDRAW_init()
	//{
	//    TEXDRAW_posx = TEXDRAW_posy = 0;
	//    TEXDRAW_linetype(-1);
	//    fputs("%% GNUPLOT: LaTeX using TEXDRAW macros\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_graphics()
	//{
	//    static char GPFAR tdg1[] = "
	//\\begin{texdraw}\n
	//\\normalsize\n
	//\\ifx\\pathDEFINED\\relax\\else\\let\\pathDEFINED\\relax\n
	// \\def\\QtGfr{\\ifx (\\TGre \\let\\YhetT\\cpath\\else\\let\\YhetT\\relax\\fi\\YhetT}\n
	// \\def\\path (#1 #2){\\move (#1 #2)\\futurelet\\TGre\\QtGfr}\n
	// \\def\\cpath (#1 #2){\\lvec (#1 #2)\\futurelet\\TGre\\QtGfr}\n
	//\\fi\n
	//\\drawdim pt\n
	//\\setunitscale %2.2f\n
	//\\linewd %d\n
	//\\textref h:L v:C\n";
	//    fprintf(gpoutfile, tdg1,
	//	    TEXDRAW_scalefactor,
	//	    TEXDRAW_lines[2]);
	//    TEXDRAW_last_type = 0;
	//    TEXDRAW_type = 0;
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_text()
	//{
	//    TEXDRAW_endline();
	//    fputs("\\end{texdraw}\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_linetype(int linetype)
	//{
	//    TEXDRAW_endline();
	//
	//    if (linetype >= TEXDRAW_NUMLINES - 2)
	//	linetype %= (TEXDRAW_NUMLINES - 2);
	//
	//    TEXDRAW_type = linetype > -2 ? linetype : LT_BLACK;
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_move(unsigned int x, unsigned int y)
	//{
	//    TEXDRAW_endline();
	//
	//    TEXDRAW_posx = x;
	//    TEXDRAW_posy = y;
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_point(unsigned int x, unsigned int y, int number)
	//{
	//    TEXDRAW_move(x, y);
	//
	// /* Print the character defined by 'number'; number < 0 means
	//  * to use a dot, otherwise one of the defined points. */
	//    fprintf(gpoutfile, "\\move (%d %d)\n",
	//	    (int) ((double) x * TEXDRAW_xscale),
	//	    (int) ((double) y * TEXDRAW_yscale));
	//    if (TEXDRAW_last_justify != CENTRE) {
	//	fprintf(gpoutfile, "\\textref h:C v:C ");
	//	TEXDRAW_last_justify = CENTRE;
	//    }
	//    fprintf(gpoutfile, "%s\n",
	//	    (number < 0 ?
	//	     TEXDRAW_TINY_DOT :
	//	     TEXDRAW_points[number % TEXDRAW_POINT_TYPES]));
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_vector(unsigned int ux, unsigned int uy)
	//{
	//    if (!TEXDRAW_inline) {
	//	TEXDRAW_inline = TRUE;
	//
	// /* Start a new line. This depends on line type */
	//	if (TEXDRAW_type != TEXDRAW_last_type) {
	//	    if (TEXDRAW_lines[TEXDRAW_type + 2] != TEXDRAW_lines[TEXDRAW_last_type + 2])
	//		fprintf(gpoutfile, "\\linewd %d\n",
	//			TEXDRAW_lines[TEXDRAW_type + 2]);
	//	    TEXDRAW_last_type = TEXDRAW_type;
	//	}
	//	fprintf(gpoutfile, "\\path (%d %d)",
	//		(int) ((double) TEXDRAW_posx * TEXDRAW_xscale),
	//		(int) ((double) TEXDRAW_posy * TEXDRAW_yscale));
	//	TEXDRAW_linecount = 1;
	//    } else {
	// /* Even though we are in middle of a path,
	//  * we may want to start a new path command.
	//  * If they are too long then latex will choke.
	//  */
	//	if (TEXDRAW_linecount++ >= TEXDRAW_LINEMAX) {
	//	    fputs("\n\\cpath ", gpoutfile);
	//	    TEXDRAW_linecount = 1;
	//	}
	//    }
	//    fprintf(gpoutfile, "(%d %d)",
	//	    (int) ((double) ux * TEXDRAW_xscale),
	//	    (int) ((double) uy * TEXDRAW_yscale));
	//    TEXDRAW_posx = ux;
	//    TEXDRAW_posy = uy;
	//}
	//
	//static void
	//TEXDRAW_endline()
	//{
	//    if (TEXDRAW_inline) {
	//	putc('\n', gpoutfile);
	//	TEXDRAW_inline = FALSE;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    char text;
	//
	//    if (head)
	//	text = 'a';
	//    else
	//	text = 'l';
	//    fprintf(gpoutfile, "\\move (%d %d)\\%cvec (%d %d)",
	//	    (int) ((double) sx * TEXDRAW_xscale),
	//	    (int) ((double) sy * TEXDRAW_yscale),
	//	    text,
	//	    (int) ((double) ex * TEXDRAW_xscale),
	//	    (int) ((double) ey * TEXDRAW_yscale));
	//    TEXDRAW_posx = ex;
	//    TEXDRAW_posy = ey;
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    char text;
	//
	//    TEXDRAW_endline();
	//
	//    fprintf(gpoutfile, "\\move (%d %d)",
	//	    (int) ((double) x * TEXDRAW_xscale),
	//	    (int) ((double) y * TEXDRAW_yscale));
	//
	//    if (!TEXDRAW_angle)
	//	text = 'h';
	//    else
	//	text = 'v';
	//
	//    if (TEXDRAW_last_justify != TEXDRAW_justify) {
	//	TEXDRAW_last_justify = TEXDRAW_justify;
	//	if (TEXDRAW_justify == LEFT)
	//	    fputs("\\textref h:L v:C ", gpoutfile);
	//	else if (TEXDRAW_justify == CENTRE)
	//	    fputs("\\textref h:C v:C ", gpoutfile);
	//	else if (TEXDRAW_justify == RIGHT)
	//	    fputs("\\textref h:R v:C ", gpoutfile);
	//    }
	//    fprintf(gpoutfile, "\\%ctext{%s}\n", text, str);
	//}
	//
	//
	//TERM_PUBLIC int
	//TEXDRAW_justify_text(enum JUSTIFY mode)
	//{
	//    TEXDRAW_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//TEXDRAW_text_angle(int ang)
	//{
	//    TEXDRAW_angle = ang;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC void
	//TEXDRAW_reset()
	//{
	//    TEXDRAW_endline();
	//    TEXDRAW_posx = TEXDRAW_posy = 0;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(texdraw_driver)
	//    "texdraw",
	//    "LaTeX texdraw environment",
	//    TEXDRAW_XMAX, TEXDRAW_YMAX, TEXDRAW_VCHAR, TEXDRAW_HCHAR,
	//    TEXDRAW_VTIC, TEXDRAW_HTIC, options_null, TEXDRAW_init, TEXDRAW_reset,
	//    TEXDRAW_text, null_scale, TEXDRAW_graphics, TEXDRAW_move, TEXDRAW_vector,
	//    TEXDRAW_linetype, TEXDRAW_put_text, TEXDRAW_text_angle,
	//    TEXDRAW_justify_text, TEXDRAW_point, TEXDRAW_arrow, set_font_null
	//TERM_TABLE_END(texdraw_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM texdraw_driver
	//
	///#endif // TERM_TABLE 

	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(texdraw)
	//"1 texdraw",
	//"?commands set terminal texdraw",
	//"?set terminal texdraw",
	//"?set term texdraw",
	//"?terminal texdraw",
	//"?term texdraw",
	//"?texdraw",
	//" The `texdraw` terminal driver supports the LaTeX texdraw environment.  It is",
	//" intended for use with \"texdraw.sty\" and \"texdraw.tex\" in the texdraw package.",
	//"",
	//" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",
	//" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",
	//" in the latexsym package, which is part of the base distribution and thus part",
	//" of any LaTeX implementation.  Please do not forget to use this package.",
	//"",
	//" It has no options."
	//END_HELP(texdraw)
	///#endif // TERM_HELP 


	/* METAFONT */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: metafont.trm,v 1.20 2006/07/21 02:35:47 sfeam Exp $
	 */

	/* GNUPLOT - metafont.trm */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 *			  GNUPLOT -- mf.trm
	 *
	 *		    This terminal driver supports:
	 *		       Metafont Plot Commands
	 *
	 * Written by : Pl Hedne
	 *		Trondheim, Norway
	 *		Pal.Hedne@termo.unit.no
	 */

	/*
	 * Improvements and bug fixes by Carsten Steger:
	 * - Set default plot size to 5 by 3 inches as in the latex- and eepic-
	 *   drivers
	 * - Fixed some bugs concerning resolution dependent output
	 * - Added MF_scale function
	 * - Added MF_justify_text function and modified MF_put_text function and
	 *   put_text macro accordingly
	 * - Modified MF_move and MF_vector to make output shorter and modified
	 *   MF_text accordingly
	 * - Added various linetypes by plotting dashed lines; had to modify
	 *   MF_linetype and MF_vector for this
	 * - Added MF_arrow function
	 * - All global variables and #define'd names begin with MF_ now
	 * As a consequence almost nothing of the original code by Pl Hedne remains
	 * but credit goes to him for the ingenious trick of storing the character
	 * images into picture variables, without which this driver would have been
	 * impossible for me to write.
	 *
	 * 10/03/95: Converted to new terminal layout by Carsten Steger.
	 */


	///#ifdef TERM_REGISTER
	//register_term(mf)
	///#endif

	///#ifdef TERM_PROTO
	//
	///#define MF_DPI (300)
	// /* resolution of printer we expect to use; the value itself is not
	//  * particularly important... it is here only for compatibility to the
	//  * LaTeX-driver and to get the spacing right. */
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define MF_XSIZE 5.0
	///#define MF_YSIZE 3.0
	///#define MF_XMAX (MF_XSIZE*MF_DPI)
	///#define MF_YMAX (MF_YSIZE*MF_DPI)
	//
	///#define MF_HTIC (5*MF_DPI/72)
	///#define MF_VTIC (5*MF_DPI/72)
	///#define MF_HCHAR (MF_DPI*53/10/72)
	///#define MF_VCHAR (MF_DPI*11/72)
	//
	//TERM_PUBLIC void MF_init __PROTO((void));
	//TERM_PUBLIC void MF_graphics __PROTO((void));
	//TERM_PUBLIC void MF_text __PROTO((void));
	//TERM_PUBLIC int MF_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int MF_text_angle __PROTO((int ang));
	//TERM_PUBLIC void MF_linetype __PROTO((int linetype));
	//TERM_PUBLIC void MF_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void MF_vector __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void MF_arrow __PROTO((unsigned int sx, unsigned int sy,
	//				   unsigned int ex, unsigned int ey,
	//				   int head));
	//TERM_PUBLIC void MF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void MF_reset __PROTO((void));
	//
	///#define GOT_MF_PROTO
	//
	///#endif // TERM_PROTO 


	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	//
	// /* Plot size in inches */
	//static double MF_xsize = MF_XSIZE;
	//static double MF_ysize = MF_YSIZE;
	//static int MF_char_code;
	//static int MF_ang;
	//static int MF_line_type;
	//static enum JUSTIFY MF_justify;
	//static double MF_dist_left;
	//static int MF_is_solid;
	//static int MF_picked_up_pen;
	// /*
	//  * We keep track of where we are with respect to dashed lines by using
	//  * the next five variables. MF_dash_index indicates which element of
	//  * MF_lines[..].dashlen should be used. The MF_last.. variables keep
	//  * track of the position of the pen.
	//  */
	//static int MF_dash_index;
	//static unsigned int MF_last_x, MF_last_y;
	//
	//static struct {
	//    int solid;			// Is the line solid? 
	//    float thickness;		// Thickness of pen we are going to use 
	//    int dashlen[4];		// Length of individual segments; even: line; odd: gap 
	//} MF_lines[10] =
	//{
	//    {
	//	1, 1.5, { 0, 0, 0, 0 }
	//    },
	//    {
	//	0, 1.0, { MF_DPI / 60, MF_DPI / 50, MF_DPI / 60, MF_DPI / 50 }
	//    },
	//    {
	//	1, 1.5, { 0, 0, 0, 0 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 20, MF_DPI / 30, MF_DPI / 20, MF_DPI / 30 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 30, MF_DPI / 20, MF_DPI / 30, MF_DPI / 20 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 15, MF_DPI / 30, MF_DPI / 60, MF_DPI / 30 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 30, MF_DPI / 50, MF_DPI / 30, MF_DPI / 50 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 20, MF_DPI / 50, MF_DPI / 60, MF_DPI / 30 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 30, MF_DPI / 50, MF_DPI / 30, MF_DPI / 30 }
	//    },
	//    {
	//	0, 1.5, { MF_DPI / 60, MF_DPI / 50, MF_DPI / 60, MF_DPI / 30 }
	//    }
	// /* dash: line,     gap,      line,     gap      */
	//};
	//
	//
	//
	//TERM_PUBLIC void
	//MF_init()
	//{
	//    MF_char_code = 0;
	//    MF_ang = 0;
	//
	//    fputs("
	//if unknown cmbase: input cmbase fi\n\n
	//tracingstats:=1;\n
	//picture r[];\n
	//\ndef openit = openwindow currentwindow\n
	//  from (0,0) to (400,800) at (-50,500) enddef;\n
	//\nmode_setup;\n", gpoutfile);
	//
	//    fputs("
	//\n%Include next eight lines if you have problems with the mode on your system..\n
	//%proofing:=0;\n
	//%fontmaking:=1;\n
	//%tracingtitles:=0;\n
	//%pixels_per_inch:=300;\n
	//%blacker:=0;\n
	//%fillin:=.2;\n
	//%o_correction:=.6;\n
	//%fix_units;\n", gpoutfile);
	//
	// /* Next lines must be included if text support is needed (CM base used) */
	//    fputs("
	//\ndef put_text(expr ts,xstart,ystart,rot,justification) =\n
	//  begingroup\n
	//    text_width:=0;text_height:=0;text_depth:=0;\n
	//    for ind:=0 step 1 until length(ts)-1:\n
	//      dec_num:=ASCII substring (ind,ind+1) of ts;\n
	//      if unknown r[dec_num]: dec_num:=32; fi\n
	//      if dec_num=32: \n
	//        text_width:=text_width+wd[65];\n
	//        text_height:=max(text_height,ht[65]);\n
	//        text_depth:=max(text_depth,dp[65]);\n
	//      elseif dec_num>=0: \n
	//        text_width:=text_width+wd[dec_num];\n
	//        text_height:=max(text_height,ht[dec_num]);\n
	//        text_depth:=max(text_depth,dp[dec_num]);\n
	//      fi\n
	//    endfor\n
	//    if rot=90:\n
	//      if justification=1: ynext:=ystart;\n
	//      elseif justification=2: ynext:=round(ystart-text_width/2);\n
	//      else: ynext:=round(ystart-text_width);\n
	//      fi\n
	//      xnext:=xstart+(text_height-text_depth)/2;\n
	//    else:\n
	//      if justification=1: xnext:=xstart;\n
	//      elseif justification=2: xnext:=round(xstart-text_width/2);\n
	//      else: xnext:=round(xstart-text_width);\n
	//      fi\n
	//      ynext:=ystart-(text_height-text_depth)/2;\n
	//    fi\n
	//    for ind:=0 step 1 until length(ts)-1:\n
	//      dec_num:=ASCII substring (ind,ind+1) of ts;\n
	//      if unknown r[dec_num]: dec_num:=32; fi\n
	//      if dec_num=32: \n
	//        xnext:=xnext+wd[65]*cosd rot;\n
	//        ynext:=ynext+wd[65]*sind rot;\n
	//      elseif dec_num>=0: \n
	//        currentpicture:=currentpicture+r[dec_num] shifted(xnext,ynext)\n
	//          rotatedaround ((xnext,ynext),rot); \n
	//        xnext:=xnext+wd[dec_num]*cosd rot;\n
	//        ynext:=ynext+wd[dec_num]*sind rot;\n
	//      fi\n
	//    endfor\n
	//  endgroup \n
	//enddef;\n", gpoutfile);
	//
	//    fputs("
	//\ndef endchar =\n
	//  r[charcode]:=currentpicture;\n
	//  wd[charcode]:=w;ht[charcode]:=h;dp[charcode]:=d;\n
	//  message \"Picture of charcode no.\" & decimal charcode;\n
	//  endgroup;\n
	//enddef;\n
	//let endchar_ = endchar;\n
	//let generate = relax;\n
	//let roman = relax;\n", gpoutfile);
	//
	//    fputs("
	//input cmr10.mf\n
	//if ligs>1: font_coding_scheme:=\"TeX text\";\n
	//  spanish_shriek=oct\"074\"; spanish_query=oct\"076\";\n
	//else: font_coding_scheme:=\n
	//  if ligs=0: \"TeX typewriter text\"\n
	//  else: \"TeX text without f-ligatures\" fi;\n
	//  spanish_shriek=oct\"016\"; spanish_query=oct\"017\"; fi\n
	//font_setup;\n
	//input romanu.mf %Roman uppercase.\n
	//input romanl.mf %Roman lowercase.\n
	//input greeku.mf %Greek uppercase.\n
	//input romand.mf %Numerals.\n
	//input romanp.mf %Ampersand, question marks, currency sign.\n
	//input romspl.mf %Lowercase specials (dotless \\i, ligature \\ae, etc.)\n
	//input romspu.mf %Uppercase specials (\\AE, \\OE, \\O)\n
	//input punct.mf %Punctuation symbols.\n
	//\nminus=ASCII\"-\"; cmchar \"Minus sign\";\n
	// beginarithchar(minus); \n
	//  pickup rule.nib;\n
	//  lft x1=hround 1.5u-eps;\n
	//  x2=w-x1; y1=y2=math_axis;\n
	//  draw z1--z2;	 % bar\n
	//  labels(1,2); \n
	//endchar;\n", gpoutfile);
	//
	//    fputs("
	//\ncmchar \"Period\";\n
	//  numeric dot_diam#; dot_diam#:=if monospace: 5/4 fi\\ dot_size#;\n
	//  define_whole_blacker_pixels(dot_diam);\n
	//  beginchar(\".\",5u#,dot_diam#,0);\n
	//  adjust_fit(0,0); pickup fine.nib;\n
	//  pos1(dot_diam,0); pos2(dot_diam,90);\n
	//  lft x1l=hround(.5w-.5dot_diam); bot y2l=0; z1=z2; dot(1,2);	% dot\n
	//  penlabels(1,2);\n
	//endchar;\n", gpoutfile);
	//
	//    fputs("
	//\ndef endchar =\n
	//  % Next line should probably be removed if CM base is used\n
	//  l:=0; r:=w;\n
	//  %Include the next two lines if you want to\n
	//  %rotate the picture 90 deg.(Portrait to Landscape)\n
	//  %currentpicture:=currentpicture rotated 90 shifted (h,0);\n
	//  %tmp:=charht; charht:=charwd; charwd:=tmp;\n
	//  scantokens extra_endchar;\n
	//  if proofing>0: makebox(proofrule); fi\n
	//  chardx:=w;\n
	//  shipit;\n
	//  if displaying>0: makebox(screenrule); showit; fi\n
	//  endgroup \n
	//enddef;\n
	//let endchar_ = endchar;\n
	//let generate = input;\n
	//let roman = roman;\n", gpoutfile);
	//
	// /* font_size must be bigger than em#/16 by METAFONT rules.
	//  * Therefore make it pretty big so big figures will be
	//  * handled correctly. Setting font_size to 72pt# lets us
	//  * handle characters up to 15.94 by 15.94 inches. */
	//    fputs("
	//\n\nfont_identifier:=\"GNUPLOT\";\n
	//font_size 72pt#;\n
	//th#=0.4pt#; define_whole_pixels(th);\n
	//\npath arrowhead;\n
	//arrowhead = (-7pt,-2pt){dir30}..(-6pt,0pt)..
	//{dir150}(-7pt,2pt) &\n
	//  (-7pt,2pt)--(0pt,0pt)--(-7pt,-2pt) & cycle;\n", gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_graphics()
	//{
	//    register struct termentry *t = term;
	//
	//    fprintf(gpoutfile, "\n\nbeginchar(%d,%gin#,%gin#,0);\n",
	//	    MF_char_code, MF_xsize, MF_ysize);
	//    MF_char_code++;
	//    fprintf(gpoutfile, "a:=w/%d;b:=h/%d;\n", t->xmax, t->ymax);
	//    MF_picked_up_pen = 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_text()
	//{
	//    fputs("endchar;\n", gpoutfile);
	//}
	//
	//
	//TERM_PUBLIC int
	//MF_justify_text(enum JUSTIFY mode)
	//{
	//    MF_justify = mode;
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC int
	//MF_text_angle(int ang)
	//{
	//    if (ang > 0)
	//	MF_ang = 90;
	//    else
	//	MF_ang = 0;
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_linetype(int linetype)
	//{
	//    if (linetype >= 8)
	//	linetype %= 8;
	//    linetype += 2;
	//    if (linetype < 0)
	//	linetype = 0;
	// /* Only output change in pens if it actually affects the pen used */
	//    if ((MF_lines[linetype].thickness != MF_lines[MF_line_type].thickness) ||
	//	(!MF_picked_up_pen)) {
	//	fprintf(gpoutfile, "pickup pencircle scaled %gth;\n",
	//		MF_lines[linetype].thickness);
	//	MF_picked_up_pen = 1;
	//    }
	//    MF_line_type = linetype;
	//    MF_dash_index = 0;
	//    MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
	//    MF_is_solid = MF_lines[MF_line_type].solid;
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_move(unsigned int x, unsigned int y)
	//{
	//    MF_last_x = x;
	//    MF_last_y = y;
	//    MF_dash_index = 0;
	//    MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_vector(unsigned int x, unsigned int y)
	//{
	//    if (MF_is_solid) {
	//	if (x == MF_last_x && y == MF_last_y)
	//	    fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
	//	else
	//	    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
	//		    MF_last_x, MF_last_y, x, y);
	//    } else {
	//	double dist_to_go, delta_x, delta_y, inc_x, inc_y;
	//	double last_x_d, last_y_d, next_x_d, next_y_d;
	//	unsigned int next_x, next_y;
	//
	//	if (x == MF_last_x && y == MF_last_y) {
	//	    if (!(MF_dash_index & 1))
	//		fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
	//	} else {
	//	    last_x_d = MF_last_x;
	//	    last_y_d = MF_last_y;
	//	    delta_x = x - last_x_d;
	//	    delta_y = y - last_y_d;
	//	    dist_to_go = sqrt(delta_x * delta_x + delta_y * delta_y);
	//	    inc_x = delta_x / dist_to_go;
	//	    inc_y = delta_y / dist_to_go;
	//	    while (MF_dist_left < dist_to_go) {
	//		next_x_d = last_x_d + inc_x * MF_dist_left;
	//		next_y_d = last_y_d + inc_y * MF_dist_left;
	//		next_x = floor(next_x_d + 0.5);
	//		next_y = floor(next_y_d + 0.5);
	// /* MF_dash_index & 1 == 0 means: draw a line; otherwise just move */
	//		if (!(MF_dash_index & 1))
	//		    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
	//			    MF_last_x, MF_last_y, next_x, next_y);
	//		MF_last_x = next_x;
	//		MF_last_y = next_y;
	//		last_x_d = next_x_d;
	//		last_y_d = next_y_d;
	//		dist_to_go -= MF_dist_left;
	//		MF_dash_index = (MF_dash_index + 1) & 3;
	//		MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
	//	    }
	//	    delta_x = x - last_x_d;
	//	    delta_y = y - last_y_d;
	//	    MF_dist_left -= sqrt(delta_x * delta_x + delta_y * delta_y);
	//	    if (!(MF_dash_index & 1)) {
	//		if (x == MF_last_x && y == MF_last_y)
	//		    fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
	//		else
	//		    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
	//			    MF_last_x, MF_last_y, x, y);
	//	    }
	//	}
	//    }
	//    MF_last_x = x;
	//    MF_last_y = y;
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_arrow(
	//    unsigned int sx, unsigned int sy,
	//    unsigned int ex, unsigned int ey,
	//    int head)
	//{
	//    int delta_x, delta_y;
	//
	//    MF_move(sx, sy);
	//    MF_vector(ex, ey);
	//    if (head) {
	//	delta_x = ex - sx;
	//	delta_y = ey - sy;
	//	fprintf(gpoutfile, "fill arrowhead rotated angle(%d,%d) shifted (%da,%db);\n",
	//		delta_x, delta_y, ex, ey);
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	//    int i, j = 0;
	//    char *text;
	//
	// /* ignore empty strings */
	//    if (!str || !*str)
	//	return;
	//
	// /* F***. why do drivers need to modify string args? */
	//    text = gp_strdup(str);
	//
	//    for (i = 0; i < strlen(text); i++)
	//	if (text[i] == '"')
	//	    text[i] = '\'';	// Replace " with ' 
	//    switch (MF_justify) {
	//    case LEFT:
	//	j = 1;
	//	break;
	//    case CENTRE:
	//	j = 2;
	//	break;
	//    case RIGHT:
	//	j = 3;
	//	break;
	//    }
	//    fprintf(gpoutfile, "put_text(\"%s\",%da,%db,%d,%d);\n",
	//	    text, x, y, MF_ang, j);
	//    free(text);
	//}
	//
	//
	//TERM_PUBLIC void
	//MF_reset()
	//{
	//    fputs("end.\n", gpoutfile);
	//}
	//
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(mf_driver)
	//    "mf", "Metafont plotting standard",
	//    MF_XMAX, MF_YMAX, MF_VCHAR, MF_HCHAR,
	//    MF_VTIC, MF_HTIC, options_null, MF_init, MF_reset,
	//    MF_text, null_scale, MF_graphics, MF_move, MF_vector,
	//    MF_linetype, MF_put_text, MF_text_angle,
	//    MF_justify_text, line_and_point, MF_arrow, set_font_null
	//TERM_TABLE_END(mf_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM mf_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 


	///#ifdef TERM_HELP
	//START_HELP(mf)
	//"1 mf",
	//"?commands set terminal mf",
	//"?set terminal mf",
	//"?set term mf",
	//"?terminal mf",
	//"?term mf",
	//"?mf",
	//"?metafont",
	//" The `mf` terminal driver creates an input file to the METAFONT program.  Thus a",
	//" figure may be used in the TeX document in the same way as is a character.",
	//"",
	//" To use a picture in a document, the METAFONT program must be run with the",
	//" output file from `gnuplot` as input.  Thus, the user needs a basic knowledge",
	//" of the font creating process and the procedure for including a new font in a",
	//" document.  However, if the METAFONT program is set up properly at the local",
	//" site, an unexperienced user could perform the operation without much trouble.",
	//"",
	//" The text support is based on a METAFONT character set.  Currently the",
	//" Computer Modern Roman font set is input, but the user is in principal free to",
	//" choose whatever fonts he or she needs.  The METAFONT source files for the",
	//" chosen font must be available.  Each character is stored in a separate",
	//" picture variable in METAFONT.  These variables may be manipulated (rotated,",
	//" scaled etc.) when characters are needed.  The drawback is the interpretation",
	//" time in the METAFONT program.  On some machines (i.e. PC) the limited amount",
	//" of memory available may also cause problems if too many pictures are stored.",
	//"",
	//" The `mf` terminal has no options.",
	//"2 METAFONT Instructions",
	//"?commands set terminal mf detailed",
	//"?set terminal mf detailed",
	//"?set term mf detailed",
	//"?mf detailed",
	//"?metafont detailed",
	//"",
	//" - Set your terminal to METAFONT:",
	//"   set terminal mf",
	//" - Select an output-file, e.g.:",
	//"   set output \"myfigures.mf\"",
	//" - Create your pictures. Each picture will generate a separate character. Its",
	//" default size will be 5*3 inches. You can change the size by saying `set size",
	//" 0.5,0.5` or whatever fraction of the default size you want to have.",
	//"",
	//" - Quit `gnuplot`.",
	//"",
	//" - Generate a TFM and GF file by running METAFONT on the output of `gnuplot`.",
	//" Since the picture is quite large (5*3 in), you will have to use a version of",
	//" METAFONT that has a value of at least 150000 for memmax.  On Unix systems",
	//" these are conventionally installed under the name bigmf.  For the following",
	//" assume that the command virmf stands for a big version of METAFONT.  For",
	//" example:",
	//"",
	//" - Invoke METAFONT:",
	//"     virmf '&plain'",
	//" - Select the output device: At the METAFONT prompt ('*') type:",
	//"     \\mode:=CanonCX;     % or whatever printer you use",
	//" - Optionally select a magnification:",
	//"     mag:=1;             % or whatever you wish",
	//" - Input the `gnuplot`-file:",
	//"     input myfigures.mf",
	//" On a typical Unix machine there will usually be a script called \"mf\" that",
	//" executes virmf '&plain', so you probably can substitute mf for virmf &plain.",
	//" This will generate two files: mfput.tfm and mfput.$$$gf (where $$$ indicates",
	//" the resolution of your device).  The above can be conveniently achieved by",
	//" typing everything on the command line, e.g.:",
	//" virmf '&plain' '\\mode:=CanonCX; mag:=1; input myfigures.mf'",
	//" In this case the output files will be named myfigures.tfm and",
	//" myfigures.300gf.",
	//"",
	//" - Generate a PK file from the GF file using gftopk:",
	//"   gftopk myfigures.300gf myfigures.300pk",
	//" The name of the output file for gftopk depends on the DVI driver you use.",
	//" Ask your local TeX administrator about the naming conventions.  Next, either",
	//" install the TFM and PK files in the appropriate directories, or set your",
	//" environment variables properly.  Usually this involves setting TEXFONTS to",
	//" include the current directory and doing the same thing for the environment",
	//" variable that your DVI driver uses (no standard name here...).  This step is",
	//" necessary so that TeX will find the font metric file and your DVI driver will",
	//" find the PK file.",
	//"",
	//" - To include your pictures in your document you have to tell TeX the font:",
	//"   \\font\\gnufigs=myfigures",
	//" Each picture you made is stored in a single character.  The first picture is",
	//" character 0, the second is character 1, and so on...  After doing the above",
	//" step, you can use the pictures just like any other characters.  Therefore, to",
	//" place pictures 1 and 2 centered in your document, all you have to do is:",
	//"   \\centerline{\\gnufigs\\char0}",
	//"   \\centerline{\\gnufigs\\char1}",
	//" in plain TeX.  For LaTeX you can, of course, use the picture environment and",
	//" place the picture wherever you wish by using the \\makebox and \\put macros.",
	//"",
	//" This conversion saves you a lot of time once you have generated the font;",
	//" TeX handles the pictures as characters and uses minimal time to place them,",
	//" and the documents you make change more often than the pictures do.  It also",
	//" saves a lot of TeX memory.  One last advantage of using the METAFONT driver",
	//" is that the DVI file really remains device independent, because no \\special",
	//" commands are used as in the eepic and tpic drivers."
	//END_HELP(mf)
	///#endif // TERM_HELP 


	/* METAPOST */
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: metapost.trm,v 1.43 2008/05/31 15:05:29 sfeam Exp $
	 */

	/* GNUPLOT - metapost.trm */

	/*[
	 * Copyright 1990 - 1993, 1998, 2004
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/* 1999/04/22
	 *			GNUPLOT -- metapost.trm
	 *
	 *			This terminal driver supports:
	 *		    		Metapost Commands
	 *
	 * Based on metafont.trm, written by
	 *		Pl Hedne
	 *		Trondheim, Norway
	 *		Pal.Hedne@termo.unit.no;
	 *		with improvements by Carsten Steger
	 *
	 * and pstricks.trm, written by
	 *		David Kotz and Raymond Toy
	 *
	 * Adapted to metapost by:
	 * 		Daniel H. Luecking <luecking@comp.uark.edu> and
	 * 	 	L Srinivasa Mohan <mohan@chemeng.iisc.ernet.in>
	 */


	///#ifdef TERM_REGISTER
	//register_term(mp)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void MP_options __PROTO((void));
	//TERM_PUBLIC void MP_init __PROTO((void));
	//TERM_PUBLIC void MP_graphics __PROTO((void));
	//TERM_PUBLIC void MP_text __PROTO((void));
	//TERM_PUBLIC void MP_linetype __PROTO((int linetype));
	//TERM_PUBLIC void MP_move __PROTO((unsigned int x, unsigned int y));
	//TERM_PUBLIC void MP_point __PROTO((unsigned int x, unsigned int y, int number));
	//TERM_PUBLIC void MP_pointsize __PROTO((double size));
	//TERM_PUBLIC void MP_linewidth __PROTO((double width));
	//TERM_PUBLIC void MP_vector __PROTO((unsigned int ux, unsigned int uy));
	//TERM_PUBLIC void MP_arrow __PROTO((unsigned int sx, unsigned int sy,
	//				   unsigned int ex, unsigned int ey,
	//				   int head));
	//TERM_PUBLIC void MP_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC int MP_justify_text __PROTO((enum JUSTIFY mode));
	//TERM_PUBLIC int MP_text_angle __PROTO((int ang));
	//TERM_PUBLIC void MP_reset __PROTO((void));
	//TERM_PUBLIC int MP_set_font __PROTO((const char *font));
	//TERM_PUBLIC void MP_boxfill __PROTO((int style, unsigned int x1,
	//				     unsigned int y1, unsigned int width,
	//				     unsigned int height));
	//TERM_PUBLIC int MP_make_palette __PROTO((t_sm_palette *));
	//TERM_PUBLIC void MP_previous_palette __PROTO((void));
	//TERM_PUBLIC void MP_set_color __PROTO((t_colorspec *));
	//TERM_PUBLIC void MP_filled_polygon __PROTO((int, gpiPoint *));
	//
	// /* 5 inches wide by 3 inches high (default) */
	///#define MP_XSIZE 5.0
	///#define MP_YSIZE 3.0
	//
	// /* gnuplot units will be one pixel if printing device has this
	//    resolution. Too small resolutions (like 300) can give rough
	//    appearence to curves when user tries to smooth a curve by choosing
	//    high sampling rate. */
	///#define MP_DPI (2400)
	//
	///#define MP_XMAX (MP_XSIZE*MP_DPI)
	///#define MP_YMAX (MP_YSIZE*MP_DPI)
	//
	///#define MP_HTIC (5*MP_DPI/72)	// nominally 5pt   
	///#define MP_VTIC (5*MP_DPI/72)	//    "      5pt   
	///#define MP_HCHAR (MP_DPI*53/10/72)	//    "      5.3pt 
	///#define MP_VCHAR (MP_DPI*11/72)	//    "      11pt  
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY
	///#ifdef TERM_BODY
	//
	//static double MP_xsize = MP_XSIZE;
	//static double MP_ysize = MP_YSIZE;
	// /* static double MP_xmax = MP_XMAX;
	//    static double MP_ymax = MP_YMAX;
	//  * unused, for now
	//  */
	//static int MP_posx;
	//static int MP_posy;
	//static char MP_fontname[MAX_ID_LEN + 1];
	//static double MP_fontsize;
	//static double MP_textmag;
	//static enum JUSTIFY MP_justify = LEFT;
	//static int MP_ang = 0;
	//static int MP_char_code = 0;
	//
	// /* number of nodes in an output line so far */
	//static int MP_linecount = 1;
	//
	// /* Number of point types */
	///#define MP_POINT_TYPES 10
	//
	// /* Number of line types */
	///#define MP_LINE_TYPES 8
	//
	// /* are we in the middle of a MP path? */
	//static TBOOLEAN MP_inline = FALSE;
	// /* colored or dashed lines? */
	//static TBOOLEAN MP_color = FALSE;
	//static TBOOLEAN MP_solid = FALSE;
	//
	// /* compatability mode*/
	// /* static TBOOLEAN MP_notex = FALSE; */
	///#define MP_NO_TEX 0
	///#define MP_TEX 1
	///#define MP_LATEX 2
	//static int MP_tex = MP_TEX;
	// /* add usepackage instructions for PSNFSS ? */
	///#define MP_PSNFSS_NONE 0
	///#define MP_PSNFSS_7    1
	///#define MP_PSNFSS_8    2
	//static int MP_psnfss = MP_PSNFSS_NONE;
	// /* should amstex packages be included? */
	//static int MP_amstex = 0;
	// /* add a4paper option to documentclass */
	//static int MP_a4paper = 0;
	// /* write a prologues line */
	//static int MP_prologues = -1;
	//
	// /* has color changed? */
	//static int MP_color_changed = 0;
	//
	// /* has a font change taken place? */
	//static TBOOLEAN MP_fontchanged = FALSE;
	//
	// /* The old types */
	//static int MP_oldline = -2;
	//
	// /* The old sizes */
	//static double MP_oldptsize = 1.0;
	//static double MP_oldpen = 1.0;
	//
	// /* terminate any path in progress */
	//static void MP_endline __PROTO((void));
	//
	// /* max number of path nodes before a newline */
	///#define MP_LINEMAX 5
	//
	//enum MP_id {
	//    MP_OPT_MONOCHROME, MP_OPT_COLOUR,
	//    MP_OPT_SOLID, MP_OPT_DASHED,
	//    MP_OPT_NOTEX, MP_OPT_TEX, MP_OPT_LATEX,
	//    MP_OPT_A4PAPER,
	//    MP_OPT_PSNFSS, MP_OPT_PSNFSS_V7, MP_OPT_NOPSNFSS,
	//    MP_OPT_AMSTEX,
	//    MP_OPT_FONT, MP_OPT_FONTSIZE,
	//    MP_OPT_PROLOGUES, MP_OPT_NOPROLOGUES,
	//    MP_OPT_MAGNIFICATION, MP_OPT_OTHER
	//};
	//
	//static struct gen_table MP_opts[] = {
	//    { "mo$nochrome", MP_OPT_MONOCHROME },
	//    { "c$olor", MP_OPT_COLOUR },
	//    { "c$olour", MP_OPT_COLOUR },
	//    { "s$olid", MP_OPT_SOLID },
	//    { "da$shed", MP_OPT_DASHED },
	//    { "n$otex", MP_OPT_NOTEX },
	//    { "t$ex", MP_OPT_TEX },
	//    { "la$tex", MP_OPT_LATEX },
	//    { "a4$paper", MP_OPT_A4PAPER },
	//    { "am$stex", MP_OPT_AMSTEX },
	//    { "ps$nfss", MP_OPT_PSNFSS },
	//    { "psnfss-v$ersion7", MP_OPT_PSNFSS_V7 },
	//    { "nops$nfss", MP_OPT_NOPSNFSS },
	//    { "pro$logues", MP_OPT_PROLOGUES },
	//    { "nopro$logues", MP_OPT_NOPROLOGUES },
	//    { "ma$gnification", MP_OPT_MAGNIFICATION },
	//    { "fo$nt", MP_OPT_FONT },
	//    { NULL, MP_OPT_OTHER }
	//};
	//
	//TERM_PUBLIC void
	//MP_options()
	//{
	//    struct value a;
	//
	// /* Annoying hack to handle the case of 'set termoption' after */
	// /* we have already initialized the terminal.                  */
	//    if (c_token != 2) {
	//	MP_color = FALSE;
	//	MP_solid = FALSE;
	//	MP_tex = MP_TEX;
	//	MP_a4paper = 0;
	//	MP_amstex  = 0;
	//	MP_psnfss = MP_PSNFSS_NONE;
	//	MP_fontsize = 10.0;
	//	MP_textmag = 1.0;
	//	MP_prologues = -1;
	//	strcpy(MP_fontname, "cmr10");
	//    }
	//
	//    while (!END_OF_COMMAND) {
	//	int option = lookup_table(&MP_opts[0], c_token);
	//	switch (option) {
	//	case MP_OPT_MONOCHROME:
	//	    MP_color = FALSE;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_COLOUR:
	//	    MP_color = TRUE;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_SOLID:
	//	    MP_solid = TRUE;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_DASHED:
	//	    MP_solid = FALSE;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_NOTEX:
	//	    MP_tex = MP_NO_TEX;
	//	    strcpy(MP_fontname, "pcrr8r");
	//	    c_token++;
	//	    break;
	//	case MP_OPT_TEX:
	//	    MP_tex = MP_TEX;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_LATEX:
	//	    MP_tex = MP_LATEX;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_AMSTEX:
	//	    MP_tex = MP_LATEX; // only makes sense when using LaTeX 
	//	    MP_amstex = 1;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_A4PAPER:
	//	    MP_tex = MP_LATEX; // only makes sense when using LaTeX 
	//	    MP_a4paper = 1;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_PSNFSS:
	//	    MP_tex = MP_LATEX;    // only makes sense when using LaTeX 
	//	    MP_psnfss = MP_PSNFSS_8;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_PSNFSS_V7:
	//	    MP_tex = MP_LATEX; // only makes sense when using LaTeX 
	//	    MP_psnfss = MP_PSNFSS_7;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_NOPSNFSS:
	//	    MP_psnfss = MP_PSNFSS_NONE;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_PROLOGUES:
	//	    c_token++;
	//	    if (!(END_OF_COMMAND)) {
	//		int dummy_for_prologues;
	//
	//		if (sscanf(gp_input_line + token[c_token].start_index,
	//			   "%d", &dummy_for_prologues) == 1) {
	//		    MP_prologues = dummy_for_prologues;
	//		}
	//		c_token++;
	//	    }
	//	    break;
	//	case MP_OPT_NOPROLOGUES:
	//	    MP_prologues = -1;
	//	    c_token++;
	//	    break;
	//	case MP_OPT_MAGNIFICATION:
	//	    c_token++;
	//	    if (!END_OF_COMMAND)	// global text scaling 
	//		MP_textmag = (double) real(const_express(&a));
	// /* c_token++; //Tangible continue code after comment*/
	// /* Needed ??? */
	//	    break;
	//	case MP_OPT_FONT:
	//	    c_token++;
	//	case MP_OPT_OTHER:
	//	default:
	//	{
	//	    char *s;
	//	    if ((s = try_to_get_string())) {
	//		int sep = strcspn(s,",");
	//		if (sep > 0) {
	//		    strncpy(MP_fontname, s, sizeof(MP_fontname));
	//		    MP_fontname[sep] = '\0';
	//		}
	//		if (s[sep] == ',')
	//		    sscanf(&s[sep+1],"%lf",&MP_fontsize);
	//		free(s);
	//	    } else if (option == MP_OPT_FONT) {
	//		int_error(c_token,"expecting font name");
	//	    } else if (!END_OF_COMMAND) {	//font size 
	//		MP_fontsize = (double) real(const_express(&a));
	//		c_token++;
	//	    }
	//	    break;
	//	}
	//
	//	}
	//    }
	//
	// /* minimal error recovery: */
	//    if (MP_fontsize < 5.0)
	//	MP_fontsize = 5.0;
	//    if (MP_fontsize > 99.99)
	//	MP_fontsize = 99.99;
	//
	//    term->v_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 11 / 720);
	//    if (MP_tex == MP_NO_TEX) {	// Courier is a little wider than cmtt 
	//	term->h_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 6.0 / 720 + 0.5);
	//    } else {
	//	term->h_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 5.3 / 720 + 0.5);
	//    }
	//
	//    if (MP_psnfss == MP_PSNFSS_NONE) { // using the normal font scheme 
	//      sprintf(term_options,
	//	    "%s %s %stex%s%s mag %.3f font \"%s\" %.2f %sprologues(%d)",
	//	    MP_color ? "color" : "monochrome",
	//	    MP_solid ? "solid" : "dashed",
	//	    (MP_tex == MP_NO_TEX) ? "no" : (MP_tex == MP_LATEX) ? "la" : "",
	//	    MP_a4paper ? " a4paper" : "",
	//	    MP_amstex ? " amstex" : "",
	//	    MP_textmag,
	//	    MP_fontname, MP_fontsize,
	//	    (MP_prologues > -1) ? "" : "no", MP_prologues );
	//    } else { // using postscript fonts 
	//      sprintf(term_options,
	//	    "%s %s %stex%s%s mag %.3f %s %sprologues(%d)",
	//	    MP_color ? "color" : "monochrome",
	//	    MP_solid ? "solid" : "dashed",
	//	    (MP_tex == MP_NO_TEX) ? "no" : (MP_tex == MP_LATEX) ? "la" : "",
	//	    MP_a4paper ? " a4paper" : "",
	//	    MP_amstex ? " amstex" : "",
	//	    MP_textmag,
	//	    (MP_psnfss == MP_PSNFSS_7) ? "psnsfss(v7)" : "psnsfss",
	//	    (MP_prologues > -1) ? "" : "no", MP_prologues );
	//    };
	//}
	//
	//TERM_PUBLIC void
	//MP_init()
	//{
	//    time_t now;
	//    time(&now);
	//    MP_posx = MP_posy = 0;
	//    fprintf(gpoutfile, "%%GNUPLOT Metapost output: %s\n", asctime(localtime(&now)));
	//    if (MP_prologues > -1) {
	//	fprintf(gpoutfile, "prologues:=%d;\n", MP_prologues);
	//    }
	//    if (MP_tex == MP_LATEX) {
	//	fputs("\n
	//%% Add \\documentclass and \\begin{dcoument} for latex\n
	//%% NB you should set the environment variable TEX to the name of your\n
	//%% latex executable (normally latex) inorder for metapost to work\n
	//%% or run\n
	//%% mpost --tex=latex ...\n
	//\n
	//% BEGPRE\n
	//verbatimtex\n", gpoutfile);
	//	if (MP_a4paper) {
	//	    fputs("\\documentclass[a4paper]{article}\n", gpoutfile);
	//	} else {
	//	    fputs("\\documentclass{article}\n", gpoutfile);
	//	}
	//	switch (MP_psnfss) {
	//	case MP_PSNFSS_7:{
	//		fputs("\\usepackage[latin1]{inputenc}\n
	//\\usepackage[T1]{fontenc}\n
	//\\usepackage{times,mathptmx}\n
	//\\usepackage{helvet}\n
	//\\usepackage{courier}\n", gpoutfile);
	//	    }
	//	    break;
	//	case MP_PSNFSS_8:{
	//		fputs("\\usepackage[latin1]{inputenc}\n
	//\\usepackage[T1]{fontenc}\n
	//\\usepackage{textcomp}\n
	//\\usepackage{mathptmx}\n
	//\\usepackage[scaled=.92]{helvet}\n
	//\\usepackage{courier}\n
	//\\usepackage{latexsym}\n", gpoutfile);
	//	    }
	//	    break;
	//	}
	//	if (MP_amstex) {
	//	  fputs("\\usepackage[intlimits]{amsmath}\n
	//\\usepackage{amsfonts}\n", gpoutfile);
	//          };
	//	fputs("\\begin{document}\n
	//etex\n% ENDPRE\n", gpoutfile);
	//    }
	//
	//    fputs("\n
	//warningcheck:=0;\n
	//defaultmpt:=mpt:=4;\n
	//th:=.6;\n
	//%% Have nice sharp joins on our lines\n
	//linecap:=butt;\n
	//linejoin:=mitered;\n
	//\n
	//def scalepen expr n = pickup pencircle scaled (n*th) enddef;\n
	//def ptsize expr n = mpt:=n*defaultmpt enddef;\n
	//\n", gpoutfile);
	//
	//    fprintf(gpoutfile, "\ntextmag:=%6.3f;\n", MP_textmag);
	//
	//    fputs("
	//vardef makepic(expr str) =\n
	//  if picture str : str scaled textmag\n
	//  % otherwise a string\n
	//  else: str infont defaultfont scaled (defaultscale*textmag)\n
	//  fi\n
	//enddef;\n
	//\n
	//def infontsize(expr str, size) =\n
	//  infont str scaled (size / fontsize str)\n
	//enddef;\n", gpoutfile);
	//
	//    if (MP_tex == MP_NO_TEX) {
	//	fprintf(gpoutfile, "\n
	//defaultfont:= \"%s\";\n
	//defaultscale := %6.3f/fontsize defaultfont;\n", MP_fontname, MP_fontsize);
	//    } else {
	//	if (MP_tex != MP_LATEX) {
	//	    fputs("\n
	//%font changes\n
	//verbatimtex\n
	//\\def\\setfont#1#2{%.\n
	//  \\font\\gpfont=#1 at #2pt\n
	//\\gpfont}\n", gpoutfile);
	//	    fprintf(gpoutfile, "\\setfont{%s}{%5.2f}\netex\n",
	//		    MP_fontname, MP_fontsize);
	//	}
	//    }
	//    fputs("\n
	//color currentcolor; currentcolor:=black;\n
	//color fillcolor;\n
	//boolean colorlines,dashedlines;\n", gpoutfile);
	//    if (MP_color) {
	//	fputs("colorlines:=true;\n", gpoutfile);
	//    } else {
	//	fputs("colorlines:=false;\n", gpoutfile);
	//    }
	//    if (MP_solid) {
	//	fputs("dashedlines:=false;\n", gpoutfile);
	//    } else {
	//	fputs("dashedlines:=true;\n", gpoutfile);
	//    }
	//    fputs("\n
	//def _wc = withpen currentpen withcolor currentcolor enddef;\n
	//def _ac = addto currentpicture enddef;\n
	//def _sms = scaled mpt shifted enddef;\n
	//% drawing point-types\n
	//def gpdraw (expr n, x, y) =\n
	//  if n<0: _ac contour fullcircle _sms (x,y)\n
	//  elseif (n=1) or (n=3):\n
	//    _ac doublepath ptpath[n] _sms (x,y) _wc;\n
	//    _ac doublepath ptpath[n] rotated 90 _sms (x,y) _wc\n
	//  elseif n<6: _ac doublepath ptpath[n] _sms (x,y) _wc\n
	//  else: _ac contour ptpath[n] _sms (x,y) _wc\n
	//  fi\n
	//enddef;\n
	//\n
	//% the point shapes\n
	//path ptpath[];\n
	//%diamond\n
	//ptpath0 = ptpath6 = (-1/2,0)--(0,-1/2)--(1/2,0)--(0,1/2)--cycle;\n
	//% plus sign\n
	//ptpath1 = (-1/2,0)--(1/2,0);\n
	//% square\n
	//ptpath2 = ptpath7 = (-1/2,-1/2)--(1/2,-1/2)--(1/2,1/2)--(-1/2,1/2)--cycle;\n
	//% cross\n
	//ptpath3 := (-1/2,-1/2)--(1/2,1/2);\n
	//% circle:\n
	//ptpath4 = ptpath8:= fullcircle;\n
	//% triangle\n
	//ptpath5 = ptpath9 := (0,1/2)--(-1/2,-1/2)--(1/2,-1/2)--cycle;\n
	//\n
	//def linetype expr n =\n
	//  currentcolor:= if colorlines : col[n] else: black fi;\n
	//  if n = -1 :\n
	//      drawoptions(withcolor currentcolor withpen (currentpen scaled .5));\n
	//  elseif n < 1 :\n
	//    drawoptions(_wc);\n
	//  else :\n
	//    drawoptions( if dashedlines: dashed lt[n] fi _wc);\n
	//  fi\n
	//enddef;\n
	//\n
	//% dash patterns\n
	//picture lt[];\n
	//lt1=dashpattern(on 2 off 2); % dashes\n
	//lt2=dashpattern(on 2 off 2 on 0.2 off 2); %dash-dot\n
	//lt3=lt1 scaled 1.414;\n
	//lt4=lt2 scaled 1.414;\n
	//lt5=lt1 scaled 2;\n
	//lt6:=lt2 scaled 2;\n
	//lt7=dashpattern(on 0.2 off 2); %dots\n
	//\n
	//color col[],cyan, magenta, yellow;\n
	//cyan=blue+green; magenta=red+blue;yellow=green+red;\n
	//col[-2]:=col[-1]:=col0:=black;\n
	//col1:=red;\n
	//col2:=(.2,.2,1); %blue\n
	//col3:=(1,.66,0); %orange\n
	//col4:=.85*green;\n
	//col5:=.9*magenta;\n
	//col6:=0.85*cyan;\n
	//col7:=.85*yellow;\n
	//\n
	//%placing text\n
	//picture GPtext;\n
	//def put_text(expr pic, x, y, r, j) =\n
	//  GPtext:=makepic(pic);\n
	//  GPtext:=GPtext shifted\n
	//    if j = 1: (-(ulcorner GPtext + llcorner GPtext)/2)\n
	//    elseif j = 2: (-center GPtext)\n
	//    else: (-(urcorner GPtext + lrcorner GPtext)/2)\n
	//    fi\n
	//    rotated r;\n
	//  draw GPtext shifted (x,y)\n
	//enddef;\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//MP_graphics()
	//{
	// /* initialize "remembered" drawing parameters */
	//    MP_oldline = -2;
	//    MP_oldpen = 1.0;
	//    MP_oldptsize = pointsize;
	//    fprintf(gpoutfile, "\nbeginfig(%d);\nw:=%.3fin;h:=%.3fin;\n",
	//	    MP_char_code, MP_xsize, MP_ysize);
	// /* MetaPost can only handle numbers up to 4096. When MP_DPI
	//  * is larger than 819, this is exceeded by (term->xmax). So we
	//  * scale it and all coordinates down by factor of 10.0. And
	//  * compensate by scaling a and b up.
	//  */
	//    fprintf(gpoutfile, "a:=w/%.1f;b:=h/%.1f;\n",
	//	    (term->xmax) / 10.0, (term->ymax) / 10.0);
	//    fprintf(gpoutfile, "scalepen 1; ptsize %.3f;linetype -2;\n", pointsize);
	//    MP_char_code++;
	// /* reset MP_color_changed */
	//    MP_color_changed = 0;
	//}
	//
	//TERM_PUBLIC void
	//MP_text()
	//{
	//    if (MP_inline)
	//	MP_endline();
	//    fputs("endfig;\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//MP_linetype(int lt)
	//{
	//    int linetype = lt;
	//
	//    if (linetype >= MP_LINE_TYPES)
	//	linetype %= MP_LINE_TYPES;
	//    if (MP_inline)
	//	MP_endline();
	// /* reset the color in case it has been changed in MP_set_color() */
	//    if (MP_color_changed) {
	//	MP_oldline = linetype + 1;
	//	MP_color_changed = 0;
	//    }
	//    if (MP_oldline != linetype) {
	//	fprintf(gpoutfile, "linetype %d;\n", linetype);
	//	MP_oldline = linetype;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//MP_move(unsigned int x, unsigned int y)
	//{
	//    if ((x != MP_posx) || (y != MP_posy)) {
	//	if (MP_inline)
	//	    MP_endline();
	//	MP_posx = x;
	//	MP_posy = y;
	//    }				// else we seem to be there already 
	//}
	//
	//TERM_PUBLIC void
	//MP_point(unsigned int x, unsigned int y, int pt)
	//{
	//    int pointtype = pt;
	//    if (MP_inline)
	//	MP_endline();
	//
	// /* Print the shape defined by 'number'; number < 0 means
	//    to use a dot, otherwise one of the defined points. */
	//
	//    if (pointtype >= MP_POINT_TYPES)
	//	pointtype %= MP_POINT_TYPES;
	// /* Change %d to %f, divide x,y by 10 */
	//    fprintf(gpoutfile, "gpdraw(%d,%.1fa,%.1fb);\n", pointtype, x / 10.0, y / 10.0);
	//}
	//
	//TERM_PUBLIC void
	//MP_pointsize(double ps)
	//{
	//    if (ps < 0)
	//	ps = 1;
	//    if (MP_oldptsize != ps) {
	//	if (MP_inline)
	//	    MP_endline();
	//	fprintf(gpoutfile, "ptsize %.3f;\n", ps);
	//	MP_oldptsize = ps;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//MP_linewidth(double lw)
	//{
	//    if (MP_oldpen != lw) {
	//	if (MP_inline)
	//	    MP_endline();
	//	fprintf(gpoutfile, "scalepen %.3f;\n", lw);
	//	MP_oldpen = lw;
	//    }
	//}
	//
	//
	//TERM_PUBLIC void
	//MP_vector(unsigned int ux, unsigned int uy)
	//{
	//    if ((ux == MP_posx) && (uy == MP_posy))
	//	return;			// Zero length line 
	//
	//    if (MP_inline) {
	//	if (MP_linecount++ >= MP_LINEMAX) {
	//	    fputs("\n", gpoutfile);
	//	    MP_linecount = 1;
	//	}
	//    } else {
	//	MP_inline = TRUE;
	//	fprintf(gpoutfile, "draw (%.1fa,%.1fb)", MP_posx / 10.0, MP_posy / 10.0);
	//	MP_linecount = 2;
	//    }
	//    MP_posx = ux;
	//    MP_posy = uy;
	//    fprintf(gpoutfile, "--(%.1fa,%.1fb)", MP_posx / 10.0, MP_posy / 10.0);
	//}
	//
	//static void
	//MP_endline()
	//{
	//    MP_inline = FALSE;
	//    fprintf(gpoutfile, ";\n");
	//}
	//
	//TERM_PUBLIC void
	//MP_arrow(unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head)
	//{
	//    MP_move(sx, sy);
	//    if (head) {
	//	fprintf(gpoutfile, "%s (%.1fa,%.1fb)--(%.1fa,%.1fb);\n",
	//		head == 1 ? "drawarrow" : "drawdblarrow",
	//		sx / 10.0, sy / 10.0, ex / 10.0, ey / 10.0);
	//    } else if ((sx != ex) || (sy != ey)) {
	//	fprintf(gpoutfile, "draw (%.1fa,%.1fb)--(%.1fa,%.1fb);\n",
	//		sx / 10.0, sy / 10.0, ex / 10.0, ey / 10.0);
	//    }	// else: arrow with no length and no head = sound of one hand clapping? 
	//    MP_posx = ex;
	//    MP_posy = ey;
	//
	//}
	//
	//TERM_PUBLIC void
	//MP_put_text(unsigned int x, unsigned int y, const char str[])
	//{
	//    int i, j = 0;
	//    char *text;
	//
	// /* ignore empty strings */
	//    if (!str || !*str)
	//	return;
	//
	// /* F***. why do drivers need to modify string args? */
	//    text = gp_strdup(str);
	//
	//    if (MP_inline)
	//	MP_endline();
	//
	//
	//    switch (MP_justify) {
	//    case LEFT:
	//	j = 1;
	//	break;
	//    case CENTRE:
	//	j = 2;
	//	break;
	//    case RIGHT:
	//	j = 3;
	//	break;
	//    }
	//    if (MP_tex == MP_NO_TEX) {
	//	for (i = 0; i < strlen(text); i++)
	//	    if (text[i] == '"')
	//		text[i] = '\'';	// Replace " with ' 
	//	if (MP_fontchanged) {
	//	    fprintf(gpoutfile, "
	//put_text(\"%s\" infontsize(\"%s\",%5.2f), %.1fa, %.1fb, %d, %d);\n",
	//		    text, MP_fontname, MP_fontsize,
	//		    x / 10.0, y / 10.0, MP_ang, j);
	//	} else {
	//	    fprintf(gpoutfile, "put_text(\"%s\", %.1fa, %.1fb, %d, %d);\n",
	//		    text, x / 10.0, y / 10.0, MP_ang, j);
	//	}
	//    } else if (MP_fontchanged) {
	//	if (MP_tex != MP_LATEX) {
	//	    fprintf(gpoutfile, "
	//put_text( btex \\setfont{%s}{%5.2f} %s etex, %.1fa, %.1fb, %d, %d);\n",
	//		    MP_fontname, MP_fontsize, text,
	//		    x / 10.0, y / 10.0, MP_ang, j);
	//	} else {
	//	    fprintf(gpoutfile, "put_text( btex %s etex, %.1fa, %.1fb, %d, %d);\n",
	//		    text, x / 10.0, y / 10.0, MP_ang, j);
	//	}
	//    } else {
	//	fprintf(gpoutfile, "put_text( btex %s etex, %.1fa, %.1fb, %d, %d);\n",
	//		text, x / 10.0, y / 10.0, MP_ang, j);
	//    }
	//
	//    free(text);
	//}
	//
	//TERM_PUBLIC int
	//MP_justify_text(enum JUSTIFY mode)
	//{
	//    MP_justify = mode;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//MP_text_angle(int ang)
	//{
	// /* Metapost code does the conversion */
	//    MP_ang = ang;
	//    return (TRUE);
	//}
	//
	//TERM_PUBLIC int
	//MP_set_font(const char *font)
	//{
	//    if (*font) {
	//	size_t sep = strcspn(font, ",");
	//	if (sep < sizeof(MP_fontname))
	//	    strncpy(MP_fontname, font, sizeof(MP_fontname));
	//	sscanf(&(font[sep + 1]), "%lf", &MP_fontsize);
	//	if (MP_fontsize < 5)
	//	    MP_fontsize = 5.0;
	//	if (MP_fontsize >= 100)
	//	    MP_fontsize = 99.99;
	// /*  */
	//	MP_fontchanged = TRUE;
	//    } else {
	//	MP_fontchanged = FALSE;
	//    }
	//    return TRUE;
	//}
	//
	//
	//TERM_PUBLIC void
	//MP_reset()
	//{
	//    if (MP_tex == MP_LATEX) {
	//	fputs("% BEGPOST\n",gpoutfile);
	//	fputs("verbatimtex\n",gpoutfile);
	//	fputs(" \\end{document}\n",gpoutfile);
	//	fputs("etex\n",gpoutfile);
	//	fputs("% ENDPOST\n",gpoutfile);
	//    };
	//    fputs("end.\n", gpoutfile);
	//}
	//
	//TERM_PUBLIC void
	//MP_boxfill(
	//    int style,
	//    unsigned int x1, unsigned int y1,
	//    unsigned int wd, unsigned int ht)
	//{
	//
	// /* fillpar:
	//  * - solid   : 0 - 100% intensity
	//  * - pattern : 0 - n    pattern number
	//  */
	//    int fillpar = style >> 4;
	//    style &= 0xf;
	//
	//    if (MP_inline)
	//	MP_endline();
	//
	//    switch (style) {
	//
	//	case FS_EMPTY: // fill with background color 
	//	    fprintf(gpoutfile, "
	//fill (%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--cycle withcolor background;\n",
	//		x1 / 10.0, y1 / 10.0, (x1 + wd) / 10.0, y1 / 10.0,
	//		(x1 + wd) / 10.0, (y1 + ht) / 10.0, x1 / 10.0,
	//		(y1 + ht) / 10.0);
	//	    break;
	//
	//	case FS_PATTERN: // pattern fill 
	//	case FS_TRANSPARENT_PATTERN:
	// /* FIXME: not yet implemented, dummy it up as fill density */
	//	    fillpar *= 12;
	//
	//	default:
	//	case FS_SOLID: // solid fill 
	//	case FS_TRANSPARENT_SOLID:
	//	    if (fillpar < 100) {
	//		double density = (100-fillpar) * 0.01;
	//		fprintf(gpoutfile,"fillcolor:=currentcolor*%.2f+background*%.2f;\n",
	//		    1.0-density, density);
	//		MP_color_changed = 1;
	//	    } else
	//		fprintf(gpoutfile,"fillcolor:=currentcolor;\n");
	//	    fprintf(gpoutfile, "
	//fill (%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--cycle withpen (pencircle scaled 0pt) withcolor fillcolor;\n",
	//	    x1 / 10.0, y1 / 10.0, (x1 + wd) / 10.0, y1 / 10.0,
	//	    (x1 + wd) / 10.0, (y1 + ht) / 10.0, x1 / 10.0,
	//	    (y1 + ht) / 10.0);
	//	    break;
	//
	//    }
	//
	//}
	//
	//TERM_PUBLIC int
	//MP_make_palette(t_sm_palette *palette)
	//{
	// /* metapost can do continuous number of colours */
	//    return 0;
	//}
	//
	//
	//TERM_PUBLIC void
	//MP_set_color(t_colorspec *colorspec)
	//{
	//    double gray = colorspec->value;
	//    rgb_color color;
	//
	// /* remeber that we changed the color, needed to reset color in MP_linetype()*/
	//    MP_color_changed = 1;
	//
	//    if (MP_inline)
	//	MP_endline();
	//
	//    if (!MP_color) {		// gray mode 
	//	if (gray < 1e-3) gray = 0;
	//	fprintf(gpoutfile, "currentcolor:=%.3gwhite;\n", gray);
	//    } else {			// color mode 
	//	if (colorspec->type == TC_LT) {
	//	    int linecolor = colorspec->lt;
	//	    if (linecolor >= MP_LINE_TYPES)
	//		linecolor %= MP_LINE_TYPES;
	//	    if (linecolor == -1)
	//		fprintf(gpoutfile, "currentcolor:=black;\n");
	//	    else if (linecolor >= 0)
	//		fprintf(gpoutfile, "currentcolor:=col%d;\n",linecolor);
	//	}
	//	if (colorspec->type == TC_FRAC) {
	//	    if (sm_palette.colors != 0) // finite nb of colors explicitly requested 
	//		gray = (gray >= ((double)(sm_palette.colors-1)) / sm_palette.colors) ?
	//		    1 : floor(gray * sm_palette.colors) / sm_palette.colors;
	//	    rgb1_from_gray( gray, &color );
	//	} else if (colorspec->type == TC_RGB) {
	//	    color.r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
	//	    color.g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
	//	    color.b = (double)(colorspec->lt & 255) / 255.;
	//	} else
	//	    return;
	//
	//	if (color.r < 1e-4) color.r = 0;
	//	if (color.g < 1e-4) color.g = 0;
	//	if (color.b < 1e-4) color.b = 0;
	//	fprintf(gpoutfile, "currentcolor:=%.4g*red+%.4g*green+%.4g*blue;\n",
	//		color.r, color.g, color.b);
	//    }
	//    return;
	//}
	//
	//TERM_PUBLIC void
	//MP_filled_polygon(int points, gpiPoint *corners)
	//{
	//    int i;
	//    int fillpar = corners->style >> 4;
	//    int style = corners->style & 0xf;
	//
	//    if (MP_inline)
	//	MP_endline();
	//
	//    switch (style) {
	//	case FS_EMPTY:	// fill with background color 
	//		fprintf(gpoutfile,"fillcolor:=background;\n");
	//		break;
	//	case FS_PATTERN: // pattern fill implemented as partial density 
	//	case FS_TRANSPARENT_PATTERN:
	//		fillpar *= 12;
	//	case FS_SOLID:	// solid fill 
	//	case FS_TRANSPARENT_SOLID:
	//		if (fillpar < 100) {
	//		    double density = (100-fillpar) * 0.01;
	//		    fprintf(gpoutfile,"fillcolor:=currentcolor*%.2f+background*%.2f;\n",
	//		        1.0-density, density);
	//		} else {
	//		    fprintf(gpoutfile,"fillcolor:=currentcolor;\n");
	//		}
	//	default:
	//		break;
	//    }
	//
	//    fprintf(gpoutfile, "fill ");
	//    for (i = 0; i < points; i++)
	//	fprintf(gpoutfile, "(%.1fa,%.1fb)%s",
	//		corners[i].x / 10.0, corners[i].y / 10.0,
	//		(i < points - 1 && (i + 1) % MP_LINEMAX == 0) ? "\n--" : "--");
	//    fprintf(gpoutfile, "cycle withcolor fillcolor;\n");
	//}
	//
	//TERM_PUBLIC void
	//MP_previous_palette()
	//{
	//    return;
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//
	//TERM_TABLE_START(mp_driver)
	//    "mp", "MetaPost plotting standard",
	//    MP_XMAX, MP_YMAX, MP_VCHAR, MP_HCHAR,
	//    MP_VTIC, MP_HTIC, MP_options, MP_init, MP_reset,
	//    MP_text, null_scale, MP_graphics, MP_move, MP_vector,
	//    MP_linetype, MP_put_text, MP_text_angle,
	//    MP_justify_text, MP_point, MP_arrow, MP_set_font, MP_pointsize,
	//    TERM_BINARY|TERM_CAN_CLIP|TERM_CAN_DASH,	//flags 
	//    0, 0, MP_boxfill, MP_linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0		// no mouse support for metapost 
	///#endif
	//    , MP_make_palette,
	//    MP_previous_palette,	// write grestore 
	//    MP_set_color,
	//    MP_filled_polygon
	//TERM_TABLE_END(mp_driver)
	///#undef LAST_TERM
	///#define LAST_TERM mp_driver
	//
	///#endif				// TERM_TABLE 
	///#endif				// TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(mp)
	//"1 mp",
	//"?commands set terminal mpost",
	//"?set terminal mp",
	//"?set term mp",
	//"?terminal mp",
	//"?term mp",
	//"?mp",
	//"?metapost",
	//"",
	//" The `mp` driver produces output intended to be input to the Metapost program.",
	//" Running Metapost on the file creates EPS files containing the plots. By",
	//" default, Metapost passes all text through TeX.  This has the advantage of",
	//" allowing essentially  any TeX symbols in titles and labels.",
	//"",
	//" Syntax:",
	//"    set term mp {color | colour | monochrome}",
	//"                {solid | dashed}",
	//"                {notex | tex | latex}",
	//"                {magnification <magsize>}",
	//"                {psnfss | psnfss-version7 | nopsnfss}",
	//"                {prologues <value>}",
	//"                {a4paper}",
	//"                {amstex}",
	//"                {\"<fontname>\"} {<fontsize>}",
	//"",
	//" The option `color` causes lines to be drawn in color (on a printer or display",
	//" that supports it), `monochrome` (or nothing) selects black lines.  The option",
	//" `solid` draws solid lines, while `dashed` (or nothing) selects lines with",
	//" different patterns of dashes.  If `solid` is selected but `color` is not,",
	//" nearly all lines will be identical.  This may occasionally be useful, so it is",
	//" allowed.",
	//"",
	//" The option `notex` bypasses TeX entirely, therefore no TeX code can be used in",
	//" labels under this option.  This is intended for use on old plot files or files",
	//" that make frequent use of common characters like `$` and `%` that require",
	//" special handling in TeX.",
	//"",
	//" The option `tex` sets the terminal to output its text for TeX to process.",
	//"",
	//" The option `latex` sets the terminal to output its text for processing by",
	//" LaTeX. This allows things like \\frac for fractions which LaTeX knows about",
	//" but TeX does not.  Note that you must set the environment variable TEX to the",
	//" name of your LaTeX executable (normally latex) if you use this option or use",
	//" `mpost --tex=<name of LaTeX executable> ...`. Otherwise metapost will try and",
	//" use TeX to process the text and it won't work.",
	//"",
	//" Changing font sizes in TeX has no effect on the size of mathematics, and there",
	//" is no foolproof way to make such a change, except by globally  setting a",
	//" magnification factor. This is the purpose of the `magnification` option. It",
	//" must be followed by a scaling factor. All text (NOT the graphs) will be scaled",
	//" by this factor. Use this if you have math that you want at some size other",
	//" than the default 10pt. Unfortunately, all math will be the same size, but see",
	//" the discussion below on editing the MP output. `mag` will also work under",
	//" `notex` but there seems no point in using it as the font size option (below)",
	//" works as well.",
	//"",
	//" The option `psnfss` uses postscript fonts in combination with LaTeX. Since",
	//" this option only makes sense, if LaTeX is being used, the `latex` option is selected",
	//" automatically. This option includes the following packages for LaTeX:",
	//" inputenc(latin1), fontenc(T1), mathptmx, helvet(scaled=09.2), courier, latexsym ",
	//" and textcomp.",
	//"",
	//" The option `psnfss-version7` uses also postscript fonts in LaTeX (option `latex`",
	//" is also automatically selected), but uses the following packages with LaTeX:",
	//" inputenc(latin1), fontenc(T1), times, mathptmx, helvet and courier.",
	//"",
	//" The option `nopsnfss` is the default and uses the standard font (cmr10 if not",
	//" otherwise specified).",
	//"",
	//" The option `prologues` takes a value as an additional argument and adds the line",
	//" `prologues:=<value>` to the metapost file. If a value of `2` is specified metapost",
	//" uses postscript fonts to generate the eps-file, so that the result can be viewed",
	//" using e.g. ghostscript. Normally the output of metapost uses TeX fonts and therefore",
	//" has to be included in a (La)TeX file before you can look at it.",
	//"",
	//" The option `noprologues` is the default. No additional line specifying the prologue",
	//" will be added.",
	//"",
	//" The option `a4paper` adds a `[a4paper]` to the documentclass. Normally letter paper",
	//" is used (default). Since this option is only used in case of LaTeX, the `latex` option",
	//" is selected automatically.",
	//"",
	//" The option `amstex` automatically selects the `latex` option and includes the following",
	//" LaTeX packages: amsfonts, amsmath(intlimits). By default these packages are not",
	//" included.",
	//"",
	//" A name in quotes selects the font that will be used when no explicit font is",
	//" given in a `set label` or `set title`.  A name recognized by TeX (a TFM file",
	//" exists) must be used.  The default is \"cmr10\" unless `notex` is selected,",
	//" then it is \"pcrr8r\" (Courier).  Even under `notex`, a TFM file is needed by",
	//" Metapost. The file `pcrr8r.tfm` is the name given to Courier in LaTeX's psnfss",
	//" package.  If you change the font from the `notex` default, choose a font that",
	//" matches the ASCII encoding at least in the range 32-126.  `cmtt10` almost",
	//" works, but it has a nonblank character in position 32 (space).",
	//"",
	//" The size can be any number between 5.0 and 99.99.  If it is omitted, 10.0 is",
	//" used.  It is advisable to use `magstep` sizes: 10 times an integer or",
	//" half-integer power of 1.2, rounded to two decimals, because those are the most",
	//" available sizes of fonts in TeX systems.",
	//"",
	//" All the options are optional.  If font information is given, it must be at the",
	//" end, with size (if present) last.  The size is needed to select a size for the",
	//" font, even if the font name includes size information.  For example,",
	//" `set term mp \"cmtt12\"` selects cmtt12 shrunk to the default size 10.  This",
	//" is probably not what you want or you would have used cmtt10.",
	//"",
	//" The following common ascii characters need special treatment in TeX:",
	//"    $, &, #, %, _;  |, <, >;  ^, ~,  \\, {, and }",
	//" The five characters $, #, &, _, and % can simply be escaped, e.g., `\\$`.",
	//" The three characters <, >, and | can be wrapped in math mode, e.g., `$<$`.",
	//" The remainder require some TeX work-arounds.  Any good book on TeX will give",
	//" some guidance.",
	//"",
	//" If you type your labels inside double quotes, backslashes in TeX code need to",
	//" be escaped (doubled). Using single quotes will avoid having to do this, but",
	//" then you cannot use `\\n` for line breaks.  As of this writing, version 3.7 of",
	//" gnuplot processes titles given in a `plot` command differently than in other",
	//" places, and backslashes in TeX commands need to be doubled regardless of the",
	//" style of quotes.",
	//"",
	//" Metapost pictures are typically used in TeX documents.  Metapost deals with",
	//" fonts pretty much the same way TeX does, which is different from most other",
	//" document preparation programs.  If the picture is included in a LaTeX document",
	//" using the graphics package, or in a plainTeX document via epsf.tex, and then",
	//" converted to PostScript with dvips (or other dvi-to-ps converter), the text in",
	//" the plot will usually be handled correctly.  However, the text may not appear",
	//" if you send the Metapost output as-is to a PostScript interpreter.",
	//"",
	//"2 Metapost Instructions",
	//"?commands set terminal mp detailed",
	//"?set terminal mp detailed",
	//"?set term mp detailed",
	//"?mp detailed",
	//"?metapost detailed",
	//"",
	//" - Set your terminal to Metapost, e.g.:",
	//"    set terminal mp mono \"cmtt12\" 12",
	//"",
	//" - Select an output-file, e.g.:",
	//"    set output \"figure.mp\"",
	//"",
	//" - Create your pictures.  Each plot (or multiplot group) will generate a",
	//" separate Metapost beginfig...endfig group.  Its default size will be 5 by 3",
	//" inches.  You can change the size by saying `set size 0.5,0.5` or whatever",
	//" fraction of the default size you want to have.",
	//"",
	//" - Quit gnuplot.",
	//"",
	//" - Generate EPS files by running Metapost on the output of gnuplot:",
	//"    mpost figure.mp  OR  mp figure.mp",
	//" The name of the Metapost program depends on the system, typically `mpost` for",
	//" a Unix machine and `mp` on many others.  Metapost will generate one EPS file",
	//" for each picture.",
	//"",
	//" - To include your pictures in your document you can use the graphics package",
	//" in LaTeX or epsf.tex in plainTeX:",
	//"    \\usepackage{graphics} % LaTeX",
	//"    \\input epsf.tex       % plainTeX",
	//" If you use a driver other than dvips for converting TeX DVI output to PS, you",
	//" may need to add the following line in your LaTeX document:",
	//"    \\DeclareGraphicsRule{*}{eps}{*}{}",
	//" Each picture you made is in a separate file.  The first picture is in, e.g.,",
	//" figure.0, the second in figure.1, and so on....  To place the third picture in",
	//" your document, for example, all you have to do is:",
	//"    \\includegraphics{figure.2} % LaTeX",
	//"    \\epsfbox{figure.2}         % plainTeX",
	//"",
	//" The advantage, if any, of the mp terminal over a postscript terminal is",
	//" editable output.  Considerable effort went into making this output as clean as",
	//" possible.  For those knowledgeable in the Metapost language, the default line",
	//" types and colors can be changed by editing the arrays `lt[]` and `col[]`.",
	//" The choice of solid vs dashed lines, and color vs black lines can be change by",
	//" changing the values assigned to the booleans `dashedlines` and `colorlines`.",
	//" If the default `tex` option was in effect, global changes to the text of",
	//" labels can be achieved by editing the `vebatimtex...etex` block.  In",
	//" particular, a LaTeX preamble can be added if desired, and then LaTeX's",
	//" built-in size changing commands can be used for maximum flexibility. Be sure",
	//" to set the appropriate MP configuration variable to force Metapost to run",
	//" LaTeX instead of plainTeX."
	//END_HELP(mp)
	///#endif				// TERM_HELP 


	///#ifdef USE_GGI_DRIVER
	///#include "ggi.trm"
	///#endif

	///#ifdef GP_ENH_EST
	/* Hello, Emacs, this is -*-C-*-
	 * $Id: estimate.trm,v 1.8 2009/03/26 00:49:20 sfeam Exp $
	 *
	 */

	/* GNUPLOT - estimate.trm */

	/*
	 * This file is included by ../src/term.c via term.h.
	 *
	 * This terminal driver supports:
	 *   On return from ENHest_put_text()
	 *	(*term)->xmax = estimated string width
	 *	(*term)->ymax = estimated string height (in tenths of a character height)
	 *
	 * AUTHORS
	 *
	 *   Ethan A Merritt - Dec 2004
	 *
	 */

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void ENHest_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
	//TERM_PUBLIC void ENHest_OPEN __PROTO((char * fontname, double fontsize,
	//	                            double base, TBOOLEAN widthflag, TBOOLEAN showflag,
	//				    int overprint));
	//TERM_PUBLIC void ENHest_FLUSH __PROTO((void));
	///#endif // TERM_PROTO 

	///#ifdef TERM_BODY
	//
	//static double ENHest_x, ENHest_y;
	//static double ENHest_xsave, ENHest_ysave;
	//static double ENHest_fragment_width;
	//static double ENHest_fontsize;
	//static double ENHest_min_height, ENHest_max_height;
	//static double ENHest_total_width;
	//
	//static TBOOLEAN ENHest_opened_string;
	//static TBOOLEAN ENHest_show = TRUE;
	//static int ENHest_overprint = 0;
	//static TBOOLEAN ENHest_widthflag = TRUE;
	///#define ENHest_font ""
	//static double ENHest_base;
	//
	//TERM_PUBLIC void
	//ENHest_OPEN(
	//    char *fontname,
	//    double fontsize, double base,
	//    TBOOLEAN widthflag, TBOOLEAN showflag,
	//    int overprint)
	//{
	// /* There are two special cases:
	//  * overprint = 3 means save current position
	//  * overprint = 4 means restore saved position
	//  */
	//    if (overprint == 3) {
	//	ENHest_xsave = ENHest_x;
	//	ENHest_ysave = ENHest_y;
	//	return;
	//    } else if (overprint == 4) {
	//	ENHest_x = ENHest_xsave;
	//	ENHest_y = ENHest_ysave;
	//	return;
	//    }
	//
	//    if (!ENHest_opened_string) {
	//	ENHest_opened_string = TRUE;
	// /* Start new text fragment */
	//	    ENHest_fragment_width = 0;
	// /* font size will be used to estimate width of each character */
	//	    ENHest_fontsize = fontsize > 2.0 ? 1.0 : fontsize;
	// /* Scale fractional font height */
	//	    ENHest_base = base * 1.0;
	//	    if (ENHest_max_height < ENHest_base+1.0*fontsize)
	//		ENHest_max_height = ENHest_base+1.0*fontsize;
	//	    if (ENHest_min_height > ENHest_base)
	//		ENHest_min_height = ENHest_base;
	//	    FPRINTF((stderr,"ENHest_OPEN: base %g fontsize %g  min %g max %g\n",
	//	    	    base,fontsize,ENHest_min_height,ENHest_max_height));
	// /* Keep track of whether we are supposed to show this string */
	//	    ENHest_show = showflag;
	// /* 0/1/2  no overprint / 1st pass / 2nd pass */
	//	    ENHest_overprint = overprint;
	// /* widthflag FALSE means do not update text position after printing */
	//	    ENHest_widthflag = widthflag;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHest_FLUSH()
	//{
	//    double len = ENHest_fragment_width;
	//
	//    if (ENHest_opened_string) {
	//	ENHest_fragment_width = 0;
	//
	//	if (!ENHest_widthflag)
	// /* don't update position */
	//	    ;
	//	else if (ENHest_overprint == 1)
	// /* First pass of overprint, leave position in center of fragment */
	//	    ENHest_x += len / 2;
	//	else
	// /* Normal case is to update position to end of fragment */
	//	    ENHest_x += len;
	//
	//	ENHest_total_width = GPMAX(ENHest_total_width, ENHest_x);
	//	ENHest_opened_string = FALSE;
	//    }
	//}
	//
	//TERM_PUBLIC void
	//ENHest_put_text(unsigned int x, unsigned int y, const char *str)
	//{
	// /* Set up global variables needed by enhanced_recursion() */
	//    ENHest_fontsize  = 1.0;
	//    ENHest_opened_string = FALSE;
	//    ENHest_max_height = 1.0;
	//    ENHest_min_height = 0.0;
	//    ENHest_total_width = 0.0;
	//
	// /* If no enhanced text processing is needed, strlen() is sufficient */
	//    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~\n")) {
	//	term->xmax = strlen(str);
	//	term->ymax = 10;
	//	return;
	//    }
	//
	//    ENHest_x = x;
	//    ENHest_y = y;
	//
	//    while (*(str = enhanced_recursion((char *)str, TRUE,
	//    			ENHest_font, ENHest_fontsize,
	//			0.0, TRUE, TRUE, 0))) {
	//	(term->enhanced_flush)();
	//
	//	enh_err_check(str);
	//	if (!*++str)
	//	    break; // end of string 
	//    }
	//
	//    if (ENHest_x > 0.0 && ENHest_x < 1.0)
	//	ENHest_x = 1;
	//    term->xmax = ENHest_total_width;
	//    term->ymax = 10. * (ENHest_max_height - ENHest_min_height) + 0.5;
	//}
	//
	//TERM_PUBLIC void
	//ENHest_writec(int c)
	//{
	//    if (c == '\n') {
	//	ENHest_FLUSH();
	//	ENHest_opened_string = TRUE;
	//	ENHest_min_height -= 1.0 * ENHest_fontsize;
	//	ENHest_base -= 1.0 * ENHest_fontsize;
	//	ENHest_x = 0;
	//    }
	//
	//    ENHest_fragment_width += ENHest_fontsize;
	//}
	//
	//
	//static struct termentry ENHest = {
	//    "estimate", "estimate width of enhanced text string",
	//    1, 1, 1, 1, 1, 1,
	//    NULL, NULL, NULL,
	//    NULL, NULL, NULL, NULL, NULL,
	//    NULL, ENHest_put_text, NULL,
	//    NULL, NULL, NULL, NULL,
	//    0, 0,			// pointsize, flags 
	//    NULL, NULL, NULL, NULL
	///#ifdef USE_MOUSE
	//    , NULL, NULL, NULL, NULL, NULL
	///#endif
	//    , NULL, NULL, NULL, NULL
	//    , NULL
	//    , ENHest_OPEN, ENHest_FLUSH, ENHest_writec
	//};
	//
	///#endif // TERM_BODY 

	///#endif

	/* WXWIDGETS */
	///#ifdef WXWIDGETS
	///#include "wxt.trm"
	///#endif

	///#ifdef HAVE_CAIROPDF
	/*
	 * $Id: cairo.trm,v 1.29.2.3 2009/09/13 17:54:09 sfeam Exp $
	 */

	/* GNUPLOT - cairo.trm */

	/*[
	 * Copyright 2007   Timothee Lecomte
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/

	/*
	 * Modifications:
	 *	Peter Danenberg, Ethan Merritt	- handle png output as well as pdf
	 *	Peter Danenberg - crop for PNGs
	 */

	///#ifdef TERM_REGISTER
	//register_term (pdfcairo)
	///#endif

	///#ifdef TERM_PROTO
	//TERM_PUBLIC void cairotrm_options __PROTO ((void));
	//TERM_PUBLIC void cairotrm_init __PROTO ((void));
	//TERM_PUBLIC void cairotrm_graphics __PROTO ((void));
	//TERM_PUBLIC void cairotrm_text __PROTO ((void));
	//TERM_PUBLIC void cairotrm_linetype __PROTO ((int linetype));
	//TERM_PUBLIC void cairotrm_move __PROTO ((unsigned int x, unsigned int y));
	//TERM_PUBLIC void cairotrm_vector __PROTO ((unsigned int x, unsigned int y));
	//TERM_PUBLIC void cairotrm_put_text __PROTO ((unsigned int x, unsigned int y, const char *str));
	//TERM_PUBLIC void cairotrm_enhanced_flush();
	//TERM_PUBLIC void cairotrm_enhanced_writec(int c);
	//TERM_PUBLIC void cairotrm_enhanced_open(char* fontname, double fontsize, double base, TBOOLEAN widthflag, TBOOLEAN showflag, int overprint);
	//TERM_PUBLIC void cairotrm_reset __PROTO ((void));
	//TERM_PUBLIC int cairotrm_justify_text __PROTO ((enum JUSTIFY mode));
	//TERM_PUBLIC void cairotrm_point __PROTO ((unsigned int x, unsigned int y, int pointstyle));
	//TERM_PUBLIC void cairotrm_linewidth __PROTO ((double linewidth));
	//TERM_PUBLIC int cairotrm_text_angle __PROTO ((int ang));
	//TERM_PUBLIC void cairotrm_fillbox __PROTO ((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
	//TERM_PUBLIC int cairotrm_set_font __PROTO ((const char *font));
	//TERM_PUBLIC void cairotrm_pointsize __PROTO ((double ptsize));
	//TERM_PUBLIC void cairotrm_image __PROTO ((unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode));
	//TERM_PUBLIC int cairotrm_make_palette __PROTO ((t_sm_palette *palette));
	//TERM_PUBLIC void cairotrm_set_color __PROTO ((t_colorspec *colorspec));
	//TERM_PUBLIC void cairotrm_filled_polygon __PROTO ((int n, gpiPoint * corners));
	///#endif // TERM_PROTO 

	///#ifndef TERM_PROTO_ONLY

	///#ifdef TERM_BODY
	//
	///#include "cairo-pdf.h"
	///#include "wxterminal/gp_cairo.h"
	///#include "wxterminal/gp_cairo_helpers.h"
	///#include "glib.h"		// For guint32 
	//
	///#define CAIROTRM_DEFAULT_FONTNAME "Sans"
	//
	// /* terminal state */
	//TBOOLEAN cairotrm_enhanced_enabled = FALSE;
	//TBOOLEAN cairotrm_dashed = FALSE;
	//TBOOLEAN cairotrm_mono = FALSE;
	//TBOOLEAN cairotrm_rounded = FALSE;
	//TBOOLEAN cairotrm_transparent = FALSE;
	//TBOOLEAN cairotrm_crop = FALSE;
	// /* default text font family: */
	//char cairotrm_set_fontname[MAX_ID_LEN + 1] = "";
	// /* default text size*/
	//int cairotrm_set_fontsize = 0;
	//
	// /* default sizes vary with the terminal type */
	///#define CAIROPDF_DEFAULT_WIDTH  5*72 // PDF  5x3 inches 
	///#define CAIROPDF_DEFAULT_HEIGHT 3*72
	///#define CAIROPNG_DEFAULT_WIDTH  640  // PNG 640x480 pixels 
	///#define CAIROPNG_DEFAULT_HEIGHT 480
	//float cairopdf_width = CAIROPDF_DEFAULT_WIDTH;
	//float cairopdf_height = CAIROPDF_DEFAULT_HEIGHT;
	//float cairopng_width = CAIROPNG_DEFAULT_WIDTH;
	//float cairopng_height = CAIROPNG_DEFAULT_HEIGHT;
	//float cairotrm_width, cairotrm_height;
	//float cairotrm_default_fontsize;
	//
	//float cairopdf_base_linewidth = 0.25;
	//float cairopng_base_linewidth = 1.0;
	//float cairotrm_base_linewidth;
	//
	// /* Default multipliers for linewidths and dashlengths */
	//float cairotrm_lw = 1.0;
	//float cairotrm_dl = 1.0;
	//
	//
	//plot_struct plot;
	//
	//enum CAIROTRM_id {
	//    CAIROTRM_FONT,
	//    CAIROTRM_ENHANCED,
	//    CAIROTRM_NOENHANCED,
	//    CAIROTRM_SIZE,
	//    CAIROTRM_ROUNDED,
	//    CAIROTRM_BUTT,
	//    CAIROTRM_LINEWIDTH,
	//    CAIROTRM_DASHED,
	//    CAIROTRM_SOLID,
	//    CAIROTRM_MONO,
	//    CAIROTRM_COLOR,
	//    CAIROTRM_DASHLENGTH,
	//    CAIROTRM_TRANSPARENT,
	//    CAIROTRM_NOTRANSPARENT,
	//    CAIROTRM_CROP,
	//    CAIROTRM_NOCROP,
	//    CAIROTRM_OTHER
	//};
	//
	//static struct gen_table cairotrm_opts[] = {
	//    {"f$ont",   CAIROTRM_FONT},
	//    {"enh$anced", CAIROTRM_ENHANCED},
	//    {"noenh$anced", CAIROTRM_NOENHANCED},
	//    {"si$ze", CAIROTRM_SIZE},
	//    {"round$ed", CAIROTRM_ROUNDED},
	//    {"butt", CAIROTRM_BUTT},
	//    {"lw", CAIROTRM_LINEWIDTH},
	//    {"linew$idth", CAIROTRM_LINEWIDTH},
	//    {"dash$ed", CAIROTRM_DASHED},
	//    {"solid", CAIROTRM_SOLID},
	//    {"mono$chrome", CAIROTRM_MONO},
	//    {"color", CAIROTRM_COLOR},
	//    {"col$our", CAIROTRM_COLOR},
	//    {"dl", CAIROTRM_DASHLENGTH},
	//    {"dashl$ength", CAIROTRM_DASHLENGTH},
	//    {"transp$arent", CAIROTRM_TRANSPARENT},
	//    {"notransp$arent", CAIROTRM_NOTRANSPARENT},
	//    {"crop", CAIROTRM_CROP},
	//    {"nocrop", CAIROTRM_NOCROP},
	//    {NULL, CAIROTRM_OTHER}
	//};
	//
	// /* "Called when terminal type is selected. This procedure should parse options on the command line.
	// * A list of the currently selected options should be stored in term_options[],
	// * in a form suitable for use with the set term command.
	// * term_options[] is used by the save command.  Use options_null() if no options are available." */
	//TERM_PUBLIC void cairotrm_options()
	//{
	//	char *s = NULL;
	//	char *font_setting = NULL;
	//	int sep;
	//	TBOOLEAN duplication = FALSE;
	//	TBOOLEAN set_enhanced = FALSE, set_font = FALSE, set_size = FALSE;
	//	TBOOLEAN set_capjoin = FALSE;
	//	size_units cairotrm_explicit_units;
	//	char tmp_term_options[MAX_LINE_LEN+1] = "";
	///#if 0
	// /* terminals should not reset options during "set term" call */
	//	cairotrm_dashed = FALSE;	// Dashed lines? (default is solid) 
	//	cairotrm_mono = FALSE;  	// Mono? (default is color) 
	//	cairotrm_transparent = FALSE;
	//	cairotrm_crop = FALSE;
	///#endif
	//
	// /* Initialize terminal-dependent values */
	//	if (!strcmp(term->name,"pngcairo")) {
	//		cairotrm_explicit_units = PIXELS;
	//		cairotrm_default_fontsize = 12;
	//	} else {
	//		cairotrm_explicit_units = INCHES;
	//		cairotrm_default_fontsize = 6;
	//	}
	//
	//	while (!END_OF_COMMAND) {
	//		FPRINTF((stderr, "processing token\n"));
	//		switch (lookup_table(&cairotrm_opts[0], c_token)) {
	//		case CAIROTRM_FONT:
	//			c_token++;
	//			if (!(s = try_to_get_string()))
	//				int_error(c_token,"font: expecting string");
	//			if (!(*s)) {
	//				strcpy (cairotrm_set_fontname, "");
	//				cairotrm_set_fontsize = 0;
	//			} else {
	//				sep = strcspn(s,",");
	//				if (sep > 0) {
	//					strncpy(cairotrm_set_fontname, s, sep);
	//					cairotrm_set_fontname[sep] = '\0';
	//				}
	//				if (s[sep] == ',')
	//					sscanf(&(s[sep+1]), "%d", &cairotrm_set_fontsize);
	//			}
	//			font_setting = (char*) gp_alloc(strlen(s) + 1,"cairo terminal font");
	//			strcpy(font_setting,s);
	//			free(s);
	//			if (set_font) duplication=TRUE;
	//			set_font = TRUE;
	//			break;
	//		case CAIROTRM_ENHANCED:
	//			c_token++;
	//			cairotrm_enhanced_enabled = TRUE;
	//			term->flags |= TERM_ENHANCED_TEXT;
	//			if (set_enhanced) duplication=TRUE;
	//			set_enhanced = TRUE;
	//			break;
	//		case CAIROTRM_NOENHANCED:
	//			c_token++;
	//			cairotrm_enhanced_enabled = FALSE;
	//			term->flags &= ~TERM_ENHANCED_TEXT;
	//			if (set_enhanced) duplication=TRUE;
	//			set_enhanced = TRUE;
	//			break;
	//		case CAIROTRM_SIZE:
	//			c_token++;
	//			if (!strcmp(term->name,"pngcairo"))
	//			    cairotrm_explicit_units = parse_term_size(&cairopng_width, &cairopng_height, PIXELS);
	//			else
	//			    cairotrm_explicit_units = parse_term_size(&cairopdf_width, &cairopdf_height, INCHES);
	//			if (set_size) duplication=TRUE;
	//			set_size = TRUE;
	//			break;
	//		case CAIROTRM_ROUNDED:
	//			c_token++;
	//			if (set_capjoin) duplication=TRUE;
	//			cairotrm_rounded = TRUE;
	//			set_capjoin = TRUE;
	//			break;
	//		case CAIROTRM_BUTT:
	//			c_token++;
	//			if (set_capjoin) duplication=TRUE;
	//			cairotrm_rounded = FALSE;
	//			set_capjoin = TRUE;
	//			break;
	//		case CAIROTRM_LINEWIDTH:
	//			c_token++;
	//			cairotrm_lw = real_expression();
	//			if (cairotrm_lw < 0.0)
	//			    cairotrm_lw = 1.0;
	//			break;
	//		case CAIROTRM_DASHED:
	//			c_token++;
	//			cairotrm_dashed = TRUE;
	//			break;
	//		case CAIROTRM_SOLID:
	//			c_token++;
	//			cairotrm_dashed = FALSE;
	//			break;
	//		case CAIROTRM_MONO:
	//			c_token++;
	//			cairotrm_mono = TRUE;
	//			term->flags |= TERM_MONOCHROME;
	//			break;
	//		case CAIROTRM_COLOR:
	//			c_token++;
	//			cairotrm_mono = FALSE;
	//			term->flags &= ~TERM_MONOCHROME;
	//			break;
	//		case CAIROTRM_DASHLENGTH:
	//			c_token++;
	//			cairotrm_dl = real_expression();
	//			if (cairotrm_dl < 0.0)
	//			    cairotrm_dl = 1.0;
	//			break;
	//		case CAIROTRM_TRANSPARENT:
	//			c_token++;
	//			if (!strcmp(term->name,"pngcairo"))
	//			    cairotrm_transparent = TRUE;
	//			break;
	//		case CAIROTRM_NOTRANSPARENT:
	//			c_token++;
	//			if (!strcmp(term->name,"pngcairo"))
	//			    cairotrm_transparent = FALSE;
	//			break;
	//		case CAIROTRM_CROP:
	//			c_token++;
	//			if (!strcmp(term->name,"pngcairo"))
	//			    cairotrm_crop = TRUE;
	//			break;
	//		case CAIROTRM_NOCROP:
	//			c_token++;
	//			if (!strcmp(term->name,"pngcairo"))
	//			    cairotrm_crop = FALSE;
	//			break;
	//		case CAIROTRM_OTHER:
	// /* Ignore irrelevant keywords used by other png/pdf drivers */
	//			if (almost_equals(c_token,"true$color")
	//			||  almost_equals(c_token,"inter$lace")
	//			||  almost_equals(c_token,"nointer$lace")) {
	//			    c_token++;
	//			    break;
	//			}
	//		default:
	//			int_error(c_token, "unrecognized terminal option");
	//			break;
	//		}
	//
	//		if (duplication)
	//			int_error(c_token-1, "Duplicated or contradicting arguments in cairo terminal options.");
	//	}
	//
	// /* Copy terminal-dependent values to the generic equivalent */
	//	if (!strcmp(term->name,"pngcairo")) {
	//		cairotrm_width = cairopng_width;
	//		cairotrm_height = cairopng_height;
	//		cairotrm_base_linewidth = cairopng_base_linewidth;
	//	} else {
	//		cairotrm_width = cairopdf_width;
	//		cairotrm_height = cairopdf_height;
	//		cairotrm_base_linewidth = cairopdf_base_linewidth;
	//	}
	//
	//
	// /* Save options back into options string in normalized format */
	//	if (cairotrm_transparent)
	//		strncat(term_options, " transparent", sizeof(term_options)-strlen(term_options));
	//
	//	if (cairotrm_crop)
	//		strncat(term_options, " crop", sizeof(term_options)-strlen(term_options));
	//
	//	if (set_enhanced)
	//		strncat(term_options, " enhanced", sizeof(term_options)-strlen(term_options));
	//
	//	if (set_font) {
	//		snprintf(tmp_term_options, sizeof(tmp_term_options), " font \"%s\"", font_setting);
	//		free(font_setting);
	//		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	//	}
	//
	//	if (cairotrm_mono)
	//		strncat(term_options, " monochrome", sizeof(term_options)-strlen(term_options));
	//
	//	if (cairotrm_dashed)
	//		strncat(term_options, " dashed", sizeof(term_options)-strlen(term_options));
	//
	//	if (1 || set_size) {
	//		if (cairotrm_explicit_units == CM)
	//			snprintf(tmp_term_options,
	//				sizeof(tmp_term_options),
	//				" size %.2fcm, %.2fcm ",
	//				2.54*cairotrm_width/72., 2.54*cairotrm_height/72.);
	//		else if (cairotrm_explicit_units == PIXELS)
	//			snprintf(tmp_term_options,
	//				sizeof(tmp_term_options),
	//				" size %d, %d ",
	//				(int)cairotrm_width, (int)cairotrm_height);
	//		else
	//			snprintf(tmp_term_options,
	//				sizeof(tmp_term_options),
	//				" size %.2fin, %.2fin ",
	//				cairotrm_width/72., cairotrm_height/72.);
	//		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	//	}
	//
	//	if (set_capjoin) {
	//		strncat(term_options, cairotrm_rounded ? " rounded" : " butt",
	//			sizeof(term_options)-strlen(term_options));
	//	}
	//
	//	if (cairotrm_lw != 1.0) {
	//		snprintf(tmp_term_options,sizeof(tmp_term_options), " linewidth %g", cairotrm_lw);
	//		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	//	}
	//
	//	if (cairotrm_dl != 1.0) {
	//		snprintf(tmp_term_options,sizeof(tmp_term_options), " dashlength %g", cairotrm_dl);
	//		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	//	}
	//}
	//
	// /* "Called once, when the device is first selected."
	//  * Is the 'main' function of the terminal. */
	//void cairotrm_init()
	//{
	//	cairo_surface_t *surface = NULL;
	//
	//	FPRINTF((stderr,"Init\n"));
	//
	// /* do a sanity check for once */
	//	if (strcmp(term->name,"pdfcairo") && strcmp(term->name,"pngcairo"))
	//		int_error(c_token,"Unrecognized cairo terminal");
	//
	// /* initialisations */
	//	gp_cairo_initialize_plot(&plot);
	//	plot.device_xmax = (double) cairotrm_width;
	//	plot.device_ymax = (double) cairotrm_height;
	//	plot.dashlength = cairotrm_dl;
	//
	// /* is supposed to be done in cairotrm_reset */
	//	if ( plot.cr )
	//		cairo_destroy(plot.cr);
	//
	//	if (!strcmp(term->name,"pdfcairo")) {
	//		surface = cairo_pdf_surface_create(outstr,
	//				plot.device_xmax //double width_in_points
	//,
	//				plot.device_ymax //double height_in_points
	//);
	// /* it is up to the pdf viewer to do the hinting */
	//		plot.hinting = 0;
	// /* disable OPERATOR_SATURATE, not implemented in cairo pdf backend,
	//  * results in bitmap fallback. However, polygons are drawn with seams
	//  * between each other. */
	//		plot.polygons_saturate = FALSE;
	// /* Empirical correction to make pdf output look more like wxt and png */
	//		plot.dashlength /= 2;
	//	} else if (!strcmp(term->name,"pngcairo")) {
	//		surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32,
	//				plot.device_xmax //double width_in_points
	//,
	//				plot.device_ymax //double height_in_points
	//);
	// /* png is bitmapped, let's do the full hinting */
	//		plot.hinting = 100;
	// /* png is produced by cairo "image" backend, which has full support
	//  * of OPERATOR_SATURATE */
	//		plot.polygons_saturate = TRUE;
	//	}
	//
	//	plot.cr = cairo_create(surface);
	//	cairo_surface_destroy( surface );
	//
	//	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
	//	FPRINTF((stderr,"Init finished \n"));
	//}
	//
	// /* "Called just before a plot is going to be displayed."
	//  * Should clear the terminal. */
	//void cairotrm_graphics()
	//{
	// /* Initialize background to solid white */
	//	if (cairotrm_transparent)
	//		gp_cairo_clear_background(&plot);
	//	else
	//		gp_cairo_solid_background(&plot);
	//
	//
	// /* update the window scale factor first, cairo needs it */
	//	plot.xscale = 1.0;
	//	plot.yscale = 1.0;
	//
	// /* update graphics state properties */
	//	plot.rounded = cairotrm_rounded;
	//
	//	FPRINTF((stderr,"Graphics1\n"));
	//
	// /* set the transformation matrix of the context, and other details */
	// /* depends on plot.xscale and plot.yscale */
	//	gp_cairo_initialize_context(&plot);
	//
	// /* set or refresh terminal size according to the window size */
	// /* oversampling_scale is updated in gp_cairo_initialize_context */
	//	term->xmax = (unsigned int) plot.device_xmax*plot.oversampling_scale;
	//	term->ymax = (unsigned int) plot.device_ymax*plot.oversampling_scale;
	//	term->tscale = plot.oversampling_scale;
	//	plot.xmax = term->xmax;
	//	plot.ymax = term->ymax;
	// /* initialize encoding */
	//	plot.encoding = encoding;
	//
	// /* set font details (h_char, v_char) according to settings */
	//	cairotrm_set_font("");
	//
	//	term->v_tic = (unsigned int) (term->v_char/2.5);
	//	term->h_tic = (unsigned int) (term->v_char/2.5);
	//
	//	FPRINTF((stderr,"Graphics xmax %d ymax %d v_char %d h_char %d\n",
	//		term->xmax, term->ymax, term->v_char, term->h_char));
	//}
	//
	//
	// /* cairo mechanism to allow writing to an output stream */
	//cairo_status_t
	//cairopng_write(void *closure, unsigned char *data, unsigned int length)
	//{
	//	if (length != fwrite(data, 1, length, gpoutfile))
	//		return CAIRO_STATUS_WRITE_ERROR;
	//	return CAIRO_STATUS_SUCCESS;
	//}
	//
	//cairo_surface_t *
	//cairopng_do_crop()
	//{
	//  cairo_surface_t *surface = cairo_get_target(plot.cr);
	//  unsigned char *data = cairo_image_surface_get_data(surface);
	//  int width = cairo_image_surface_get_width(surface);
	//  int height = cairo_image_surface_get_height(surface);
	//  int stride = cairo_image_surface_get_stride(surface);
	//  int  i, j, x1 = 0, y1 = 0, x2 = width, y2 = height;
	//
	//  guint32 *row;
	//  guint32 BG = (cairotrm_transparent) ? 0x0 : ~0x0;
	//
	// /* return unadulterated surface if we're not cropping */
	//  if (!cairotrm_crop)
	//	return(surface);
	//
	// /* Row-wise, top-down iteration */
	//  for (i = 0; i < height; i++) {
	//    row = (guint32 *) (data + i * stride);
	//    for (j = 0; j < width; j++) {
	//      if (row[j] != BG) {
	//	y1 = i;
	//	goto found_y1;
	//      }
	//    }
	//  }
	// found_y1:
	// /* Row-wise, bottom-up iteration */
	//  for (i = height - 1; i >= y1; i--) {
	//    row = (guint32 *)(data + i * stride);
	//    for (j = 0; j < width; j++) {
	//      if (row[j] != BG) {
	//	y2 = i;
	//	goto found_y2;
	//      }
	//    }
	//  }
	// found_y2:
	// /* Column-wise, left-to-right iteration */
	//  for (j = 0; j < width; j++) {
	//    for (i = y1; i <= y2; i++) {
	//      row = (guint32 *) (data + i * stride);
	//      if (row[j] != BG) {
	//	x1 = j;
	//	goto found_x1;
	//      }
	//    }
	//  }
	// found_x1:
	// /* Column-wise, right-to-left iteration */
	//  for (j = width - 1; j >= x1; j--) {
	//    for (i = y1; i <= y2; i++) {
	//      row = (guint32 *) (data + i * stride);
	//      if (row[j] != BG) {
	//	x2 = j;
	//	goto found_x2;
	//      }
	//    }
	//  }
	// found_x2:
	//  {
	//  const int padding = 10;
	//  int clip_width = GPMIN(x2 - x1 + padding, width);
	//  int clip_height = GPMIN(y2 - y1 + padding, height);
	//  cairo_surface_t *clip = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 
	//  			clip_width, clip_height);
	//  cairo_t *clip_cr = cairo_create(clip);
	//  cairo_set_source_surface(clip_cr, cairo_get_target(plot.cr),
	//			-GPMAX(x1 - padding / 2, 0),
	//			-GPMAX(y1 - padding / 2, 0));
	//  cairo_rectangle(clip_cr, 0, 0, clip_width, clip_height);
	//  cairo_fill(clip_cr);
	//  return clip;
	//  }
	//}
	//
	//void cairotrm_text()
	//{
	//	FPRINTF((stderr,"Text0\n"));
	//
	// /* don't forget to stroke the last path if vector was the last command */
	//	gp_cairo_stroke(&plot);
	// /* and don't forget to draw the polygons if draw_polygon was the last command */
	//	gp_cairo_end_polygon(&plot);
	//
	//	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
	//
	// /* finish the page - cairo_destroy still has to be called for the whole documentation
	//  * to be written */
	//	cairo_show_page(plot.cr);
	//	if (!strcmp(term->name,"pngcairo")) {
	//		int error_data[1];
	//		cairo_surface_write_to_png_stream(cairopng_do_crop(),
	//			(cairo_write_func_t)cairopng_write, error_data);
	//	}
	//
	//	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
	//
	//	FPRINTF((stderr,"Text finished\n"));
	//}
	//
	// /* sent when gnuplot exits and when the terminal or the output change.*/
	//void cairotrm_reset()
	//{
	// /* finish the document */
	//	cairo_destroy(plot.cr);
	//
	//	FPRINTF((stderr,"cairotrm_reset\n"));
	//}
	//
	//void cairotrm_move(unsigned int x, unsigned int y)
	//{
	//	gp_cairo_move(&plot, x, term->ymax - y);
	//}
	//
	//void cairotrm_vector(unsigned int x, unsigned int y)
	//{
	//	gp_cairo_vector(&plot, x, term->ymax - y);
	//}
	//
	//void cairotrm_put_text(unsigned int x, unsigned int y, const char * string)
	//{
	// /* if ignore_enhanced_text is set, draw with the normal routine.
	//  * This is meant to avoid enhanced syntax when the enhanced mode is on */
	//	if (cairotrm_enhanced_enabled && !ignore_enhanced_text) {
	// /* Uses enhanced_recursion() to analyse the string to print.
	//  * enhanced_recursion() calls _enhanced_open() to initialize the text drawing,
	//  * then it calls _enhanced_writec() which buffers the characters to draw,
	//  * and finally _enhanced_flush() to draw the buffer with the correct justification. */
	//
	//		gp_cairo_enhanced_init(&plot, strlen(string));
	//
	// /* set up the global variables needed by enhanced_recursion() */
	//		enhanced_fontscale = 1.0;
	//		strncpy(enhanced_escape_format, "%c", sizeof(enhanced_escape_format));
	//
	// /* Set the recursion going. We say to keep going until a
	// * closing brace, but we don't really expect to find one.
	// * If the return value is not the nul-terminator of the
	// * string, that can only mean that we did find an unmatched
	// * closing brace in the string. We inplot->crement past it (else
	// * we get stuck in an infinite loop) and try again. */
	//
	//		while (*(string = enhanced_recursion((char*)string, TRUE, plot.fontname,
	//				plot.fontsize, 0.0, TRUE, TRUE, 0))) {
	//			cairotrm_enhanced_flush();
	//
	// /* we can only get here if *str == '}' */
	//			enh_err_check(string);
	//
	//			if (!*++string)
	//				break; // end of string 
	// /* else carry on and process the rest of the string */
	//		}
	//
	// /* finish */
	//		gp_cairo_enhanced_finish(&plot, x, term->ymax - y);
	//		return;
	//	}
	//
	//	gp_cairo_draw_text(&plot, x, term->ymax - y, string);
	//}
	//
	//void cairotrm_enhanced_flush()
	//{
	//	gp_cairo_enhanced_flush(&plot);
	//}
	//
	//void cairotrm_enhanced_writec(int c)
	//{
	//	gp_cairo_enhanced_writec(&plot, c);
	//}
	//
	//void cairotrm_enhanced_open(char* fontname, double fontsize, double base, TBOOLEAN widthflag, TBOOLEAN showflag, int overprint)
	//{
	//	gp_cairo_enhanced_open(&plot, fontname, fontsize, base, widthflag, showflag, overprint);
	//}
	//
	//void cairotrm_linetype(int lt)
	//{
	//	gp_cairo_set_linetype(&plot, lt);
	//
	//	if (cairotrm_dashed || lt == -1)
	//	    gp_cairo_set_linestyle(&plot,  GP_CAIRO_DASH);
	//	else
	//	    gp_cairo_set_linestyle(&plot,  GP_CAIRO_SOLID);
	//
	//	if (cairotrm_mono && lt >= -1)
	//	    gp_cairo_set_color(&plot, gp_cairo_linetype2color( -1 ));
	//	else
	//	    gp_cairo_set_color(&plot, gp_cairo_linetype2color( lt ));
	//
	//}
	//
	//
	// /* - fonts are selected as strings "name,size".
	//  * - _set_font("") restores the terminal's default font.*/
	//int cairotrm_set_font (const char *font)
	//{
	//	char fontname[MAX_ID_LEN + 1] = "";
	//	int fontsize = 0;
	//
	//	if (!font || !(*font)) {
	//		strncpy(fontname, "", sizeof(fontname));
	//		fontsize = 0;
	//	} else {
	//		int sep;
	//
	//		sep = strcspn(font,",");
	//		if (sep > 0) {
	//			strncpy(fontname, font, sep);
	//			fontname[sep] = '\0';
	//		}
	//		if (font[sep] == ',')
	//			sscanf(&(font[sep+1]), "%d", &fontsize);
	//	}
	//
	//	if ( strlen(fontname) == 0 ) {
	//		if ( strlen(cairotrm_set_fontname) == 0 )
	//			strncpy(fontname, CAIROTRM_DEFAULT_FONTNAME, sizeof(fontname));
	//		else
	//			strncpy(fontname, cairotrm_set_fontname, sizeof(fontname));
	//	}
	//
	//	if ( fontsize == 0 ) {
	//		if ( cairotrm_set_fontsize == 0 )
	//			fontsize = cairotrm_default_fontsize;
	//		else
	//			fontsize = cairotrm_set_fontsize;
	//	}
	//
	//
	// /* Reset the term variables (hchar, vchar, h_tic, v_tic).
	//  * They may be taken into account in next plot commands */
	//	gp_cairo_set_font(&plot, fontname, fontsize);
	//	gp_cairo_set_termvar(&plot, &(term->v_char),
	//				    &(term->h_char));
	//
	// /* the returned int is not used anywhere */
	//	return 1;
	//}
	//	
	//
	//int cairotrm_justify_text(enum JUSTIFY mode)
	//{
	//	gp_cairo_set_justify(&plot,mode);
	//
	//	return 1; // we can justify 
	//}
	//
	//void cairotrm_point(unsigned int x, unsigned int y, int pointstyle)
	//{
	//	gp_cairo_draw_point(&plot, x, term->ymax - y, pointstyle);
	//}
	//
	//void cairotrm_pointsize(double ptsize)
	//{
	// /* same behaviour as x11 terminal */
	//	if (ptsize<0) ptsize = 1;
	//
	//	gp_cairo_set_pointsize(&plot, ptsize);
	//}
	//
	//void cairotrm_linewidth(double lw)
	//{
	//	lw *= cairotrm_lw * cairotrm_base_linewidth;
	//	gp_cairo_set_linewidth(&plot, lw);
	//}
	//
	//int cairotrm_text_angle(int angle)
	//{
	// /* a double is needed to compute cos, sin, etc. */
	//	gp_cairo_set_textangle(&plot, (double) angle);
	//
	//	return 1; // 1 means we can rotate 
	//}
	//
	//void cairotrm_fillbox(int style, unsigned int x, unsigned int y, unsigned int width, unsigned int height)
	//{
	//	gp_cairo_draw_fillbox(&plot, x, term->ymax - y,
	//				width, height,
	//				style);
	//}
	//
	//int cairotrm_make_palette(t_sm_palette * palette)
	//{
	// /* we can do continuous colors */
	//	return 0;
	//}
	//
	//void cairotrm_set_color(t_colorspec *colorspec)
	//{
	//	rgb_color rgb1;
	//
	//	if (colorspec->type == TC_LT) {
	//		rgb1 = gp_cairo_linetype2color(colorspec->lt);
	//	} else if (colorspec->type == TC_FRAC && cairotrm_mono) {
	//		int save_colorMode = sm_palette.colorMode;
	//		sm_palette.colorMode = SMPAL_COLOR_MODE_GRAY;
	//		rgb1maxcolors_from_gray( colorspec->value, &rgb1 );
	//		sm_palette.colorMode = save_colorMode;
	//	} else if (colorspec->type == TC_FRAC) {
	//		rgb1maxcolors_from_gray( colorspec->value, &rgb1 );
	//	} else if (colorspec->type == TC_RGB) {
	//		rgb1.r = (double) ((colorspec->lt >> 16) & 0xff)/255;
	//		rgb1.g = (double) ((colorspec->lt >> 8) & 0xff)/255;
	//		rgb1.b = (double) ((colorspec->lt) & 0xff)/255;
	//	} else return;
	//
	//	gp_cairo_set_color(&plot, rgb1);
	//}
	//
	//
	// /* here we send the polygon command */
	//void cairotrm_filled_polygon(int n, gpiPoint *corners)
	//{
	//	gpiPoint *mirrored_corners = (gpiPoint*) gp_alloc(n*sizeof(gpiPoint),"mirrored_corners");
	// /* can't use memcpy() here, as we have to mirror the y axis */
	//	gpiPoint *corners_copy = mirrored_corners;
	//	while (corners_copy < (mirrored_corners + n)) {
	//		*corners_copy = *corners++;
	//		corners_copy->y = term->ymax - corners_copy->y;
	//		++corners_copy;
	//	}
	//
	//	gp_cairo_draw_polygon(&plot, n, mirrored_corners);
	//	free(mirrored_corners);
	//}
	//
	//void cairotrm_image(unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode)
	//{
	// /* This routine is to plot a pixel-based image on the display device.
	// 'M' is the number of pixels along the y-dimension of the image and
	// 'N' is the number of pixels along the x-dimension of the image.  The
	// coordval pointer 'image' is the pixel values normalized to the range
	// [0:1].  These values should be scaled accordingly for the output
	// device.  They 'image' data starts in the upper left corner and scans
	// along rows finishing in the lower right corner.  If 'color_mode' is
	// IC_PALETTE, the terminal is to use palette lookup to generate color
	// information.  In this scenario the size of 'image' is M*N.  If
	// 'color_mode' is IC_RGB, the terminal is to use RGB components.  In
	// this scenario the size of 'image' is 3*M*N.  The data appears in RGB
	// tripples, i.e., image[0] = R(1,1), image[1] = G(1,1), image[2] =
	// B(1,1), image[3] = R(1,2), image[4] = G(1,2), ..., image[3*M*N-1] =
	// B(M,N).  The 'image' is actually an "input" image in the sense that
	// it must also be properly resampled for the output device.  Many output
	// mediums, e.g., PostScript, do this work via various driver functions.
	// To determine the appropriate rescaling, the 'corner' information
	// should be used.  There are four entries in the gpiPoint data array.
	// 'corner[0]' is the upper left corner (in terms of plot location) of
	// the outer edge of the image.  Similarly, 'corner[1]' is the lower
	// right corner of the outer edge of the image.  (Outer edge means the
	// outer extent of the corner pixels, not the middle of the corner
	// pixels.)  'corner[2]' is the upper left corner of the visible part
	// of the image, and 'corner[3]' is the lower right corner of the visible
	// part of the image.  The information is provided in this way because
	// often it is necessary to clip a portion of the outer pixels of the
	// image. */
	//
	// /* we will draw an image, scale and resize it */
	// /* FIXME add palette support ??? */
	//
	//	unsigned int *image255 = gp_cairo_helper_coordval_to_chars(image, M, N, color_mode);
	//	gp_cairo_draw_image(&plot, image255,
	//			corner[0].x, term->ymax - corner[0].y,
	//			corner[1].x, term->ymax - corner[1].y,
	//			corner[2].x, term->ymax - corner[2].y,
	//			corner[3].x, term->ymax - corner[3].y,
	//			M, N);
	//	free(image255);
	//}
	//
	///#endif // TERM_BODY 

	///#ifdef TERM_TABLE
	//TERM_TABLE_START (pdfcairo_driver)
	//    "pdfcairo", "pdf terminal based on cairo",
	// /* the following values are overriden by cairotrm_graphics */
	//    1 // xmax 
	// , 1 // ymax 
	// , 1 // vchar 
	// , 1 // hchar 
	// ,
	//    1 // vtic 
	// , 1 // htic 
	// ,
	//    cairotrm_options, cairotrm_init, cairotrm_reset, cairotrm_text, null_scale, cairotrm_graphics,
	//    cairotrm_move, cairotrm_vector, cairotrm_linetype, cairotrm_put_text,
	//    cairotrm_text_angle, cairotrm_justify_text,
	//    cairotrm_point, do_arrow, cairotrm_set_font,
	//    cairotrm_pointsize,
	//    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,
	//    0 // suspend 
	//, 0 // resume 
	//, cairotrm_fillbox, cairotrm_linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0
	///#endif
	//    , cairotrm_make_palette, 0 // cairotrm_previous_palette 
	//, cairotrm_set_color, cairotrm_filled_polygon
	//    , cairotrm_image
	//    , cairotrm_enhanced_open, cairotrm_enhanced_flush, cairotrm_enhanced_writec
	//    , 0, 0, 1.0
	//TERM_TABLE_END (pdfcairo_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM pdfcairo_driver
	//
	//
	//TERM_TABLE_START (pngcairo_driver)
	//    "pngcairo", "png terminal based on cairo",
	// /* the following values are overriden by cairotrm_graphics */
	//    1 // xmax 
	// , 1 // ymax 
	// , 1 // vchar 
	// , 1 // hchar 
	// ,
	//    1 // vtic 
	// , 1 // htic 
	// ,
	//    cairotrm_options, cairotrm_init, cairotrm_reset, cairotrm_text, null_scale, cairotrm_graphics,
	//    cairotrm_move, cairotrm_vector, cairotrm_linetype, cairotrm_put_text,
	//    cairotrm_text_angle, cairotrm_justify_text,
	//    cairotrm_point, do_arrow, cairotrm_set_font,
	//    cairotrm_pointsize,
	//    TERM_BINARY|TERM_CAN_DASH|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
	//    0 // suspend 
	//, 0 // resume 
	//, cairotrm_fillbox, cairotrm_linewidth
	///#ifdef USE_MOUSE
	//    , 0, 0, 0, 0, 0
	///#endif
	//    , cairotrm_make_palette, 0 // cairotrm_previous_palette 
	//, cairotrm_set_color, cairotrm_filled_polygon
	//    , cairotrm_image
	//    , cairotrm_enhanced_open, cairotrm_enhanced_flush, cairotrm_enhanced_writec
	//    , 0, 0, 1.0
	//TERM_TABLE_END (pngcairo_driver)
	//
	///#undef LAST_TERM
	///#define LAST_TERM pngcairo_driver
	//
	///#endif // TERM_TABLE 
	///#endif // TERM_PROTO_ONLY 

	///#ifdef TERM_HELP
	//START_HELP(pdfcairo)
	//"1 pdfcairo",
	//"?set terminal pdfcairo",
	//"?terminal pdfcairo",
	//"?set term pdfcairo",
	//"?term pdfcairo",
	//"?pdfcairo",
	//" The `pdfcairo` terminal device generates output in pdf. The actual",
	//" drawing is done via cairo, a 2D graphics library, and pango, a library for",
	//" laying out and rendering text.",
	//"",
	//" Syntax:",
	//"         set term pdfcairo",
	//"                      {{no}enhanced} {mono|color} {solid|dashed}",
	//"                      {font <font>}",
	//"                      {linewidth <lw>} {rounded|butt} {dashlength <dl>}",
	//"                      {size <XX>{unit},<YY>{unit}}",
	//"",
	//" This terminal supports an enhanced text mode, which allows font and other",
	//" formatting commands (subscripts, superscripts, etc.) to be embedded in labels",
	//" and other text strings. The enhanced text mode syntax is shared with other",
	//" gnuplot terminal types. See `enhanced` for more details.",
	//"",
	//" The width of all lines in the plot can be modified by the factor <lw>",
	//" specified in `linewidth`. The default linewidth is 0.25 points.",
	//" (1 \"PostScript\" point = 1/72 inch = 0.353 mm)",
	//"",
	//" `rounded` sets line caps and line joins to be rounded; `butt` is the",
	//" default, butt caps and mitered joins.",
	//"",
	//" The default size for the output is 5 inches x 3 inches. The `size` option",
	//" changes this to whatever the user requests. By default the X and Y sizes are",
	//" taken to be in inches, but other units are possibly (currently only cm).",
	//" Screen coordinates always run from 0.0 to 1.0 along the full length of the",
	//" plot edges as specified by the `size` option.",
	//"",
	//" <font> is in the format \"FontFace,FontSize\", i.e. the face and the size",
	//" comma-separated in a single string. FontFace is a usual font face name, such",
	//" as \'Arial\'. If you do not provide FontFace, the pdfcairo terminal will use",
	//" \'Sans\'. FontSize is the font size, in points. If you do not provide it,",
	//" the pdfcairo terminal will use a size of 6 points.",
	//"    For example :",
	//"       set term pdfcairo font \"Arial,12\"",
	//"       set term pdfcairo font \"Arial\" # to change the font face only",
	//"       set term pdfcairo font \",12\" # to change the font size only",
	//"       set term pdfcairo font \"\" # to reset the font name and size",
	//"",
	//" The fonts are retrieved from the usual fonts subsystems. Under Windows,",
	//" those fonts are to be found and configured in the entry \"Fonts\" of the",
	//" control panel. Under UNIX, they are handled by \"fontconfig\".",
	//"",
	//" Pango, the library used to layout the text, is based on utf-8. Thus, the pdfcairo",
	//" terminal has to convert from your encoding to utf-8. The default input",
	//" encoding is based on your \'locale\'. If you want to use another encoding,",
	//" make sure gnuplot knows which one you are using. See `encoding` for more",
	//" details.",
	//"",
	//" Pango may give unexpected results with fonts that do not respect the unicode",
	//" mapping. With the Symbol font, for example, the pdfcairo terminal will use the map",
	//" provided by http://www.unicode.org/ to translate character codes to unicode.",
	//" Note that \"the Symbol font\" is to be understood as the Adobe",
	//" Symbol font, distributed with Acrobat Reader as \"SY______.PFB\".",
	//" Alternatively, the OpenSymbol font, distributed with OpenOffice.org as",
	//" \"opens___.ttf\", offers the same characters. Microsoft has distributed a",
	//" Symbol font (\"symbol.ttf\"), but it has a different character set with",
	//" several missing or moved mathematic characters. If you experience problems",
	//" with your default setup (if the demo enhancedtext.dem is not displayed",
	//" properly for example), you probably have to install one of the Adobe or",
	//" OpenOffice Symbol fonts, and remove the Microsoft one.",
	//" Other non-conform fonts, such as \"wingdings\" have been observed working.",
	//"",
	//" The rendering of the plot cannot be altered yet. To obtain the best output",
	//" possible, the rendering involves two mechanisms : antialiasing and",
	//" oversampling.",
	//" Antialiasing allows to display non-horizontal and non-vertical lines",
	//" smoother.",
	//" Oversampling combined with antialiasing provides subpixel accuracy,",
	//" so that gnuplot can draw a line from non-integer coordinates. This avoids",
	//" wobbling effects on diagonal lines ('plot x' for example).",
	//""
	//END_HELP(pdfcairo)
	///#endif // TERM_HELP 

	///#ifdef TERM_HELP
	//START_HELP(pngcairo)
	//"1 pngcairo",
	//"?set terminal pngcairo",
	//"?terminal pngcairo",
	//"?set term pngcairo",
	//"?term pngcairo",
	//"?pngcairo",
	//" The `pngcairo` terminal device generates output in png. The actual",
	//" drawing is done via cairo, a 2D graphics library, and pango, a library for",
	//" laying out and rendering text.",
	//"",
	//" Syntax:",
	//"         set term pngcairo",
	//"                      {{no}enhanced} {mono|color} {solid|dashed}",
	//"                      {{no}transparent} {{no}crop} {font <font>}",
	//"                      {linewidth <lw>} {rounded|butt} {dashlength <dl>}",
	//"                      {size <XX>{unit},<YY>{unit}}",
	//"",
	//" This terminal supports an enhanced text mode, which allows font and other",
	//" formatting commands (subscripts, superscripts, etc.) to be embedded in labels",
	//" and other text strings. The enhanced text mode syntax is shared with other",
	//" gnuplot terminal types. See `enhanced` for more details.",
	//"",
	//" The width of all lines in the plot can be modified by the factor <lw>",
	//" specified in `linewidth`. The default linewidth is 0.25 points.",
	//" (1 \"PostScript\" point = 1/72 inch = 0.353 mm)",
	//"",
	//" `rounded` sets line caps and line joins to be rounded; `butt` is the",
	//" default, butt caps and mitered joins.",
	//"",
	//" The default size for the output is 5 inches x 3 inches. The `size` option",
	//" changes this to whatever the user requests. By default the X and Y sizes are",
	//" taken to be in inches, but other units are possibly (currently only cm).",
	//" Screen coordinates always run from 0.0 to 1.0 along the full length of the",
	//" plot edges as specified by the `size` option.",
	//"",
	//" <font> is in the format \"FontFace,FontSize\", i.e. the face and the size",
	//" comma-separated in a single string. FontFace is a usual font face name, such",
	//" as \'Arial\'. If you do not provide FontFace, the pngcairo terminal will use",
	//" \'Sans\'. FontSize is the font size, in points. If you do not provide it,",
	//" the pngcairo terminal will use a size of 6 points.",
	//"    For example :",
	//"       set term pngcairo font \"Arial,12\"",
	//"       set term pngcairo font \"Arial\" # to change the font face only",
	//"       set term pngcairo font \",12\" # to change the font size only",
	//"       set term pngcairo font \"\" # to reset the font name and size",
	//"",
	//" The fonts are retrieved from the usual fonts subsystems. Under Windows,",
	//" those fonts are to be found and configured in the entry \"Fonts\" of the",
	//" control panel. Under UNIX, they are handled by \"fontconfig\".",
	//"",
	//" Pango, the library used to layout the text, is based on utf-8. Thus, the pngcairo",
	//" terminal has to convert from your encoding to utf-8. The default input",
	//" encoding is based on your \'locale\'. If you want to use another encoding,",
	//" make sure gnuplot knows which one you are using. See `encoding` for more",
	//" details.",
	//"",
	//" Pango may give unexpected results with fonts that do not respect the unicode",
	//" mapping. With the Symbol font, for example, the pngcairo terminal will use the map",
	//" provided by http://www.unicode.org/ to translate character codes to unicode.",
	//" Note that \"the Symbol font\" is to be understood as the Adobe",
	//" Symbol font, distributed with Acrobat Reader as \"SY______.PFB\".",
	//" Alternatively, the OpenSymbol font, distributed with OpenOffice.org as",
	//" \"opens___.ttf\", offers the same characters. Microsoft has distributed a",
	//" Symbol font (\"symbol.ttf\"), but it has a different character set with",
	//" several missing or moved mathematic characters. If you experience problems",
	//" with your default setup (if the demo enhancedtext.dem is not displayed",
	//" properly for example), you probably have to install one of the Adobe or",
	//" OpenOffice Symbol fonts, and remove the Microsoft one.",
	//" Other non-conform fonts, such as \"wingdings\" have been observed working.",
	//"",
	//" The rendering of the plot cannot be altered yet. To obtain the best output",
	//" possible, the rendering involves two mechanisms : antialiasing and",
	//" oversampling.",
	//" Antialiasing allows to display non-horizontal and non-vertical lines",
	//" smoother.",
	//" Oversampling combined with antialiasing provides subpixel accuracy,",
	//" so that gnuplot can draw a line from non-integer coordinates. This avoids",
	//" wobbling effects on diagonal lines ('plot x' for example).",
	//""
	//END_HELP(pngcairo)
	///#endif // TERM_HELP 


	///#endif

	///#ifdef HAVE_LUA
	///#include "lua.trm"
	///#endif

	///#endif // !SHORT_TERMLIST 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_x3d(x) ((x-X_AXIS.min)*xscale3d + xcenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_y3d(y) ((y-Y_AXIS.min)*yscale3d + ycenter3d -1.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define map_z3d(z) ((z-floor_z)*zscale3d + zcenter3d -1.0)
	///#define ISO_SAMPLES 10
	///#ifdef USE_MOUSE
	///#endif

	///#ifdef USE_MOUSE
	///#endif

	///#ifdef _Windows
	//FILE *open_printer __PROTO((void));     // in wprinter.c 
	//void close_printer __PROTO((FILE * outfile));
	///#ifdef __MSC__
	///#include <malloc.h>
	///#include <io.h>
	///#else
	///#include <alloc.h>
	///#endif                         // MSC 
	///#endif // _Windows 

	public static int termcomp(Object arga, Object argb)
	{
		final int a = arga;
		final int b = argb;

		return (strcasecmp(term_tbl[a].name, term_tbl[b].name));
	}

	/* Externally visible variables */
	/* the central instance: the current terminal's interface structure */
	public static TERMENTRY term = DefineConstants.NULL; // unknown

	/* ... and its options string */
	public static String term_options = "";

	/* the 'output' file name and handle */
	public static String outstr = DefineConstants.NULL; // means "STDOUT"
	public static FILE gpoutfile;

	/* Output file where the PostScript output goes to. See term_api.h for more
	   details.
	*/
	public static FILE gppsfile = 0;

	/* true if terminal has been initialized */
	public static boolean term_initialised;

	/* true if in multiplot mode */
	public static boolean multiplot = false;

	/* text output encoding, for terminals that support it */
	public static set_encoding_id encoding;
	/* table of encoding names, for output of the setting */
	public static String[] encoding_names = {"default", "iso_8859_1", "iso_8859_2", "iso_8859_9", "iso_8859_15", "cp437", "cp850", "cp852", "cp1250", "cp1254", "koi8r", "koi8u", "utf8", DefineConstants.NULL};
	/* 'set encoding' options */
	public static final gen_table[] set_encoding_tbl = {new gen_table("def$ault", set_encoding_id.S_ENC_DEFAULT), new gen_table("utf$8", set_encoding_id.S_ENC_UTF8), new gen_table("iso$_8859_1", set_encoding_id.S_ENC_ISO8859_1), new gen_table("iso_8859_2", set_encoding_id.S_ENC_ISO8859_2), new gen_table("iso_8859_9", set_encoding_id.S_ENC_ISO8859_9), new gen_table("iso_8859_15", set_encoding_id.S_ENC_ISO8859_15), new gen_table("cp4$37", set_encoding_id.S_ENC_CP437), new gen_table("cp850", set_encoding_id.S_ENC_CP850), new gen_table("cp852", set_encoding_id.S_ENC_CP852), new gen_table("cp1250", set_encoding_id.S_ENC_CP1250), new gen_table("cp1254", set_encoding_id.S_ENC_CP1254), new gen_table("koi8$r", set_encoding_id.S_ENC_KOI8_R), new gen_table("koi8$u", set_encoding_id.S_ENC_KOI8_U), new gen_table(DefineConstants.NULL, set_encoding_id.S_ENC_INVALID)};

	public static String[] arrow_head_names = {"nohead", "head", "backhead", "heads"};

	/* HBB 20020225: moved here, from ipc.h, where it never should have
	 * been. */
	///#ifdef PIPE_IPC
	/* HBB 20020225: currently not used anywhere outside term.c --> make
	 * it static */
	public static int ipc_back_fd = AnonymousEnum.IPC_BACK_CLOSED.getValue();
	///#endif

	/* resolution in dpi for converting pixels to size units */
	public static int gp_resolution = 72;

	/* Support for enhanced text mode. Declared extern in term_api.h */
	public static String enhanced_text = "";
	public static String enhanced_cur_text = DefineConstants.NULL;
	public static double enhanced_fontscale = 1.0;
	public static String enhanced_escape_format = "";
	public static double enhanced_max_height = 0.0;
	public static double enhanced_min_height = 0.0;
	/* flag variable to disable enhanced output of filenames, mainly. */
	public static boolean ignore_enhanced_text = false;

	/* Internal variables */

	/* true if terminal is in graphics mode */
	public static boolean term_graphics = false;

	/* we have suspended the driver, in multiplot mode */
	public static boolean term_suspended = false;

	/* true if? */
	public static boolean opened_binary = false;

	/* true if require terminal to be initialized */
	public static boolean term_force_init = false;

	/* internal pointsize for do_point */
	public static double term_pointsize = 1;

	/* Internal prototypes: */

	public static void term_suspend()
	{
		GlobalMembersFit.a((stderr, "term_suspend()\n"));
		if (term_initialised && !term_suspended && term.suspend)
		{
		GlobalMembersFit.a((stderr, "- calling term->suspend()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.suspend)();
		term_suspended = true;
		}
	}
///#endif // PIPES 

	public static void term_close_output()
	{
		GlobalMembersFit.a((stderr, "term_close_output\n"));

		opened_binary = false;

		if (outstr == null) // ie using stdout
		return;

	///#if defined(PIPES)
		if (output_pipe_open)
		{
		() GlobalMembersAmiga.pclose(gpoutfile);
		output_pipe_open = false;
		}
		else
	///#endif // PIPES
	///#ifdef _Windows
	//    if (stricmp(outstr, "PRN") == 0)
	//	close_printer(gpoutfile);
	//    else
	///#endif
		if (gpoutfile != gppsfile)
		fclose(gpoutfile);

		gpoutfile = stdout; // Don't dup...
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(outstr);
		outstr = DefineConstants.NULL;

		if (gppsfile != null)
		fclose(gppsfile);
		gppsfile = DefineConstants.NULL;
	}

/* change_term: get terminal number from name and set terminal type
 *
 * returns NULL for unknown or ambiguous, otherwise is terminal
 * driver pointer
 */
	public static TERMENTRY change_term(String origname, int length)
	{
		int i;
		TERMENTRY t = DefineConstants.NULL;
		boolean ambiguous = false;

		/* For backwards compatibility only */
		String name = (String)origname;
		if (!strncmp(origname,"X11",length))
		{
		name = "x11";
		length = 3;
		}

//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for (i = 0; i < sizeof(term_tbl) / sizeof(term_tbl[0]); i++)
		for (i = 0; i < term_tbl.length; i++)
		{
		if (!strncmp(name, term_tbl[i].name, length))
		{
			if (t != null)
			ambiguous = true;
			t = term_tbl + i;
			/* Exact match is always accepted */
			if (length == String.valueOf(term_tbl[i].name).length())
			{
			ambiguous = false;
			break;
			}
		}
		}

		if (t == null || ambiguous)
		return (DefineConstants.NULL);

		/* Success: set terminal type now */

		term = t;
		term_initialised = false;

		if (term.scale != GlobalMembersTerm.null_scale)
		fputs("Warning: scale interface is not null_scale - may not work with multiplot\n", stderr);

		/* check that optional fields are initialised to something */
		if (term.text_angle == 0)
		term.text_angle = GlobalMembersTerm.null_text_angle;
		if (term.justify_text == 0)
		term.justify_text = GlobalMembersTerm.null_justify_text;
		if (term.point == 0)
		term.point = GlobalMembersTerm.do_point;
		if (term.arrow == 0)
		term.arrow = GlobalMembersTerm.do_arrow;
		if (term.pointsize == 0)
		term.pointsize = GlobalMembersTerm.do_pointsize;
		if (term.linewidth == 0)
		term.linewidth = GlobalMembersTerm.null_linewidth;
		if (term.tscale <= 0)
		term.tscale = 1.0;

		/* Special handling for unixplot term type */
		if (!strncmp("unixplot", term.name, 8))
		{
		GlobalMembersTerm.UP_redirect(2); // Redirect actual stdout for unixplots
		}
		else if (unixplot != 0)
		{
		GlobalMembersTerm.UP_redirect(3); // Put stdout back together again.
		}
		if (GlobalMembersPlot.interactive)
		fprintf(stderr, "Terminal type set to '%s'\n", term.name);

		/* Invalidate any terminal-specific structures that may be active */
		GlobalMembersColor.invalidate_palette();

		return (t);
	}

	public static void null_linewidth(double s)
	{
		() s; // avoid -Wunused warning
	}
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void do_point(int x, int y, int number);
	public static void do_pointsize(double size)
	{
		term_pointsize = (size >= 0 ? size : 1);
	}
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void line_and_point(int x, int y, int number);
	public static void do_arrow(int usx, int usy, int uex, int uey, int headstyle)
	{
		/* Clipping and angle calculations do not work if coords are unsigned! */
		int sx = (int)usx;
		int sy = (int)usy;
		int ex = (int)uex;
		int ey = (int)uey;

		TERMENTRY t = term;
		float len_tic = ((double)(t.h_tic + t.v_tic)) / 2.0;
		/* average of tic sizes */
		/* (dx,dy) : vector from end to start */
		double dx = sx - ex;
		double dy = sy - ey;
		double len_arrow = Math.sqrt(dx * dx + dy * dy);
		gpiPoint[] filledhead = new gpiPoint[5];
		int xm = 0;
		int ym = 0;
		BoundingBox clip_save;
		e_arrow_head head = (e_arrow_head)((headstyle < 0) ? - headstyle : headstyle);
		/* negative headstyle means draw heads only, no shaft */

		/* FIXME: The plan is to migrate calling routines to call via            */
		/* draw_clip_arrow() in which case we would not need to clip again here. */
		clip_save = GlobalMembersGadgets.clip_area;
		if (term.flags & DefineConstants.TERM_CAN_CLIP != 0)
		GlobalMembersGadgets.clip_area = DefineConstants.NULL;
		else
		GlobalMembersGadgets.clip_area = GlobalMembersGadgets.canvas;

		/* Calculate and draw arrow heads.
		 * Draw no head for arrows with length = 0, or, to be more specific,
		 * length < DBL_EPSILON, because len_arrow will almost always be != 0.
		 */
		if ((head != e_arrow_head.NOHEAD) && Math.abs(len_arrow) >= DefineConstants.DBL_EPSILON)
		{
		int x1;
		int y1;
		int x2;
		int y2;
		if (curr_arrow_headlength <= 0)
		{
			/* arrow head with the default size */
			/* now calc the head_coeff */
			double coeff_shortest = len_tic * DefineConstants.HEAD_SHORT_LIMIT / len_arrow;
			double coeff_longest = len_tic * DefineConstants.HEAD_LONG_LIMIT / len_arrow;
			double head_coeff = ((coeff_shortest) > (((DefineConstants.HEAD_COEFF) < (coeff_longest) ? (DefineConstants.HEAD_COEFF) : (coeff_longest))) ? (coeff_shortest) : (((DefineConstants.HEAD_COEFF) < (coeff_longest) ? (DefineConstants.HEAD_COEFF) : (coeff_longest))));
			/* we put the arrowhead marks at 15 degrees to line */
			x1 = (int)((DefineConstants.COS15 * dx - DefineConstants.SIN15 * dy) * head_coeff);
			y1 = (int)((DefineConstants.SIN15 * dx + DefineConstants.COS15 * dy) * head_coeff);
			x2 = (int)((DefineConstants.COS15 * dx + DefineConstants.SIN15 * dy) * head_coeff);
			y2 = (int)((-DefineConstants.SIN15 * dx + DefineConstants.COS15 * dy) * head_coeff);
			/* backangle defaults to 90 deg */
			xm = (int)((x1 + x2) / 2);
			ym = (int)((y1 + y2) / 2);
		}
		else
		{
			/* the arrow head with the length + angle specified explicitly */
			double alpha = curr_arrow_headangle * DefineConstants.M_PI / 180.0;
			double beta = curr_arrow_headbackangle * DefineConstants.M_PI / 180.0;
			double phi = Math.atan2(-dy,-dx); // azimuthal angle of the vector
			double backlen = curr_arrow_headlength * Math.sin(alpha) / Math.sin(beta);
			double dx2;
			double dy2;
			/* anticlock-wise head segment */
			x1 = -(int)(curr_arrow_headlength * Math.cos(alpha - phi));
			y1 = (int)(curr_arrow_headlength * Math.sin(alpha - phi));
			/* clock-wise head segment */
			dx2 = -curr_arrow_headlength * Math.cos(phi + alpha);
			dy2 = -curr_arrow_headlength * Math.sin(phi + alpha);
			x2 = (int)(dx2);
			y2 = (int)(dy2);
			/* back point */
			xm = (int)(dx2 + backlen * Math.cos(phi + beta));
			ym = (int)(dy2 + backlen * Math.sin(phi + beta));
		}

		if (head & e_arrow_head.END_HEAD != 0)
		{
			if (curr_arrow_headfilled == 2 && GlobalMembersGadgets.clip_point(ex, ey) == 0)
			{
			/* draw filled forward arrow head */
			filledhead[0].x = ex + xm;
			filledhead[0].y = ey + ym;
			filledhead[1].x = ex + x1;
			filledhead[1].y = ey + y1;
			filledhead[2].x = ex;
			filledhead[2].y = ey;
			filledhead[3].x = ex + x2;
			filledhead[3].y = ey + y2;
			filledhead[4].x = ex + xm;
			filledhead[4].y = ey + ym;
			filledhead.style = t_fillstyle.FS_SOLID.getValue() + (100 << 4);
			if (t.filled_polygon)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.filled_polygon)(5, filledhead);
			}
			/* draw outline of forward arrow head */
			if (GlobalMembersGadgets.clip_point(ex, ey) != 0)
			;
			else if (curr_arrow_headfilled != 0)
			{
			GlobalMembersGadgets.draw_clip_line(ex + xm, ey + ym, ex + x1, ey + y1);
			GlobalMembersGadgets.draw_clip_line(ex + x1, ey + y1, ex, ey);
			GlobalMembersGadgets.draw_clip_line(ex, ey, ex + x2, ey + y2);
			GlobalMembersGadgets.draw_clip_line(ex + x2, ey + y2, ex + xm, ey + ym);
			}
			else
			{
			GlobalMembersGadgets.draw_clip_line(ex + x1, ey + y1, ex, ey);
			GlobalMembersGadgets.draw_clip_line(ex, ey, ex + x2, ey + y2);
			}
		}

		/* backward arrow head */
		if ((head & e_arrow_head.BACKHEAD) && GlobalMembersGadgets.clip_point(sx, sy) == 0)
		{
			if (curr_arrow_headfilled == 2)
			{
			/* draw filled backward arrow head */
			filledhead[0].x = sx - xm;
			filledhead[0].y = sy - ym;
			filledhead[1].x = sx - x1;
			filledhead[1].y = sy - y1;
			filledhead[2].x = sx;
			filledhead[2].y = sy;
			filledhead[3].x = sx - x2;
			filledhead[3].y = sy - y2;
			filledhead[4].x = sx - xm;
			filledhead[4].y = sy - ym;
			filledhead.style = t_fillstyle.FS_SOLID.getValue() + (100 << 4);
			if (t.filled_polygon)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.filled_polygon)(5, filledhead);
			}
			/* draw outline of backward arrow head */
			if (curr_arrow_headfilled != 0)
			{
			GlobalMembersGadgets.draw_clip_line(sx - xm, sy - ym, sx - x2, sy - y2);
			GlobalMembersGadgets.draw_clip_line(sx - x2, sy - y2, sx, sy);
			GlobalMembersGadgets.draw_clip_line(sx, sy, sx - x1, sy - y1);
			GlobalMembersGadgets.draw_clip_line(sx - x1, sy - y1, sx - xm, sy - ym);
			}
			else
			{
			GlobalMembersGadgets.draw_clip_line(sx - x2, sy - y2, sx, sy);
			GlobalMembersGadgets.draw_clip_line(sx, sy, sx - x1, sy - y1);
			}
		}
		}

		/* Draw the line for the arrow. */
		if (headstyle >= 0)
		{
		if ((head & e_arrow_head.BACKHEAD) && (Math.abs(len_arrow) >= DefineConstants.DBL_EPSILON) && (curr_arrow_headfilled != 0))
		{
			sx -= xm;
			sy -= ym;
		}
		if ((head & e_arrow_head.END_HEAD) && (Math.abs(len_arrow) >= DefineConstants.DBL_EPSILON) && (curr_arrow_headfilled != 0))
		{
			ex += xm;
			ey += ym;
		}
		if (GlobalMembersGadgets.clip_line(sx, sy, ex, ey) != 0)
			GlobalMembersGadgets.draw_clip_line(sx, sy, ex, ey);
		}

		/* Restore previous clipping box */
		GlobalMembersGadgets.clip_area = clip_save;

	}

///#ifdef __ZTC__
//char *
//ztc_init()
//{
//    int g_mode;
//    char *term_name = NULL;
//
//    g_mode = fg_init();
//
//    switch (g_mode) {
//    case FG_NULL:
//	fputs("Graphics card not detected or not supported.\n", stderr);
//	exit(1);
//    case FG_HERCFULL:
//	term_name = "hercules";
//	break;
//    case FG_EGAMONO:
//	term_name = "egamono";
//	break;
//    case FG_EGAECD:
//	term_name = "egalib";
//	break;
//    case FG_VGA11:
//	term_name = "vgamono";
//	break;
//    case FG_VGA12:
//	term_name = "vgalib";
//	break;
//    case FG_VESA6A:
//	term_name = "svgalib";
//	break;
//    case FG_VESA5:
//	term_name = "ssvgalib";
//	break;
//    }
//    fg_term();
//    return (term_name);
//}
///#endif // __ZTC__ 


/*
 * Unixplot can't really write to gpoutfile--it wants to write to stdout.
 * This is normally ok, but the original design of gnuplot gives us
 * little choice.  Originally users of unixplot had to anticipate
 * their needs and redirect all I/O to a file...  Not very gnuplot-like.
 *
 * caller:  1 - called from SET OUTPUT "FOO.OUT"
 * 2 - called from SET TERM UNIXPLOT
 * 3 - called from SET TERM other
 * 4 - called from SET OUTPUT
 */

	public static void UP_redirect(int caller)
	{
	///#if defined(UNIXPLOT) && !defined(GNUGRAPH)
	//    switch (caller) {
	//    case 1:
	// /* Don't save, just replace stdout w/gpoutfile (save was already done). */
	//	if (unixplot)
	//	    *(stdout) = *(gpoutfile);   // Copy FILE structure
	//	break;
	//    case 2:
	//	if (!unixplot) {
	//	    fflush(stdout);
	//	    save_stdout = *(stdout);
	//	    *(stdout) = *(gpoutfile);   // Copy FILE structure
	//	    unixplot = 1;
	//	}
	//	break;
	//    case 3:
	// /* New terminal in use--put stdout back to original. */
	// /* closepl(); //Tangible continue code after comment*/
	// /* This is called by the term. */
	//	fflush(stdout);
	//	*(stdout) = save_stdout;        // Copy FILE structure
	//	unixplot = 0;
	//	break;
	//    case 4:
	// /*  User really wants to go to normal output... */
	//	if (unixplot) {
	//	    fflush(stdout);
	//	    *(stdout) = save_stdout;    // Copy FILE structure
	//	}
	//	break;
	//    } // switch()
	///#else // !UNIXPLOT || GNUGRAPH
		() caller; // avoid -Wunused warning
	///#endif // !UNIXPLOT || GNUGRAPH
	}

//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static int null_text_angle(int ang);
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static int null_justify_text(JUSTIFY just);
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static int null_scale(double x, double y);
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void options_null();
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void UNKNOWN_null();
	public static void MOVE_null(int x, int y)
	{
		() x; // avoid -Wunused warning
		() y;
	}
	public static void LINETYPE_null(int t)
	{
		() t; // avoid -Wunused warning
	}
	public static void PUTTEXT_null(int x, int y, String s)
	{
		() s; // avoid -Wunused warning
		() x;
		() y;
	}

/* Utility routine for drivers to accept an explicit size for the 
 * output image.
 */
	public static size_units parse_term_size(float xsize, float ysize, size_units default_units)
	{
		size_units units = default_units;

		if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "size requires two numbers:  xsize, ysize");
		xsize = GlobalMembersParse.real_expression();
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "in$ches") != 0)
		{
		GlobalMembersCommand.c_token++;
		units = size_units.INCHES;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "cm") != 0)
		{
		GlobalMembersCommand.c_token++;
		units = size_units.CM;
		}
		switch (units)
		{
		case INCHES:
			xsize *= gp_resolution;
			break;
		case CM:
			xsize *= (float)gp_resolution / 2.54;
			break;
		case PIXELS:
		default:
			break;
		}

		if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token++, ",") == 0)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "size requires two numbers:  xsize, ysize");
		ysize = GlobalMembersParse.real_expression();
		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "in$ches") != 0)
		{
		GlobalMembersCommand.c_token++;
		units = size_units.INCHES;
		}
		else if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "cm") != 0)
		{
		GlobalMembersCommand.c_token++;
		units = size_units.CM;
		}
		switch (units)
		{
		case INCHES:
			ysize *= gp_resolution;
			break;
		case CM:
			ysize *= (float)gp_resolution / 2.54;
			break;
		case PIXELS:
		default:
			break;
		}

		if (xsize < 1 || ysize < 1)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "size: out of range");

		return units;
	}

/* Helper function for multiplot auto layout to issue size and offset cmds */

	/*
	 * Bookkeeping and support routine for 'set multiplot layout <rows>, <cols>'
	 * July 2004
	 * Volker Dobler <v.dobler@web.de>
	 */

	public static void mp_layout_size_and_offset()
	{
		if (!mp_layout.auto_layout)
			return;

		/* fprintf(stderr,"col==%d row==%d\n",mp_layout.act_col,mp_layout.act_row); */
		/* the 'set size' command */
		GlobalMembersGadgets.xsize = mp_layout.xscale / mp_layout.num_cols;
		GlobalMembersGadgets.ysize = mp_layout.yscale / mp_layout.num_rows;

		/* the 'set origin' command */
		GlobalMembersGadgets.xoffset = (double)(mp_layout.act_col) / mp_layout.num_cols;
		if (mp_layout.downwards)
		GlobalMembersGadgets.yoffset = 1.0 - (double)(mp_layout.act_row + 1) / mp_layout.num_rows;
		else
		GlobalMembersGadgets.yoffset = (double)(mp_layout.act_row) / mp_layout.num_rows;
		/* fprintf(stderr,"xoffset==%g  yoffset==%g\n", xoffset,yoffset); */

		/* Allow a little space at the top for a title */
		if (mp_layout.title.text != null)
		{
		GlobalMembersGadgets.ysize *= (1.0 - mp_layout.title_height);
		GlobalMembersGadgets.yoffset *= (1.0 - mp_layout.title_height);
		}

		/* corrected for x/y-scaling factors and user defined offsets */
		GlobalMembersGadgets.xoffset -= (mp_layout.xscale-1) / (2 * mp_layout.num_cols);
		GlobalMembersGadgets.yoffset -= (mp_layout.yscale-1) / (2 * mp_layout.num_rows);
		/* fprintf(stderr,"  xoffset==%g  yoffset==%g\n", xoffset,yoffset); */
		GlobalMembersGadgets.xoffset += mp_layout.xoffset;
		GlobalMembersGadgets.yoffset += mp_layout.yoffset;
		/* fprintf(stderr,"  xoffset==%g  yoffset==%g\n", xoffset,yoffset); */
	}

	public static final struct[] gen_table set_multiplot_tbl = {{"lay$out", set_multiplot_id.S_MULTIPLOT_LAYOUT}, {"col$umnsfirst", set_multiplot_id.S_MULTIPLOT_COLUMNSFIRST}, {"row$sfirst", set_multiplot_id.S_MULTIPLOT_ROWSFIRST}, {"down$wards", set_multiplot_id.S_MULTIPLOT_DOWNWARDS}, {"up$wards", set_multiplot_id.S_MULTIPLOT_UPWARDS}, {"sca$le", set_multiplot_id.S_MULTIPLOT_SCALE}, {"off$set", set_multiplot_id.S_MULTIPLOT_OFFSET}, {"ti$tle", set_multiplot_id.S_MULTIPLOT_TITLE}, {DefineConstants.NULL, set_multiplot_id.S_MULTIPLOT_INVALID}};
	public static AnonymousClass4 mp_layout = new AnonymousClass4(false, 0, 0, false, true, 0, 0, 1, 1, 0, 0, 0,0,0,0, {DefineConstants.NULL, -2, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, JUSTIFY.CENTRE, 0, 0, DefineConstants.NULL, DefineConstants.NULL, {DefineConstants.TC_LT, -2, 0.0}, {0, -2, 0, 0, 1.0, DefineConstants.PTSZ_DEFAULT, false, {DefineConstants.TC_DEFAULT, 0, 0.0}}, {position_type.character, position_type.character, position_type.character, 0.0, 0.0, 0.0}, false}, 0.0);


	///#ifdef __ZTC__
	//char *ztc_init();
	// /* #undef TGIF */
	///#endif

	///#ifdef VMS
	//char *vms_init();
	//void vms_reset();
	//void term_mode_tek();
	//void term_mode_native();
	//void term_pasthru();
	//void term_nopasthru();
	//void fflush_binary();
	///#define FOPEN_BINARY(file) fopen(file, "wb", "rfm=fix", "bls=512", "mrs=512")
	///#else // !VMS 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FOPEN_BINARY(file) fopen(file, "wb")
	///#endif // !VMS 

	///#if defined(MSDOS) || defined(WIN32) || defined(WIN16)
	///#if defined(__DJGPP__) || defined (__TURBOC__)
	///#include <io.h>
	///#endif
	///#include <fcntl.h>
	///#ifndef O_BINARY
	///#ifdef _O_BINARY
	///#define O_BINARY _O_BINARY
	///#else
	///#define O_BINARY O_BINARY_is_not_defined
	///#endif
	///#endif
	///#endif

	///#ifdef __EMX__
	///#include <io.h>
	///#include <fcntl.h>
	///#endif

	///#if defined(__WATCOMC__) || defined(__MSC__)
	///#include <io.h>        // for setmode() 
	///#endif

	/* This is needed because the unixplot library only writes to stdout,
	 * but GNU plotutils libplot.a doesn't */
	///#if defined(UNIXPLOT) && !defined(GNUGRAPH)
	//static FILE save_stdout;
	///#endif
	public static int unixplot = 0;

	///#define NICE_LINE 0
	///#define POINT_TYPES 6

	///#ifndef DEFAULTTERM
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEFAULTTERM NULL
	///#endif

	/* interface to the rest of gnuplot - the rules are getting
	 * too complex for the rest of gnuplot to be allowed in
	 */

	///#if defined(PIPES)
	public static boolean output_pipe_open = false;

	///#ifdef OS2
	///#define POPEN_MODE ("wb")
	///#else
	///#define POPEN_MODE ("w")
	///#endif

	/* assigns dest to outstr, so it must be allocated or NULL
	 * and it must not be outstr itself !
	 */
	public static void term_set_output(String dest)
	{
		FILE f = DefineConstants.NULL;

		GlobalMembersFit.a((stderr, "term_set_output\n"));
		assert dest.equals(DefineConstants.NULL) || !outstr.equals(dest);

		if (multiplot)
		{
		fputs("In multiplot mode you can't change the output\n", stderr);
		return;
		}
		if (term != null && term_initialised)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.reset)();
		term_initialised = false;
		/* switch off output to special postscript file (if used) */
		gppsfile = DefineConstants.NULL;
		}
		if (dest.equals(DefineConstants.NULL)) // stdout
		{
		GlobalMembersTerm.UP_redirect(4);
		GlobalMembersTerm.term_close_output();
		}
		else
		{

	///#if defined(PIPES)
		if (dest.equals('|'))
		{
			if ((f = GlobalMembersAmiga.popen(dest + 1, DefineConstants.POPEN_MODE)) == (FILE) DefineConstants.NULL)
			GlobalMembersUtil.os_error(GlobalMembersCommand.c_token, "cannot create pipe; output not changed");
			else
			output_pipe_open = true;
		}
		else
		{
	///#endif // PIPES 

	///#ifdef _Windows
	//	if (outstr && stricmp(outstr, "PRN") == 0) {
	// /* we can't call open_printer() while printer is open, so */
	//	    close_printer(gpoutfile);   // close printer immediately if open 
	//	    gpoutfile = stdout; // and reset output to stdout 
	//	    free(outstr);
	//	    outstr = NULL;
	//	}
	//	if (stricmp(dest, "PRN") == 0) {
	//	    if ((f = open_printer()) == (FILE *) NULL)
	//		os_error(c_token, "cannot open printer temporary file; output may have changed");
	//	} else
	///#endif

		{
	///#if defined (MSDOS)
	//	    if (outstr && (0 == stricmp(outstr, dest))) {
	// /* On MSDOS, you cannot open the same file twice and
	//  * then close the first-opened one and keep the second
	//  * open, it seems. If you do, you get lost clusters
	//  * (connection to the first version of the file is
	//  * lost, it seems). */
	// /* FIXME: this is not yet safe enough. You can fool it by
	//  * specifying the same output file in two different ways
	//  * (relative vs. absolute path to file, e.g.) */
	//		term_close_output();
	//	    }
	///#endif
			if (term != null && (term.flags & DefineConstants.TERM_BINARY))
			f = fopen(dest, "wb");
			else
			f = fopen(dest, "w");

			if (f == (FILE) DefineConstants.NULL)
			GlobalMembersUtil.os_error(GlobalMembersCommand.c_token, "cannot open file; output not changed");
		}
	///#if defined(PIPES)
		}
	///#endif

		GlobalMembersTerm.term_close_output();
		gpoutfile = f;
		outstr = dest;
		opened_binary = (term != null && (term.flags & DefineConstants.TERM_BINARY));
		GlobalMembersTerm.UP_redirect(1);
		}
	}

	public static void term_initialise()
	{
		GlobalMembersFit.a((stderr, "term_initialise()\n"));

		if (term == null)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "No terminal defined");

		/* check if we have opened the output file in the wrong mode
		 * (text/binary), if set term comes after set output
		 * This was originally done in change_term, but that
		 * resulted in output files being truncated
		 */

		if (outstr != null && (term.flags & DefineConstants.TERM_NO_OUTPUTFILE))
		{
		if (GlobalMembersPlot.interactive)
			fprintf(stderr,"Closing %s\n",outstr);
		GlobalMembersTerm.term_close_output();
		}

		if (outstr != null && (((term.flags & DefineConstants.TERM_BINARY) && !opened_binary) || ((!(term.flags & DefineConstants.TERM_BINARY) && opened_binary))))
		{
		/* this is nasty - we cannot just term_set_output(outstr)
		 * since term_set_output will first free outstr and we
		 * end up with an invalid pointer. I think I would
		 * prefer to defer opening output file until first plot.
		 */
		byte temp = GlobalMembersAlloc.gp_alloc(outstr.length() + 1, "temp file string");
		if (temp != 0)
		{
				GlobalMembersFit.a((stderr, "term_initialise: reopening \"%s\" as %s\n", outstr, term.flags & DefineConstants.TERM_BINARY ? "binary" : "text"));
			temp = outstr;
			GlobalMembersTerm.term_set_output(temp); // will free outstr
			if (!outstr.equals(temp))
			{
			if (temp != 0)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(temp);
			temp = outstr;
			}
		}
		else
			fputs("Cannot reopen output file in binary", stderr);
		/* and carry on, hoping for the best ! */
		}
	///#if defined(MSDOS) || defined (_Windows) || defined(OS2)
	///#ifdef _Windows
	//    else if (!outstr && (term->flags & TERM_BINARY))
	///#else
	//    else if (!outstr && !interactive && (term->flags & TERM_BINARY))
	///#endif
	//	{
	// /* binary to stdout in non-interactive session... */
	//	    fflush(stdout);
	//	    setmode(fileno(stdout), O_BINARY);
	//	}
	///#endif


		if (!term_initialised || term_force_init)
		{
		GlobalMembersFit.a((stderr, "- calling term->init()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.init)();
		term_initialised = true;
		}
	}


	public static void term_start_plot()
	{
		GlobalMembersFit.a((stderr, "term_start_plot()\n"));

		if (!term_initialised)
			GlobalMembersTerm.term_initialise();

		if (!term_graphics)
		{
		GlobalMembersFit.a((stderr, "- calling term->graphics()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.graphics)();
		term_graphics = true;
		}
		else if (multiplot && term_suspended)
		{
		if (term.resume)
		{
			GlobalMembersFit.a((stderr, "- calling term->resume()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*term.resume)();
		}
		term_suspended = false;
		}

		/* Sync point for epslatex text positioning */
		if (term.layer)
		(term.layer)(termlayer.TERM_LAYER_RESET);

		/* Because PostScript plots may be viewed out of order, make sure */
		/* Each new plot makes no assumption about the previous palette.  */
		if (term.flags & DefineConstants.TERM_IS_POSTSCRIPT != 0)
		GlobalMembersColor.invalidate_palette();

		/* Set canvas size to full range of current terminal coordinates */
		GlobalMembersGadgets.canvas.xleft = 0;
		GlobalMembersGadgets.canvas.xright = term.xmax - 1;
		GlobalMembersGadgets.canvas.ybot = 0;
		GlobalMembersGadgets.canvas.ytop = term.ymax - 1;

	}

	public static void term_end_plot()
	{
		GlobalMembersFit.a((stderr, "term_end_plot()\n"));

		if (!term_initialised)
		return;

		/* Sync point for epslatex text positioning */
		if (term.layer)
		(term.layer)(termlayer.TERM_LAYER_END_TEXT);

		if (!multiplot)
		{
		GlobalMembersFit.a((stderr, "- calling term->text()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.text)();
		term_graphics = false;
		}
		else
		{
		if (mp_layout.auto_layout)
		{
			if (mp_layout.row_major)
			{
			mp_layout.act_row++;
			if (mp_layout.act_row == mp_layout.num_rows)
			{
				mp_layout.act_row = 0;
				mp_layout.act_col++;
				if (mp_layout.act_col == mp_layout.num_cols)
				{
				/* int_warn(NO_CARET,"will overplot first plot"); */
				mp_layout.act_col = 0;
				}
			}
			} // column-major
			else
			{
			mp_layout.act_col++;
			if (mp_layout.act_col == mp_layout.num_cols)
			{
				mp_layout.act_col = 0;
				mp_layout.act_row++;
				if (mp_layout.act_row == mp_layout.num_rows)
				{
				/* int_warn(NO_CARET,"will overplot first plot"); */
				mp_layout.act_col = 0;
				}
			}
			}
			GlobalMembersTerm.mp_layout_size_and_offset();
		}
		}
	///#ifdef VMS
	//    if (opened_binary)
	//	fflush_binary();
	//    else
	///#endif // VMS 

		() fflush(gpoutfile);

	///#ifdef USE_MOUSE
		GlobalMembersMouse.recalc_statusline();
		GlobalMembersMouse.update_ruler();
	///#endif
	}

	public static void term_start_multiplot()
	{
		GlobalMembersFit.a((stderr, "term_start_multiplot()\n"));

		GlobalMembersCommand.c_token++;
		if (multiplot)
		GlobalMembersTerm.term_end_multiplot();

		GlobalMembersTerm.term_start_plot();

		mp_layout.auto_layout = false;

		/* Parse options (new in version 4.1 */
		while (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
		String s;

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "ti$tle") != 0)
		{
			GlobalMembersCommand.c_token++;
			if ((s = GlobalMembersUtil.try_to_get_string()))
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(mp_layout.title.text);
			mp_layout.title.text = s;
			}
			 continue;
		}

		   if (GlobalMembersUtil.equals(GlobalMembersCommand.c_token, "font") != 0)
		   {
			GlobalMembersCommand.c_token++;
			 if ((s = GlobalMembersUtil.try_to_get_string()))
			 {
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			 free(mp_layout.title.font);
			 mp_layout.title.font = s;
			 }
			continue;
		   }

		if (GlobalMembersUtil.almost_equals(GlobalMembersCommand.c_token, "lay$out") != 0)
		{
			if (mp_layout.auto_layout)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "too many layout commands");
			else
			mp_layout.auto_layout = true;

			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			{
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting '<num_cols>,<num_rows>'");
			}

			/* read row,col */
			mp_layout.num_rows = GlobalMembersParse.int_expression();
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") == 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting ', <num_cols>'");

			GlobalMembersCommand.c_token++;
			if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting <num_cols>");
			mp_layout.num_cols = GlobalMembersParse.int_expression();

			/* remember current values of the plot size */
			mp_layout.prev_xsize = GlobalMembersGadgets.xsize;
			mp_layout.prev_ysize = GlobalMembersGadgets.ysize;
			mp_layout.prev_xoffset = GlobalMembersGadgets.xoffset;
			mp_layout.prev_yoffset = GlobalMembersGadgets.yoffset;

			mp_layout.act_row = 0;
			mp_layout.act_col = 0;

			continue;
		}

		/* The remaining options are only valid for auto-layout mode */
		if (!mp_layout.auto_layout)
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "only valid as part of an auto-layout command");

		switch (GlobalMembersTables.lookup_table(set_multiplot_tbl[0], GlobalMembersCommand.c_token))
		{
			case S_MULTIPLOT_COLUMNSFIRST:
			mp_layout.row_major = true;
			GlobalMembersCommand.c_token++;
			break;
			case S_MULTIPLOT_ROWSFIRST:
			mp_layout.row_major = false;
			GlobalMembersCommand.c_token++;
			break;
			case S_MULTIPLOT_DOWNWARDS:
			mp_layout.downwards = true;
			GlobalMembersCommand.c_token++;
			break;
			case S_MULTIPLOT_UPWARDS:
			mp_layout.downwards = false;
			GlobalMembersCommand.c_token++;
			break;
			case S_MULTIPLOT_SCALE:
			GlobalMembersCommand.c_token++;
			mp_layout.xscale = GlobalMembersParse.real_expression();
			mp_layout.yscale = mp_layout.xscale;
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting <yscale>");
				}
				mp_layout.yscale = GlobalMembersParse.real_expression();
			}
			break;
			case S_MULTIPLOT_OFFSET:
			GlobalMembersCommand.c_token++;
			mp_layout.xoffset = GlobalMembersParse.real_expression();
			mp_layout.yoffset = mp_layout.xoffset;
			if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0 && GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ",") != 0)
			{
				GlobalMembersCommand.c_token++;
				if (GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
				{
				GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "expecting <yoffset>");
				}
				mp_layout.yoffset = GlobalMembersParse.real_expression();
			}
			break;
			default:
			GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token, "invalid or duplicate option");
			break;
		}
		}

		/* If we reach here, then the command has been successfully parsed */
		multiplot = true;
		GlobalMembersEval.fill_gpval_integer("GPVAL_MULTIPLOT", 1);

		/* Place overall title before doing anything else */
		if (mp_layout.title.text != null)
		{
		double tmpx;
		double tmpy;
		int x;
		int y;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * p = mp_layout.title.text;

		GlobalMembersGraphics.map_position_r((mp_layout.title.offset), tmpx, tmpy, "mp title");
		x = term.xmax / 2 + tmpx;
		y = term.ymax - term.v_char + tmpy;

		GlobalMembersTerm.ignore_enhanced(mp_layout.title.noenhanced);
		GlobalMembersGadgets.apply_pm3dcolor((mp_layout.title.textcolor), term);
		GlobalMembersTerm.write_multiline(x, y, mp_layout.title.text, JUSTIFY.CENTRE, VERT_JUSTIFY.JUST_TOP, 0, mp_layout.title.font);
		GlobalMembersGadgets.reset_textcolor((mp_layout.title.textcolor), term);
		GlobalMembersTerm.ignore_enhanced(false);

		/* Calculate fractional height of title compared to entire page */
		/* If it would fill the whole page, forget it! */
		for (y = 2; * p; p++)
			if (*p == '\n')
			y++;
		mp_layout.title_height = (double)(y * term.v_char) / (double)term.ymax;
		if (mp_layout.title_height > 0.9)
			mp_layout.title_height = 0.05;
		}
		else
		{
		mp_layout.title_height = 0.0;
		}

		GlobalMembersTerm.mp_layout_size_and_offset();

	///#ifdef USE_MOUSE
		GlobalMembersMouse.UpdateStatusline();
	///#endif
	}

	public static void term_end_multiplot()
	{
		GlobalMembersFit.a((stderr, "term_end_multiplot()\n"));
		if (!multiplot)
		return;

		if (term_suspended)
		{
		if (term.resume)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*term.resume)();
		term_suspended = false;
		}
		multiplot = false;
		GlobalMembersEval.fill_gpval_integer("GPVAL_MULTIPLOT", 0);
		/* reset plot size and origin to values before 'set multiplot layout' */
		if (mp_layout.auto_layout)
		{
		GlobalMembersGadgets.xsize = mp_layout.prev_xsize;
		GlobalMembersGadgets.ysize = mp_layout.prev_ysize;
		GlobalMembersGadgets.xoffset = mp_layout.prev_xoffset;
		GlobalMembersGadgets.yoffset = mp_layout.prev_yoffset;
		}
		/* reset automatic multiplot layout */
		mp_layout.auto_layout = false;
		mp_layout.xscale = mp_layout.yscale = 1.0;
		mp_layout.xoffset = mp_layout.yoffset = 0.0;
		if (mp_layout.title.text != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(mp_layout.title.text);
		mp_layout.title.text = DefineConstants.NULL;
		}

		GlobalMembersTerm.term_end_plot();
	///#ifdef USE_MOUSE
		GlobalMembersMouse.UpdateStatusline();
	///#endif
	}

	public static void term_reset()
	{
		GlobalMembersFit.a((stderr, "term_reset()\n"));

	///#ifdef USE_MOUSE
		/* Make sure that ^C will break out of a wait for 'pause mouse' */
		GlobalMembersCommand.paused_for_mouse = 0;
	///#endif

		if (!term_initialised)
		return;

		if (term_suspended)
		{
		if (term.resume)
		{
			GlobalMembersFit.a((stderr, "- calling term->resume()\n"));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*term.resume)();
		}
		term_suspended = false;
		}
		if (term_graphics)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.text)();
		term_graphics = false;
		}
		if (term_initialised)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.reset)();
		term_initialised = false;
		/* switch off output to special postscript file (if used) */
		gppsfile = DefineConstants.NULL;
		}
	}

	public static void term_apply_lp_properties(lp_style_type lp)
	{
		/*  This function passes all the line and point properties to the
		 *  terminal driver and issues the corresponding commands.
		 *
		 *  Alas, sometimes it might be necessary to give some help to
		 *  this function by explicitly issuing additional '(*term)(...)'
		 *  commands.
		 */

		if (lp.pointflag != 0)
		{
		/* change points, too
		 * Currently, there is no 'pointtype' function.  For points
		 * there is a special function also dealing with (x,y) co-
		 * ordinates.
		 */
		if (lp.p_size < 0)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*term.pointsize)(GlobalMembersGadgets.pointsize);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*term.pointsize)(lp.p_size);
		}
		/*  _first_ set the line width, _then_ set the line type !
	
		 *  The linetype might depend on the linewidth in some terminals.
		 */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.linewidth)(lp.l_width);

		/* Apply "linetype", which can include both color and dot/dash */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.linetype)(lp.l_type);
		/* Possibly override the linetype color with a fancier colorspec */
		if (lp.use_palette)
		GlobalMembersGadgets.apply_pm3dcolor(lp.pm3d_color, term);
	}



	public static void term_check_multiplot_okay(boolean f_interactive)
	{
		GlobalMembersFit.a((stderr, "term_multiplot_okay(%d)\n", f_interactive));

		if (!term_initialised)
		return; // they've not started yet

		/* make sure that it is safe to issue an interactive prompt
		 * it is safe if
		 *   it is not an interactive read, or
		 *   the terminal supports interactive multiplot, or
		 *   we are not writing to stdout and terminal doesn't
		 *     refuse multiplot outright
		 */
		if (!f_interactive || (term.flags & DefineConstants.TERM_CAN_MULTIPLOT) || ((gpoutfile != stdout) && !(term.flags & DefineConstants.TERM_CANNOT_MULTIPLOT)))
		{
		/* it's okay to use multiplot here, but suspend first */
		GlobalMembersTerm.term_suspend();
		return;
		}
		/* uh oh: they're not allowed to be in multiplot here */

		GlobalMembersTerm.term_end_multiplot();

		/* at this point we know that it is interactive and that the
		 * terminal can either only do multiplot when writing to
		 * to a file, or it does not do multiplot at all
		 */

		if (term.flags & DefineConstants.TERM_CANNOT_MULTIPLOT != 0)
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "This terminal does not support multiplot");
		else
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "Must set output to a file or put all multiplot commands on one input line");
	}


	public static void write_multiline(int x, int y, String text, JUSTIFY hor, VERT_JUSTIFY vert, int angle, String font) // NULL or "" means use default -  assume term has already been set for this -  ... and vertical just - text in hor direction despite angle -  horizontal ...
	{
		TERMENTRY t = term;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * p = text;

		if (p == 0)
		return;

		/* EAM 9-Feb-2003 - Set font before calculating sizes */
		if (font != null && font != null && t.set_font)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.set_font)(font);

		if (vert != VERT_JUSTIFY.JUST_TOP)
		{
		/* count lines and adjust y */
		int lines = 0; // number of linefeeds - one fewer than lines
		while (*p)
		{
			if (*p++== '\n')
			++lines;
		}
		if (angle != 0)
			x -= (vert * lines * t.v_char) / 2;
		else
			y += (vert * lines * t.v_char) / 2;
		}

		for (;;) // we will explicitly break out
		{

		if ((!text.equals(DefineConstants.NULL)) && (p = tangible.StringFunctions.strChr(text, '\n')) != DefineConstants.NULL)
			*p = 0; // terminate the string

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(hor))
			{
			if (GlobalMembersTerm.on_page(x, y))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.put_text)(x, y, text);
			}
		else
		{
			int fix = (int)hor * t.h_char * GlobalMembersTerm.estimate_text.length() / 2;
			if (angle != 0)
			{
			if (GlobalMembersTerm.on_page(x, y - fix))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.put_text)(x, y - fix, text);
			}
			else
			{
			if (GlobalMembersTerm.on_page(x - fix, y))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.put_text)(x - fix, y, text);
			}
		}
		if (angle == 90 || angle == DefineConstants.TEXT_VERTICAL)
			x += t.v_char;
		else if (angle == -90 || angle == -DefineConstants.TEXT_VERTICAL)
			x -= t.v_char;
		else
			y -= t.v_char;

		if (p == 0)
			break;
		else
		{
			/* put it back */
			*p = (byte)'\n';
		}

		text = p + 1;
		} // unconditional branch back to the for(;;) - just a goto !

		if (font != null && font != null && t.set_font)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.set_font)("");

	}

	/*
	 * general arrow routine
	 *
	 * I set the angle between the arrowhead and the line 15 degree.
	 * The length of arrowhead varies depending on the line length
	 * within the the range [0.3*(the-tic-length), 2*(the-tic-length)].
	 * No head is printed if the arrow length is zero.
	 *
	 *            Yasu-hiro Yamazaki(hiro@rainbow.physics.utoronto.ca)
	 *            Jul 1, 1993
	 */

	///#define COS15 (0.96593)
	///#define SIN15 (0.25882)

	///#define HEAD_LONG_LIMIT (2.0)
	///#define HEAD_SHORT_LIMIT (0.3)
					/* their units are the "tic" length */

	///#define HEAD_COEFF (0.3)

	public static int curr_arrow_headlength; // access head length + angle without changing API
	public static double curr_arrow_headangle; // angle in degrees
	public static double curr_arrow_headbackangle; // angle in degrees
	public static int curr_arrow_headfilled; // arrow head filled or not

	///#ifdef EAM_OBJECTS
	/* Generic routine for drawing circles or circular arcs.          */
	/* If this feature proves useful, we can add a new terminal entry */
	/* point term->arc() to the API and let terminals either provide  */
	/* a private implemenation or use this generic one.               */

	public static void do_arc(int cx, int cy, double radius, double arc_start, double arc_end, int style) // Limits of arc in degress -  Radius -  Center
	{
		gpiPoint[] vertex = new gpiPoint[120];
		int i;
		int segments;
		double aspect;

		/* Protect against out-of-range values */
		while (arc_start < 0.)
		arc_start += 360.;
		while (arc_end > 360.)
		arc_end -= 360.;

		/* Always draw counterclockwise */
		while (arc_end < arc_start)
		arc_end += 360.;

		/* Choose how many segments to draw for this arc */
	///#define INC 5.
		segments = (arc_end - arc_start) / DefineConstants.INC;

		/* Calculate the vertices */
		aspect = (double)term.v_tic / (double)term.h_tic;
		vertex[0].style = style;
		for (i = 0; i < segments; i++)
		{
		vertex[i].x = cx + Math.cos(DefineConstants.M_PI / 180.0 * (arc_start + i * DefineConstants.INC)) * radius;
		vertex[i].y = cy + Math.sin(DefineConstants.M_PI / 180.0 * (arc_start + i * DefineConstants.INC)) * radius * aspect;
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef INC
		vertex[segments].x = cx + Math.cos(DefineConstants.M_PI / 180.0 * arc_end) * radius;
		vertex[segments].y = cy + Math.sin(DefineConstants.M_PI / 180.0 * arc_end) * radius * aspect;
		if (Math.abs(arc_end - arc_start) > .1 && Math.abs(arc_end - arc_start) < 359.9)
		{
		vertex[++segments].x = cx;
		vertex[segments].y = cy;
		vertex[++segments].x = vertex[0].x;
		vertex[segments].y = vertex[0].y;
		}

		if (style != 0)
		{
		/* Fill in the center */
		if (term.filled_polygon)
			term.filled_polygon(segments + 1, vertex);
		}
		else
		{
		/* Draw the arc */
		for (i = 0; i < segments; i++)
			GlobalMembersGadgets.draw_clip_line(vertex[i].x, vertex[i].y, vertex[i + 1].x, vertex[i + 1].y);
		}
	}
	///#endif // EAM_OBJECTS 



	///#define TERM_PROTO
	///#define TERM_BODY
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERM_PUBLIC static


	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef TERM_PROTO
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef TERM_BODY
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef TERM_PUBLIC


	/* setup the magic macros to compile in the right parts of the
	 * terminal drivers included by term.h
	 */
	///#define TERM_TABLE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERM_TABLE_START(x) ,{
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERM_TABLE_END(x) }


	/*
	 * term_tbl[] contains an entry for each terminal.  "unknown" must be the
	 *   first, since term is initialized to 0.
	 */
	public static TERMENTRY[] term_tbl = {{"unknown", "Unknown terminal type - not a plotting device", 100, 100, 1, 1, 1, 1, options_null, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, null_scale, UNKNOWN_null, MOVE_null, MOVE_null, LINETYPE_null, PUTTEXT_null}};

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TERMCOUNT (sizeof(term_tbl) / sizeof(term_tbl[0]))
	///#if 0 // UNUSED
	//// /* mainly useful for external code */
	////int
	////term_count()
	////{
	////    return TERMCOUNT;
	////}
	///#endif

	public static void list_terms()
	{
		int i;
		byte line_buffer = GlobalMembersAlloc.gp_alloc(BUFSIZ, "list_terms");
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: int sort_idxs[sizeof(term_tbl) / sizeof(term_tbl[0])];
		int[[]] sort_idxs = new int[term_tbl.length];

		/* sort terminal types alphabetically */
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for(i = 0; i < sizeof(term_tbl) / sizeof(term_tbl[0]); i++)
		for (i = 0; i < term_tbl.length; i++)
		sort_idxs[i] = i;
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: qsort(sort_idxs, sizeof(term_tbl) / sizeof(term_tbl[0]), sizeof(int), termcomp);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(sort_idxs, term_tbl.length, sizeof(int), GlobalMembersTerm.termcomp);
		/* now sort_idxs[] contains the sorted indices */

		GlobalMembersHelp.StartOutput();
		line_buffer = "\nAvailable terminal types:\n";
		GlobalMembersHelp.OutLine(line_buffer);

//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for (i = 0; i < sizeof(term_tbl) / sizeof(term_tbl[0]); i++)
		for (i = 0; i < term_tbl.length; i++)
		{
		String.format(line_buffer, "  %15s  %s\n", term_tbl[sort_idxs[i]].name, term_tbl[sort_idxs[i]].description);
		GlobalMembersHelp.OutLine(line_buffer);
		}

		GlobalMembersHelp.EndOutput();
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(line_buffer);
	}

	/* Return string with all terminal names.
	   Note: caller must free the returned names after use.
	*/
	public static String get_terminals_names()
	{
		int i;
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: sbyte *buf = gp_alloc(sizeof(term_tbl) / sizeof(term_tbl[0])*15, "all_term_names");
		byte buf = GlobalMembersAlloc.gp_alloc(term_tbl.length * 15, "all_term_names"); // max 15 chars per name
		String names;
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: int sort_idxs[sizeof(term_tbl) / sizeof(term_tbl[0])];
		int[[]] sort_idxs = new int[term_tbl.length];

		/* sort terminal types alphabetically */
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for(i = 0; i < sizeof(term_tbl) / sizeof(term_tbl[0]); i++)
		for (i = 0; i < term_tbl.length; i++)
		sort_idxs[i] = i;
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: qsort(sort_idxs, sizeof(term_tbl) / sizeof(term_tbl[0]), sizeof(int), termcomp);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		qsort(sort_idxs, term_tbl.length, sizeof(int), GlobalMembersTerm.termcomp);
		/* now sort_idxs[] contains the sorted indices */

		buf = " "; // let the string have leading and trailing " " in order to search via strstrt(GPVAL_TERMINALS, " png ");
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for (i = 0; i < sizeof(term_tbl) / sizeof(term_tbl[0]); i++)
		for (i = 0; i < term_tbl.length; i++)
		String.format(buf + buf.length(), "%s ", term_tbl[sort_idxs[i]].name);
		names = GlobalMembersAlloc.gp_alloc(buf.length() + 1, "all_term_names2");
		names = buf;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(buf);
		return names;
	}

	/* set_term: get terminal number from name on command line
	 * will change 'term' variable if successful
	 */
	public static TERMENTRY set_term()
	{
		TERMENTRY t = DefineConstants.NULL;
		String input_name = DefineConstants.NULL;

		if (!GlobalMembersCommand.c_token >= GlobalMembersCommand.num_tokens || GlobalMembersUtil.equals(GlobalMembersCommand.c_token, ";") != 0)
		{
		input_name = GlobalMembersCommand.gp_input_line + GlobalMembersCommand.token[GlobalMembersCommand.c_token].start_index;
			t = GlobalMembersTerm.change_term(input_name, GlobalMembersCommand.token[GlobalMembersCommand.c_token].length);
		if (t == null && (GlobalMembersUtil.isstring(GlobalMembersCommand.c_token) != 0 || GlobalMembersUtil.type_udv(GlobalMembersCommand.c_token) == DATA_TYPES.STRING))
		{
			input_name = GlobalMembersUtil.try_to_get_string(); // Cannot fail if isstringvalue succeeded
			t = GlobalMembersTerm.change_term(input_name, input_name.length());
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(input_name);
		}
		else
		{
				GlobalMembersCommand.c_token++;
		}
		}

		if (t == null)
		GlobalMembersBf_test.int_error(GlobalMembersCommand.c_token - 1, "unknown or ambiguous terminal type; type just 'set terminal' for a list");

		/* otherwise the type was changed */
		return (t);
	}

	/*
	 * Routine to detect what terminal is being used (or do anything else
	 * that would be nice).  One anticipated (or allowed for) side effect
	 * is that the global ``term'' may be set.
	 * The environment variable GNUTERM is checked first; if that does
	 * not exist, then the terminal hardware is checked, if possible,
	 * and finally, we can check $TERM for some kinds of terminals.
	 * A default can be set with -DDEFAULTTERM=myterm in the Makefile
	 * or #define DEFAULTTERM myterm in term.h
	 */
	/* thanks to osupyr!alden (Dave Alden) for the original GNUTERM code */
	public static void init_terminal()
	{
		String term_name = DefineConstants.NULL;
	///#if (defined(__TURBOC__) && defined(MSDOS) && !defined(_Windows)) || defined(NEXT) || defined(SUN) || defined(X11)
		String env_term = DefineConstants.NULL; // from TERM environment var
	///#endif
	///#ifdef X11
		String display = DefineConstants.NULL;
	///#endif
		String gnuterm = DefineConstants.NULL;

		/* GNUTERM environment variable is primary */
		gnuterm = getenv("GNUTERM");
		if (!gnuterm.equals((String) DefineConstants.NULL))
		{
		term_name = gnuterm;
		}
		else
		{

	///#ifdef __ZTC__
	//	term_name = ztc_init();
	///#endif

	///#ifdef VMS
	//	term_name = vms_init();
	///#endif // VMS 

	///#ifdef NEXT
	//	env_term = getenv("TERM");
	//	if (term_name == (char *) NULL
	//	    && env_term != (char *) NULL && strcmp(env_term, "next") == 0)
	//	    term_name = "next";
	///#endif // NeXT 

	///#ifdef __BEOS__
	//	env_term = getenv("TERM");
	//	if (term_name == (char *) NULL
	//	    && env_term != (char *) NULL && strcmp(env_term, "beterm") == 0)
	//	    term_name = "be";
	///#endif // BeOS 

	///#ifdef SUN
	//	env_term = getenv("TERM");      // try $TERM 
	//	if (term_name == (char *) NULL
	//	    && env_term != (char *) NULL && strcmp(env_term, "sun") == 0)
	//	    term_name = "sun";
	///#endif // SUN 

	///#ifdef WXWIDGETS
	//	if (term_name == (char *) NULL)
	//		term_name = "wxt";
	///#endif

	///#ifdef _Windows
	// /* let the wxWidgets terminal be the default when available */
	//	if (term_name == (char *) NULL)
	//		term_name = "win";
	///#endif // _Windows 

	///#ifdef GPR
	// /* find out whether stdout is a DM pad. See term/gpr.trm */
	//	if (gpr_isa_pad())
	//	    term_name = "gpr";
	///#else
	///#ifdef APOLLO
	// /* find out whether stdout is a DM pad. See term/apollo.trm */
	//	if (apollo_isa_pad())
	//	    term_name = "apollo";
	///#endif                         // APOLLO 
	///#endif // GPR    

	///#if defined(__APPLE__) && defined(__MACH__) && defined(HAVE_LIBAQUATERM)
	// /* Mac OS X with AquaTerm installed */
	//	term_name = "aqua";
	///#endif

	///#ifdef X11
		env_term = getenv("TERM"); // try $TERM
		if (term_name.equals((String) DefineConstants.NULL) && !env_term.equals((String) DefineConstants.NULL) && strcmp(env_term, "xterm") == 0)
			term_name = "x11";
		display = getenv("DISPLAY");
		if (term_name.equals((String) DefineConstants.NULL) && !display.equals((String) DefineConstants.NULL))
			term_name = "x11";
		if (X11_Display)
			term_name = "x11";
	///#endif // x11 

	///#ifdef AMIGA
	//	term_name = "amiga";
	///#endif

	///#ifdef UNIXPC
	//	if (iswind() == 0) {
	//	    term_name = "unixpc";
	//	}
	///#endif // unixpc 

	///#ifdef CGI
	//	if (getenv("CGIDISP") || getenv("CGIPRNT"))
	//	    term_name = "cgi";
	///#endif //CGI 

	///#ifdef DJGPP
	//	term_name = "svga";
	///#endif

	///#ifdef GRASS
	//	term_name = "grass";
	///#endif

	///#ifdef OS2
	// /* amai: Note that we do some checks above and now overwrite any
	//    results. Perhaps we may disable checks above!? */
	///#ifdef X11
	// /* WINDOWID is set in sessions like xterm, etc.
	//    DISPLAY is also mandatory. */
	//	env_term = getenv("WINDOWID");
	//	display  = getenv("DISPLAY");
	//	if ((env_term != (char *) NULL) && (display != (char *) NULL))
	//	    term_name = "x11";
	//	else
	///#endif          // X11 
	//	    term_name = "pm";
	///#endif //OS2 

	/* set linux terminal only if LINUX_setup was successfull, if we are on X11
	   LINUX_setup has failed, also if we are logged in by network */
	///#ifdef LINUXVGA
	//	if (LINUX_graphics_allowed)
	///#ifdef VGAGL
	//	    term_name = "vgagl";
	///#else
	//	    term_name = "linux";
	///#endif
	///#endif // LINUXVGA 
		}

		/* We have a name, try to set term type */
		if (!term_name.equals(DefineConstants.NULL) && !term_name.equals('\0'))
		{
		int namelength = term_name.length();
		udvt_entry name = GlobalMembersEval.add_udv_by_name("GNUTERM");

		GlobalMembersEval.Gstring(name.udv_value, GlobalMembersUtil.gp_strdup(term_name));
		name.udv_undef = false;

		if (tangible.StringFunctions.strChr(term_name,' '))
			namelength = tangible.StringFunctions.strChr(term_name,' ') - term_name;

		/* Force the terminal to initialize default fonts, etc.	This prevents */
		/* segfaults and other strangeness if you set GNUTERM to "post" or    */
		/* "png" for example. However, calling X11_options() is expensive due */
		/* to the fork+execute of gnuplot_x11 and x11 can tolerate not being  */
		/* initialized until later.                                           */
		/* Note that gp_input_line[] is blank at this point.	              */
		if (GlobalMembersTerm.change_term(term_name, namelength) != null)
		{
			if (strcmp(term.name,"x11"))
			term.options();
			return;
		}
		fprintf(stderr, "Unknown or ambiguous terminal name '%s'\n", term_name);
		}
		GlobalMembersTerm.change_term("unknown", 7);
	}

	/* test terminal by drawing border and text */
	/* called from command test */
	public static void test_term()
	{
		TERMENTRY t = term;
		String str;
		int x;
		int y;
		int xl;
		int yl;
		int i;
		int xmax_t;
		int ymax_t;
		String label = new String(new char[DefineConstants.MAX_ID_LEN]);
		int key_entry_height;
		int p_width;
		boolean already_in_enhanced_text_mode;

		already_in_enhanced_text_mode = t.flags & DefineConstants.TERM_ENHANCED_TEXT;
		if (!already_in_enhanced_text_mode)
		GlobalMembersCommand.do_string("set termopt enh", false);

		GlobalMembersTerm.term_start_plot();
		GlobalMembersUtil.screen_ok = false;
		xmax_t = (int)(t.xmax * GlobalMembersGadgets.xsize);
		ymax_t = (int)(t.ymax * GlobalMembersGadgets.ysize);

		p_width = GlobalMembersGadgets.pointsize * t.h_tic;
		key_entry_height = GlobalMembersGadgets.pointsize * t.v_tic * 1.25;
		if (key_entry_height < t.v_char)
		key_entry_height = t.v_char;

		/* Sync point for epslatex text positioning */
		if (term.layer)
		(term.layer)(termlayer.TERM_LAYER_FRONTTEXT);

		/* border linetype */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linewidth)(1.0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(0, 0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t - 1, 0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t - 1, ymax_t - 1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(0, ymax_t - 1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(0, 0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(0);

		/* Echo back the current terminal type */
		if (!strcmp(term.name,"unknown"))
		GlobalMembersBf_test.int_error(DefineConstants.NO_CARET, "terminal type is unknown");
		else
		{
		String tbuf = new String(new char[64]);
		tbuf = term.name;
		tbuf += "  terminal test";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(t.h_char * 2, ymax_t - t.v_char * 0.5, tbuf);
		}

	///#ifdef USE_MOUSE
		if (t.set_ruler)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(t.h_char * 5, ymax_t - t.v_char * 3, "Mouse and hotkeys are supported, hit: h r m 6");
		}
	///#endif
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_AXIS);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(xmax_t / 2, 0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t / 2, ymax_t - 1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(0, ymax_t / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t - 1, ymax_t / 2);
		/* test width and height of characters */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(3);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(xmax_t / 2 - t.h_char * 10, ymax_t / 2 + t.v_char / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t / 2 + t.h_char * 10, ymax_t / 2 + t.v_char / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t / 2 + t.h_char * 10, ymax_t / 2 - t.v_char / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t / 2 - t.h_char * 10, ymax_t / 2 - t.v_char / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(xmax_t / 2 - t.h_char * 10, ymax_t / 2 + t.v_char / 2);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2 - t.h_char * 10, ymax_t / 2, "12345678901234567890");
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2 - t.h_char * 10, ymax_t / 2 + t.v_char * 1.4, "test of character width:");
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);

		/* Test for enhanced text */
		if (t.flags & DefineConstants.TERM_ENHANCED_TEXT != 0)
		{
		byte tmptext = GlobalMembersUtil.gp_strdup("Enhanced text:   {x@_{0}^{n+1}}");
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t * 0.5, ymax_t * 0.40, tmptext);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(tmptext);
		if (!already_in_enhanced_text_mode)
			GlobalMembersCommand.do_string("set termopt noenh", false);
		}

		/* test justification */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2, ymax_t / 2 + t.v_char * 6, "left justified");
		str = "centre+d text";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(JUSTIFY.CENTRE))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2, ymax_t / 2 + t.v_char * 5, str);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2 - str.length() * t.h_char / 2, ymax_t / 2 + t.v_char * 5, str);
		str = "right justified";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(JUSTIFY.RIGHT))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2, ymax_t / 2 + t.v_char * 4, str);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(xmax_t / 2 - str.length() * t.h_char, ymax_t / 2 + t.v_char * 4, str);
		/* test text angle */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(1);
		str = "rotated ce+ntred text";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.text_angle)(DefineConstants.TEXT_VERTICAL))
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(JUSTIFY.CENTRE))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.put_text)(t.v_char, ymax_t / 2, str);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.put_text)(t.v_char, ymax_t / 2 - str.length() * t.h_char / 2, str);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.justify_text)(JUSTIFY.LEFT);
		str = " rotated by +45 deg";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.text_angle)(45);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(t.v_char * 3, ymax_t / 2, str);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.justify_text)(JUSTIFY.LEFT);
		str = " rotated by -45 deg";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.text_angle)(-45);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(t.v_char * 2, ymax_t / 2, str);
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(t.h_char * 2, ymax_t / 2 - t.v_char * 2, "can't rotate text");
		}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.text_angle)(0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);

		/* test tic size */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(4);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)((int)(xmax_t / 2 + t.h_tic * (1 + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale)), (int) ymax_t - 1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)((int)(xmax_t / 2 + t.h_tic * (1 + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale)), (int)(ymax_t - GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale * t.v_tic));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)((int)(xmax_t / 2), (int)(ymax_t - t.v_tic * (1 + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale)));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)((int)(xmax_t / 2 + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale * t.h_tic), (int)(ymax_t - t.v_tic * (1 + GlobalMembersAxis.axis_array[AXIS_INDEX.FIRST_X_AXIS.getValue()].ticscale)));
		/* HBB 19990530: changed this to use right-justification, if possible... */
		str = "show ticscale";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(JUSTIFY.RIGHT))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)((int)(xmax_t / 2 - 1* t.h_char), (int)(ymax_t - (t.v_tic * 2 + t.v_char / 2)), str);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)((int)(xmax_t / 2 - (str.length()+1) * t.h_char), (int)(ymax_t - (t.v_tic * 2 + t.v_char / 2)), str);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);

		/* test line and point types */
		x = xmax_t - t.h_char * 6 - p_width;
		y = ymax_t - key_entry_height;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.pointsize)(GlobalMembersGadgets.pointsize);
		for (i = -2; y > key_entry_height; i++)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(i);
		/*      (void) sprintf(label,"%d",i);  Jorgen Lippert
		   lippert@risoe.dk */
		() sprintf(label, "%d", i + 1);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	if ((*t.justify_text)(JUSTIFY.RIGHT))
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.put_text)(x, y, label);
		else
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.put_text)(x - label.length() * t.h_char, y, label);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x + t.h_char, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x + t.h_char * 4, y);
		if (i >= -1)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.point)(x + t.h_char * 5 + p_width / 2, y, i);
		y -= key_entry_height;
		}

		/* test some arrows */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linewidth)(1.0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(0);
		x = xmax_t * .375;
		y = ymax_t * .250;
		xl = t.h_tic * 7;
		yl = t.v_tic * 7;
		i = curr_arrow_headfilled;
		curr_arrow_headfilled = 0;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x, y, x + xl, y, e_arrow_head.END_HEAD);
		curr_arrow_headfilled = 1;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x, y, x - xl, y, e_arrow_head.END_HEAD);
		curr_arrow_headfilled = 2;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x, y, x, y + yl, e_arrow_head.END_HEAD);
		curr_arrow_headfilled = 1; // Was 3, but no terminals implement it
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x, y, x, y - yl, e_arrow_head.END_HEAD);
		curr_arrow_headfilled = i;
		xl = t.h_tic * 5;
		yl = t.v_tic * 5;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x - xl, y - yl, x + xl, y + yl, e_arrow_head.END_HEAD | e_arrow_head.BACKHEAD);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x - xl, y + yl, x, y, e_arrow_head.NOHEAD);
		curr_arrow_headfilled = 1; // Was 3, but no terminals implement it
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.arrow)(x, y, x + xl, y - yl, e_arrow_head.BACKHEAD);

		/* test line widths */
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	()(*t.justify_text)(JUSTIFY.LEFT);
		xl = xmax_t / 10;
		yl = ymax_t / 25;
		x = xmax_t * .075;
		y = yl;

		for (i = 1; i < 7; i++)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linewidth)((float)(i));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x, y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x+xl, y);
		String.format(label,"  lw %1d%c",i,0);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(x+xl, y, label);
		y += yl;
		}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(x, y, "linewidth");

		/* test fill patterns */
		x = xmax_t * 0.5;
		y = 0;
		xl = xmax_t / 40;
		yl = ymax_t / 8;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linewidth)((float)(1));
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.justify_text)(JUSTIFY.CENTRE);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(x+xl *7, yl+t.v_char *1.5, "pattern fill");
		for (i = 0; i < 10; i++)
		{
		int style = ((i << 4) + t_fillstyle.FS_PATTERN);
		if (t.fillbox)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//		(*t.fillbox)(style, x, y, xl, yl);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.move)(x,y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x,y+yl);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x+xl,y+yl);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x+xl,y);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.vector)(x,y);
		String.format(label,"%2d",i);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(x+xl/2, y+yl+t.v_char *0.5, label);
		x += xl * 1.5;
		}

		{
		int cen_x = (int)(0.70 * xmax_t);
		int cen_y = (int)(0.83 * ymax_t);
		int radius = xmax_t / 20;

		/* test pm3d -- filled_polygon(), but not set_color() */
		if (t.filled_polygon)
		{
			int i;
			int j;
	///#define NUMBER_OF_VERTICES 6
			int n = DefineConstants.NUMBER_OF_VERTICES;
			gpiPoint[] corners = new gpiPoint[DefineConstants.NUMBER_OF_VERTICES + 1];
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef NUMBER_OF_VERTICES

			for (j = 0; j <= 1; j++)
			{
			int ix = cen_x + j * radius;
			int iy = cen_y - j * radius / 2;
			for (i = 0; i < n; i++)
			{
				corners[i].x = ix + radius * Math.cos(2 * DefineConstants.M_PI * i / n);
				corners[i].y = iy + radius * Math.sin(2 * DefineConstants.M_PI * i / n);
			}
			corners[n].x = corners[0].x;
			corners[n].y = corners[0].y;
			if (j == 0)
			{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.linetype)(2);
				corners.style = t_fillstyle.FS_SOLID.getValue() + (100 << 4);
			}
			else
			{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//			(*t.linetype)(1);
				corners.style = t_fillstyle.FS_TRANSPARENT_SOLID.getValue() + (50 << 4);
			}
			term.filled_polygon(n + 1, corners);
			}
			str = "filled polygons:";
		}
		else
			str = "No filled polygons";
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.linetype)(DefineConstants.LT_BLACK);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	i = ((*t.justify_text)(JUSTIFY.CENTRE)) ? 0 : t.h_char * str.length() / 2;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*t.put_text)(cen_x + i, cen_y + radius + t.v_char * 0.5, str);
		}

		GlobalMembersTerm.term_end_plot();
	}

	///#if 0
	////#if defined(MSDOS)||defined(g)||defined(OS2)||defined(_Windows)||defined(DOS386)
	////
	//// /* output for some terminal types must be binary to stop non Unix computers
	////    changing \n to \r\n.
	////    If the output is not STDOUT, the following code reopens gpoutfile
	////    with binary mode. */
	////void
	////reopen_binary()
	////{
	////    if (outstr) {
	////	(void) fclose(gpoutfile);
	////#ifdef _Windows
	////	if (!stricmp(outstr, "PRN")) {
	//// /* use temp file for windows */
	////	    (void) strcpy(filename, win_prntmp);
	////	}
	////#endif
	////	if ((gpoutfile = fopen(filename, "wb")) == (FILE *) NULL) {
	////	    if ((gpoutfile = fopen(filename, "w")) == (FILE *) NULL) {
	////		os_error(NO_CARET, "cannot reopen file with binary type; output unknown");
	////	    } else {
	////		os_error(NO_CARET, "cannot reopen file with binary type; output reset to ascii");
	////	    }
	////	}
	////#if defined(__TURBOC__) && defined(MSDOS)
	////#ifndef _Windows
	////	if (!stricmp(outstr, "PRN")) {
	//// /* Put the printer into binary mode. */
	////	    union REGS regs;
	////	    regs.h.ah = 0x44;   // ioctl 
	////	    regs.h.al = 0;      // get device info 
	////	    regs.x.bx = fileno(gpoutfile);
	////	    intdos(&regs, &regs);
	////	    regs.h.dl |= 0x20;  // binary (no ^Z intervention) 
	////	    regs.h.dh = 0;
	////	    regs.h.ah = 0x44;   // ioctl 
	////	    regs.h.al = 1;      // set device info 
	////	    intdos(&regs, &regs);
	////	}
	////#endif // !_Windows 
	////#endif // TURBOC && MSDOS 
	////    }
	////}
	////
	////#endif // MSDOS || g || ... 
	///#endif // 0 

	///#ifdef VMS
	// /* these are needed to modify terminal characteristics */
	///#ifndef VWS_XMAX
	// /* avoid duplicate warning; VWS includes these */
	///#include <descrip.h>
	///#include <ssdef.h>
	///#endif                         // !VWS_MAX 
	///#include <iodef.h>
	///#include <ttdef.h>
	///#include <tt2def.h>
	///#include <dcdef.h>
	///#include <stat.h>
	///#include <fab.h>
	// /* If you use WATCOM C or a very strict ANSI compiler, you may have to
	//  * delete or comment out the following 3 lines: */
	///#ifndef TT2$M_DECCRT3          // VT300 not defined as of VAXC v2.4 
	///#define TT2$M_DECCRT3 0X80000000
	///#endif
	//static unsigned short chan;
	//static int old_char_buf[3], cur_char_buf[3];
	//$DESCRIPTOR(sysoutput_desc, "SYS$OUTPUT");
	//
	// /* Look first for decw$display (decterms do regis).  Determine if we
	//  * have a regis terminal and save terminal characteristics */
	//char *
	//vms_init()
	//{
	// /* Save terminal characteristics in old_char_buf and
	//    initialise cur_char_buf to current settings. */
	//    int i;
	//    if (getenv("DECW$DISPLAY"))
	//	return ("x11");
	//    atexit(vms_reset);
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    sys$qiow(0, chan, IO$_SENSEMODE, 0, 0, 0, old_char_buf, 12, 0, 0, 0, 0);
	//    for (i = 0; i < 3; ++i)
	//	cur_char_buf[i] = old_char_buf[i];
	//    sys$dassgn(chan);
	//
	// /* Test if terminal is regis */
	//    if ((cur_char_buf[2] & TT2$M_REGIS) == TT2$M_REGIS)
	//	return ("regis");
	//    return (NULL);
	//}
	//
	// /* set terminal to original state */
	//void
	//vms_reset()
	//{
	//    int i;
	//
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, old_char_buf, 12, 0, 0, 0, 0);
	//    for (i = 0; i < 3; ++i)
	//	cur_char_buf[i] = old_char_buf[i];
	//    sys$dassgn(chan);
	//}
	//
	// /* set terminal mode to tektronix */
	//void
	//term_mode_tek()
	//{
	//    long status;
	//
	//    if (gpoutfile != stdout)
	//	return;                 // don't modify if not stdout 
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    cur_char_buf[0] = 0x004A0000 | DC$_TERM | (TT$_TEK401X << 8);
	//    cur_char_buf[1] = (cur_char_buf[1] & 0x00FFFFFF) | 0x18000000;
	//
	//    cur_char_buf[1] &= ~TT$M_CRFILL;
	//    cur_char_buf[1] &= ~TT$M_ESCAPE;
	//    cur_char_buf[1] &= ~TT$M_HALFDUP;
	//    cur_char_buf[1] &= ~TT$M_LFFILL;
	//    cur_char_buf[1] &= ~TT$M_MECHFORM;
	//    cur_char_buf[1] &= ~TT$M_NOBRDCST;
	//    cur_char_buf[1] &= ~TT$M_NOECHO;
	//    cur_char_buf[1] &= ~TT$M_READSYNC;
	//    cur_char_buf[1] &= ~TT$M_REMOTE;
	//    cur_char_buf[1] |= TT$M_LOWER;
	//    cur_char_buf[1] |= TT$M_TTSYNC;
	//    cur_char_buf[1] |= TT$M_WRAP;
	//    cur_char_buf[1] &= ~TT$M_EIGHTBIT;
	//    cur_char_buf[1] &= ~TT$M_MECHTAB;
	//    cur_char_buf[1] &= ~TT$M_SCOPE;
	//    cur_char_buf[1] |= TT$M_HOSTSYNC;
	//
	//    cur_char_buf[2] &= ~TT2$M_APP_KEYPAD;
	//    cur_char_buf[2] &= ~TT2$M_BLOCK;
	//    cur_char_buf[2] &= ~TT2$M_DECCRT3;
	//    cur_char_buf[2] &= ~TT2$M_LOCALECHO;
	//    cur_char_buf[2] &= ~TT2$M_PASTHRU;
	//    cur_char_buf[2] &= ~TT2$M_REGIS;
	//    cur_char_buf[2] &= ~TT2$M_SIXEL;
	//    cur_char_buf[2] |= TT2$M_BRDCSTMBX;
	//    cur_char_buf[2] |= TT2$M_EDITING;
	//    cur_char_buf[2] |= TT2$M_INSERT;
	//    cur_char_buf[2] |= TT2$M_PRINTER;
	//    cur_char_buf[2] &= ~TT2$M_ANSICRT;
	//    cur_char_buf[2] &= ~TT2$M_AVO;
	//    cur_char_buf[2] &= ~TT2$M_DECCRT;
	//    cur_char_buf[2] &= ~TT2$M_DECCRT2;
	//    cur_char_buf[2] &= ~TT2$M_DRCS;
	//    cur_char_buf[2] &= ~TT2$M_EDIT;
	//    cur_char_buf[2] |= TT2$M_FALLBACK;
	//
	//    status = sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, cur_char_buf, 12, 0, 0, 0, 0);
	//    if (status == SS$_BADPARAM) {
	// /* terminal fallback utility not installed on system */
	//	cur_char_buf[2] &= ~TT2$M_FALLBACK;
	//	sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, cur_char_buf, 12, 0, 0, 0, 0);
	//    } else {
	//	if (status != SS$_NORMAL)
	//	    lib$signal(status, 0, 0);
	//    }
	//    sys$dassgn(chan);
	//}
	//
	// /* set terminal mode back to native */
	//void
	//term_mode_native()
	//{
	//    int i;
	//
	//    if (gpoutfile != stdout)
	//	return;                 // don't modify if not stdout 
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, old_char_buf, 12, 0, 0, 0, 0);
	//    for (i = 0; i < 3; ++i)
	//	cur_char_buf[i] = old_char_buf[i];
	//    sys$dassgn(chan);
	//}
	//
	// /* set terminal mode pasthru */
	//void
	//term_pasthru()
	//{
	//    if (gpoutfile != stdout)
	//	return;                 // don't modify if not stdout 
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    cur_char_buf[2] |= TT2$M_PASTHRU;
	//    sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, cur_char_buf, 12, 0, 0, 0, 0);
	//    sys$dassgn(chan);
	//}
	//
	// /* set terminal mode nopasthru */
	//void
	//term_nopasthru()
	//{
	//    if (gpoutfile != stdout)
	//	return;                 // don't modify if not stdout 
	//    sys$assign(&sysoutput_desc, &chan, 0, 0);
	//    cur_char_buf[2] &= ~TT2$M_PASTHRU;
	//    sys$qiow(0, chan, IO$_SETMODE, 0, 0, 0, cur_char_buf, 12, 0, 0, 0, 0);
	//    sys$dassgn(chan);
	//}
	//
	//void
	//fflush_binary()
	//{
	//    typedef short int INT16;    // signed 16-bit integers 
	//    INT16 k;            // loop index 
	//
	//    if (gpoutfile != stdout) {
	// /* Stupid VMS fflush() raises error and loses last data block
	//    unless it is full for a fixed-length record binary file.
	//    Pad it here with NULL characters. */
	//	for (k = (INT16) ((*gpoutfile)->_cnt); k > 0; --k)
	//	    putc('\0', gpoutfile);
	//	fflush(gpoutfile);
	//    }
	//}
	///#endif // VMS 

	/*
	 * This is an abstraction of the enhanced text mode originally written
	 * for the postscript terminal driver by David Denholm and Matt Heffron.
	 * I have split out a terminal-independent recursive syntax-parser
	 * routine that can be shared by all drivers that want to add support
	 * for enhanced text mode.
	 *
	 * A driver that wants to make use of this common framework must provide
	 * three new entries in TERM_TABLE:
	 *      void *enhanced_open   (char *fontname, double fontsize, double base,
	 *                             TBOOLEAN widthflag, TBOOLEAN showflag,
	 *                             int overprint)
	 *      void *enhanced_writec (char c)
	 *      void *enhanced_flush  ()
	 *
	 * Each driver also has a separate ENHXX_put_text() routine that replaces
	 * the normal (term->put_text) routine while in enhanced mode.
	 * This routine must initialize the following globals used by the shared code:
	 *      enhanced_fontscale      converts font size to device resolution units
	 *      enhanced_escape_format  used to process octal escape characters \xyz
	 *
	 * I bent over backwards to make the output of the revised code identical
	 * to the output of the original postscript version.  That means there is
	 * some cruft left in here (enhanced_max_height for one thing) that is
	 * probably irrelevant to any new drivers using the code.
	 *
	 * Ethan A Merritt - November 2003
	 */

	///#ifdef DEBUG_ENH
	///#define ENH_DEBUG(x) printf x;
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ENH_DEBUG(x)
	///#endif

	public static void do_enh_writec(int c)
	{
		/* note: c is meant to hold a char, but is actually an int, for
		 * the same reasons applying to putc() and friends */
		enhanced_cur_text++= c;
	}

	/*
	 * Process a bit of string, and return the last character used.
	 * p is start of string
	 * brace is TRUE to keep processing to }, FALSE to do one character only
	 * fontname & fontsize are obvious
	 * base is the current baseline
	 * widthflag is TRUE if the width of this should count,
	 *              FALSE for zero width boxes
	 * showflag is TRUE if this should be shown,
	 *             FALSE if it should not be shown (like TeX \phantom)
	 * overprint is 0 for normal operation,
	 *              1 for the underprinted text (included in width calculation),
	 *              2 for the overprinted text (not included in width calc)
	 *              (overprinted text is centered horizontally on underprinted text
	 */

	public static String enhanced_recursion(String p, boolean brace, String fontname, double fontsize, double base, boolean widthflag, boolean showflag, int overprint)
	{
		x(("RECURSE WITH [%p] \"%s\", %d %s %.1f %.1f %d %d %d\n", p, p, brace, fontname, fontsize, base, widthflag, showflag, overprint));

		/* Start each recursion with a clean string */
		(term.enhanced_flush)();

		if (base + fontsize > enhanced_max_height)
		{
		enhanced_max_height = base + fontsize;
		x(("Setting max height to %.1f\n", enhanced_max_height));
		}

		if (base < enhanced_min_height)
		{
		enhanced_min_height = base;
		x(("Setting min height to %.1f\n", enhanced_min_height));
		}

		while (p != null)
		{
		float shift;

		/*
		 * EAM Jun 2009 - treating bytes one at a time does not work for multibyte
		 * encodings, including utf-8. If we hit a byte with the high bit set, test
		 * whether it starts a legal UTF-8 sequence and if so copy the whole thing.  
		 * Other multibyte encodings are still a problem.
		 * Gnuplot's other defined encodings are all single-byte; for those we
		 * really do want to treat one byte at a time.
		 */
		if ((p & 0x80) && (encoding == set_encoding_id.S_ENC_DEFAULT || encoding == set_encoding_id.S_ENC_UTF8))
		{
			int utf8char;
			String nextchar = p;

			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			if (GlobalMembersUtil.utf8toulong(utf8char, nextchar)) // Legal UTF8 sequence
			{
			while (p.compareTo(nextchar) < 0)
				(term.enhanced_writec)(p++);
			p--;
			} // Some other multibyte encoding?
			else
			{
			(term.enhanced_writec)(p);
			}
		}
		else

		switch (p)
		{
		case '}' :
			/*{{{  deal with it*/
			if (brace)
			return (p);

			GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "enhanced text parser - spurious }");
			break;
			/*}}}*/

		case '_' :
		case '^' :
			/*{{{  deal with super/sub script*/
			shift = (p.equals('^')) ? 0.5 : -0.3;
			(term.enhanced_flush)();
			p = GlobalMembersTerm.enhanced_recursion(p + 1, false, fontname, fontsize * 0.8, base + shift * fontsize, widthflag, showflag, overprint);
			break;
			/*}}}*/
		case '{' :
		{
			String savepos = DefineConstants.NULL;
			byte save = 0;
			String localfontname = fontname;
			byte ch;
			float f = fontsize;
			float ovp;

			/*{{{  recurse (possibly with a new font) */

			x(("Dealing with {\n"));

			/* get vertical offset (if present) for overprinted text */
			while (*++p == ' ');
			if (overprint == 2)
			{
				ovp = (float)strtod(p, p);
				if (term.flags & DefineConstants.TERM_IS_POSTSCRIPT != 0)
				base = ovp * f;
				else
				base += ovp * f;
			}
			--p; // HBB 20001021: bug fix: 10^{2} broken

			if (*++p == '/')
			{
				/* then parse a fontname, optional fontsize */
				while (*++p == ' ')
				; // do nothing
				if (p.equals('-'))
				{
				while (*++p == ' ')
					; // do nothing
				}
				localfontname = p;
				while ((ch = p) > ' ' && ch != '=' && ch != '*' && ch != '}')
				++p;
				save = *(savepos = p);
				if (ch == '=')
				{
				p++= '\0';
				/*{{{  get optional font size*/
				x(("Calling strtod(\"%s\") ...", p));
				f = (float)strtod(p, p);
				x(("Returned %.1f and \"%s\"\n", f, p));

				if (f == 0)
					f = fontsize;
				else
					f *= enhanced_fontscale; // remember the scaling

				x(("Font size %.1f\n", f));
				/*}}}*/
				}
				else if (ch == '*')
				{
				p++= '\0';
				/*{{{  get optional font size scale factor*/
				x(("Calling strtod(\"%s\") ...", p));
				f = (float)strtod(p, p);
				x(("Returned %.1f and \"%s\"\n", f, p));

				if (f != 0F)
					f *= fontsize; // apply the scale factor
				else
					f = fontsize;

				x(("Font size %.1f\n", f));
				/*}}}*/
				}
				else if (ch == '}')
				{
				GlobalMembersUtil.int_warn(DefineConstants.NO_CARET,"bad syntax in enhanced text string");
				p++= '\0';
				}
				else
				{
				p++= '\0';
				f = fontsize;
				}

				while (p.equals(' '))
				++p;
				if (localfontname == null)
				localfontname = fontname;
			}
			/*}}}*/

			x(("Before recursing, we are at [%p] \"%s\"\n", p, p));

			p = GlobalMembersTerm.enhanced_recursion(p, true, localfontname, f, base, widthflag, showflag, overprint);

			x(("BACK WITH \"%s\"\n", p));

			(term.enhanced_flush)();

			if (savepos != null)
				/* restore overwritten character */
				savepos = save;
			break;
		} // case '{'
		case '@' :
			/*{{{  phantom box - prints next 'char', then restores currentpoint */
			(term.enhanced_flush)();
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, 3);
			p = GlobalMembersTerm.enhanced_recursion(++p, false, fontname, fontsize, base, widthflag, showflag, overprint);
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, 4);
			break;
			/*}}}*/

		case '&' :
			/*{{{  character skip - skips space equal to length of character(s) */
			(term.enhanced_flush)();

			p = GlobalMembersTerm.enhanced_recursion(++p, false, fontname, fontsize, base, widthflag, false, overprint);
			break;
			/*}}}*/

		case '~' :
			/*{{{ overprinted text */
			/* the second string is overwritten on the first, centered
			 * horizontally on the first and (optionally) vertically
			 * shifted by an amount specified (as a fraction of the
			 * current fontsize) at the beginning of the second string
	
			 * Note that in this implementation neither the under- nor
			 * overprinted string can contain syntax that would result
			 * in additional recursions -- no subscripts,
			 * superscripts, or anything else, with the exception of a
			 * font definition at the beginning of the text */

			(term.enhanced_flush)();
			p = GlobalMembersTerm.enhanced_recursion(++p, false, fontname, fontsize, base, widthflag, showflag, 1);
			(term.enhanced_flush)();
			p = GlobalMembersTerm.enhanced_recursion(++p, false, fontname, fontsize, base, false, showflag, 2);

			overprint = 0; // may not be necessary, but just in case . . .
			break;
			/*}}}*/

		case '(' :
		case ')' :
			/*{{{  an escape and print it */
			/* special cases */
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			if (term.flags & DefineConstants.TERM_IS_POSTSCRIPT != 0)
			(term.enhanced_writec)('\\');
			(term.enhanced_writec)(p);
			break;
			/*}}}*/

		case '\\' :
			if (p.charAt(1) == '\\' || p.charAt(1) == '(' || p.charAt(1) == ')')
			{
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			(term.enhanced_writec)('\\');

			/*{{{  The enhanced mode always uses \xyz as an octal character representation
			   but each terminal type must give us the actual output format wanted.
			   pdf.trm wants the raw character code, which is why we use strtol();
			   most other terminal types want some variant of "\\%o". */
			}
			else if (p.charAt(1) >= '0' && p.charAt(1) <= '7')
			{
			String e;
			String escape = new String(new char[16]);
			String octal = "\0\0\0";

			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			octal = tangible.StringFunctions.changeCharacter(octal, 0, *(++p));
			if (p.charAt(1) >= '0' && p.charAt(1) <= '7')
			{
				octal = tangible.StringFunctions.changeCharacter(octal, 1, *(++p));
				if (p.charAt(1) >= '0' && p.charAt(1) <= '7')
				octal = tangible.StringFunctions.changeCharacter(octal, 2, *(++p));
			}
			String.format(escape, enhanced_escape_format, strtol(octal,DefineConstants.NULL,8));
			for (e = escape; e; e++)
			{
				(term.enhanced_writec)(e);
			}
			break;
			}
			else if (term.flags & DefineConstants.TERM_IS_POSTSCRIPT != 0)
			{
			/* Shigeharu TAKENO  Aug 2004 - Needed in order for shift-JIS */
			/* encoding to work. If this change causes problems then we   */
			/* need a separate flag for shift-JIS and certain other 8-bit */
			/* character sets.                                            */
			/* EAM Nov 2004 - Nevertheless we must allow \ to act as an   */
			/* escape for a few enhanced mode formatting characters even  */
			/* though it corrupts certain Shift-JIS character sequences.  */
			if (tangible.StringFunctions.strChr("^_@&~{}", p.charAt(1)) == DefineConstants.NULL)
			{
				(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
				(term.enhanced_writec)('\\');
				(term.enhanced_writec)('\\');
				break;
			}
			}
			++p;

			/* HBB 20030122: Avoid broken output if there's a
	//  * exactly at the end of the line */
			if (p.equals('\0'))
			{
			GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "enhanced text parser -- spurious backslash");
			break;
			}

			/* SVG requires an escaped '&' to be passed as something else */
			/* FIXME: terminal-dependent code does not belong here */
			if (p.equals('&') && encoding == set_encoding_id.S_ENC_DEFAULT && !strcmp(term.name, "svg"))
			{
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			(term.enhanced_writec)('\376');
			break;
			}

			/* just go and print it (fall into the 'default' case) */
			/*}}}*/
		default:
			/*{{{  print it */
			(term.enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);
			(term.enhanced_writec)(p);
			/*}}}*/
		} // switch (*p)

		/* like TeX, we only do one character in a recursion, unless it's
		 * in braces
		 */

		if (!brace)
		{
			(term.enhanced_flush)();
			return (p); // the ++p in the outer copy will increment us
		}

		if (p != null) // only not true if { not terminated, I think
			++p;
		} // while (*p)

		(term.enhanced_flush)();
		return p;
	}

	/* Called after the end of recursion to check for errors */
	public static void enh_err_check(String str)
	{
		if (str.equals('}'))
		GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "enhanced text mode parser - ignoring spurious }");
		else
		GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "enhanced text mode parsing error");
	}

	/*
	 * Text strings containing control information for enhanced text mode
	 * contain more characters than will actually appear in the output.
	 * This makes it hard to estimate how much horizontal space on the plot
	 * (e.g. in the key box) must be reserved to hold them.  To approximate
	 * the eventual length we switch briefly to the dummy terminal driver
	 * "estimate.trm" and then switch back to the current terminal.
	 * If better, perhaps terminal-specific methods of estimation are
	 * developed later they can be slotted into this one call site.
	 */
	public static int estimate_strlen(String text)
	{
	int len;

	///#ifdef GP_ENH_EST
		if (tangible.StringFunctions.strChr(text,'\n') || (term.flags & DefineConstants.TERM_ENHANCED_TEXT))
		{
		TERMENTRY tsave = term;
		term = ENHest;
		term.put_text(0,0,text);
		len = term.xmax;
		GlobalMembersFit.a((stderr,"Estimating length %d height %g for enhanced text string \"%s\"\n", len, (double)(term.ymax) / 10., text));
		term = tsave;
		}
		else
	///#endif
		len = text.length();

		return len;
	}

	public static void ignore_enhanced(boolean flag)
	{
		/* Force a return to the default font */
		if (flag && !ignore_enhanced_text)
		{
		ignore_enhanced_text = true;
		if (term.set_font)
			term.set_font("");
		}
		ignore_enhanced_text = flag;
	}

	/* Simple-minded test for whether the point (x,y) is in bounds for the current terminal.
	 * Some terminals can do their own clipping, and can clip partial objects.
	 * If the flag TERM_CAN_CLIP is set, we skip this relative crude test and let the
	 * driver or the hardware handle clipping.
	 */
	public static boolean on_page(int x, int y)
	{
		if (term.flags & DefineConstants.TERM_CAN_CLIP != 0)
		return true;

		if ((0 < x && x < term.xmax) && (0 < y && y < term.ymax))
		return true;

		return false;
	}

	/*
	 * Wrappers for newpath and closepath
	 */

	public static void newpath()
	{
		if (term.path)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.path)(0);
	}

	public static void closepath()
	{
		if (term.path)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
	//	(*term.path)(1);
	}

	/* Squeeze all fill information into the old style parameter.
	 * The terminal drivers know how to extract the information.
	 * We assume that the style (int) has only 16 bit, therefore we take
	 * 4 bits for the style and allow 12 bits for the corresponding fill parameter.
	 * This limits the number of styles to 16 and the fill parameter's
	 * values to the range 0...4095, which seems acceptable.
	 */
	public static int style_from_fill(fill_style_type fs)
	{
		int fillpar;
		int style;

		switch (fs.fillstyle)
		{
		case FS_SOLID:
		case FS_TRANSPARENT_SOLID:
		fillpar = fs.filldensity;
		style = ((fillpar & 0xfff) << 4) + fs.fillstyle;
		break;
		case FS_PATTERN:
		case FS_TRANSPARENT_PATTERN:
		fillpar = fs.fillpattern;
		style = ((fillpar & 0xfff) << 4) + fs.fillstyle;
		break;
		case FS_EMPTY:
		default:
		/* solid fill with background color */
		style = t_fillstyle.FS_EMPTY.getValue();
		break;
		}

		return style;
	}


	public static void lp_use_properties(lp_style_type lp, int tag)
	{
		/*  This function looks for a linestyle defined by 'tag' and copies
		 *  its data into the structure 'lp'.
		 */

		linestyle_def this_Renamed;
		int save_pointflag = lp.pointflag;

		this_Renamed = GlobalMembersGadgets.first_linestyle;
		while (this_Renamed != DefineConstants.NULL)
		{
		if (this_Renamed.tag == tag)
		{
			lp = this_Renamed.lp_properties;
			lp.pointflag = save_pointflag;
			/* FIXME - It would be nicer if this were always true already */
			if (!lp.use_palette)
			{
			lp.pm3d_color.type = DefineConstants.TC_LT;
			lp.pm3d_color.lt = lp.l_type;
			}
			return;
		}
		else
		{
			this_Renamed = this_Renamed.next;
		}
		}

		/* No user-defined style with this tag; fall back to default line type. */
		/* NB: We assume that the remaining fields of lp have been initialized. */
		lp.l_type = tag - 1;
		lp.pm3d_color.type = DefineConstants.TC_LT;
		lp.pm3d_color.lt = lp.l_type;
		lp.p_type = tag - 1;
	}
}