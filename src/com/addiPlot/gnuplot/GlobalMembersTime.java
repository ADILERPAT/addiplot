package com.addiPlot.gnuplot;

public class GlobalMembersTime
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: time.c,v 1.20.2.1 2009/06/12 05:02:14 sfeam Exp $");
	}
	///#endif

	/* GNUPLOT - time.c */

	/*[
	 * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
	 *
	 * Permission to use, copy, and distribute this software and its
	 * documentation for any purpose with or without fee is hereby granted,
	 * provided that the above copyright notice appear in all copies and
	 * that both that copyright notice and this permission notice appear
	 * in supporting documentation.
	 *
	 * Permission to modify the software is granted, but not the right to
	 * distribute the complete modified source code.  Modifications are to
	 * be distributed as patches to the released version.  Permission to
	 * distribute binaries produced by compiling modified sources is granted,
	 * provided you
	 *   1. distribute the corresponding source modifications from the
	 *    released version in the form of a patch file along with the binaries,
	 *   2. add special version identification to distinguish your version
	 *    in addition to the base release version number,
	 *   3. provide your name and address as the primary contact for the
	 *    support of your modified version, and
	 *   4. retain our contact information in regard to use of the base
	 *    software.
	 * Permission to distribute the released version of the source code along
	 * with corresponding source modifications in the form of a patch file is
	 * granted with same provisions 2 through 4 for binary distributions.
	 *
	 * This software is provided "as is" without express or implied warranty
	 * to the extent permitted by applicable law.
	]*/


	/* some systems may not implement time very well ; in particular,
	 * things might break as the year 2000 approaches.
	 * This module either adds a routine gstrptime() to read a formatted time,
	 * augmenting the standard suite of time routines provided by ansi,
	 * or it completely replaces the whole lot with a new set of routines,
	 * which count time relative to the year 2000. Default is to use the
	 * new routines. define USE_SYSTEM_TIME to use the system routines, at your
	 * own risk. One problem in particular is that not all systems allow
	 * the time with integer value 0 to be represented symbolically, which
	 * prevents use of relative times.
	 */


	///#ifdef HAVE_CONFIG_H
	///#define EAM_OBJECTS 1
	///#define EXTERNAL_X11_WINDOW 1
	///#define GIF_ANIMATION 1
	///#define GNUPLOT_HISTORY 1
	///#define GP_FIT_ERRVARS 1
	///#define GP_MACROS 1
	///#define HAVE_ATEXIT 1
	///#define HAVE_BCOPY 1
	///#define HAVE_BZERO 1
	///#define HAVE_CAIROPDF 1
	///#define HAVE_DECL_SIGNGAM 1
	///#define HAVE_DIRENT_H 1
	///#define HAVE_ERF 1
	///#define HAVE_ERFC 1
	///#define HAVE_ERRNO_H 1
	///#define HAVE_FLOAT_H 1
	///#define HAVE_GAMMA 1
	///#define HAVE_GD_GIF 1
	///#define HAVE_GD_H 1
	///#define HAVE_GD_JPEG 1
	///#define HAVE_GD_PNG 1
	///#define HAVE_GD_TTF 1
	///#define HAVE_GETCWD 1
	///#define HAVE_INDEX 1
	///#define HAVE_INTTYPES_H 1
	///#define HAVE_ISNAN 1
	///#define HAVE_LGAMMA 1
	///#define HAVE_LIBGD 1
	///#define HAVE_LIBM 1
	///#define HAVE_LIBREADLINE 1
	///#define HAVE_LIBZ 1
	///#define HAVE_LIMITS_H 1
	///#define HAVE_LOCALE_H 1
	///#define HAVE_MALLOC_H 1
	///#define HAVE_MATH_H 1
	///#define HAVE_MEMCPY 1
	///#define HAVE_MEMMOVE 1
	///#define HAVE_MEMORY_H 1
	///#define HAVE_MEMSET 1
	///#define HAVE_ON_EXIT 1
	///#define HAVE_PCLOSE 1
	///#define HAVE_POLL 1
	///#define HAVE_POLL_H 1
	///#define HAVE_POPEN 1
	///#define HAVE_READLINE_HISTORY_H 1
	///#define HAVE_READLINE_READLINE_H 1
	///#define HAVE_READLINE_TILDE_H 1
	///#define HAVE_RINDEX 1
	///#define HAVE_SELECT 1
	///#define HAVE_SETVBUF 1
	///#define HAVE_SGTTY_H 1
	///#define HAVE_SIGSETJMP 1
	///#define HAVE_SLEEP 1
	///#define HAVE_SNPRINTF 1
	///#define HAVE_STDBOOL_H 1
	///#define HAVE_STDINT_H 1
	///#define HAVE_STDLIB_H 1
	///#define HAVE_STPCPY 1
	///#define HAVE_STRCASECMP 1
	///#define HAVE_STRCHR 1
	///#define HAVE_STRCSPN 1
	///#define HAVE_STRDUP 1
	///#define HAVE_STRERROR 1
	///#define HAVE_STRINGIZE 1
	///#define HAVE_STRINGS_H 1
	///#define HAVE_STRING_H 1
	///#define HAVE_STRNCASECMP 1
	///#define HAVE_STRRCHR 1
	///#define HAVE_STRSTR 1
	///#define HAVE_STRUCT_EXCEPTION_IN_MATH_H 1
	///#define HAVE_SYSINFO 1
	///#define HAVE_SYS_IOCTL_H 1
	///#define HAVE_SYS_PARAM_H 1
	///#define HAVE_SYS_SELECT_H 1
	///#define HAVE_SYS_SOCKET_H 1
	///#define HAVE_SYS_STAT_H 1
	///#define HAVE_SYS_TIMEB_H 1
	///#define HAVE_SYS_TIME_H 1
	///#define HAVE_SYS_TYPES_H 1
	///#define HAVE_SYS_UTSNAME_H 1
	///#define HAVE_TCGETATTR 1
	///#define HAVE_TERMIOS_H 1
	///#define HAVE_TIME_H 1
	///#define HAVE_TIME_T_IN_TIME_H 1
	///#define HAVE_UNISTD_H 1
	///#define HAVE_USLEEP 1
	///#define HAVE_VALUES_H 1
	///#define HAVE_VFPRINTF 1
	///#define HAVE__BOOL 1
	///#define HIDDEN3D_QUADTREE 1
	///#define HIDDEN3D_VAR_PTSIZE 1
	///#define PACKAGE "gnuplot"
	///#define PACKAGE_BUGREPORT ""
	///#define PACKAGE_NAME "gnuplot"
	///#define PACKAGE_STRING "gnuplot 4.4.0"
	///#define PACKAGE_TARNAME "gnuplot"
	///#define PACKAGE_URL ""
	///#define PACKAGE_VERSION "4.4.0"
	///#define PIPES 1
	///#define PIPE_IPC 1
	///#define PROTOTYPES 1
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RETSIGTYPE void
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG1 int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG234 (fd_set *)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SELECT_TYPE_ARG5 (struct timeval *)
	///#define STDC_HEADERS 1
	///#define USE_MOUSE 1
	///#define USE_X11_MULTIBYTE 1
	///#define VERSION "4.4.0"
	///#define VOLATILE_REFRESH 1
	///#define X11 1
	///#define __PROTOTYPES 1
	///#ifndef __cplusplus
	///#endif
	///#endif
	///#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5) || defined(__amigaos__)
	///#ifndef __amigaos__
	///#define OS "Amiga"
	///#define HELPFILE "S:gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define SHELL    "NewShell"
	///#define DIRSEP2  ':'
	///#define PATHSEP  ';'
	///#endif
	///#ifndef AMIGA
	///#define AMIGA
	///#endif
	///#ifdef AMIGA_SC_6_1
	///#define S_IFIFO S_IREAD
	///#endif
	///#endif // Amiga 
	///#ifdef DOS386
	///#define OS       "DOS 386"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#endif // DOS386 
	///#if defined(__NeXT__) || defined(NEXT)
	///#ifndef NEXT
	///#define NEXT
	///#endif
	///#endif // NeXT 
	///#ifdef OS2
	///#define OS       "OS/2"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "c:\\os2\\cmd.exe"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // OS/2 
	///#ifdef OSK
	///#define OS    "OS-9"
	///#define SHELL "/dd/cmds/shell"
	///#endif // OS-9 
	///#if defined(vms) || defined(VMS)
	///#define OS "VMS"
	///#ifndef VMS
	///#define VMS
	///#endif
	///#define HOME   "sys$login:"
	///#define PLOTRC "gnuplot.ini"
	///#ifdef NO_GIH
	///#define HELPFILE "GNUPLOT$HELP"
	///#endif
	///#if !defined(VAXCRTL) && !defined(DECCRTL)
	///#define VAXCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#define DECCRTL VAXCRTL_AND_DECCRTL_UNDEFINED
	///#endif
	///#ifdef __DECC
	///#include <starlet.h>
	///#endif  // __DECC 
	///#endif // VMS 
	///#if defined(_WINDOWS) || defined(_Windows)
	///#ifndef _Windows
	///#define _Windows
	///#endif
	///#ifdef WIN32
	///#define OS "MS-Windows 32 bit"
	///#define far
	///#define S_IFIFO  _S_IFIFO
	///#else
	///#define OS "MS-Windows"
	///#ifndef WIN16
	///#define WIN16
	///#endif
	///#endif // WIN32 
	///#define HOME    "GNUPLOT"
	///#define PLOTRC  "gnuplot.ini"
	///#define SHELL   "\\command.com"
	///#define DIRSEP1 '\\'
	///#define PATHSEP ';'
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot_history"
	///#endif // _WINDOWS 
	///#if defined(MSDOS) && !defined(_Windows)
	///#if !defined(DOS32) && !defined(DOS16)
	///#define DOS16
	///#endif
	///#define OS       "MS-DOS"
	///#define HELPFILE "gnuplot.gih"
	///#define HOME     "GNUPLOT"
	///#define PLOTRC   "gnuplot.ini"
	///#define SHELL    "\\command.com"
	///#define DIRSEP1  '\\'
	///#define PATHSEP  ';'
	///#ifdef __DJGPP__
	///#define DIRSEP2 '/'
	///#endif
	///#define GNUPLOT_HISTORY_FILE "~\\gnuplot.his"
	///#endif // MSDOS 
	///#ifndef OS
	///#define OS "non-recognized OS"
	///#endif
	///#ifndef HELPFILE
	///#define HELPFILE "docs/gnuplot.gih"
	///#endif
	///#ifndef HOME
	///#define HOME "HOME"
	///#endif
	///#ifndef PLOTRC
	///#define PLOTRC ".gnuplot"
	///#endif
	///#ifndef SHELL
	///#define SHELL "/bin/sh"
	///#endif
	///#ifndef DIRSEP1
	///#define DIRSEP1 '/'
	///#endif
	///#ifndef DIRSEP2
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DIRSEP2 NUL
	///#endif
	///#ifndef PATHSEP
	///#define PATHSEP ':'
	///#endif
	///#ifdef PROTOTYPES
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PROTO(proto) proto
	///#else
	///#define __PROTO(proto) ()
	///#endif
	///#if defined(MSDOS) || defined(DOS386)
	///#ifdef DJGPP
	///#include <dos.h>
	///#include <dir.h>              // HBB: for setdisk() 
	///#else
	///#include <process.h>
	///#endif                         // !DJGPP 
	///#ifdef __ZTC__
	///#define HAVE_SLEEP 1
	///#define P_WAIT 0
	///#elif defined(__TURBOC__)
	///#include <dos.h>		// for sleep() prototype 
	///#ifndef _Windows
	///#define HAVE_SLEEP 1
	///#include <conio.h>
	///#include <dir.h>            // setdisk() 
	///#endif                       // _Windows 
	///#ifdef WIN32
	///#define HAVE_SLEEP 1
	///#endif
	///#else                         // must be MSC 
	///#if !defined(__EMX__) && !defined(DJGPP)
	///#ifdef __MSC__
	///#include <direct.h>        // for _chdrive() 
	///#endif                      // __MSC__ 
	///#endif                       // !__EMX__ && !DJGPP 
	///#endif                        // !ZTC 
	///#endif // MSDOS 
	///#ifdef __WATCOMC__
	///#include <direct.h>
	///#include <dos.h>
	///#define HAVE_GETCWD 1
	///#define GP_EXCEPTION_NAME _exception
	///#endif
	///#ifdef apollo
	///#ifndef APOLLO
	///#define APOLLO
	///#endif
	///#define GPR
	///#endif
	///#if defined(APOLLO) || defined(alliant)
	///#endif
	///#ifdef sequent
	///#endif
	///#ifdef unixpc
	///#ifndef UNIXPC
	///#define UNIXPC
	///#endif
	///#endif
	///#if (defined(__TURBOC__) && defined(MSDOS)) || defined(WIN16)
	///#define GPHUGE huge
	///#define GPFAR far
	///#else // not TurboC || WIN16 
	///#define GPHUGE
	///#define GPFAR
	///#endif // not TurboC || WIN16 
	///#if defined(DOS16) || defined(WIN16)
	///#define COORDVAL_FLOAT 1
	///#else
	///#endif
	///#ifdef DOS16
	///#define MAX_NUM_VAR	3
	///#else
	///#define MAX_NUM_VAR 12
	///#endif
	///#ifdef VMS
	///#define DEFAULT_COMMENTS_CHARS "#!"
	///#define is_system(c) ((c) == '$')
	///#define BACKUP_FILESYSTEM 1
	///#else // not VMS 
	///#define DEFAULT_COMMENTS_CHARS "#"
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define is_system(c) ((c) == '!')
	///#endif // not VMS 
	///#ifndef RETSIGTYPE
	///#define RETSIGTYPE void
	///#endif
	///#ifndef SIGFUNC_NO_INT_ARG
	///#else
	///#endif
	///#ifdef HAVE_SIGSETJMP
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SETJMP(env, save_signals) sigsetjmp(env, save_signals)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define LONGJMP(env, retval) siglongjmp(env, retval)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define JMP_BUF sigjmp_buf
	///#else
	///#define SETJMP(env, save_signals) setjmp(env)
	///#define LONGJMP(env, retval) longjmp(env, retval)
	///#define JMP_BUF jmp_buf
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define generic void
	///#ifndef SORTFUNC_ARGS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define SORTFUNC_ARGS const generic *
	///#endif
	///#ifdef HAVE_STRINGIZE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT(x,y) x##y
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CONCAT3(x,y,z) x##y##z
	///#else
	///#define CONCAT(x,y) x//
	///#define CONCAT3(x,y,z) x//
	///#endif
	///#if defined(_Windows) && !defined(WINDOWS_NO_GUI)
	///#include "win/wtext.h"
	///#endif
	///#ifndef GP_EXCEPTION_NAME
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_EXCEPTION_NAME exception
	///#endif
	///#ifndef GP_MATHERR
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_MATHERR matherr
	///#endif
	///#ifdef HAVE_STRUCT_EXCEPTION_IN_MATH_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define STRUCT_EXCEPTION_P_X struct GP_EXCEPTION_NAME *x
	///#else
	///#define STRUCT_EXCEPTION_P_X // nothing 
	///#endif
	///#ifndef GP_INLINE
	///#ifdef __GNUC__
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_INLINE __inline__
	///#else
	///#define GP_INLINE //nothing
	///#endif
	///#endif
	///#if HAVE_STDBOOL_H
	///#else
	///#if ! HAVE__BOOL
	///#ifdef __cplusplus
	///#else
	///#endif
	///#endif
	///#define bool _Bool
	///#define false 0
	///#define true 1
	///#define __bool_true_false_are_defined 1
	///#endif
	///#if defined(__SUNPRO_CC) && !defined(bool)
	///#define bool unsigned char
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TRUE true
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FALSE false
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define TBOOLEAN bool
	///#ifdef HAVE_STRING_H
	///#else
	///#include <strings.h>
	///#endif
	///#ifdef HAVE_BCOPY
	///#ifndef HAVE_MEMCPY
	///#define memcpy(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#ifndef HAVE_MEMMOVE
	///#define memmove(d,s,n) bcopy((s),(d),(n))
	///#endif
	///#else
	///#ifndef HAVE_MEMCPY
	///#endif
	///#endif // HAVE_BCOPY 
	///#ifndef HAVE_STRCHR
	///#ifdef strchr
	///#endif
	///#ifdef HAVE_INDEX
	///#define strchr index
	///#else
	///#endif
	///#ifdef strrchr
	///#endif
	///#ifdef HAVE_RINDEX
	///#define strrchr rindex
	///#endif
	///#endif
	///#ifndef HAVE_STRCSPN
	///#define strcspn gp_strcspn
	///#endif
	///#ifndef HAVE_STRSTR
	///#endif
	///#ifndef HAVE_STDLIB_H
	///#ifdef HAVE_MALLOC_H
	///#include <malloc.h>
	///#else
	///#endif // HAVE_MALLOC_H 
	///#else // HAVE_STDLIB_H 
	///#ifndef VMS
	///#ifndef EXIT_FAILURE
	///#define EXIT_FAILURE (1)
	///#endif
	///#ifndef EXIT_SUCCESS
	///#define EXIT_SUCCESS (0)
	///#endif
	///#else // VMS 
	///#ifdef VAXC            // replacement values suppress some messages 
	///#ifdef  EXIT_FAILURE
	///#endif
	///#ifdef  EXIT_SUCCESS
	///#endif
	///#endif // VAXC 
	///#ifndef  EXIT_FAILURE
	///#define EXIT_FAILURE  0x10000002
	///#endif
	///#ifndef  EXIT_SUCCESS
	///#define EXIT_SUCCESS  1
	///#endif
	///#endif // VMS 
	///#endif // HAVE_STDLIB_H 
	///#if defined(HAVE_VFPRINTF) || defined(HAVE_DOPRNT)
	///#ifdef STDC_HEADERS
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define VA_START(args, lastarg) va_start(args, lastarg)
	///#else
	///#include <varargs.h>
	///#define VA_START(args, lastarg) va_start(args)
	///#endif // !STDC_HEADERS 
	///#else // HAVE_VFPRINTF || HAVE_DOPRNT 
	///#define va_dcl char *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, char *a8
	///#endif // !(HAVE_VFPRINTF || HAVE_DOPRNT) 
	///#ifdef HAVE_UNISTD_H
	///#else
	///#ifdef HAVE_LIBC_H // NeXT uses libc instead of unistd 
	///#include <libc.h>
	///#endif
	///#endif // HAVE_UNISTD_H 
	///#ifdef HAVE_ERRNO_H
	///#endif
	///#ifdef EXTERN_ERRNO
	///#endif
	///#ifndef HAVE_STRERROR
	///#endif
	///#ifdef HAVE_SYS_TYPES_H
	///#endif
	///#ifdef HAVE_SYS_STAT_H
	///#if !S_IRUSR
	///#if S_IREAD
	///#define S_IRUSR S_IREAD
	///#else
	///#define S_IRUSR 00400
	///#endif
	///#endif
	///#if !S_IWUSR
	///#if S_IWRITE
	///#define S_IWUSR S_IWRITE
	///#else
	///#define S_IWUSR 00200
	///#endif
	///#endif
	///#if !S_IXUSR
	///#if S_IEXEC
	///#define S_IXUSR S_IEXEC
	///#else
	///#define S_IXUSR 00100
	///#endif
	///#endif
	///#ifdef STAT_MACROS_BROKEN
	///#endif // STAT_MACROS_BROKEN.  
	///#if !defined(S_ISBLK) && defined(S_IFBLK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
	///#endif
	///#if !defined(S_ISCHR) && defined(S_IFCHR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
	///#endif
	///#if !defined(S_ISDIR) && defined(S_IFDIR)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
	///#endif
	///#if !defined(S_ISREG) && defined(S_IFREG)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
	///#endif
	///#if !defined(S_ISFIFO) && defined(S_IFIFO)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
	///#endif
	///#if !defined(S_ISLNK) && defined(S_IFLNK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
	///#endif
	///#if !defined(S_ISSOCK) && defined(S_IFSOCK)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
	///#endif
	///#if !defined(S_ISMPB) && defined(S_IFMPB) // V7
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
	///#endif
	///#if !defined(S_ISNWK) && defined(S_IFNWK) // HP/UX
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
	///#endif
	///#endif // HAVE_SYS_STAT_H 
	///#ifdef HAVE_LIMITS_H
	///#else
	///#ifdef HAVE_VALUES_H
	///#include <values.h>
	///#endif // HAVE_VALUES_H 
	///#endif // HAVE_LIMITS_H 
	///#ifdef HAVE_TIME_H
	///#endif
	///#ifndef HAVE_TIME_T_IN_TIME_H
	///#define time_t long
	///#endif
	///#if defined(PIPES) && (defined(VMS) || (defined(OSK) && defined(_ANSI_EXT))) || defined(PIPES) && defined(AMIGA_SC_6_1)
	///#endif
	///#ifdef HAVE_FLOAT_H
	///#endif
	///#ifndef DBL_EPSILON
	///#define DBL_EPSILON 2.2204460492503131E-16
	///#endif
	///#ifdef HAVE_LOCALE_H
	///#endif
	///#ifdef HAVE_MATH_H
	///#endif
	///#ifndef M_PI
	///#define M_PI 3.14159265358979323846
	///#endif
	///#ifndef M_PI_2
	///#define M_PI_2 1.57079632679489661923
	///#endif
	///#ifndef M_LN10
	///#define M_LN10 2.3025850929940456840e0
	///#endif
	///#if defined(DBL_MIN_10_EXP)
	///#define E_MINEXP (DBL_MIN_10_EXP * M_LN10)
	///#endif
	///#if defined(DBL_MAX_10_EXP)
	///#define E_MAXEXP (DBL_MAX_10_EXP * M_LN10)
	///#endif
	///#ifndef HAVE_STRCASECMP
	///#ifdef HAVE_STRICMP
	///#define strcasecmp stricmp
	///#else
	///#define strcasecmp gp_stricmp
	///#endif
	///#endif
	///#ifndef HAVE_STRNCASECMP
	///#ifdef HAVE_STRNICMP
	///#define strncasecmp strnicmp
	///#else
	///#define strncasecmp gp_strnicmp
	///#endif
	///#endif
	///#ifndef GP_GETCWD
	///#if defined(HAVE_GETCWD)
	///#if defined(__EMX__)
	///#define GP_GETCWD(path,len) _getcwd2 (path, len)
	///#else
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_GETCWD(path,len) getcwd (path, len)
	///#endif // __EMX__ 
	///#else
	///#define GP_GETCWD(path,len) getwd (path)
	///#endif
	///#endif
	///#ifdef WIN32
	///#include <windows.h>
	///#endif
	///#if defined(HAVE_USLEEP)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_SLEEP(delay) usleep((unsigned int) ((delay)*1e6))
	///#elif defined(__EMX__)
	///#define GP_SLEEP(delay) _sleep2((unsigned int) ((delay)*1e3))
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#elif defined(WIN32)
	///#define GP_SLEEP(delay) win_sleep((DWORD) 1000*delay)
	///#ifndef HAVE_SLEEP
	///#define HAVE_SLEEP
	///#endif
	///#endif
	///#ifndef GP_SLEEP
	///#ifdef __ZTC__
	///#define GP_SLEEP(delay) usleep ((unsigned long) (delay+0.5))
	///#else
	///#define GP_SLEEP(delay) sleep ((unsigned int) (delay+0.5))
	///#endif
	///#endif
	///#ifdef HAVE_ATEXIT
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GP_ATEXIT(x) atexit((x))
	///#elif defined(HAVE_ON_EXIT)
	///#define GP_ATEXIT(x) on_exit((x),0)
	///#else
	///#define GP_ATEXIT(x) // you lose 
	///#endif
	///#define NUL ('\0')
	///#ifdef DEBUG
	///#define DEBUG_WHERE do { fprintf(stderr,"%s:%d ",__FILE__,__LINE__); } while (0)
	///#define FPRINTF(a) do { DEBUG_WHERE; fprintf a; } while (0)
	///#else
	///#define DEBUG_WHERE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FPRINTF(a)
	///#endif // DEBUG 
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define INT_STR_LEN (3*sizeof(int))
	///#if defined ( NEXT ) && NX_CURRENT_COMPILER_RELEASE<310
	///#if defined ( DBL_MAX)
	///#endif
	///#define DBL_MAX 1.7976931348623157e+308
	///#define HUGE    DBL_MAX
	///#define HUGE_VAL DBL_MAX
	///#endif // NEXT && NX_CURRENT_COMPILER_RELEASE<310 
	///#ifndef COORDVAL_FLOAT
	///#ifdef DBL_MAX
	///#define VERYLARGE (DBL_MAX/2-1)
	///#endif
	///#else // COORDVAL_FLOAT 
	///#ifdef FLT_MAX
	///#define VERYLARGE (FLT_MAX/2-1)
	///#endif
	///#endif // COORDVAL_FLOAT 
	///#ifndef VERYLARGE
	///#ifdef HUGE
	///#define VERYLARGE (HUGE/2-1)
	///#elif defined(HUGE_VAL)
	///#define VERYLARGE (HUGE_VAL/2-1)
	///#else
	///#define VERYLARGE (1e37)
	///#endif // HUGE 
	///#endif // VERYLARGE 
	///#ifdef HAVE_SYS_PARAM_H
	///#endif
	///#ifndef PATH_MAX
	///#ifndef MAXPATHLEN
	///#define PATH_MAX 1024
	///#else
	///#define PATH_MAX MAXPATHLEN
	///#endif
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PATH_CONCAT(path,file) { char *p = path; p += strlen(path); if (p!=path) p--; if (*p && (*p != DIRSEP1) && (*p != DIRSEP2)) { if (*p) p++; *p++ = DIRSEP1; *p = NUL; } strcat (path, file); }
	///#ifndef inrange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define inrange(z,min,max) (((min)<(max)) ? (((z)>=(min)) && ((z)<=(max))) : (((z)>=(max)) && ((z)<=(min))))
	///#endif
	///#ifndef cliptorange
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define cliptorange(z,min,max) do { if ((min) < (max)) { if ((z) > (max)) (z) = (max); else if ((z) < (min)) (z) = (min); } else { if ((z) > (min)) (z) = (min); else if ((z) < (max)) (z) = (max); } } while (0)
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMAX(a,b) ( (a) > (b) ? (a) : (b) )
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GPMIN(a,b) ( (a) < (b) ? (a) : (b) )
	///#ifndef HAVE_SLEEP
	///#endif
	///#define ZERO_YEAR 2000
	///#define JAN_FIRST_WDAY 6
	///#define SEC_OFFS_SYS 946684800.0
	///#define YEAR_SEC 31557600.0
	///#define MON_SEC 2629800.0
	///#define WEEK_SEC 604800.0
	///#define DAY_SEC 86400.0

	///#define MAX_ID_LEN 50
	///#define MAX_LINE_LEN 1024
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define DEG2RAD (M_PI / 180.0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_COLOR ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_R yhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_G xlow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_B xhigh
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_A ylow
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CRD_PTSIZE xlow
	///#if 0
	///#endif
	///#if defined(WIN16) || (defined(MSDOS) && defined(__TURBOC__))
	///#endif
	///#define NO_CARET (-1)
	///#define DATAFILE (-2)
	///#if 0 // UNUSED
	///#endif
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define isstringvalue(c_token) (isstring(c_token) || type_udv(c_token)==STRING)
	///#if defined(VA_START) && defined(STDC_HEADERS)
	///#else
	///#endif
	///#ifdef NORWEGIAN
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "Mai"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Okt"
	///#define AMON11 "Nov"
	///#define AMON12 "Des"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sxn"
	///#define ADAY1 "Man"
	///#define ADAY2 "Tir"
	///#define ADAY3 "Ons"
	///#define ADAY4 "Tor"
	///#define ADAY5 "Fre"
	///#define ADAY6 "Lxr"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#elif defined(HUNGARIAN)
	///#define AMON01 "jan"
	///#define AMON02 "febr"
	///#define AMON03 "m&aacute;rc"
	///#define AMON04 "&aacute;pr"
	///#define AMON05 "m&aacute;j"
	///#define AMON06 "j&uacute;n"
	///#define AMON07 "j&uacute;l"
	///#define AMON08 "aug"
	///#define AMON09 "szept"
	///#define AMON10 "okt"
	///#define AMON11 "nov"
	///#define AMON12 "dec"
	///#define FMON01 "janu&aacute;r"
	///#define FMON02 "febru&aacute;r"
	///#define FMON03 "m&aacute;rcius"
	///#define FMON04 "&aacute;prilis"
	///#define FMON05 "m&aacute;jus"
	///#define FMON06 "j&uacute;nius"
	///#define FMON07 "j&uacute;lius"
	///#define FMON08 "augusztus"
	///#define FMON09 "szeptember"
	///#define FMON10 "okt&oacute;ber"
	///#define FMON11 "november"
	///#define FMON12 "december"
	///#define ADAY0 "vas"
	///#define ADAY1 "h&eacute;t"
	///#define ADAY2 "kedd"
	///#define ADAY3 "sze"
	///#define ADAY4 "cs&uuml;t"
	///#define ADAY5 "p&eacute;n"
	///#define ADAY6 "szo"
	///#define FDAY0 "vas&aacute;rnap"
	///#define FDAY1 "h&eacute;tf&otilde;"
	///#define FDAY2 "kedd"
	///#define FDAY3 "szerda"
	///#define FDAY4 "cs&uacute;t&ouml;rt&ouml;k"
	///#define FDAY5 "p&eacute;ntek"
	///#define FDAY6 "szombat"
	///#else
	///#define AMON01 "Jan"
	///#define AMON02 "Feb"
	///#define AMON03 "Mar"
	///#define AMON04 "Apr"
	///#define AMON05 "May"
	///#define AMON06 "Jun"
	///#define AMON07 "Jul"
	///#define AMON08 "Aug"
	///#define AMON09 "Sep"
	///#define AMON10 "Oct"
	///#define AMON11 "Nov"
	///#define AMON12 "Dec"
	///#define FMON01 "January"
	///#define FMON02 "February"
	///#define FMON03 "March"
	///#define FMON04 "April"
	///#define FMON05 "May"
	///#define FMON06 "June"
	///#define FMON07 "July"
	///#define FMON08 "August"
	///#define FMON09 "September"
	///#define FMON10 "October"
	///#define FMON11 "November"
	///#define FMON12 "December"
	///#define ADAY0 "Sun"
	///#define ADAY1 "Mon"
	///#define ADAY2 "Tue"
	///#define ADAY3 "Wed"
	///#define ADAY4 "Thu"
	///#define ADAY5 "Fri"
	///#define ADAY6 "Sat"
	///#define FDAY0 "Sunday"
	///#define FDAY1 "Monday"
	///#define FDAY2 "Tuesday"
	///#define FDAY3 "Wednesday"
	///#define FDAY4 "Thursday"
	///#define FDAY5 "Friday"
	///#define FDAY6 "Saturday"
	///#endif // language 
	///#ifdef ACTION_NULL
	///#endif
	///#ifdef ACTION_INIT
	///#endif
	///#ifdef ACTION_SHOW
	///#endif
	///#ifdef ACTION_SET
	///#endif
	///#ifdef ACTION_GET
	///#endif
	///#ifndef ACTION_SAVE
	///#endif
	///#ifdef ACTION_CLEAR
	///#endif
	///#define ACTION_NULL 0
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_INIT (1<<0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SHOW (1<<1)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SET (1<<2)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_GET (1<<3)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_SAVE (1<<4)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ACTION_CLEAR (1<<5)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_loadpath() loadpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_loadpath(path) loadpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_loadpath() loadpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_loadpath() loadpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_loadpath() loadpath_handler(ACTION_CLEAR,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_fontpath() fontpath_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_fontpath(path) fontpath_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_fontpath() fontpath_handler(ACTION_GET,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define save_fontpath() fontpath_handler(ACTION_SAVE,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define clear_fontpath() fontpath_handler(ACTION_CLEAR,NULL)
	///#define INITIAL_LOCALE ("C")
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define init_locale() locale_handler(ACTION_INIT,NULL)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_var_locale(path) locale_handler(ACTION_SET,(path))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_time_locale() locale_handler(ACTION_GET,NULL)
	///#ifdef HAVE_LOCALE_H
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define set_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,numeric_locale);} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define reset_numeric_locale() do {if (numeric_locale && strcmp(numeric_locale,"C")) setlocale(LC_NUMERIC,"C");} while (0)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define get_decimal_locale() (localeconv()->decimal_point)
	///#else
	///#define set_numeric_locale()
	///#define reset_numeric_locale()
	///#define get_decimal_locale() "."
	///#endif

	/* build as a standalone test */

	///#ifdef TEST_TIME
	//
	///#ifdef HAVE_SYS_TIMEB_H
	///#include <sys/timeb.h>
	///#else
	// /* declare struct timeb */
	//extern int ftime(struct timeb *);
	///#endif				// !HAVE_SYS_TIMEB_H 
	//
	///#define int_error(x,y) fprintf(stderr, "Error: " y "\n")
	///#define int_warn(x,y) fprintf(stderr, "Warn: " y "\n")
	//
	// /* need (only) these from plot.h */
	///#define ZERO_YEAR	2000
	// /* 1st jan, 2000 is a Saturday (cal 1 2000 on unix) */
	///#define JAN_FIRST_WDAY 6
	//
	// /*  zero gnuplot (2000) - zero system (1970) */
	///#define SEC_OFFS_SYS	946684800.0
	//
	// /* avg, incl. leap year */
	///#define YEAR_SEC	31557600.0
	//
	// /* YEAR_SEC / 12 */
	///#define MON_SEC		2629800.0
	//
	///#define WEEK_SEC	604800.0
	///#define DAY_SEC		86400.0
	//
	// /* HBB 990826: moved definitions up here, to avoid 'extern' where
	//  * it is neither wanted nor needed */
	//char *abbrev_month_names[] =
	//{ "jan", "feb", "mar", "apr", "may", "jun", "jul",
	//  "aug", "sep", "oct", "nov", "dec"
	//};
	//
	//char *full_month_names[] =
	//{ "January", "February", "March", "April", "May",
	//  "June", "July", "August", "September", "October",
	//  "November", "December"
	//};
	//
	//char *abbrev_day_names[] =
	//{ "sun", "mon", "tue", "wed", "thu", "fri", "sat"};
	//
	//char *full_day_names[] =
	//{ "Sunday", "Monday", "Tuesday", "Wednesday",
	//  "Thursday", "Friday", "Saturday"
	//};
	//
	///#else // TEST_TIME 

	/*  # include "setshow.h" */			/* for month names etc */

	///#endif // TEST_TIME 

	public static String read_int(String s, int nr, int d)
	{
		int result = 0;

		while (--nr >= 0 && s.compareTo('0') >= 0 && s.compareTo('9') <= 0)
		result = result * 10 + (s++ - '0');

		d = result;
		return (s);
	}

/* days in year */



	///#ifndef USE_SYSTEM_TIME

	/* a new set of routines to completely replace the ansi ones
	 * Use at your own risk
	 */

	public static int gdysize(int yr)
	{

		if (!(yr % 4))
		{
		if ((!(yr % 100)) && yr % 400)
			return (365);
		return (366);
		}
		return (365);
	}

	public static int[] mndday = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

	public static int xstrftime(String str, int bsz, String fmt, tm tm)
	{
		int l = 0; // chars written so far

//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * s = str;

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
		memset(s, '\0', bsz);

		while (!fmt.equals('\0'))
		{
		if (!fmt.equals('%'))
		{
			if (l >= bsz)
			return (0);
			*s++= fmt++;
			l++;
		}
		else
		{
			/* set up format modifiers */
			int w = 0;
			int z = 0;

			if (*++fmt == '0')
			{
			z = 1;
			++fmt;
			}
			while (fmt.compareTo('0') >= 0 && fmt.compareTo('9') <= 0)
			{
			w = w * 10 + (fmt - '0');
			++fmt;
			}

			switch (fmt++)
			{

			/* some shorthands : check that there is space in the
			 * output string. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define CHECK_SPACE(n) do { if ((l+(n)) > bsz) return 0; } while (0)

			/* copy a fixed string, checking that there's room */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define COPY_STRING(z) do { do { if ((l+(strlen(z))) > bsz) return 0; } while (0) ; strcpy(s, z); } while (0)

			/* format a string, using default spec if none given w
			 * and z are width and zero-flag dw and dz are the
			 * defaults for these In fact, CHECK_SPACE(w) is not a
			 * sufficient test, since sprintf("%2d", 365) outputs
			 * three characters
			 */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define FORMAT_STRING(dz, dw, x) do { if (w==0) { w=(dw); if (!z) z=(dz); } do { if ((l+(w)) > bsz) return 0; } while (0); sprintf(s, z ? "%0*d" : "%*d", w, (x)); } while(0)

			case '%':
			do
			{
				if ((l + (1)) > bsz)
					return 0;
			} while (0);
			*s = (byte)'%';
			break;

			case 'a':
			do
			{
				do
				{
					if ((l + (String.valueOf(GlobalMembersVariable.abbrev_day_names[tm.tm_wday]).length())) > bsz)
						return 0;
				} while (0);
				s = GlobalMembersVariable.abbrev_day_names[tm.tm_wday];
			} while (0);
			break;

			case 'A':
			do
			{
				do
				{
					if ((l + (String.valueOf(GlobalMembersVariable.full_day_names[tm.tm_wday]).length())) > bsz)
						return 0;
				} while (0);
				s = GlobalMembersVariable.full_day_names[tm.tm_wday];
			} while (0);
			break;

			case 'b':
			case 'h':
			do
			{
				do
				{
					if ((l + (String.valueOf(GlobalMembersVariable.abbrev_month_names[tm.tm_mon]).length())) > bsz)
						return 0;
				} while (0);
				s = GlobalMembersVariable.abbrev_month_names[tm.tm_mon];
			} while (0);
			break;

			case 'B':
			do
			{
				do
				{
					if ((l + (String.valueOf(GlobalMembersVariable.full_month_names[tm.tm_mon]).length())) > bsz)
						return 0;
				} while (0);
				s = GlobalMembersVariable.full_month_names[tm.tm_mon];
			} while (0);
			break;


	///#if 0
	//// /* %x not currently supported, so neither is c */
	////	    case 'c':
	////		if (!xstrftime(s, bsz - l, "%x %X", tm))
	////		    return (0);
	////		break;
	///#endif

			case 'd':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_mday));
			} while (0);
			break;

			case 'D':
			if (GlobalMembersTime.xstrftime(s, bsz - l, "%m/%d/%y", tm) == 0)
				return (0);
			break;

			case 'F':
			if (GlobalMembersTime.xstrftime(s, bsz - l, "%Y-%m-%d", tm) == 0)
				return (0);
			break;

			case 'H':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_hour));
			} while (0);
			break;

			case 'I':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, ((tm.tm_hour + 11) % 12 + 1));
			} while (0);
			break;

			case 'j':
			do
			{
				if (w == 0)
				{
					w = (3);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_yday + 1));
			} while (0);
			break;

			/* not in linux strftime man page. Not really needed now */
			case 'k':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (0);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_hour));
			} while (0);
			break;

			case 'l':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (0);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, ((tm.tm_hour + 11) % 12 + 1));
			} while (0);
			break;

			case 'm':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_mon + 1));
			} while (0);
			break;

			case 'M':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_min));
			} while (0);
			break;

			case 'p':
			do
			{
				if ((l + (2)) > bsz)
					return 0;
			} while (0);
			s = (tm.tm_hour < 12) ? "am" : "pm";
			break;

			case 'r':
			if (GlobalMembersTime.xstrftime(s, bsz - l, "%I:%M:%S %p", tm) == 0)
				return (0);
			break;

			case 'R':
			if (GlobalMembersTime.xstrftime(s, bsz - l, "%H:%M", tm) == 0)
				return (0);
			break;

			case 'S':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_sec));
			} while (0);
			break;

			case 'T':
			if (GlobalMembersTime.xstrftime(s, bsz - l, "%H:%M:%S", tm) == 0)
				return (0);
			break;

			case 'W': // mon 1 day of week
			{
				int week;
				if (tm.tm_yday <= tm.tm_wday)
				{
				week = 1;

				if ((tm.tm_mday - tm.tm_yday) > 4)
				{
					week = 52;
				}
				if (tm.tm_yday == tm.tm_wday && tm.tm_wday == 0)
					week = 52;

				}
				else
				{

				/* sun prev week */
				int bw = tm.tm_yday - tm.tm_wday;

				if (tm.tm_wday > 0)
					bw += 7; // sun end of week

				week = (int) bw / 7;

				if ((bw % 7) > 2) // jan 1 is before friday
					week++;
				}
				do
				{
					if (w == 0)
					{
						w = (2);
						if (z == 0)
							z = (1);
					}
					do
					{
						if ((l + (w)) > bsz)
							return 0;
					} while (0);
					String.format(s, z != 0 ? "%0*d" : "%*d", w, (week));
				} while (0);
				break;
			}

			case 'U': // sun 1 day of week
			{
				int week;
				int bw;

				if (tm.tm_yday <= tm.tm_wday)
				{
				week = 1;
				if ((tm.tm_mday - tm.tm_yday) > 4)
				{
					week = 52;
				}
				}
				else
				{
				/* sat prev week */
				bw = tm.tm_yday - tm.tm_wday - 1;
				if (tm.tm_wday >= 0)
					bw += 7; // sat end of week
				week = (int) bw / 7;
				if ((bw % 7) > 1) // jan 1 is before friday
				{
					week++;
				}
				}
				do
				{
					if (w == 0)
					{
						w = (2);
						if (z == 0)
							z = (1);
					}
					do
					{
						if ((l + (w)) > bsz)
							return 0;
					} while (0);
					String.format(s, z != 0 ? "%0*d" : "%*d", w, (week));
				} while (0);
				break;
			}

			case 'w': // day of week, sun=0
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_wday));
			} while (0);
			break;

			case 'y':
			do
			{
				if (w == 0)
				{
					w = (2);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_year % 100));
			} while (0);
			break;

			case 'Y':
			do
			{
				if (w == 0)
				{
					w = (4);
					if (z == 0)
						z = (1);
				}
				do
				{
					if ((l + (w)) > bsz)
						return 0;
				} while (0);
				String.format(s, z != 0 ? "%0*d" : "%*d", w, (tm.tm_year));
			} while (0);
			break;

	///#if 0
	////	    case 'Z':
	////		COPY_STRING(tm->tm_zone);
	////		break;
	///#endif
			} // switch

			while (*s != '\0')
			{
			s++;
			l++;
			}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef CHECK_SPACE
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef COPY_STRING
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef FORMAT_STRING
		} // switch(fmt letter)
		} // if(fmt letter not '%')
		return (l);
	}


	/* new strptime() and gmtime() to allow time to be read as 24 hour,
	 * and spaces in the format string. time is converted to seconds from
	 * year 2000.... */

	public static String gstrptime(String s, String fmt, tm tm)
	{
		int yday;
		int date;

		date = yday = 0;
		tm.tm_mday = 1;
		tm.tm_mon = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
		/* make relative times work (user-defined tic step) */
		tm.tm_year = DefineConstants.ZERO_YEAR;

		/* we do not yet calculate wday or yday, so make them illegal
		 * [but yday will be read by %j]
		 */

		tm.tm_yday = tm.tm_wday = -1;

		while (fmt != null)
		{
		if (!fmt.equals('%'))
		{
			if (fmt.equals(' '))
			{
			/* space in format means zero or more spaces in input */
			while (s.equals(' '))
				++s;
			++fmt;
			continue;
			}
			else if (*s.equals(fmt))
			{
			++s;
			++fmt;
			continue;
			}
			else
			break; // literal match has failed
		}
		/* we are processing a percent escape */

		switch (*++fmt)
		{
		case 'b': // abbreviated month name
		{
			int m;

			for (m = 0; m < 12; ++m)
				if (strncasecmp(s, GlobalMembersVariable.abbrev_month_names[m], String.valueOf(GlobalMembersVariable.abbrev_month_names[m]).length()) == 0)
				{
				s += String.valueOf(GlobalMembersVariable.abbrev_month_names[m]).length();
//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
				goto found_abbrev_mon;
				}
			/* get here => not found */
			GlobalMembersUtil.int_warn(DefineConstants.DATAFILE, "Bad abbreviated month name");
			m = 0;
//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
			  found_abbrev_mon:
			tm.tm_mon = m;
			break;
		}

		case 'B': // full month name
		{
			int m;

			for (m = 0; m < 12; ++m)
				if (strncasecmp(s, GlobalMembersVariable.full_month_names[m], String.valueOf(GlobalMembersVariable.full_month_names[m]).length()) == 0)
				{
				s += String.valueOf(GlobalMembersVariable.full_month_names[m]).length();
//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
				goto found_full_mon;
				}
			/* get here => not found */
			GlobalMembersUtil.int_warn(DefineConstants.DATAFILE, "Bad full month name");
			m = 0;
//C++ TO JAVA CONVERTER TODO TASK: There are no gotos or labels in Java:
			  found_full_mon:
			tm.tm_mon = m;
			break;
		}

		case 'd': // read a day of month
			s = GlobalMembersTime.read_int(s, 2, tm.tm_mday);
			date++;
			break;

		case 'm': // month number
			s = GlobalMembersTime.read_int(s, 2, tm.tm_mon);
			date++;
			--tm.tm_mon;
			break;

		case 'y': // year number
			s = GlobalMembersTime.read_int(s, 2, tm.tm_year);
			/* In line with the current UNIX98 specification by
			 * The Open Group and major Unix vendors,
			 * two-digit years 69-99 refer to the 20th century, and
			 * values in the range 00-68 refer to the 21st century.
			 */
			if (tm.tm_year <= 68)
			tm.tm_year += 100;
			date++;
			tm.tm_year += 1900;
			break;

		case 'Y':
			s = GlobalMembersTime.read_int(s, 4, tm.tm_year);
			date++;
			break;

		case 'j':
			s = GlobalMembersTime.read_int(s, 3, tm.tm_yday);
			tm.tm_yday--;
			date++;
			yday++;
			break;

		case 'H':
			s = GlobalMembersTime.read_int(s, 2, tm.tm_hour);
			break;

		case 'M':
			s = GlobalMembersTime.read_int(s, 2, tm.tm_min);
			break;

		case 'S':
			s = GlobalMembersTime.read_int(s, 2, tm.tm_sec);
			break;

		/* read EPOCH data
		 * EPOCH is the std. unixtimeformat seconds since 01.01.1970 UTC
		 * actualy i would need a read_long (or what time_t is else)
		 *  aktualy this is not my idea       i got if from
		 * AlunDa Penguin Jones (21.11.97)
		 * but changed %t to %s because of strftime
		 * and fixed the localtime() into gmtime()
		 * maybe we should use ggmtime() ? but who choose double ????
		 * Walter Harms <WHarms@bfs.de> 26 Mar 2000
		 */

		case 's':
	///#if 0 // HBB 20040213: comment this out, but keep it around for now
	////	    {
	//// /* time_t when; */
	////		int when;
	////		struct tm *tmwhen;
	////		s = read_int(s, 10, &when);
	////		tmwhen = gmtime((time_t*)&when);
	////		tmwhen->tm_year += 1900;
	////		*tm = *tmwhen;
	////		break;
	////	    }
	///#else
			/* HBB 20040213: New version of this.  64-bit proof and
			 * more in line with the rest of this module than the
			 * original one. */
		{
			double when;
			/* offset from UNIX epoch (1970) to gnuplot epoch */
			final int epoch_offset = (int)((DefineConstants.ZERO_YEAR - 1970) * 365.25) * DefineConstants.DAY_SEC;

			when = strtod(s, s) - epoch_offset;
			GlobalMembersTime.ggmtime(tm, when);
			break;
		}
	///#endif
		default:
			GlobalMembersUtil.int_warn(DefineConstants.DATAFILE, "Bad time format in string");
		}
		fmt++;
		}

		GlobalMembersFit.a((stderr, "read date-time : %02d/%02d/%d:%02d:%02d:%02d\n", tm.tm_mday, tm.tm_mon + 1, tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec));

		/* now check the date/time entered, normalising if necessary
		 * read_int cannot read a -ve number, but can read %m=0 then decrement
		 * it to -1
		 */

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define S (tm->tm_sec)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define M (tm->tm_min)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define H (tm->tm_hour)

		if (tm.tm_sec >= 60)
		{
		tm.tm_min += tm.tm_sec / 60;
		tm.tm_sec %= 60;
		}
		if (tm.tm_min >= 60)
		{
		tm.tm_hour += tm.tm_min / 60;
		tm.tm_min %= 60;
		}
		if (tm.tm_hour >= 24)
		{
		if (yday != 0)
			tm.tm_yday += tm.tm_hour / 24;
		tm.tm_mday += tm.tm_hour / 24;
		tm.tm_hour %= 24;
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef S
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef M
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef H

		GlobalMembersFit.a((stderr, "normalised time : %02d/%02d/%d:%02d:%02d:%02d\n", tm.tm_mday, tm.tm_mon + 1, tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec));

		if (date != 0)
		{
		if (yday != 0)
		{

			if (tm.tm_yday < 0)
			GlobalMembersBf_test.int_error(DefineConstants.DATAFILE, "Illegal day of year");

			/* we just set month to jan, day to yday, and let the
			 * normalising code do the work.
			 */

			tm.tm_mon = 0;
			/* yday is 0->365, day is 1->31 */
			tm.tm_mday = tm.tm_yday + 1;
		}
		if (tm.tm_mon < 0)
		{
			GlobalMembersBf_test.int_error(DefineConstants.DATAFILE, "illegal month");
			return (DefineConstants.NULL);
		}
		if (tm.tm_mday < 1)
		{
			GlobalMembersBf_test.int_error(DefineConstants.DATAFILE, "illegal day of month");
			return (DefineConstants.NULL);
		}
		if (tm.tm_mon > 11)
		{
			tm.tm_year += tm.tm_mon / 12;
			tm.tm_mon %= 12;
		}
		{
			int days_in_month;
			while (tm.tm_mday > (days_in_month = (mndday[tm.tm_mon] + (tm.tm_mon == 1 && (GlobalMembersTime.gdysize(tm.tm_year) > 365)))))
			{
			if (++tm.tm_mon == 12)
			{
				++tm.tm_year;
				tm.tm_mon = 0;
			}
			tm.tm_mday -= days_in_month;
			}
		}
		}
		return (s);
	}

	public static int gstrftime(String s, int bsz, String fmt, double l_clock)
	{
		tm tm = new tm();

		GlobalMembersTime.ggmtime(tm, l_clock);
	///#if 0
	////    if ((tm.tm_zone = (char *) malloc(strlen(xtm->tm_zone) + 1)))
	////	strcpy(tm.tm_zone, xtm->tm_zone);
	//// /* printf("zone: %s - %s\n",tm.tm_zone,xtm->tm_zone); */
	///#endif

		return GlobalMembersTime.xstrftime(s, bsz, fmt, tm);
	}



	/* time_t  */
	public static double gtimegm(tm tm)
	{
		int i;
		/* returns sec from year ZERO_YEAR, defined in plot.h */
		double dsec = 0.;

		if (tm.tm_year < DefineConstants.ZERO_YEAR)
		{
		for (i = tm.tm_year; i < DefineConstants.ZERO_YEAR; i++)
		{
			dsec -= (double) GlobalMembersTime.gdysize(i);
		}
		}
		else
		{
		for (i = DefineConstants.ZERO_YEAR; i < tm.tm_year; i++)
		{
			dsec += (double) GlobalMembersTime.gdysize(i);
		}
		}
		if (tm.tm_mday > 0)
		{
		for (i = 0; i < tm.tm_mon; i++)
		{
			dsec += (double) mndday[i] + (i == 1 && (GlobalMembersTime.gdysize(tm.tm_year) > 365));
		}
		dsec += (double) tm.tm_mday - 1;
		}
		else
		{
		dsec += (double) tm.tm_yday;
		}
		dsec *= (double) 24;

		dsec += tm.tm_hour;
		dsec *= 60.0;
		dsec += tm.tm_min;
		dsec *= 60.0;
		dsec += tm.tm_sec;

		GlobalMembersFit.a((stderr, "broken-down time : %02d/%02d/%d:%02d:%02d:%02d = %g seconds\n", tm.tm_mday, tm.tm_mon + 1, tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec, dsec));

		return (dsec);
	}

	public static int ggmtime(tm tm, double l_clock)
	{
		/* l_clock is relative to ZERO_YEAR, jan 1, 00:00:00,defined in plot.h */
		int i;
		int days;

		/* dodgy way of doing wday - i hope it works ! */
		int wday = DefineConstants.JAN_FIRST_WDAY; // eg 6 for 2000

		GlobalMembersFit.a((stderr, "%g seconds = ", l_clock));
		if (Math.abs(l_clock) > 1.e12) // Some time in the year 33688
		{
		GlobalMembersUtil.int_warn(DefineConstants.NO_CARET, "time value out of range");
		return (-1);
		}

		tm.tm_year = DefineConstants.ZERO_YEAR;
		tm.tm_mday = tm.tm_yday = tm.tm_mon = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
		if (l_clock < 0)
		{
		while (l_clock < 0)
		{
			int days_in_year = GlobalMembersTime.gdysize(--tm.tm_year);
			l_clock += days_in_year * DefineConstants.DAY_SEC; // 24*3600
			/* adding 371 is noop in modulo 7 arithmetic, but keeps wday +ve */
			wday += 371 - days_in_year;
		}
		}
		else
		{
		for (;;)
		{
			int days_in_year = GlobalMembersTime.gdysize(tm.tm_year);
			if (l_clock < days_in_year * DefineConstants.DAY_SEC)
			break;
			l_clock -= days_in_year * DefineConstants.DAY_SEC;
			tm.tm_year++;
			/* only interested in result modulo 7, but %7 is expensive */
			wday += (days_in_year - 364);
		}
		}
		tm.tm_yday = (int)(l_clock / DefineConstants.DAY_SEC);
		l_clock -= tm.tm_yday * DefineConstants.DAY_SEC;
		tm.tm_hour = (int) l_clock / 3600;
		l_clock -= tm.tm_hour * 3600;
		tm.tm_min = (int) l_clock / 60;
		l_clock -= tm.tm_min * 60;
		tm.tm_sec = (int) l_clock;

		days = tm.tm_yday;

		/* wday%7 should be day of week of first day of year */
		tm.tm_wday = (wday + days) % 7;

		while (days >= (i = mndday[tm.tm_mon] + (tm.tm_mon == 1 && (GlobalMembersTime.gdysize(tm.tm_year) > 365))))
		{
		days -= i;
		tm.tm_mon++;
		}
		tm.tm_mday = days + 1;

		GlobalMembersFit.a((stderr, "broken-down time : %02d/%02d/%d:%02d:%02d:%02d\n", tm.tm_mday, tm.tm_mon + 1, tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec));

		return (0);
	}
	///#endif // USE_SYSTEM_TIME 
}
///#else // USE_SYSTEM_TIME 
//
// /* define gnu time routines in terms of system time routines */
//
//size_t
//gstrftime(char *buf, size_t bufsz, const char *fmt, double l_clock)
//{
//    time_t t = (time_t) l_clock;
//    return strftime(buf, bufsz, fmt, gmtime(&t));
//}
//
//double
//gtimegm(struct tm *tm)
//{
//    return (double) mktime(tm);
//}
//
//int
//ggmtime(struct tm *tm, double l_clock)
//{
//    time_t t = (time_t) l_clock;
//    struct tm *m = gmtime(&t);
//    *tm = *m;			// can any non-ansi compilers not do this ? 
//    return 0;
//}
//
// /* supplemental routine gstrptime() to read a formatted time */
//
//char *
//gstrptime(char *s, char *fmt, struct tm *tm)
//{
//    FPRINTF((stderr, "gstrptime(\"%s\", \"%s\")\n", s, fmt));
//
// /* linux does not appear to like years before 1902
//  * NT complains if its before 1970
//  * initialise fields to midnight, 1st Jan, 1970 (for relative times)
//  */
//    tm->tm_sec = tm->tm_min = tm->tm_hour = 0;
//    tm->tm_mday = 1;
//    tm->tm_mon = 0;
//    tm->tm_year = 70;
// /* oops - it goes wrong without this */
//    tm->tm_isdst = 0;
//
//    for (; *fmt && *s; ++fmt) {
//	if (*fmt != '%') {
//	    if (*s != *fmt)
//		return s;
//	    ++s;
//	    continue;
//	}
//	assert(*fmt == '%');
//
//	switch (*++fmt) {
//	case 0:
// /* uh oh - % is last character in format */
//	    return s;
//	case '%':
// /* literal % */
//	    if (*s++ != '%')
//		return s - 1;
//	    continue;
//
///#define NOTHING	// nothing 
///#define LETTER(L, width, field, extra)			case L:						    s=read_int(s,width,&tm->field);		    extra;					    continue;
//ignore
//ignore
//ignore
//ignore
//
//	    LETTER('d', 2, tm_mday, NOTHING);
//	    LETTER('m', 2, tm_mon, NOTHING);
//	    LETTER('y', 2, tm_year, NOTHING);
//	    LETTER('Y', 4, tm_year, tm->tm_year -= 1900);
//	    LETTER('H', 2, tm_hour, NOTHING);
//	    LETTER('M', 2, tm_min, NOTHING);
//	    LETTER('S', 2, tm_sec, NOTHING);
///#undef NOTHING
///#undef LETTER
//
//	default:
//	    int_error(DATAFILE, "incorrect time format character");
//	}
//    }
//
//    FPRINTF((stderr, "Before mktime : %d/%d/%d:%d:%d:%d\n", tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_hour, tm->tm_min, tm->tm_sec));
// /* mktime range-checks the time */
//
//    if (mktime(tm) == -1) {
//	FPRINTF((stderr, "mktime() was not happy\n"));
//	int_error(DATAFILE, "Invalid date/time [mktime() did not like it]");
//    }
//    FPRINTF((stderr, "After mktime : %d/%d/%d:%d:%d:%d\n", tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_hour, tm->tm_min, tm->tm_sec));
//
//    return s;
//}
//
//


///#ifdef TEST_TIME
//
// /* either print current time using supplied format, or read
//  * supplied time using supplied format
//  */
//
//
//int
//main(int argc, char *argv[])
//{
//    char output[80];
//
//    if (argc < 2) {
//	fputs("usage : test 'format' ['time']\n", stderr);
//	exit(EXIT_FAILURE);
//    }
//    if (argc == 2) {
//	struct timeb now;
//	struct tm *tm;
//	ftime(&now);
//	tm = gmtime(&now.time);
//	xstrftime(output, 80, argv[1], tm);
//	puts(output);
//    } else {
//	struct tm tm;
//	gstrptime(argv[2], argv[1], &tm);
//	puts(asctime(&tm));
//    }
//    exit(EXIT_SUCCESS);
//}
//
///#endif // TEST_TIME 
