package com.addiPlot.gnuplot;

public class GlobalMembersGplt_x11
{
	///#define __STDC__ 1
	///#define __STDC_HOSTED__ 1
	///#define __GNUC__ 4
	///#define __GNUC_MINOR__ 3
	///#define __GNUC_PATCHLEVEL__ 6
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __SIZE_TYPE__ long unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __PTRDIFF_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WCHAR_TYPE__ int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __WINT_TYPE__ unsigned int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __INTMAX_TYPE__ long int
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __UINTMAX_TYPE__ long unsigned int
	///#define __GXX_ABI_VERSION 1002
	///#define __SCHAR_MAX__ 127
	///#define __SHRT_MAX__ 32767
	///#define __INT_MAX__ 2147483647
	///#define __LONG_MAX__ 9223372036854775807L
	///#define __LONG_LONG_MAX__ 9223372036854775807LL
	///#define __WCHAR_MAX__ 2147483647
	///#define __CHAR_BIT__ 8
	///#define __INTMAX_MAX__ 9223372036854775807L
	///#define __FLT_EVAL_METHOD__ 0
	///#define __DEC_EVAL_METHOD__ 2
	///#define __FLT_RADIX__ 2
	///#define __FLT_MANT_DIG__ 24
	///#define __FLT_DIG__ 6
	///#define __FLT_MIN_EXP__ (-125)
	///#define __FLT_MIN_10_EXP__ (-37)
	///#define __FLT_MAX_EXP__ 128
	///#define __FLT_MAX_10_EXP__ 38
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MAX__ 3.40282347e+38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_MIN__ 1.17549435e-38F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_EPSILON__ 1.19209290e-7F
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __FLT_DENORM_MIN__ 1.40129846e-45F
	///#define __FLT_HAS_DENORM__ 1
	///#define __FLT_HAS_INFINITY__ 1
	///#define __FLT_HAS_QUIET_NAN__ 1
	///#define __DBL_MANT_DIG__ 53
	///#define __DBL_DIG__ 15
	///#define __DBL_MIN_EXP__ (-1021)
	///#define __DBL_MIN_10_EXP__ (-307)
	///#define __DBL_MAX_EXP__ 1024
	///#define __DBL_MAX_10_EXP__ 308
	///#define __DBL_MAX__ 1.7976931348623157e+308
	///#define __DBL_MIN__ 2.2250738585072014e-308
	///#define __DBL_EPSILON__ 2.2204460492503131e-16
	///#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
	///#define __DBL_HAS_DENORM__ 1
	///#define __DBL_HAS_INFINITY__ 1
	///#define __DBL_HAS_QUIET_NAN__ 1
	///#define __LDBL_MANT_DIG__ 64
	///#define __LDBL_DIG__ 18
	///#define __LDBL_MIN_EXP__ (-16381)
	///#define __LDBL_MIN_10_EXP__ (-4931)
	///#define __LDBL_MAX_EXP__ 16384
	///#define __LDBL_MAX_10_EXP__ 4932
	///#define __DECIMAL_DIG__ 21
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MAX__ 1.18973149535723176502e+4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_MIN__ 3.36210314311209350626e-4932L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
	///#define __LDBL_HAS_DENORM__ 1
	///#define __LDBL_HAS_INFINITY__ 1
	///#define __LDBL_HAS_QUIET_NAN__ 1
	///#define __DEC32_MANT_DIG__ 7
	///#define __DEC32_MIN_EXP__ (-95)
	///#define __DEC32_MAX_EXP__ 96
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MIN__ 1E-95DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_MAX__ 9.999999E96DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_EPSILON__ 1E-6DF
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC32_DEN__ 0.000001E-95DF
	///#define __DEC64_MANT_DIG__ 16
	///#define __DEC64_MIN_EXP__ (-383)
	///#define __DEC64_MAX_EXP__ 384
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MIN__ 1E-383DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_MAX__ 9.999999999999999E384DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_EPSILON__ 1E-15DD
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC64_DEN__ 0.000000000000001E-383DD
	///#define __DEC128_MANT_DIG__ 34
	///#define __DEC128_MIN_EXP__ (-6143)
	///#define __DEC128_MAX_EXP__ 6144
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MIN__ 1E-6143DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_EPSILON__ 1E-33DL
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define __DEC128_DEN__ 0.000000000000000000000000000000001E-6143DL
	///#define __REGISTER_PREFIX__
	///#define __USER_LABEL_PREFIX__
	///#define __VERSION__ "4.3.6"
	///#define __GNUC_GNU_INLINE__ 1
	///#define _LP64 1
	///#define __LP64__ 1
	///#define __OPTIMIZE__ 1
	///#define __FINITE_MATH_ONLY__ 0
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
	///#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
	///#define __SIZEOF_INT__ 4
	///#define __SIZEOF_LONG__ 8
	///#define __SIZEOF_LONG_LONG__ 8
	///#define __SIZEOF_SHORT__ 2
	///#define __SIZEOF_FLOAT__ 4
	///#define __SIZEOF_DOUBLE__ 8
	///#define __SIZEOF_LONG_DOUBLE__ 16
	///#define __SIZEOF_SIZE_T__ 8
	///#define __SIZEOF_WCHAR_T__ 4
	///#define __SIZEOF_WINT_T__ 4
	///#define __SIZEOF_PTRDIFF_T__ 8
	///#define __SIZEOF_POINTER__ 8
	///#define __amd64 1
	///#define __amd64__ 1
	///#define __x86_64 1
	///#define __x86_64__ 1
	///#define __k8 1
	///#define __k8__ 1
	///#define __MMX__ 1
	///#define __SSE__ 1
	///#define __SSE2__ 1
	///#define __SSE_MATH__ 1
	///#define __SSE2_MATH__ 1
	///#define __gnu_linux__ 1
	///#define __linux 1
	///#define __linux__ 1
	///#define linux 1
	///#define __unix 1
	///#define __unix__ 1
	///#define unix 1
	///#define __ELF__ 1
	///#define __DECIMAL_BID_FORMAT__ 1
	///#define HAVE_CONFIG_H 1
	///#define BINDIR "/usr/local/bin"
	///#define X11_DRIVER_DIR "/usr/local/libexec/gnuplot/4.4"
	///#define GNUPLOT_PS_DIR "/usr/local/share/gnuplot/4.4/PostScript"
	///#define GNUPLOT_JS_DIR "/usr/local/share/gnuplot/4.4/js"
	///#define GNUPLOT_LUA_DIR "/usr/local/share/gnuplot/4.4/lua"
	///#define CONTACT "gnuplot-bugs@lists.sourceforge.net"
	///#define HELPFILE "/usr/local/share/gnuplot/4.4/gnuplot.gih"
	///#define GNUPLOT_X11 "gnuplot_x11"
	///#define XAPPLRESDIR "/etc/X11/app-defaults/"

	///#ifndef lint
	public static String RCSid()
	{
		return GlobalMembersAlloc.RCSid("$Id: gplt_x11.c,v 1.194.2.4 2010/03/10 00:15:57 sfeam Exp $");
	}
	///#endif

	/* always allocate a default colormap (done in preset()) */
	public static cmap_t default_cmap = new cmap_t();
///#endif


/*-----------------------------------------------------------------------------
 *   Add_Plot_To_Linked_List - Create space for plot and put in linked list.
 *---------------------------------------------------------------------------*/


	public static plot_struct Add_Plot_To_Linked_List(int plot_number)
	{
		plot_struct psp;
		if (plot_number >= 0)
		/* Make sure plot does not already exist in the list. */
		psp = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Number(plot_number);
		else
		psp = DefineConstants.NULL;

		if (psp == DefineConstants.NULL)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		psp = (plot_struct) malloc(sizeof(plot_struct));
		if (psp != null)
		{
			/* Initialize structure variables. */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memset((Object)psp, 0, sizeof(plot_struct));
			psp.plot_number = plot_number;
	///#if EXTERNAL_X11_WINDOW
			/* Number and container methods are mutually exclusive. */
			if (plot_number >= 0)
			psp.external_container = None;
	///#endif
			/* Add link to beginning of the list. */
			psp.prev_plot = DefineConstants.NULL;
			if (plot_list_start != DefineConstants.NULL)
			{
			plot_list_start.prev_plot = psp;
			psp.next_plot = plot_list_start;
			}
			else
			psp.next_plot = DefineConstants.NULL;
			plot_list_start = psp;
		}
		else
		{
			psp = DefineConstants.NULL;
			fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Could not allocate memory for plot.\n\n");
		}
		}

		return psp;
	}

/*-----------------------------------------------------------------------------
 *   Remove_Plot_From_Linked_List - Remove from linked list and free memory.
 *---------------------------------------------------------------------------*/

	public static void Remove_Plot_From_Linked_List(Window plot_window)
	{
		/* Make sure plot exists in the list. */
		plot_struct psp = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Window(plot_window);

		if (psp != DefineConstants.NULL)
		{
		/* Remove link from the list. */
		if (psp.next_plot != DefineConstants.NULL)
			psp.next_plot.prev_plot = psp.prev_plot;
		if (psp.prev_plot != DefineConstants.NULL)
		{
			psp.prev_plot.next_plot = psp.next_plot;
		}
		else
		{
			plot_list_start = psp.next_plot;
		}
		/* If global pointers point at this plot, reassign them. */
		if (current_plot == psp)
		{
	///#if 0 // Make some other plot current.
	////	    if (psp->prev_plot != NULL)
	////		current_plot = psp->prev_plot;
	////	    else
	////		current_plot = psp->next_plot;
	///#else // No current plot.
			current_plot = DefineConstants.NULL;
	///#endif
		}
		/* Deallocate memory.  Make sure plot removed from list first. */
		GlobalMembersGplt_x11.delete_plot(psp);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(psp);
		}
	}

/*-----------------------------------------------------------------------------
 *   Find_Plot_In_Linked_List_By_Number - Search for the plot in the linked list.
 *---------------------------------------------------------------------------*/

	public static plot_struct Find_Plot_In_Linked_List_By_Number(int plot_number)
	{
		plot_struct psp = plot_list_start;

		while (psp != DefineConstants.NULL)
		{
		if (psp.plot_number == plot_number)
			break;
		psp = psp.next_plot;
		}

		return psp;
	}

/*-----------------------------------------------------------------------------
 *   Find_Plot_In_Linked_List_By_Window - Search for the plot in the linked list.
 *---------------------------------------------------------------------------*/

	public static plot_struct Find_Plot_In_Linked_List_By_Window(Window window)
	{
		plot_struct psp = plot_list_start;

		while (psp != DefineConstants.NULL)
		{
		if (psp.window == window)
			break;
		psp = psp.next_plot;
		}

	///#ifdef EXTERNAL_X11_WINDOW
		if (psp != DefineConstants.NULL)
		return psp;

		/* Search through the containers, but do so as a separate loop to not
		 * effect performance for normal numbered plot window searches. */
		psp = plot_list_start;

		while (psp != DefineConstants.NULL)
		{
		if (psp.external_container != None && psp.external_container == window)
			break;
		psp = psp.next_plot;
		}
	///#endif

		return psp;

	}

/*-----------------------------------------------------------------------------
 *   Find_Plot_In_Linked_List_By_CMap - Search for the plot in the linked list.
 *---------------------------------------------------------------------------*/

	public static plot_struct Find_Plot_In_Linked_List_By_CMap(cmap_t cmp)
	{
		plot_struct psp = plot_list_start;

		while (psp != DefineConstants.NULL)
		{
		cmap_struct csp = psp.first_cmap_struct;
		while (csp != DefineConstants.NULL)
		{
			if (csp.cmap == cmp)
			break;
			csp = csp.next_cmap_struct;
		}
		if (csp != DefineConstants.NULL)
			break;
		psp = psp.next_plot;
		}

		return psp;
	}

	public static plot_struct current_plot = DefineConstants.NULL;
	public static int most_recent_plot_number = 0;
	public static plot_struct plot_list_start = DefineConstants.NULL;

	public static void x11_setfill(GC gc, int style)
	{
		int fillpar = style >> 4;
		XColor xcolor = new XColor();
		XColor bgnd = new XColor();
		float dim;
		int idx;

		style = style & 0xf;

		switch (style)
		{
		case FS_SOLID:
		case FS_TRANSPARENT_SOLID:
			/* filldensity is from 0..100 percent */
			if (fillpar >= 100)
			break;
			dim = (double)(fillpar) / 100.;
			/* use halftone fill pattern according to filldensity */
			xcolor.red = (double)(0xffff) * (double)((current_plot.current_rgb >> 16) & 0xff) / 255.;
			xcolor.green = (double)(0xffff) * (double)((current_plot.current_rgb >> 8) & 0xff) / 255.;
			xcolor.blue = (double)(0xffff) * (double)(current_plot.current_rgb & 0xff) / 255.;
			bgnd.red = (double)(0xffff) * (double)((current_plot.cmap.rgbcolors[0] >> 16) & 0xff) / 255.;
			bgnd.green = (double)(0xffff) * (double)((current_plot.cmap.rgbcolors[0] >> 8) & 0xff) / 255.;
			bgnd.blue = (double)(0xffff) * (double)(current_plot.cmap.rgbcolors[0] & 0xff) / 255.;
			xcolor.red = dim * xcolor.red + (1.-dim) * bgnd.red;
			xcolor.green = dim * xcolor.green + (1.-dim) * bgnd.green;
			xcolor.blue = dim * xcolor.blue + (1.-dim) * bgnd.blue;
			GlobalMembersFit.a((stderr,"Dimming poly color %.6x by %.2f to %2d %2d %2d\n", (int)(current_plot.current_rgb), dim, xcolor.red, xcolor.green, xcolor.blue));
			if (XAllocColor(dpy, current_plot.cmap.colormap, xcolor))
			XSetForeground(dpy, gc, xcolor.pixel);
			break;
		case FS_PATTERN:
		case FS_TRANSPARENT_PATTERN:
			/* use fill pattern according to fillpattern */
			idx = (int) fillpar; // fillpattern is enumerated
			if (idx < 0)
			idx = 0;
			idx = idx % DefineConstants.stipple_pattern_num;
			XSetStipple(dpy, gc, stipple_pattern[idx]);
			if (style == t_fillstyle.FS_TRANSPARENT_PATTERN.getValue())
			XSetFillStyle(dpy, gc, FillStippled);
			else
			XSetFillStyle(dpy, gc, FillOpaqueStippled);
			XSetBackground(dpy, gc, current_plot.cmap.colors[0]);
			break;
		case FS_EMPTY:
			/* fill with background color */
			XSetFillStyle(dpy, gc, FillSolid);
			XSetForeground(dpy, gc, current_plot.cmap.colors[0]);
			break;
		default:
			/* fill with current color */
			XSetFillStyle(dpy, gc, FillSolid);
			break;
		}
	}

/* NOTE:  The removing of plots via the ErrorHandler routine is rather
   tricky.  The error events can happen at any time during execution of
   the program, very similar to an interrupt.  The consequence is that
   the error handling routine can't remove plots from the linked list
   directly.  Instead we use a queuing system in which the main code
   eventually removes the plots.

   Furthermore, to be safe, only the error handling routine should create
   and delete elements in the FIFO.  Otherwise, the possibility of bogus
   pointers can arise if error events happen at the exact wrong time.
   (Requires a lot of thought.)

   The scheme here is for the error handler to put elements in the
   queue marked as "processed = 0" and then indicate that the main
   code should process elements in the queue.  The main code then
   copies the information about the plot to remove and sets the value
   "processed = 1".  Afterward the main code removes the plot.
*/

/*-----------------------------------------------------------------------------
 *   Add_Plot_To_Remove_FIFO_Queue - Method for error handler to destroy plot.
 *---------------------------------------------------------------------------*/


	public static void Add_Plot_To_Remove_FIFO_Queue(Window plot_window)
	{
		/* Clean up any processed links. */
		plot_remove_struct prsp = remove_fifo_queue_start;
		GlobalMembersFit.a((stderr, "Add plot to remove FIFO queue called.\n"));
		while (prsp != DefineConstants.NULL)
		{
		if (prsp.processed != 0)
		{
			remove_fifo_queue_start = prsp.next_remove;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(prsp);
			prsp = remove_fifo_queue_start;
			GlobalMembersFit.a((stderr, "  -> Removed a processed element from FIFO queue.\n"));
		}
		else
		{
			break;
		}
		}

		/* Go to end of list while checking if this window is already in list. */
		while (prsp != DefineConstants.NULL)
		{
		if (prsp.plot_window_to_remove == plot_window)
		{
			/* Discard this request because the same window is yet to be processed.
			   X11 could be stuck sending the same error message again and again
			   while the main program is not responding for some reason.  This would
			   lead to the FIFO queue growing indefinitely. */
			return;
		}
		if (prsp.next_remove == DefineConstants.NULL)
			break;
		else
			prsp = prsp.next_remove;
		}

		/* Create link and add to end of queue. */
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			plot_remove_struct prsp_new = (plot_remove_struct) malloc(sizeof(plot_remove_struct));
		if (prsp_new != null)
		{
		/* Initialize structure variables. */
		prsp_new.next_remove = DefineConstants.NULL;
		prsp_new.plot_window_to_remove = plot_window;
		prsp_new.processed = 0;
		if (remove_fifo_queue_start != null)
			prsp.next_remove = prsp_new;
		else
			remove_fifo_queue_start = prsp_new;
		process_remove_fifo_queue = 1; // Indicate to main loop that there is a plot to remove.
		GlobalMembersFit.a((stderr, "  -> Added an element to FIFO queue.\n"));
		}
		else
		{
		fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Could not allocate memory for plot remove queue.\n\n");
		}
		}
	}

/*-----------------------------------------------------------------------------
 *   Process_Remove_FIFO_Queue - Remove plots queued by error handler.
 *---------------------------------------------------------------------------*/

	public static void Process_Remove_FIFO_Queue()
	{
		plot_remove_struct prsp = remove_fifo_queue_start;

		/* Clear flag before processing so that if an ErrorHandler event
		 * comes along while running the remainder of this routine, any new
		 * error events that were missed because of timing issues will be
		 * processed next time through the main loop.
		 */
		GlobalMembersGplt_x11.Process_Remove_FIFO_Queue = 0;

		/* Go through the list and process any unprocessed queue request.
		 * No clean up is done here because having two asynchronous routines
		 * modifying the queue would be too dodgy.  The ErrorHandler creates
		 * and removes links in the queue based upon the processed flag.
		 */
		while (prsp != DefineConstants.NULL)
		{

		/* Make a copy of the remove information structure before changing flag.
		 * Otherwise, there would be the possibility of the error handler routine
		 * removing the associated link upon seeing the "processed" flag set.  From
		 * this side of things, the pointer becomes invalid once that flag is set.
		 */
		plot_remove_struct prs = new plot_remove_struct();
		prs.plot_window_to_remove = prsp.plot_window_to_remove;
		prs.next_remove = prsp.next_remove;
		prs.processed = prsp.processed;

		/* Set processed flag before processing the event.  This is so
		 * that the FIFO queue does not have to repeat window entries.
		 * If the error handler were to break in right before the
		 * "processed" flag is set to 1 and not put another link in
		 * the FIFO because it sees the window in question is already
		 * in the FIFO, we're OK.  The reason is that the window in
		 * question is still to be processed.  On the other hand, if
		 * we were to process then set the flag, an entry in the queue
		 * could potentially be lost.
		 */
		prsp.processed = 1;
		GlobalMembersFit.a((stderr, "Processed element in remove FIFO queue.\n"));

		/* NOW process the plot to remove. */
		if (prs.processed == 0)
			GlobalMembersGplt_x11.Remove_Plot_From_Linked_List(prs.plot_window_to_remove);

		prsp = prs.next_remove;
		}

		/* Issue an X11 error so that error handler cleans up queue?
		 * Really, this isn't super important.  Without issuing a bogus
		 * error, the processed queue elements will be deleted the
		 * next time there is an error.  Until another error comes
		 * along it means there is maybe ten or so words of memory
		 * reserved on the heap for the FIFO queue.  In some sense,
		 * the extra code is hardly worth the effort, especially
		 * when X11 documentation is so sparse on the matter of errors.
		 */

	}

	public static plot_remove_struct remove_fifo_queue_start = DefineConstants.NULL;
	public static int process_remove_fifo_queue = 0;

/*-----------------------------------------------------------------------------
 *   Add_CMap_To_Linked_List - Create space for colormap and put in linked list.
 *---------------------------------------------------------------------------*/


	public static cmap_t Add_CMap_To_Linked_List()
	{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		cmap_t cmp = (cmap_t) malloc(sizeof(cmap_t));
		if (cmp != null)
		{
		/* Add link to beginning of the list. */
		cmp.prev_cmap = DefineConstants.NULL;
		if (cmap_list_start != DefineConstants.NULL)
		{
			cmap_list_start.prev_cmap = cmp;
			cmp.next_cmap = cmap_list_start;
		}
		else
			cmp.next_cmap = DefineConstants.NULL;
		cmap_list_start = cmp;
		}
		else
		{
		cmp = DefineConstants.NULL;
		fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Could not allocate memory for color map.\n\n");
		}
		/* Initialize structure variables. */
		GlobalMembersGplt_x11.CmapClear(cmp);
		cmp.colormap = XCreateColormap(dpy, root, vis, AllocNone);
		assert cmp.colormap;
		GlobalMembersGplt_x11.pr_color(cmp); // set default colors for lines
		return cmp;
	}

/*-----------------------------------------------------------------------------
 *   Remove_CMap_From_Linked_List - Remove from linked list and free memory.
 *---------------------------------------------------------------------------*/

	public static void Remove_CMap_From_Linked_List(cmap_t cmp)
	{
		/* Make sure colormap exists in the list. */
		cmp = GlobalMembersGplt_x11.Find_CMap_In_Linked_List(cmp);

		if (cmp != DefineConstants.NULL)
		{
		/* Remove link from the list. */
		if (cmp.next_cmap != DefineConstants.NULL)
			cmp.next_cmap.prev_cmap = cmp.prev_cmap;
		if (cmp.prev_cmap != DefineConstants.NULL)
		{
			cmp.prev_cmap.next_cmap = cmp.next_cmap;
		}
		else
		{
			cmap_list_start = cmp.next_cmap;
		}
		/* If global pointers point at this plot, reassign them. */
		if (current_cmap == cmp)
		{
	///#if 0 // Make some other cmap current.
	////	    if (cmp->prev_cmap != NULL)
	////		current_cmap = cmp->prev_cmap;
	////	    else
	////		current_cmap = psp->next_cmap;
	///#else // No current cmap.
			current_cmap = default_cmap;
	///#endif
		}
		/* Remove any memory for pixels and memory for colormap structure. */
		GlobalMembersGplt_x11.ReleaseColormap(cmp);
		}
	}

/*-----------------------------------------------------------------------------
 *   Find_CMap_In_Linked_List - Search for the color map in the linked list.
 *---------------------------------------------------------------------------*/

	public static cmap_t Find_CMap_In_Linked_List(cmap_t colormap)
	{
		cmap_t cmp = cmap_list_start;

		while (cmp != DefineConstants.NULL)
		{
		if (cmp == colormap)
			break;
		cmp = cmp.next_cmap;
		}

		return cmp;
	}

/*-----------------------------------------------------------------------------
 *   cmaps_differ - Compare two colormaps, return 1 if differ.
 *---------------------------------------------------------------------------*/

	public static int cmaps_differ(cmap_t cmap1, cmap_t cmap2)
	{

		/* First compare non-pointer elements. */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in Java:
		if (memcmp((cmap1.colors[0]), (cmap2.colors[0]), (int) & (cmap1.pixels) - (int) & (cmap1.colors[0])))
		return 1;

		/* Now compare pointer elements. */
		if (cmap1.allocated != 0)
		{
		if (cmap1.pixels && cmap2.pixels)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			if (memcmp(cmap1.pixels, cmap2.pixels, cmap1.allocated * sizeof(cmap1.pixels[0])))
			return 1;
		}
		else
			return 1;
		}

		return 0; // They are the same.

	}

	/* current_cmap always points to a valid colormap.  At start up
	 * it is the default colormap.  When a palette command comes
	 * across the pipe, the current_cmap is set to point at the
	 * resulting colormap which ends up in the linked list of colormaps.
	 * The current_cmap should never be removed from the linked list
	 * even if all windows are deleted, because that colormap will be
	 * used for the next plot.
	 */
	public static cmap_t current_cmap = DefineConstants.NULL;
	public static cmap_t cmap_list_start = DefineConstants.NULL;

	///#define SEL_LEN 0xff
	public static String selection = "";


	///#ifdef USE_MOUSE
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define GRAPH_HEIGHT(plot) ((plot)->gheight)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define PIXMAP_HEIGHT(plot) ((plot)->gheight + vchar)
	  /* note: PIXMAP_HEIGHT is the height of the plot including the status line,
	     even if the latter is not enabled right now */
	///#else
	///#define GRAPH_HEIGHT(plot)  ((plot)->height)
	///#define PIXMAP_HEIGHT(plot)  ((plot)->height)
	///#endif

	public static void CmapClear(cmap_t cmap_ptr)
	{
		cmap_ptr.total = (int) 0;
		cmap_ptr.allocated = (int) 0;
		cmap_ptr.pixels = (int) 0;
	}
	public static void RecolorWindow(plot_struct current_plot)
	{
		cmap_struct[] cspp = current_plot.first_cmap_struct;
		cmap_struct csp = current_plot.first_cmap_struct;
		while (csp != null)
		{
		if (csp.cmap == current_plot.cmap)
			break;
		cspp = &(csp.next_cmap_struct);
		csp = csp.next_cmap_struct;
		}
		if (csp == null)
		{
		/* This colormap is not in the list, add it. */
		cspp = new cmap_struct[1];
		if (cspp != null)
		{
			/* Initialize structure variables. */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			memset((Object) cspp, 0, sizeof(cmap_struct));
			cspp.cmap = current_plot.cmap;
		}
		else
		{
			fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Could not allocate memory for cmap_struct.\n\n");
			return;
		}
		}
		if (None != current_plot.window)
		{
		XSetWindowColormap(dpy, current_plot.window, current_plot.cmap.colormap);
		XSetWindowBackground(dpy, current_plot.window, current_plot.cmap.colors[0]);
		XSetWindowBorder(dpy, current_plot.window, current_plot.cmap.colors[1]);
	///#ifdef USE_MOUSE
		if (gc_xor != null)
		{
			XFreeGC(dpy, gc_xor);
			gc_xor = (GC) 0;
			GlobalMembersGplt_x11.GetGCXor(current_plot, gc_xor); // recreate gc_xor
		}
	///#endif
		}
	}
	public static void FreeColormapList(plot_struct current_plot)
	{
		while (current_plot.first_cmap_struct != DefineConstants.NULL)
		{
		cmap_struct freethis = current_plot.first_cmap_struct;
		/* Release the colormap here to free color resources, but only
		 * if this plot is using a colormap not used by another plot
		 * and is not using the current colormap.
		 */
		if (current_plot.first_cmap_struct.cmap != current_cmap && GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_CMap(current_plot.first_cmap_struct.cmap) == null)
			GlobalMembersGplt_x11.Remove_CMap_From_Linked_List(current_plot.first_cmap_struct.cmap);
		current_plot.first_cmap_struct = current_plot.first_cmap_struct.next_cmap_struct;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(freethis);
		}
	}

/*
 * free all *pm3d* colors (*not* the line colors cmap->colors)
 * of a plot_struct's colormap.  This could be either a private
 * or the default colormap.  Note, that the line colors are not
 * free'd nor even touched.
 */
	public static void FreeColors(cmap_t cmp)
	{
		if (cmp.total != 0 && cmp.pixels)
		{
		if (cmp.allocated != 0)
		{
			GlobalMembersFit.a((stderr, "freeing palette colors\n"));
			XFreeColors(dpy, cmp.colormap, cmp.pixels, cmp.allocated, 0); // XXX ??? XXX
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(cmp.pixels);
		}
		GlobalMembersGplt_x11.CmapClear(cmp);
	}

/*
 * free pm3d colors and eventually a private colormap.
 * set the plot_struct's colormap to the default colormap
 * and the line `colors' to the line colors of the default
 * colormap.
 */
	public static void ReleaseColormap(cmap_t cmp)
	{
		if (cmp != null && cmp != current_cmap)
		{
		GlobalMembersGplt_x11.FreeColors(cmp);
		GlobalMembersFit.a((stderr, "releasing private colormap\n"));
		if (cmp.colormap != null && cmp.colormap != current_cmap.colormap)
		{
			XFreeColormap(dpy, cmp.colormap);
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free((String) cmp);
		}
	}
//C++ TO JAVA CONVERTER WARNING: Java has no equivalent to methods returning pointers to value types:
//ORIGINAL LINE: static int * ReallocColors(cmap_t *cmap, int n)
	public static int ReallocColors(cmap_t cmap, int n)
	{
		GlobalMembersGplt_x11.FreeColors(cmap);
		cmap.total = n;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		cmap.pixels = (int) malloc(sizeof(int) * cmap.total);
		return cmap.pixels;
	}
	public static void PaletteMake(t_sm_palette tpal)
	{
		int max_colors;
		int min_colors;
		String save_title = (String) 0;

		/* The information retained in a linked list is the cmap_t structure.
		 * That colormap structure doesn't contain the palette specifications
		 * t_sm_palette used to generate the colormap.  Therefore, the making
		 * of the colormap must be carried all the way through before we can
		 * determine if it is unique from the other colormaps in the linked list.
		 *
		 * Rather than create and initialize a colormap outside of the list, we'll
		 * just put a new one in the list, and if it isn't unique remove it later.
		 */

		cmap_t new_cmap = GlobalMembersGplt_x11.Add_CMap_To_Linked_List();

		/* Continue until valid palette is built.  May require multiple passes. */
		while (true)
		{

		if (tpal != null)
		{

			if (tpal.use_maxcolors > 0)
			{
			max_colors = tpal.use_maxcolors;
			}
			else
			{
			max_colors = maximal_possible_colors;
			}

			GlobalMembersFit.a((stderr, "(PaletteMake) tpal->use_maxcolors = %d\n", tpal.use_maxcolors));

			/*  free old gradient table  */
			if (sm_palette.gradient != null)
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(sm_palette.gradient);
			sm_palette.gradient = DefineConstants.NULL;
			sm_palette.gradient_num = 0;
			}

			sm_palette.colorMode = tpal.colorMode;
			sm_palette.positive = tpal.positive;
			sm_palette.use_maxcolors = tpal.use_maxcolors;
			sm_palette.cmodel = tpal.cmodel;

			switch (sm_palette.colorMode)
			{
			case SMPAL_COLOR_MODE_GRAY:
			sm_palette.gamma = tpal.gamma;
			break;
			case SMPAL_COLOR_MODE_RGB:
			sm_palette.formulaR = tpal.formulaR;
			sm_palette.formulaG = tpal.formulaG;
			sm_palette.formulaB = tpal.formulaB;
			break;
			case SMPAL_COLOR_MODE_FUNCTIONS:
			fprintf(stderr, "Ooops:  no SMPAL_COLOR_MODE_FUNCTIONS here!\n");
			break;
			case SMPAL_COLOR_MODE_GRADIENT:
			sm_palette.gradient_num = tpal.gradient_num;
			/* Take over the memory from tpal. */
			sm_palette.gradient = tpal.gradient;
			tpal.gradient = DefineConstants.NULL;
			break;
			default:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr,"%s:%d ooops: Unknown color mode '%c'.\n", __FILE__, __LINE__, (byte)(sm_palette.colorMode));
			}

		}
		else
		{
			max_colors = maximal_possible_colors;
			GlobalMembersFit.a((stderr, "(PaletteMake) tpal=NULL\n"));
		}

		if (minimal_possible_colors < max_colors)
			min_colors = minimal_possible_colors;
		else
			min_colors = max_colors / (num_colormaps > 1 ? 2 : 8);

		if (current_plot != null)
		{

			if (current_plot.window != null)
			{
			String msg;
			String added_text = " allocating colors ...";
			int orig_len = (current_plot.titlestring != null ? current_plot.titlestring.length() : 0);
			XFetchName(dpy, current_plot.window, save_title);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
			if ((msg = (String) malloc(orig_len + added_text.length() + 1)))
			{
				if (current_plot.titlestring != null)
				msg = current_plot.titlestring;
				else
				msg = tangible.StringFunctions.changeCharacter(msg, 0, '\0');
				msg += added_text;
				XStoreName(dpy, current_plot.window, msg);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(msg);
			}
			}

			if (num_colormaps == 0)
			{
			XFree(XListInstalledColormaps(dpy, current_plot.window, num_colormaps));
			GlobalMembersFit.a((stderr, "(PaletteMake) num_colormaps = %d\n", num_colormaps));
			}

		}

		/* TODO */
		/* EventuallyChangeVisual(plot); */

		/*
		 * start with trying to allocate max_colors. This should
		 * always succeed with TrueColor visuals >= 16bit. If it
		 * fails (for example for a PseudoColor visual of depth 8),
		 * try it with half of the colors. Proceed until min_colors
		 * is reached. If this fails we should probably install a
		 * private colormap.
		 * Note that I make no difference for different
		 * visual types here. (joze)
		 */
		for (; max_colors >= min_colors; max_colors /= 2) // EMPTY
		{

			XColor xcolor = new XColor();
			double fact = 1.0 / (double)(max_colors - 1);

			if (current_plot != null)
			GlobalMembersGplt_x11.ReallocColors(new_cmap, max_colors);

			for (new_cmap.allocated = 0; new_cmap.allocated < max_colors; new_cmap.allocated++)
			{

			double gray = (double) new_cmap.allocated * fact;
			rgb_color color = new rgb_color();
			GlobalMembersGetcolor.rgb1_from_gray(gray, color);
			xcolor.red = 0xffff * color.r + 0.5;
			xcolor.green = 0xffff * color.g + 0.5;
			xcolor.blue = 0xffff * color.b + 0.5;

			if (XAllocColor(dpy, new_cmap.colormap, xcolor))
			{
				new_cmap.pixels[new_cmap.allocated] = xcolor.pixel;
			}
			else
			{
				GlobalMembersFit.a((stderr, "failed at color %d\n", new_cmap.allocated));
				break;
			}
			}

			if (new_cmap.allocated == max_colors)
			{
			break; // success!
			}

			/* reduce the number of max_colors to at
			 * least less than new_cmap->allocated */
			while (max_colors > new_cmap.allocated && max_colors >= min_colors)
			{
			max_colors /= 2;
			}
		}

		GlobalMembersFit.a((stderr, "(PaletteMake) allocated = %d\n", new_cmap.allocated));
		GlobalMembersFit.a((stderr, "(PaletteMake) max_colors = %d\n", max_colors));
		GlobalMembersFit.a((stderr, "(PaletteMake) min_colors = %d\n", min_colors));

		if (new_cmap.allocated < min_colors && tpal != null)
		{
			/* create a private colormap on second pass. */
			GlobalMembersFit.a((stderr, "switching to private colormap\n"));
			tpal = 0;
		}
		else
		{
			break;
		}
		}

		/* Now check the uniqueness of the new colormap against all the other
		 * colormaps in the linked list.
		 */
		{
		cmap_t cmp = cmap_list_start;

		while (cmp != DefineConstants.NULL)
		{
			if ((cmp != new_cmap) && GlobalMembersGplt_x11.cmaps_differ(cmp, new_cmap) == 0)
			break;
			cmp = cmp.next_cmap;
		}

		if (cmp != DefineConstants.NULL)
		{
			/* Found a match. Discard the newly created colormap.  (Could
			 * have simply discarded the old one and combined parts of
			 * code similar to these if statements, but we'll avoid removing
			 * old blocks of memory so that it is more likely that heap
			 * memory will remain more tidy.
			 */
			GlobalMembersGplt_x11.Remove_CMap_From_Linked_List(new_cmap);
			if (current_plot != null)
			{
			current_plot.cmap = cmp;
			GlobalMembersGplt_x11.RecolorWindow(current_plot);
			}
			current_cmap = cmp;
		}
		else
		{
			/* Unique and truely new colormap.  Make it the current map. */
			if (current_plot != null)
			{
			current_plot.cmap = new_cmap;
			GlobalMembersGplt_x11.RecolorWindow(current_plot);
			}
			/* If no other plots using colormap, then can be removed. */
			if (GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_CMap(current_cmap) == null)
			GlobalMembersGplt_x11.Remove_CMap_From_Linked_List(current_cmap);
			current_cmap = new_cmap;
		}

		}

		if (save_title != null)
		{
		/* Restore window title (current_plot and current_plot->window are
		 * valid, otherwise would not have been able to get save_title.
		 */
		XStoreName(dpy, current_plot.window, save_title);
		XFree(save_title);
		}

	}
	public static void PaletteSetColor(plot_struct current_plot, double gray)
	{
		if (current_plot.cmap.allocated != 0)
		{
		int index;

		gray = Math.floor(gray * current_plot.cmap.allocated) / (current_plot.cmap.allocated - 1);
		index = gray * (current_plot.cmap.allocated - 1);
		if (index >= current_plot.cmap.allocated)
			index = current_plot.cmap.allocated - 1;

		XSetForeground(dpy, gc, current_plot.cmap.pixels[index]);
		current_plot.current_rgb = current_plot.cmap.pixels[index];
		}
	}

/*
 * check if the display supports the visual of type `class'.
 *
 * If multiple visuals of `class' are supported, try to get
 * the one with the highest depth.
 *
 * If visual class and depth are equal to the default visual
 * class and depth, the latter is preferred.
 *
 * modifies: best, depth
 *
 * returns 1 if a visual which matches the request
 * could be found else 0.
 */
	public static int GetVisual(int class_Renamed, Visual[] visual, int depth)
	{
		XVisualInfo[] visualsavailable;
		int nvisuals = 0;
		int vinfo_mask = VisualClassMask;
		XVisualInfo vinfo = new XVisualInfo();

//C++ TO JAVA CONVERTER TODO TASK: Java does not allow declaring types within methods:
	//	vinfo.class = class_Renamed;
	//	*depth = 0;
		visual = 0;

		visualsavailable = XGetVisualInfo(dpy, vinfo_mask, vinfo, nvisuals);

		if (visualsavailable != null && nvisuals > 0)
		{
		int i;
		for (i = 0; i < nvisuals; i++)
		{
			if (visualsavailable[i].depth > depth)
			{
			visual = visualsavailable[i].visual;
			depth = visualsavailable[i].depth;
			}
		}
		XFree(visualsavailable);
		if (visual != null && (visual).class == (DefaultVisual(dpy, scr)).class && depth == DefaultDepth(dpy, scr))
		{
			/* prefer the default visual */
			visual = DefaultVisual(dpy, scr);
		}
		}
		return nvisuals > 0;
	}

/*
 * This function builds back a palette from what x11.trm has written
 * into the pipe.  It cheats:  SMPAL_COLOR_MODE_FUNCTIONS for user defined
 * formulaes to transform gray into the three color components is not
 * implemented.  If this had to be done, one would have to include all
 * the code for evaluating functions here too, and, even worse: how to
 * transmit all function definition from gnuplot to here!
 * To avoid this, the following is done:  For grayscale, and rgbformulae
 * everything is easy.  Gradients are more difficult: Each gradient point
 * is encoded in a 8-byte string (which does not include any '\n' and
 * transmitted here.  Here the gradient is rebuilt.
 * Form user defined formulae x11.trm builds a special gradient:  The gray
 * values are equally spaced and are not transmitted, only the 6 bytes for
 * the rgbcolor are sent.  These are assembled into a gradient which is
 * than used in the palette.
 *
 * This function belongs completely into record(), but is quiet large so it
 * became a function of its own.
*/
	public static void scan_palette_from_buf()
	{
		t_sm_palette tpal = new t_sm_palette();
		byte cm;
		byte pos;
		byte mod;
		if (4 != sscanf(buf + 2, "%c %c %c %d", cm, pos, mod, (tpal.use_maxcolors)))
		{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d error in setting palette.\n", __FILE__, __LINE__);

		return;
		}

		tpal.colorMode = cm;
		tpal.positive = pos;
		tpal.cmodel = mod;
		tpal.gradient = DefineConstants.NULL;

		/* function palettes are transmitted as approximated gradients: */
		if (tpal.colorMode == palette_color_mode.SMPAL_COLOR_MODE_FUNCTIONS)
		  tpal.colorMode = palette_color_mode.SMPAL_COLOR_MODE_GRADIENT;

		switch (tpal.colorMode)
		{
		case SMPAL_COLOR_MODE_GRAY:
		GlobalMembersGplt_x11.read_input_line();
		if (1 != sscanf(buf, "%lf", (tpal.gamma)))
		{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d error in setting palette.\n", __FILE__, __LINE__);
			return;
		}
		break;
		case SMPAL_COLOR_MODE_RGB:
		GlobalMembersGplt_x11.read_input_line();
		if (3 != sscanf(buf, "%d %d %d", (tpal.formulaR), (tpal.formulaG), (tpal.formulaB)))
		{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d error in setting palette.\n", __FILE__, __LINE__);
			return;
		}
		break;
		case SMPAL_COLOR_MODE_GRADIENT:
		{
		int i = 0;
		GlobalMembersGplt_x11.read_input_line();
		if (1 != sscanf(buf, "%d", (tpal.gradient_num)))
		{
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d error in setting palette.\n", __FILE__, __LINE__);
			return;
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		tpal.gradient = (gradient_struct) malloc(tpal.gradient_num * sizeof(gradient_struct));
		assert tpal.gradient;
		for (i = 0; i < tpal.gradient_num; i++)
		{
			/*  this %50 *must* match the amount of gradient structs
			written to the pipe by x11.trm!  */
			if (i % 50 == 0)
			{
				GlobalMembersGplt_x11.read_input_line();
			}
			GlobalMembersGetcolor.str_to_gradient_entry((buf.charAt(8 * (i % 50))), (tpal.gradient[i]));
		}
		break;
		}
		case SMPAL_COLOR_MODE_FUNCTIONS:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d ooops: No function palettes for x11!\n", __FILE__, __LINE__);
		break;
		default:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __FILE__ macro:
			fprintf(stderr, "%s:%d ooops: Unknown colorMode '%c'.\n", __FILE__, __LINE__, (byte)(tpal.colorMode));
		tpal.colorMode = palette_color_mode.SMPAL_COLOR_MODE_GRAY;
		break;
		}
		GlobalMembersGplt_x11.PaletteMake(tpal);

		if (tpal.gradient != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(tpal.gradient);
	}

/* Extract details about the extent of a bit mask by doing a
 * single bit shift up and then down (left shift) and down
 * and then up (right shift).  When the pre- and post-shift
 * numbers are not equal, a bit was lost so that is the
 * extent of the mask.
 */

	public static short BitMaskDetails(int mask, short left_shift, short right_shift)
	{
		short i;
		int m = mask;

		if (mask == 0)
		{
		left_shift = 0;
		right_shift = 0;
		return 0;
		}

		for (i = 0; i < 32; i++)
		{
		if ((((m << 1) & 0xffffffff) >> 1) != m)
			break;
		else
			m <<= 1;
		}
		left_shift = i;

		m = mask;
		for (i = 0; i < 32 ; i++)
		{
		if (((m >> 1) << 1) != m)
			break;
		else
			m >>= 1;
		}
		right_shift = i;

		return (short) m;
	}

	public static boolean swap_endian = false; // For binary data.
	/* Petr's byte swapping routine. */
	public static void byteswap(String data, int datalen)
	{
		byte tmp;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * dest = data + datalen - 1;
		if (datalen < 2)
			return;
		while (dest > data)
		{
		tmp = *dest;
		*dest--= data;
		data++= tmp;
		}
	}
	/* Additional macros that should be more efficient when data size is known. */
	public static byte byteswap_char;

/* store a command in a plot structure */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define byteswap1(x)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define byteswap2(x) byteswap_char = ((char *)x)[0]; ((char *)x)[0] = ((char *)x)[1]; ((char *)x)[1] = byteswap_char;
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define byteswap4(x) byteswap_char = ((char *)x)[0]; ((char *)x)[0] = ((char *)x)[3]; ((char *)x)[3] = byteswap_char; byteswap_char = ((char *)x)[1]; ((char *)x)[1] = ((char *)x)[2]; ((char *)x)[2] = byteswap_char

	public static void store_command(String buffer, plot_struct plot)
	{
		String p;

		if (plot.ncommands >= plot.max_commands)
		{
		plot.max_commands = plot.max_commands * 2 + 1;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'realloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		plot.commands = (plot.commands) ? (String) realloc(plot.commands, plot.max_commands * sizeof(String)) : (String) malloc(sizeof(String));
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
		p = (String) malloc(buffer.length() + 1);
		if (!plot.commands || p == null)
		{
		fputs("gnuplot: can't get memory. X11 aborted.\n", stderr);
		do
		{
			GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
			close(1);
			close(0);
			System.exit(1);
		} while (0);
		}
		plot.commands[plot.ncommands++] = strcpy(p, buffer);
	}

/* prepare the plot structure */
	public static void prepare_plot(plot_struct plot)
	{
		int i;

		for (i = 0; i < plot.ncommands; ++i)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(plot.commands[i]);
		plot.ncommands = 0;

		if (plot.posn_flags == 0)
		{
		/* first time this window has been used - use default or -geometry
		 * settings
		 */
		plot.posn_flags = gFlags;
		plot.x = gX;
		plot.y = gY;
		plot.width = gW;
		plot.height = gH;
		plot.window = None;
		plot.pixmap = None;
	///#ifdef USE_MOUSE
		plot.gheight = gH;
		plot.resizing = false;
		plot.str = tangible.StringFunctions.changeCharacter(plot.str, 0, '\0');
		plot.zoombox_on = false;
	///#endif
		plot.first_cmap_struct = DefineConstants.NULL;
		}
		if (plot.window == None)
		{
		plot.cmap = current_cmap; // color space
		GlobalMembersGplt_x11.pr_window(plot);
	///#ifdef USE_MOUSE
		/*
		 * set all mouse parameters
		 * to a well-defined state.
		 */
		plot.button = 0;
		plot.mouse_on = true;
		plot.x = AnonymousEnum.NOT_AVAILABLE.getValue();
		plot.y = AnonymousEnum.NOT_AVAILABLE.getValue();
		if (plot.str.charAt(0) != '\0')
		{
			/* if string was non-empty last time, initialize it as
			 * almost empty one space, to prevent window resize */
			plot.str = tangible.StringFunctions.changeCharacter(plot.str, 0, ' ');
			plot.str = tangible.StringFunctions.changeCharacter(plot.str, 1, '\0');
		}
		plot.time = 0; // XXX how should we initialize this ? XXX
	///#endif
		}

		/* Release the colormaps here to free color resources. */
		GlobalMembersGplt_x11.FreeColormapList(plot);
		/* Make the current colormap the first colormap in the plot. */
		plot.cmap = current_cmap; // color space

		/* We don't know that it is the same window as before, so we reset the
		 * cursors for all windows and then define the cursor for the active
		 * window
		 */
		plot.angle = 0; // default is horizontal
		GlobalMembersGplt_x11.reset_cursor();
		XDefineCursor(dpy, plot.window, cursor);
	}

///#elif defined(CRIPPLED_SELECT)
//
//char X11_ipcpath[32];
//
// /*
//  * CRIPPLED_SELECT mainloop
//  */
//static void
//mainloop()
//{
//    SELECT_TYPE_ARG1 nf, nfds, cn = ConnectionNumber(dpy);
//    struct timeval timeout, *timer;
//    fd_set tset;
//    unsigned long all = (unsigned long) (-1L);
//    XEvent xe;
//
//    timeout.tv_sec = 1;
//    timeout.tv_usec = 0;
//    timer = &timeout;
//    sprintf(X11_ipcpath, "/tmp/Gnuplot_%d", getppid());
//    nfds = cn + 1;
//
//    while (1) {
//	XFlush(dpy);		// see above 
//
//	FD_ZERO(&tset);
//	FD_SET(cn, &tset);
//
// /* Don't wait for events if we know that input is
//  * already sitting in a buffer.  Also don't wait for
//  * input to become available.
//  */
//	if (buffered_input_available) {
//	    timeout.tv_sec = 0;
//	    timeout.tv_usec = 0;
//	    timer = &timeout;
//	} else {
//	    timer = (struct timeval *) 0;
//	    FD_SET(in, &tset);
//	}
//
//	nfds = (cn > in) ? cn + 1 : in + 1;
//
//	nf = select(nfds, SELECT_TYPE_ARG234 &tset, 0, 0, SELECT_TYPE_ARG5 timer);
//
//	if (nf < 0) {
//	    if (errno == EINTR)
//		continue;
//	    perror("gnuplot_x11: select failed");
//	    EXIT(1);
//	}
//
//	if (nf > 0)
//	    XNoOp(dpy);
//
//	if (FD_ISSET(cn, &tset)) {
//	    while (XCheckMaskEvent(dpy, all, &xe)) {
//		process_event(&xe);
//	    }
//	}
//	if ((X11_ipc = fopen(X11_ipcpath, "r"))) {
//	    unlink(X11_ipcpath);
//	    record();
//	    fclose(X11_ipc);
//	}
//    }
//}
//
//
///#elif defined(VMS)
// /*-----------------------------------------------------------------------------
//  *    VMS mainloop - Yehavi Bourvine - YEHAVI@VMS.HUJI.AC.IL
//  *---------------------------------------------------------------------------*/
//
// /*  In VMS there is no decent Select(). hence, we have to loop inside
//  *  XGetNextEvent for getting the next X window event. In order to get input
//  *  from the master we assign a channel to SYS$INPUT and use AST's in order to
//  *  receive data. In order to exit the mainloop, we need to somehow make
//  *  XNextEvent return from within the ast. We do this with a XSendEvent() to
//  *  ourselves !
//  *  This needs a window to send the message to, so we create an unmapped window
//  *  for this purpose. Event type XClientMessage is perfect for this, but it
//  *  appears that such messages come from elsewhere (motif window manager,
//  *  perhaps ?) So we need to check fairly carefully that it is the ast event
//  *  that has been received.
//  */
//
///#include <iodef.h>
//char STDIIN[] = "SYS$INPUT:";
//short STDIINchannel, STDIINiosb[4];
//struct {
//    short size, type;
//    char *address;
//} STDIINdesc;
//char STDIINbuffer[64];
//int status;
//
//ast()
//{
//    int status = sys$qio(0, STDIINchannel, IO$_READVBLK, STDIINiosb, record,
//			 0, STDIINbuffer, sizeof(STDIINbuffer) - 1, 0, 0, 0, 0);
//    if ((status & 0x1) == 0)
//	EXIT(status);
//}
//
//Window message_window;
//
//static void
//mainloop()
//{
// /* dummy unmapped window for receiving internally-generated terminate
//  * messages
//  */
//    message_window = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 1, 0, 0);
//
//    STDIINdesc.size = strlen(STDIIN);
//    STDIINdesc.type = 0;
//    STDIINdesc.address = STDIIN;
//    status = sys$assign(&STDIINdesc, &STDIINchannel, 0, 0, 0);
//    if ((status & 0x1) == 0)
//	EXIT(status);
//    ast();
//
//    for (;;) {
//	XEvent xe;
//	XNextEvent(dpy, &xe);
//	if (xe.type == ClientMessage && xe.xclient.window == message_window) {
//	    if (xe.xclient.message_type == None && xe.xclient.format == 8 && strcmp(xe.xclient.data.b, "die gnuplot die") == 0) {
//		FPRINTF((stderr, "quit message from ast\n"));
//		return;
//	    } else {
//		FPRINTF((stderr, "Bogus XClientMessage event from window manager ?\n"));
//	    }
//	}
//	process_event(&xe);
//    }
//}
///#else // !(DEFAULT_X11 || CRIPPLED_SELECT || VMS 
///#error You lose. No mainloop.
///#endif				// !(DEFAULT_X11 || CRIPPLED_SELECT || VMS 

/* delete a window / plot */
	public static void delete_plot(plot_struct plot)
	{
		int i;

		GlobalMembersFit.a((stderr, "Delete plot %d\n", plot.plot_number));

		for (i = 0; i < plot.ncommands; ++i)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(plot.commands[i]);
		plot.ncommands = 0;
		if (plot.commands)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(plot.commands);
		plot.commands = DefineConstants.NULL;
		plot.max_commands = 0;


		/* Free up memory for window title. */
		if (plot.titlestring != null)
		{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(plot.titlestring);
		plot.titlestring = 0;
		}

		if (plot.window != null)
		{
		GlobalMembersFit.a((stderr, "Destroy window 0x%x\n", plot.window));
		XDestroyWindow(dpy, plot.window);
		plot.window = None;
		--windows_open;
		}

		if (stipple_initialized != 0) // ULIG
		{
		int i;
		for (i = 0; i < DefineConstants.stipple_pattern_num; i++)
			XFreePixmap(dpy, stipple_pattern[i]);
		stipple_initialized = 0;
		}

		if (plot.pixmap != null)
		{
		XFreePixmap(dpy, plot.pixmap);
		plot.pixmap = None;
		}
		/* Release the colormaps here to free color resources. */
		GlobalMembersGplt_x11.FreeColormapList(plot);
	}

	public static int record()
	{
		while (true)
		{
		int status = GlobalMembersGplt_x11.read_input();
		if (status == -2)
			return 0;
		if (status != 0)
			return status;

		switch (buf)
		{
		case 'G': // enter graphics mode
		{

	///#ifndef DISABLE_SPACE_RAISES_CONSOLE
	///#ifdef USE_MOUSE
	///#ifdef OS2_IPC
	//		sscanf(buf, "G%lu %li", &gnuplotXID, &ppidGnu);
	///#else
			sscanf(buf, "G%lu", gnuplotXID);
	///#endif
	///#endif
	///#endif // DISABLE_SPACE_RAISES_CONSOLE

			if (current_plot == null)
				current_plot = GlobalMembersGplt_x11.Add_Plot_To_Linked_List(most_recent_plot_number);
			if (current_plot != null)
				GlobalMembersGplt_x11.prepare_plot(current_plot);
	///#ifdef OS2_IPC
	//		if (!input_from_PM_Terminal) {	// get shared memory
	//		    sprintf(mouseShareMemName, "\\SHAREMEM\\GP%i_Mouse_Input", (int) ppidGnu);
	//		    if (DosGetNamedSharedMem(&input_from_PM_Terminal, mouseShareMemName, PAG_WRITE))
	//			DosBeep(1440L, 1000L);	// indicates error
	//		    semInputReady = 0;
	//		}
	///#endif
	///#ifdef USE_MOUSE
	///#ifdef TITLE_BAR_DRAWING_MSG
	// /* show a message in the wm's title bar that the
	//  * graph will be redrawn. This might be useful
	//  * for slow redrawing (large plots). The title
	//  * string is reset to the default at the end of
	//  * display(). We should make this configurable!
	//  */
	//		if (plot && plot->window) {
	//		    char *msg;
	//		    char *added_text = " drawing ...";
	//		    int orig_len = (plot->titlestring ? strlen(plot->titlestring) : 0);
	//		    if (msg = (char *) malloc(orig_len + strlen(added_text) + 1)) {
	//			strcpy(msg, plot->titlestring);
	//			strcat(msg, added_text);
	//			XStoreName(dpy, plot->window, msg);
	//			free(msg);
	//		    } else
	//			XStoreName(dpy, plot->window, added_text + 1);
	//		}
	///#else
			if (button_pressed == 0)
			{
				cursor_save = cursor;
				cursor = cursor_waiting;
				if (current_plot != null)
				XDefineCursor(dpy, current_plot.window, cursor);
			}
	///#endif
	///#endif
			/* continue; */
			/* return 1; To do: Should a "return" be here?  Gnuplot usually sends 'G' followed by other commands.  So perhaps not needed. DJS */
		}
			break;
		case 'N': // just update the plot number
		{
			int itmp;
			if (strcspn(buf + 1, " \n") && sscanf(buf, "N%d", itmp))
			{
				if (itmp >= 0)
				{
				most_recent_plot_number = itmp;
				current_plot = GlobalMembersGplt_x11.Add_Plot_To_Linked_List(itmp);
				}
			}
			return 1;
		}
			break;
	///#ifdef EXTERNAL_X11_WINDOW
		case DefineConstants.X11_GR_SET_WINDOW_ID: // X11 window ID
		{
			int ultmp;
			if (strcspn(buf + 1," \n") && sscanf(buf + 1, "%lx", ultmp))
			{
				Window window_id = (Window) ultmp;
				plot_struct tmpplot = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Window(window_id);
				if (tmpplot != null)
				{
				current_plot = tmpplot;
				most_recent_plot_number = tmpplot.plot_number;
				}
				else
				{
				current_plot = GlobalMembersGplt_x11.Add_Plot_To_Linked_List(-1); // Use invalid plot number.
				if (current_plot != null)
				{
					current_plot.external_container = window_id;
					GlobalMembersGplt_x11.prepare_plot(current_plot);
				}
				}
			}
			return 1;
		}
			break;
	///#endif
		case 'C': // close the plot with given number
		{
			int itmp;
			if (strcspn(buf + 1, " \n") && sscanf(buf, "C%d", itmp))
			{
				plot_struct psp;
				if ((psp = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Number(itmp)))
				GlobalMembersGplt_x11.Remove_Plot_From_Linked_List(psp.window);
			}
			else if (current_plot != null)
			{
				GlobalMembersGplt_x11.Remove_Plot_From_Linked_List(current_plot.window);
			}
			return 1;
		}
			break;
		case '^': // raise the plot with given number or the whole group
		{
			int itmp;
			if (strcspn(buf + 1," \n") && sscanf(buf, "^%d", itmp))
			{
				plot_struct psp;
				if ((psp = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Number(itmp)))
				{
				XRaiseWindow(dpy, psp.window);
				}
			}
			else
			{
				/* Find end of list, i.e., first created. */
				plot_struct psp = plot_list_start;
				while (psp != DefineConstants.NULL)
				{
				if (psp.next_plot == DefineConstants.NULL)
					break;
				psp = psp.next_plot;
				}
				while (psp != DefineConstants.NULL)
				{
				XRaiseWindow(dpy, psp.window);
				psp = psp.prev_plot;
				}
			}
			return 1;
		}
			break;
		case 'v': // lower the plot with given number or the whole group
		{
			int itmp;
			if (strcspn(buf + 1," \n") && sscanf(buf, "v%d", itmp))
			{
				plot_struct psp;
				if ((psp = GlobalMembersGplt_x11.Find_Plot_In_Linked_List_By_Number(itmp)))
				{
				XLowerWindow(dpy, psp.window);
				}
			}
			else if (current_plot != null)
			{
				plot_struct psp = plot_list_start;
				while (psp != DefineConstants.NULL)
				{
				XLowerWindow(dpy, psp.window);
				psp = psp.next_plot;
				}
			}
			return 1;
		}
			break;
		case 'n': // update the plot name (title)
		{
			if (current_plot == null)
				current_plot = GlobalMembersGplt_x11.Add_Plot_To_Linked_List(most_recent_plot_number);
			if (current_plot != null)
			{
				String cp;
				if (current_plot.titlestring != null)
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
				free(current_plot.titlestring);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
				if ((current_plot.titlestring = (String) malloc(String.valueOf(buf + 1).length() + 1)))
				{
				current_plot.titlestring = buf + 1;
				cp = current_plot.titlestring;
				}
				else
				cp = "<lost name>";
				if (current_plot.window != null)
				XStoreName(dpy, current_plot.window, cp);
			}
			return 1;
		}
			break;
		case 'E': // leave graphics mode / suspend
			if (current_plot != null)
			GlobalMembersGplt_x11.display(current_plot);
	///#ifdef USE_MOUSE
			if (current_plot != null)
			GlobalMembersGplt_x11.gp_execute_GE_plotdone(current_plot.window); // notify main program
	///#endif
			return 1;
		case 'R': // leave x11 mode
			GlobalMembersGplt_x11.reset_cursor();
			return 0;

		case DefineConstants.X11_GR_MAKE_PALETTE:
			if (have_pm3d != 0)
			{
			String cmapidx = "e";
			int cm_index;
				cmap_struct csp;
			/* Get and process palette */
			GlobalMembersGplt_x11.scan_palette_from_buf();
			/* Compute and store the resulting colormap index as a command
			 * so that a palette change can be made on the same plot. */
				csp = current_plot.first_cmap_struct;
				for (cm_index = 0; csp; cm_index++)
				{
				if (csp.cmap == current_cmap)
				break;
				csp = csp.next_cmap_struct;
				}
			String.format(cmapidx + 1, "%3u%c", cm_index, '\0');
			GlobalMembersGplt_x11.store_command(cmapidx, current_plot);
			}
			return 1;

		case DefineConstants.X11_GR_CHECK_ENDIANESS:
		{
				/* Initialize variable in case short happens to be longer than two bytes. */
			short tmp = (short) DefineConstants.ENDIAN_VALUE;
			((String) & tmp)[0] = buf.charAt(1);
			((String) & tmp)[1] = buf.charAt(2);
			if (tmp == (short) DefineConstants.ENDIAN_VALUE)
				swap_endian = false;
			else
				swap_endian = true;
		}
			return 1;

		case 'X': // tell the driver about do_raise /  persist
		{
			int tmp_do_raise = AnonymousEnum2.UNSET.getValue();
			int tmp_persist = AnonymousEnum2.UNSET.getValue();
			int tmp_dashed = AnonymousEnum2.UNSET.getValue();
			int tmp_ctrlq = AnonymousEnum2.UNSET.getValue();
			sscanf(buf, "X%d%d%d%d", tmp_do_raise, tmp_persist, tmp_dashed, tmp_ctrlq);
			if (AnonymousEnum2.UNSET.getValue() != tmp_do_raise)
				do_raise = tmp_do_raise;
			if (AnonymousEnum2.UNSET.getValue() != tmp_persist)
				persist = tmp_persist;
			if (AnonymousEnum2.UNSET.getValue() != tmp_dashed)
				dashedlines = tmp_dashed;
			if (AnonymousEnum2.UNSET.getValue() != tmp_ctrlq)
				ctrlq = tmp_ctrlq;
		}
			return 1;

			case 's': // set window geometry
			{
			String strtmp = new String(new char[256]);
			sscanf(buf.charAt(2), "%s", strtmp);
			GlobalMembersGplt_x11.pr_geometry(strtmp);
			}
			return 1;

	///#ifdef USE_MOUSE
		case 'u':
	///#ifdef PIPE_IPC
			if (GlobalMembersGpexecute.pipe_died == 0)
	///#endif
			{
			/* `set cursor' */
			int c;
			int x;
			int y;
			sscanf(buf, "u%4d%4d%4d", c, x, y);
			if (current_plot != null)
			{
				switch (c)
				{
				case -4: // switch off line between ruler and mouse cursor
				GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
				current_plot.ruler_lineto_on = false;
				break;
				case -3: // switch on line between ruler and mouse cursor
				if (current_plot.ruler_on && current_plot.ruler_lineto_on)
					break;
				current_plot.ruler_lineto_x = (int)((x) * xscale);
				current_plot.ruler_lineto_y = (int)((4095 - (y)) * yscale);
				current_plot.ruler_lineto_on = true;
				GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
				break;
				case -2: // warp pointer
				XWarpPointer(dpy, None, current_plot.window, 0, 0, 0, 0, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
				case -1: // zoombox
				current_plot.zoombox_x1 = current_plot.zoombox_x2 = (int)((x) * xscale);
				current_plot.zoombox_y1 = current_plot.zoombox_y2 = (int)((4095 - (y)) * yscale);
				current_plot.zoombox_on = true;
				GlobalMembersGplt_x11.DrawBox(current_plot);
				break;
				case 0: // standard cross-hair cursor
				cursor = cursor_default;
				XDefineCursor(dpy, current_plot.window, cursor);
				break;
				case 1: // cursor during rotation
				cursor = cursor_exchange;
				XDefineCursor(dpy, current_plot.window, cursor);
				break;
				case 2: // cursor during scaling
				cursor = cursor_sizing;
				XDefineCursor(dpy, current_plot.window, cursor);
				break;
				case 3: // cursor during zooming
				cursor = cursor_zooming;
				XDefineCursor(dpy, current_plot.window, cursor);
				break;
				}
				if (c >= 0 && current_plot.zoombox_on)
				{
				/* erase zoom box */
				GlobalMembersGplt_x11.DrawBox(current_plot);
				current_plot.zoombox_on = false;
				}
				if (c >= 0 && current_plot.ruler_lineto_on)
				{
				/* erase line from ruler to cursor */
				GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
				current_plot.ruler_lineto_on = false;
				}
			}
			}
			return 1;

		case 't':
	///#ifdef PIPE_IPC
			if (GlobalMembersGpexecute.pipe_died == 0)
	///#endif
			{
			int where;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * second;
			if (sscanf(buf, "t%4d", where) != 1)
				return 1;
			buf = buf.substring(0, buf.length() - 1); // remove trailing \n
			if (current_plot != null)
			{
				switch (where)
				{
				case 0:
				GlobalMembersGplt_x11.DisplayCoords(current_plot, buf + 5);
				break;
				case 1:
				second = tangible.StringFunctions.strChr(buf + 5, '\r');
				if (second == DefineConstants.NULL)
				{
					*(current_plot.zoombox_str1a) = '\0';
					*(current_plot.zoombox_str1b) = '\0';
					break;
				}
				*second = 0;
				second++;
				if (current_plot.zoombox_on)
					GlobalMembersGplt_x11.DrawBox(current_plot);
				current_plot.zoombox_str1a = buf + 5;
				current_plot.zoombox_str1b = second;
				if (current_plot.zoombox_on)
					GlobalMembersGplt_x11.DrawBox(current_plot);
				break;
				case 2:
				second = tangible.StringFunctions.strChr(buf + 5, '\r');
				if (second == DefineConstants.NULL)
				{
					*(current_plot.zoombox_str2a) = '\0';
					*(current_plot.zoombox_str2b) = '\0';
					break;
				}
				*second = 0;
				second++;
				if (current_plot.zoombox_on)
					GlobalMembersGplt_x11.DrawBox(current_plot);
				current_plot.zoombox_str2a = buf + 5;
				current_plot.zoombox_str2b = second;
				if (current_plot.zoombox_on)
					GlobalMembersGplt_x11.DrawBox(current_plot);
				break;
				}
			}
			}
			return 1;

		case 'r':
	///#ifdef PIPE_IPC
			if (GlobalMembersGpexecute.pipe_died == 0)
	///#endif
			{
			if (current_plot != null)
			{
				int x;
				int y;
				GlobalMembersGplt_x11.DrawRuler(current_plot); // erase previous ruler
				sscanf(buf, "r%4d%4d", x, y);
				if (x < 0)
				{
				GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
				current_plot.ruler_on = false;
				}
				else
				{
				current_plot.ruler_on = true;
				current_plot.ruler_x = x;
				current_plot.ruler_y = y;
				current_plot.ruler_lineto_x = (int)((x) * xscale);
				current_plot.ruler_lineto_y = (int)((4095 - (y)) * yscale);
				GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
				}
				GlobalMembersGplt_x11.DrawRuler(current_plot); // draw new one
			}
			}
			return 1;

		case 'z':
	///#ifdef PIPE_IPC
			if (GlobalMembersGpexecute.pipe_died == 0)
	///#endif
			{
			int len = String.valueOf(buf + 1).length() - 1; // discard newline '\n'
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in Java:
			memcpy(selection, buf + 1, len < DefineConstants.SEL_LEN ? len : DefineConstants.SEL_LEN);
			/* terminate */
			selection = tangible.StringFunctions.changeCharacter(selection, len + 1 < DefineConstants.SEL_LEN ? len + 1 : DefineConstants.SEL_LEN - 1, '\0');
			XStoreBytes(dpy, buf + 1, len);
			XFlush(dpy);
	///#ifdef EXPORT_SELECTION
			if (current_plot != null && exportselection)
				GlobalMembersGplt_x11.export_graph(current_plot);
	///#endif
			}
			return 1;
	///#endif
	///#ifdef USE_MOUSE
		case 'Q':
			/* Set default font immediately and return size info through pipe */
			if (buf.charAt(1) == 'G')
			{
			int scaled_hchar;
			int scaled_vchar;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * c = &(buf.charAt(buf.length() - 1));
			while (*c <= ' ')
				*c--= '\0';
			default_font = String.valueOf(buf.charAt(2)).substring(0, String.valueOf(buf.charAt(2)).length() + 1);
			GlobalMembersGplt_x11.pr_font(DefineConstants.NULL);
			if (current_plot != null)
			{
				/* EAM FIXME - this is all out of order; initialization doesnt */
				/*             happen until term->graphics() is called.        */
				xscale = (current_plot.width > 0) ? current_plot.width / 4096.: gW / 4096.;
				yscale = (current_plot.height > 0) ? current_plot.height / 4096.: gH / 4096.;
				scaled_hchar = (1.0 / xscale) * hchar;
				scaled_vchar = (1.0 / yscale) * vchar;
				GlobalMembersFit.a((stderr, "gplt_x11: preset default font to %s hchar = %d vchar = %d \n", default_font, scaled_hchar, scaled_vchar));
				GlobalMembersGpexecute.gp_exec_event(AnonymousEnum.GE_fontprops, current_plot.width, current_plot.height, scaled_hchar, scaled_vchar, 0);
			}
			return 1;
			}
			/* fall through */
	///#endif
		default:
			if (current_plot != null)
			GlobalMembersGplt_x11.store_command(buf, current_plot);
			continue;
		}
		}
		if (feof(X11_ipc) || ferror(X11_ipc))
		return 0;
		else
		return 1;
	}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to events in Java:
	//static void process_event(XEvent *event)
	//{
	//	plot_struct *current_plot;
	//	KeySym keysym;
	//	sbyte key_sequence[8];
	//
	//	a((stderr, "Event 0x%x\n", event->type));
	//
	//	switch (event->type)
	//	{
	//	case ConfigureNotify:
	//	process_configure_notify_event(event);
	//	break;
	//
	//	case KeyPress:
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xkey.window);
	//
	// /* Unlike XKeycodeToKeysym, XLookupString applies the current */
	// /* shift, ctrl, alt, and meta modifiers to yield a character. */
	// /* keysym = XKeycodeToKeysym(dpy, event->xkey.keycode, 0); */
	//	XLookupString((XKeyEvent *)event, key_sequence, sizeof(key_sequence), &keysym, DefineConstants.NULL);
	//
	/////#ifdef USE_MOUSE
	//	update_modifiers(event->xkey.state);
	/////#endif
	//		switch (keysym)
	//		{
	/////#ifdef USE_MOUSE
	//
	/////#ifndef DISABLE_SPACE_RAISES_CONSOLE
	//		case ' ':
	//		{
	//		static int cmd_tried = 0;
	//		static sbyte *cmd = DefineConstants.NULL;
	//		static int newGnuplotXID = 0;
	//
	// /* If the "-ctrlq" resource is set, ignore ' ' unless control key is also pressed */
	//		if (ctrlq && !(modifier_mask & Mod_Ctrl))
	//			break;
	//
	//		if (!cmd_tried)
	//		{
	//			cmd = getMultiTabConsoleSwitchCommand(&newGnuplotXID);
	//			cmd_tried = 1;
	//		}
	// /* overwrite gnuplotXID (re)set after x11.trm:X11_options() */
	//		if (newGnuplotXID)
	//			gnuplotXID = newGnuplotXID;
	//		if (cmd)
	//			system(cmd);
	//		}
	//		if (gnuplotXID)
	//		{
	//			XMapRaised(dpy, gnuplotXID);
	//			XSetInputFocus(dpy, gnuplotXID, 0, CurrentTime); //revert
	//			XFlush(dpy);
	//		}
	//		return;
	/////#endif	// DISABLE_SPACE_RAISES_CONSOLE
	//
	//		case 'm': // Toggle mouse display, but only if we control the window here
	/////#ifdef PIPE_IPC
	//		if (((current_plot != current_plot) && (!modifier_mask))|| pipe_died)
	/////#else
	////        if (((plot != current_plot) && (!modifier_mask))
	/////#endif
	//		{
	//			current_plot->mouse_on = !(current_plot->mouse_on);
	//			DisplayCoords(current_plot, current_plot->mouse_on ? " " : "");
	//		}
	//		break;
	/////#endif
	//		case 'q':
	/////#ifdef USE_MOUSE
	// /* If the "-ctrlq" resource is set, ignore q unless control key is also pressed */
	//		if (ctrlq && !(modifier_mask & Mod_Ctrl))
	//		{
	//			a((stderr, "ignoring q, modifier_mask = %o\n", modifier_mask));
	//			break;
	//		}
	/////#endif
	// /* close X window */
	//		Remove_Plot_From_Linked_List(event->xkey.window);
	//		return;
	//		default:
	//		break;
	//		} // switch (keysym)
	/////#ifdef USE_MOUSE
	//
	//	if (is_meta(keysym))
	//		return;
	//
	//	switch (keysym)
	//	{
	//
	//#define KNOWN_KEYSYMS (gp_keysym) if (current_plot == current_plot) { gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), gp_keysym, 0, current_plot->plot_number); } else { gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), gp_keysym, 0, current_plot->plot_number); } return;
	//
	// /* Prevent hysteresis if redraw cannot keep up with rate of keystrokes */
	//#define DRAIN_KEYSTROKES(key) if (plot == current_plot) { while (XCheckTypedWindowEvent(dpy, event->xany.window, KeyPress, event)); }
	//
	//	case XK_BackSpace:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_BackSpace, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_BackSpace, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Tab:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Tab, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Tab, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Linefeed:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Linefeed, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Linefeed, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Clear:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Clear, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Clear, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Return:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Return, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Return, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Pause:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Pause, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Pause, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Scroll_Lock:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Scroll_Lock, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Scroll_Lock, 0, current_plot->plot_number);
	//		}
	//		return;
	/////#ifdef XK_Sys_Req
	////	case XK_Sys_Req:
	////	    KNOWN_KEYSYMS(GP_Sys_Req);
	/////#endif
	//	case XK_Escape:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Escape, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Escape, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Insert:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Insert, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Insert, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Delete:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Delete, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Delete, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Home:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Home, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Home, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Left:
	//		(key) if (current_plot == current_plot) { while (XCheckTypedWindowEvent(dpy, event->xany.window, KeyPress, event)); }(XK_Left);
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Left, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Left, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Up:
	//		(key) if (current_plot == current_plot) { while (XCheckTypedWindowEvent(dpy, event->xany.window, KeyPress, event)); }(XK_Up);
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Up, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Up, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Right:
	//		(key) if (current_plot == current_plot) { while (XCheckTypedWindowEvent(dpy, event->xany.window, KeyPress, event)); }(XK_Right);
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Right, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Right, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Down:
	//		(key) if (current_plot == current_plot) { while (XCheckTypedWindowEvent(dpy, event->xany.window, KeyPress, event)); }(XK_Down);
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Down, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Down, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Prior: // XXX
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_PageUp, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_PageUp, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Next: // XXX
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_PageDown, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_PageDown, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_End:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_End, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_End, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_Begin:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Begin, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_Begin, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Space:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Space, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Space, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Tab:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Tab, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Tab, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Enter:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Enter, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Enter, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_F1:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F1, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F1, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_F2:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F2, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F2, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_F3:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F3, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F3, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_F4:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F4, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_F4, 0, current_plot->plot_number);
	//		}
	//		return;
	/////#ifdef XK_KP_Home
	////	case XK_KP_Home:
	////	    KNOWN_KEYSYMS(GP_KP_Home);
	/////#endif
	/////#ifdef XK_KP_Left
	////	case XK_KP_Left:
	////	    KNOWN_KEYSYMS(GP_KP_Left);
	/////#endif
	/////#ifdef XK_KP_Up
	////	case XK_KP_Up:
	////	    KNOWN_KEYSYMS(GP_KP_Up);
	/////#endif
	/////#ifdef XK_KP_Right
	////	case XK_KP_Right:
	////	    KNOWN_KEYSYMS(GP_KP_Right);
	/////#endif
	/////#ifdef XK_KP_Down
	////	case XK_KP_Down:
	////	    KNOWN_KEYSYMS(GP_KP_Down);
	/////#endif
	/////#ifdef XK_KP_Page_Up
	////	case XK_KP_Page_Up:
	////	    KNOWN_KEYSYMS(GP_KP_Page_Up);
	/////#endif
	/////#ifdef XK_KP_Page_Down
	////	case XK_KP_Page_Down:
	////	    KNOWN_KEYSYMS(GP_KP_Page_Down);
	/////#endif
	/////#ifdef XK_KP_End
	////	case XK_KP_End:
	////	    KNOWN_KEYSYMS(GP_KP_End);
	/////#endif
	/////#ifdef XK_KP_Begin
	////	case XK_KP_Begin:
	////	    KNOWN_KEYSYMS(GP_KP_Begin);
	/////#endif
	/////#ifdef XK_KP_Insert
	////	case XK_KP_Insert:
	////	    KNOWN_KEYSYMS(GP_KP_Insert);
	/////#endif
	/////#ifdef XK_KP_Delete
	////	case XK_KP_Delete:
	////	    KNOWN_KEYSYMS(GP_KP_Delete);
	/////#endif
	//	case XK_KP_Equal:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Equal, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Equal, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Multiply:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Multiply, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Multiply, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Add:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Add, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Add, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Separator:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Separator, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Separator, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Subtract:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Subtract, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Subtract, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Decimal:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Decimal, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Decimal, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_Divide:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Divide, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_Divide, 0, current_plot->plot_number);
	//		}
	//		return;
	//
	//	case XK_KP_0:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_0, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_0, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_1:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_1, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_1, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_2:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_2, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_2, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_3:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_3, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_3, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_4:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_4, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_4, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_5:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_5, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_5, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_6:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_6, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_6, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_7:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_7, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_7, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_8:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_8, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_8, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_KP_9:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_9, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_KP_9, 0, current_plot->plot_number);
	//		}
	//		return;
	//
	//	case XK_F1:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F1, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F1, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F2:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F2, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F2, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F3:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F3, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F3, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F4:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F4, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F4, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F5:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F5, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F5, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F6:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F6, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F6, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F7:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F7, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F7, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F8:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F8, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F8, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F9:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F9, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F9, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F10:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F10, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F10, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F11:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F11, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F11, 0, current_plot->plot_number);
	//		}
	//		return;
	//	case XK_F12:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F12, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), GP_F12, 0, current_plot->plot_number);
	//		}
	//		return;
	//
	//	default:
	//		if (current_plot == current_plot)
	//		{
	//			gp_exec_event(GE_keypress, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), (int) keysym, 0, current_plot->plot_number);
	//		}
	//		else
	//		{
	//			gp_exec_event(GE_keypress_old, (int)(((event->xkey.x)+0.5)/xscale), (int)(4095-((event->xkey.y)+0.5)/yscale), (int) keysym, 0, current_plot->plot_number);
	//		}
	//		return;
	//		break;
	//	}
	/////#endif
	//	break;
	//	case KeyRelease:
	/////#ifdef USE_MOUSE
	//	update_modifiers(event->xkey.state);
	//	keysym = XKeycodeToKeysym(dpy, event->xkey.keycode, 0);
	//	if (is_meta(keysym))
	//	{
	//		current_plot = Find_Plot_In_Linked_List_By_Window(event->xkey.window);
	//		cursor = cursor_default;
	//		if (current_plot)
	//		XDefineCursor(dpy, current_plot->window, cursor);
	//	}
	/////#endif
	//	break;
	//
	//	case ClientMessage:
	//	if (event->xclient.message_type == WM_PROTOCOLS && event->xclient.format == 32 && event->xclient.data.l[0] == WM_DELETE_WINDOW)
	//	{
	//		Remove_Plot_From_Linked_List(event->xclient.window);
	// /* EAM FIXME - may have to generate GE_reset event here also */
	//	}
	//	break;
	//
	/////#ifdef USE_MOUSE
	//	case DestroyNotify:
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xconfigure.window);
	//	if (current_plot == current_plot)
	//	{
	//		gp_exec_event(GE_reset, 0, 0, 0, 0, 0);
	//	}
	//	break;
	//
	//	case Expose:
	// /*
	//  * we need to handle expose events here, because
	//  * there might stuff like rulers which has to
	//  * be redrawn. Well. It's not really hard to handle
	//  * this. Note that the x and y fields are not used
	//  * to update the pointer pos because the pointer
	//  * might be on another window which generates the
	//  * expose events. (joze)
	//  */
	//
	// /* Check for any ConfigureNotify events further down in the X11
	//  * event queue. If one is found, handle it first and let the
	//  * expose event that is generated be handled later.
	//  * Jay Painter Nov 2003.
	//  */
	//	if (XCheckTypedWindowEvent(dpy, event->xany.window, ConfigureNotify, event))
	//	{
	//		process_configure_notify_event(event);
	//		break;
	//	}
	//	while (XCheckTypedWindowEvent(dpy, event->xany.window, Expose, event));
	//
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xexpose.window);
	//
	//	if (current_plot)
	//		UpdateWindow(current_plot);
	//	break;
	//
	//	case EnterNotify:
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xcrossing.window);
	//	if (!current_plot)
	//		break;
	//	if (current_plot == current_plot)
	//	{
	//		if (xscale<0.)
	//			display(current_plot);
	//		gp_exec_event(GE_motion, (int)(((event->xcrossing.x)+0.5)/xscale), (int)(4095-((event->xcrossing.y)+0.5)/yscale), 0, 0, 0);
	//	}
	//	if (current_plot->zoombox_on)
	//	{
	//		DrawBox(current_plot);
	//		current_plot->zoombox_x2 = event->xcrossing.x;
	//		current_plot->zoombox_y2 = event->xcrossing.y;
	//		DrawBox(current_plot);
	//	}
	//	if (current_plot->ruler_on)
	//	{
	//		DrawLineToRuler(current_plot);
	//		current_plot->ruler_lineto_x = event->xcrossing.x;
	//		current_plot->ruler_lineto_y = event->xcrossing.y;
	//		DrawLineToRuler(current_plot);
	//	}
	//	break;
	//	case MotionNotify:
	//	update_modifiers(event->xmotion.state);
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xmotion.window);
	//	if (!current_plot)
	//		break;
	//	{
	//		Window root, child;
	//		int root_x, root_y, pos_x, pos_y;
	//		int keys_buttons;
	//		if (!XQueryPointer(dpy, event->xmotion.window, &root, &child, &root_x, &root_y, &pos_x, &pos_y, &keys_buttons))
	//		break;
	//
	/////#ifdef PIPE_IPC
	//		if (current_plot == current_plot&& !pipe_died)
	/////#else
	////        if (plot == current_plot
	/////#endif
	//		{
	//		if (xscale<0.)
	//			display(current_plot);
	//		gp_exec_event(GE_motion, (int)(((pos_x)+0.5)/xscale), (int)(4095-((pos_y)+0.5)/yscale), 0, 0, 0);
	/////#if defined(USE_MOUSE) && defined(MOUSE_ALL_WINDOWS)
	//		}
	//		else if (current_plot->axis_mask && current_plot->mouse_on && current_plot->almost2d)
	//		{
	// /* This is not the active plot window, but we can still update the mouse coords */
	//		sbyte mouse_format[60];
	//		sbyte *m = mouse_format;
	//		double x, y, x2, y2;
	//
	//		*m = '\0';
	//		mouse_to_coords(current_plot, event, &x, &y, &x2, &y2);
	//		if (current_plot->axis_mask & (1<<FIRST_X_AXIS))
	//		{
	//			sprintf(m, "x=  %10g %c", x, '\0');
	//			m += 15;
	//		}
	//		if (current_plot->axis_mask & (1<<SECOND_X_AXIS))
	//		{
	//			sprintf(m, "x2= %10g %c", x2, '\0');
	//			m += 15;
	//		}
	//		if (current_plot->axis_mask & (1<<FIRST_Y_AXIS))
	//		{
	//			sprintf(m, "y=  %10g %c", y, '\0');
	//			m += 15;
	//		}
	//		if (current_plot->axis_mask & (1<<SECOND_Y_AXIS))
	//		{
	//			sprintf(m, "y2= %10g %c", y2, '\0');
	//			m += 15;
	//		}
	//		DisplayCoords(current_plot, mouse_format);
	//		}
	//		else if (!current_plot->mouse_on)
	//		{
	//		DisplayCoords(current_plot, "");
	/////#endif
	//		}
	//
	//		if (current_plot->zoombox_on)
	//		{
	//		DrawBox(current_plot);
	//		current_plot->zoombox_x2 = pos_x;
	//		current_plot->zoombox_y2 = pos_y;
	//		DrawBox(current_plot);
	//		}
	//		if (current_plot->ruler_on && current_plot->ruler_lineto_on)
	//		{
	//		DrawLineToRuler(current_plot);
	//		current_plot->ruler_lineto_x = event->xcrossing.x;
	//		current_plot->ruler_lineto_y = event->xcrossing.y;
	//		DrawLineToRuler(current_plot);
	//		}
	//	}
	//	break;
	//	case ButtonPress:
	//	update_modifiers(event->xbutton.state);
	/////#ifndef TITLE_BAR_DRAWING_MSG
	//	button_pressed |= (1 << event->xbutton.button);
	/////#endif
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xbutton.window);
	//	if (!current_plot)
	//		break;
	//	{
	//		if (current_plot == current_plot)
	//		{
	//		if (xscale<0.)
	//			display(current_plot);
	//		gp_exec_event(GE_buttonpress, (int)(((event->xbutton.x)+0.5)/xscale), (int)(4095-((event->xbutton.y)+0.5)/yscale), event->xbutton.button, 0, 0);
	//		}
	//	}
	//	break;
	//	case ButtonRelease:
	/////#ifndef TITLE_BAR_DRAWING_MSG
	//	button_pressed &= ~(1 << event->xbutton.button);
	/////#endif
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xbutton.window);
	//	if (!current_plot)
	//		break;
	//	if (current_plot == current_plot)
	//	{
	//
	//		int doubleclick = SetTime(current_plot, event->xbutton.time);
	//
	//		update_modifiers(event->xbutton.state);
	//		if (xscale<0.)
	//			display(current_plot);
	//		gp_exec_event(GE_buttonrelease, (int)(((event->xbutton.x)+0.5)/xscale), (int)(4095-((event->xbutton.y)+0.5)/yscale), event->xbutton.button, (int) doubleclick, 0);
	//	}
	//
	/////#ifdef DEBUG
	/////#if defined(USE_MOUSE) && defined(MOUSE_ALL_WINDOWS)
	//// /* This causes gnuplot_x11 to pass mouse clicks back from all plot windows,
	////  * not just the current plot. But who should we notify that a click has
	////  * happened, and how?  The fprintf to stderr is just for debugging. */
	////	else if (plot->axis_mask) {
	////	    double x, y, x2, y2;
	////	    mouse_to_coords(plot, event, &x, &y, &x2, &y2);
	////	    fprintf(stderr, "gnuplot_x11 %d: mouse button %1d from window %d at %g %g\n",
	////		    __LINE__, event->xbutton.button, (plot ? plot->plot_number : 0), x, y);
	////	}
	/////#endif
	/////#endif
	//
	//	break;
	/////#endif // USE_MOUSE
	/////#ifdef EXPORT_SELECTION
	//	case SelectionNotify:
	//	break;
	//	case SelectionRequest:
	//	if (exportselection)
	//		handle_selection_event(event);
	//	break;
	/////#endif
	//
	//	}
	//}
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to events in Java:
	//static void process_configure_notify_event(XEvent *event);

/*-----------------------------------------------------------------------------
 *   mainloop processing - process X events and input from gnuplot
 *
 *   Three different versions of main loop processing are provided to support
 *   three different platforms.
 *
 *   DEFAULT_X11:     use select() for both X events and input on stdin
 *                    from gnuplot inboard driver
 *
 *   CRIPPLED_SELECT: use select() to service X events and check during
 *                    select timeout for temporary plot file created
 *                    by inboard driver
 *
 *   VMS:             use XNextEvent to service X events and AST to
 *                    service input from gnuplot inboard driver on stdin
 *---------------------------------------------------------------------------*/


///#ifdef DEFAULT_X11

/*
 * DEFAULT_X11 mainloop
 */

	public static void mainloop()
	{
		int nf;
		int cn = ConnectionNumber(dpy);
		int in;
		int nfds;
		timeval timeout = new timeval();
		timeval timer = (GlobalMembersMouse.struct timeval *) 0;
		fd_set tset = new fd_set();

	///#ifdef PIPE_IPC
		int usleep_count = 0;
		int out;
		out = fileno(stdout);
	///#endif

		X11_ipc = stdin;
		in = fileno(X11_ipc);

	///#ifdef PIPE_IPC
		if (out > in)
		nfds = ((cn > out) ? cn : out) + 1;
		else
	///#endif
		nfds = ((cn > in) ? cn : in) + 1;

	///#ifdef ISC22
	// /* Added by Robert Eckardt, RobertE@beta.TP2.Ruhr-Uni-Bochum.de */
	//    timeout.tv_sec = 0;		// select() in ISC2.2 needs timeout
	//    timeout.tv_usec = 300000;	// otherwise input from gnuplot is
	//    timer = &timeout;		// suspended til next X event.
	///#endif // ISC22   (0.3s are short enough not to be noticed

		while (true)
		{

		/* XNextEvent does an XFlush() before waiting. But here.
		 * we must ensure that the queue is flushed, since we
		 * dont call XNextEvent until an event arrives. (I have
		 * twice wasted quite some time over this issue, so now
		 * I am making sure of it !
		 */

		XFlush(dpy);

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		memset((String)(tset), '\0', sizeof(*(tset)));
		((tset).fds_bits[0] |= (1 << ((cn) % 32)));

		/* Don't wait for events if we know that input is
		 * already sitting in a buffer.  Also don't wait for
		 * input to become available.
		 */
		if (buffered_input_available != 0)
		{
			timeout.tv_sec = 0;
			timeout.tv_usec = 0;
			timer = timeout;
		}
		else
		{
			timer = (GlobalMembersMouse.struct timeval *) 0;
			((tset).fds_bits[0] |= (1 << ((in) % 32)));
		}

	///#ifdef PIPE_IPC
		if (GlobalMembersGpexecute.buffered_output_pending != 0 && GlobalMembersGpexecute.pipe_died == 0)
		{
			/* check, if stdout becomes writable */
			((tset).fds_bits[0] |= (1 << ((out) % 32)));
		}
	///#ifdef HAVE_USLEEP
		/* Make sure this loop does not monopolize CPU if the pipe is jammed */
		if (++usleep_count > 10)
		{
			usleep(100);
			usleep_count = 0;
		}
	///#endif
	///#endif

		nf = select(nfds, fd_set * tset, 0, 0, GlobalMembersMouse.struct timeval timer);

		if (nf < 0)
		{
			if (errno == EINTR)
			continue;
			perror("gnuplot_x11: select failed");
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
		}

		if (nf > 0)
			XNoOp(dpy);

		if (XPending(dpy))
		{
			/* used to use CheckMaskEvent() but that cannot receive
			 * maskable events such as ClientMessage. So now we do
			 * one event, then return to the select.
			 * And that almost works, except that under some Xservers
			 * running without a window manager (e.g. Hummingbird Exceed under Win95)
			 * a bogus ConfigureNotify is sent followed by a valid ConfigureNotify
			 * when the window is maximized.  The two events are queued, apparently
			 * in a single I/O because select() above doesn't see the second, valid
			 * event.  This little loop fixes the problem by flushing the
			 * event queue completely.
			 */
			XEvent xe = new XEvent();
			do
			{
			XNextEvent(dpy, xe);
			process_event(xe);
			} while (XPending(dpy));
		}

		if (((tset).fds_bits[0] & (1 << ((in) % 32))) || buffered_input_available != 0)
		{
			if (GlobalMembersGplt_x11.record() == 0) // end of input
			return;
		}
	///#ifdef PIPE_IPC
		if (GlobalMembersGpexecute.pipe_died == 0 && (((tset).fds_bits[0] & (1 << ((out) % 32))) || GlobalMembersGpexecute.buffered_output_pending != 0))
		{
			GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
		}
	///#endif
		/* A method in which the ErrorHandler can queue plots to be
		   removed from the linked list.  This prevents the situation
		   that could arise if the ErrorHandler directly removed
		   plots and some other part of the program were utilizing
		   a pointer to a plot that was destroyed. */
		if (process_remove_fifo_queue != 0)
		{
			GlobalMembersGplt_x11.Process_Remove_FIFO_Queue();
		}
		}
	}

/*
 *   display - display a stored plot
 */

	public static void display(plot_struct current_plot)
	{
		int n;

		GlobalMembersFit.a((stderr, "Display %d ; %d commands\n", current_plot.plot_number, current_plot.ncommands));

		if (current_plot.ncommands == 0)
		return;

		/* set scaling factor between internal driver & window geometry */
		xscale = current_plot.width / 4096.0;
		yscale = ((current_plot).gheight) / 4096.0;

		/* initial point sizes, until overridden with P7xxxxyyyy */
		current_plot.px = (int)(xscale * pointsize);
		current_plot.py = (int)(yscale * pointsize);

		/* create new pixmap & GC */
		if (current_plot.pixmap == None)
		{
		GlobalMembersFit.a((stderr, "Create pixmap %d : %dx%dx%d\n", current_plot.plot_number, current_plot.width, ((current_plot).gheight + vchar), dep));
		current_plot.pixmap = XCreatePixmap(dpy, root, current_plot.width, ((current_plot).gheight + vchar), dep);
		}

		if (gc != null)
		XFreeGC(dpy, gc);

		gc = XCreateGC(dpy, current_plot.pixmap, 0, (XGCValues) 0);

		if (font != null)
		  GlobalMembersGplt_x11.gpXSetFont(dpy, gc, font.fid);

		XSetFillStyle(dpy, gc, FillSolid);

		/* initialize stipple for filled boxes (ULIG) */
		if (stipple_initialized == 0)
		{
		int i;
		for (i = 0; i < DefineConstants.stipple_pattern_num; i++)
			stipple_pattern[i] = XCreateBitmapFromData(dpy, current_plot.pixmap, stipple_pattern_bits[i], DefineConstants.stipple_pattern_width, DefineConstants.stipple_pattern_height);
		stipple_initialized = 1;
		}

		/* set pixmap background */
		XSetForeground(dpy, gc, current_plot.cmap.colors[0]);
		XFillRectangle(dpy, current_plot.pixmap, gc, 0, 0, current_plot.width, ((current_plot).gheight + vchar) + vchar);
		XSetBackground(dpy, gc, current_plot.cmap.colors[0]);

		if (current_plot.window == None)
		GlobalMembersGplt_x11.pr_window(current_plot);

		/* top the window but don't put keyboard or mouse focus into it. */
		if (do_raise != 0)
		XMapRaised(dpy, current_plot.window);

		/* momentarily clear the window first if requested */
		if (Clear != null)
		{
		XClearWindow(dpy, current_plot.window);
		XFlush(dpy);
		}
		/* loop over accumulated commands from inboard driver */
		for (n = 0; n < current_plot.ncommands; n++)
		{
		GlobalMembersGplt_x11.exec_cmd(current_plot, current_plot.commands[n]);
		}

	///#ifdef EXPORT_SELECTION
		if (exportselection)
		GlobalMembersGplt_x11.export_graph(current_plot);
	///#endif

		GlobalMembersGplt_x11.UpdateWindow(current_plot);
	///#ifdef USE_MOUSE
	///#ifdef TITLE_BAR_DRAWING_MSG
	//    if (plot->window) {
	// /* restore default window title */
	//	char *cp = plot->titlestring;
	//	if (!cp) cp = "";
	//	XStoreName(dpy, plot->window, cp);
	//    }
	///#else
		if (button_pressed == 0)
		{
		cursor = cursor_save != null ? cursor_save : cursor_default;
		cursor_save = (Cursor)0;
		XDefineCursor(dpy, current_plot.window, cursor);
		}
	///#endif
	///#endif
	}
	public static void UpdateWindow(plot_struct current_plot)
	{
	///#ifdef USE_MOUSE
		XEvent event = new XEvent();
	///#endif
	/* CRUFT CHECK 17jul2006.  I added a "None == plot->pixmap"
	 * to this test because I believe it may not be necessary
	 * to do anything if there is no Pixmap yet.
	 */
		if (None == current_plot.window || None == current_plot.pixmap)
		{
		return;
		}

	///#if 0 // START OF CRUFT
	////    if (plot->pixmap == None) {
	//// /* create a black background pixmap */
	////	FPRINTF((stderr, "Create pixmap %d : %dx%dx%d\n", plot->plot_number, plot->width, PIXMAP_HEIGHT(plot), dep));
	////	plot->pixmap = XCreatePixmap(dpy, root, plot->width, PIXMAP_HEIGHT(plot), dep);
	////	if (gc)
	////	    XFreeGC(dpy, gc);
	////	gc = XCreateGC(dpy, plot->pixmap, 0, (XGCValues *) 0);
	////	if (font)
	////	  gpXSetFont(dpy, gc, font->fid);
	//// /* set pixmap background */
	////	XSetForeground(dpy, gc, plot->cmap->colors[0]);
	////	XFillRectangle(dpy, plot->pixmap, gc, 0, 0, plot->width, PIXMAP_HEIGHT(plot) + vchar);
	////	XSetBackground(dpy, gc, plot->cmap->colors[0]);
	////    }
	///#endif // END OF CRUFT

		XSetWindowBackgroundPixmap(dpy, current_plot.window, current_plot.pixmap);
		XClearWindow(dpy, current_plot.window);

	///#ifdef USE_MOUSE
		GlobalMembersGplt_x11.EventuallyDrawMouseAddOns(current_plot);

		XFlush(dpy);

		/* XXX discard expose events. This is a kludge for
		 * preventing the event dispatcher calling UpdateWindow()
		 * and the latter again generating expose events, which
		 * again would trigger the event dispatcher ... (joze) XXX */
		while (XCheckWindowEvent(dpy, current_plot.window, ExposureMask, event))
		/* EMPTY */
	 ;	///#endif
	}

///#ifdef USE_MOUSE

/* Notify main program, send windowid for GPVAL_TERM_WINDOWID if it has been changed. */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int gp_execute_GE_plotdone_last_window_id = -1;
	///#ifdef USE_MOUSE
	public static void gp_execute_GE_plotdone(int windowid)
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int last_window_id = -1;
		if (windowid == gp_execute_GE_plotdone_last_window_id)
		GlobalMembersGpexecute.gp_exec_event(AnonymousEnum.GE_plotdone, 0, 0, 0, 0, 0);
		else
		{
		GlobalMembersGpexecute.gp_exec_event(AnonymousEnum.GE_plotdone, 0, 0, 0, 0, windowid);
		gp_execute_GE_plotdone_last_window_id = windowid;
		}
	}

	public static int ErrorHandler(Display display, XErrorEvent error_event)
	{
		/* Don't remove directly.  Main program might be using the memory. */
		() display; // avoid -Wunused warnings
		GlobalMembersGplt_x11.Add_Plot_To_Remove_FIFO_Queue((Window) error_event.resourceid);
		GlobalMembersGpexecute.gp_exec_event(AnonymousEnum.GE_reset, 0, 0, 0, 0, 0);
		return 0;
	}
	public static void DrawRuler(plot_struct current_plot)
	{
		if (current_plot.ruler_on)
		{
		int x = (int)((current_plot.ruler_x) * xscale);
		int y = (int)((4095 - (current_plot.ruler_y)) * yscale);
		if (gc_xor == null)
		{
			/* create a gc for `rubberbanding' (well ...) */
			GlobalMembersGplt_x11.GetGCXor(current_plot, gc_xor);
		}
		/* vertical line */
		XDrawLine(dpy, current_plot.window, gc_xor, x, 0, x, ((current_plot).gheight));
		/* horizontal line */
		XDrawLine(dpy, current_plot.window, gc_xor, 0, y, current_plot.width, y);
		}
	}
	public static void EventuallyDrawMouseAddOns(plot_struct current_plot)
	{
		GlobalMembersGplt_x11.DrawRuler(current_plot);
		GlobalMembersGplt_x11.DrawLineToRuler(current_plot);
		if (current_plot.zoombox_on)
		GlobalMembersGplt_x11.DrawBox(current_plot);
		GlobalMembersGplt_x11.DrawCoords(current_plot, current_plot.str);
		/*
		   TODO more ...
		 */
	}

/*
 * draw a box using the gc with the GXxor function.
 * This can be used to turn on *and off* a box. The
 * corners of the box are annotated with the strings
 * stored in the plot structure.
 */
	public static void DrawBox(plot_struct current_plot)
	{
		int width;
		int height;
		int X0 = current_plot.zoombox_x1;
		int Y0 = current_plot.zoombox_y1;
		int X1 = current_plot.zoombox_x2;
		int Y1 = current_plot.zoombox_y2;

		if (gc_xor_dashed == null)
		{
		GlobalMembersGplt_x11.GetGCXorDashed(current_plot, gc_xor_dashed);
		}

		if (X1 < X0)
		{
		int tmp = X1;
		X1 = X0;
		X0 = tmp;
		}

		if (Y1 < Y0)
		{
		int tmp = Y1;
		Y1 = Y0;
		Y0 = tmp;
		}

		width = X1 - X0;
		height = Y1 - Y0;

		XDrawRectangle(dpy, current_plot.window, gc_xor_dashed, X0, Y0, width, height);

		if (current_plot.zoombox_str1a.charAt(0) || current_plot.zoombox_str1b.charAt(0))
		{
	tangible.RefObject<String> tempRef_zoombox_str1a = new tangible.RefObject<String>(current_plot.zoombox_str1a);
	tangible.RefObject<String> tempRef_zoombox_str1b = new tangible.RefObject<String>(current_plot.zoombox_str1b);
		GlobalMembersGplt_x11.AnnotatePoint(current_plot, current_plot.zoombox_x1, current_plot.zoombox_y1, tempRef_zoombox_str1a, tempRef_zoombox_str1b);
		current_plot.zoombox_str1a = tempRef_zoombox_str1a.argvalue;
		current_plot.zoombox_str1b = tempRef_zoombox_str1b.argvalue;
		}
		if (current_plot.zoombox_str2a.charAt(0) || current_plot.zoombox_str2b.charAt(0))
		{
	tangible.RefObject<String> tempRef_zoombox_str2a = new tangible.RefObject<String>(current_plot.zoombox_str2a);
	tangible.RefObject<String> tempRef_zoombox_str2b = new tangible.RefObject<String>(current_plot.zoombox_str2b);
		GlobalMembersGplt_x11.AnnotatePoint(current_plot, current_plot.zoombox_x2, current_plot.zoombox_y2, tempRef_zoombox_str2a, tempRef_zoombox_str2b);
		current_plot.zoombox_str2a = tempRef_zoombox_str2a.argvalue;
		current_plot.zoombox_str2b = tempRef_zoombox_str2b.argvalue;
		}
	}

/*
 * draw a line using the gc with the GXxor function.
 * This can be used to turn on *and off* a line between
 * the current mouse pointer and the ruler.
 */
	public static void DrawLineToRuler(plot_struct current_plot)
	{
		if (current_plot.ruler_on == false || current_plot.ruler_lineto_on == false)
		return;
		if (current_plot.ruler_lineto_x < 0)
		return;
		if (gc_xor == null)
		{
		GlobalMembersGplt_x11.GetGCXor(current_plot, gc_xor);
		}
		XDrawLine(dpy, current_plot.window, gc_xor, (int)((current_plot.ruler_x) * xscale), (int)((4095 - (current_plot.ruler_y)) * yscale), current_plot.ruler_lineto_x, current_plot.ruler_lineto_y);
	}

/*
 * draw the strings xstr and ystr centered horizontally
 * and vertically at the point x, y. Use the GXxor
 * as usually, so that we can also remove the coords
 * later.
 */
	public static void AnnotatePoint(plot_struct current_plot, int x, int y, tangible.RefObject<String> xstr, tangible.RefObject<String> ystr)
	{
		int ylen;
		int xlen;
		int xwidth;
		int ywidth;

		xlen = xstr.argvalue.length();
		xwidth = GlobalMembersGplt_x11.gpXTextWidth(font, xstr.argvalue, xlen);

		ylen = ystr.argvalue.length();
		ywidth = GlobalMembersGplt_x11.gpXTextWidth(font, ystr.argvalue, ylen);

		/* horizontal centering disabled (joze) */

		if (gc_xor == null)
		{
		GlobalMembersGplt_x11.GetGCXor(current_plot, gc_xor);
		}
		GlobalMembersGplt_x11.gpXDrawString(dpy, current_plot.window, gc_xor, x, y - 3, xstr.argvalue, xlen);
		GlobalMembersGplt_x11.gpXDrawString(dpy, current_plot.window, gc_xor, x, y + vchar, ystr.argvalue, ylen);
	}

/* returns the time difference to the last click in milliseconds */
	public static int SetTime(plot_struct current_plot, Time t)
	{
		int diff = t - current_plot.time;

		GlobalMembersFit.a((stderr, "(SetTime) difftime = %ld\n", diff));

		current_plot.time = t;
		return diff > 0 ? diff : 0;
	}
	public static int AllocateXorPixel(cmap_t cmap_ptr)
	{
		int pixel;
		XColor xcolor = new XColor();

		xcolor.pixel = cmap_ptr.colors[0]; // background color
		XQueryColor(dpy, cmap_ptr.colormap, xcolor);

		if (xcolor.red + xcolor.green + xcolor.blue < 0xffff)
		{
		/* it is admittedly somehow arbitrary to call
		 * everything with a gray value < 0xffff a
		 * dark background. Try to use the background's
		 * complement for drawing which will always
		 * result in white when using xor. */
		xcolor.red = ~xcolor.red;
		xcolor.green = ~xcolor.green;
		xcolor.blue = ~xcolor.blue;
		if (XAllocColor(dpy, cmap_ptr.colormap, xcolor))
		{
			/* use white foreground for dark backgrounds */
			pixel = xcolor.pixel;
		}
		else
		{
			/* simple xor if we've run out of colors. */
			pixel = WhitePixel(dpy, scr);
		}
		}
		else
		{
		/* use the background itself for drawing.
		 * xoring two same colors will always result
		 * in black. This color is already allocated. */
		pixel = xcolor.pixel;
		}
		cmap_ptr.xorpixel = pixel;
		return pixel;
	}
	public static void GetGCXor(plot_struct current_plot, GC ret)
	{
		XGCValues values = new XGCValues();
		int mask = 0;

		values.foreground = GlobalMembersGplt_x11.AllocateXorPixel(current_plot.cmap);

	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0)
		{
		mask = GCForeground | GCFunction;
		values.function = GXxor;
		}
		else
	///#endif
		{
		mask = GCForeground | GCFunction | GCFont;
		values.function = GXxor;
		values.font = font.fid;
		}

		ret = XCreateGC(dpy, current_plot.window, mask, values);
	}
	public static void GetGCXorDashed(plot_struct current_plot, GC gc)
	{
		GlobalMembersGplt_x11.GetGCXor(current_plot, gc);
		XSetLineAttributes(dpy, gc, 0, LineOnOffDash, CapNotLast, JoinMiter); // also: JoinRound, JoinBevel -  also: CapButt, CapRound, CapProjecting -  also: LineDoubleDash -  line width, X11 treats 0 as a `thin' line
	}

///#if 0
//// /*
////  * returns the newly created gc
////  * pixmap: where the gc will be used
////  * mode == 0 --> black on white
////  * mode == 1 --> white on black
////  */
//// /* FIXME HBB 20020225: This function is not used anywhere ??? */
////static void
////GetGCBlackAndWhite(plot_struct * plot, GC * ret, Pixmap pixmap, int mode)
////{
////    XGCValues values;
////    unsigned long mask = 0;
////
////    mask = GCForeground | GCBackground | GCFont | GCFunction;
////    if (!mode) {
////#if 0
////	values.foreground = BlackPixel(dpy, scr);
////	values.background = WhitePixel(dpy, scr);
////#else
////	values.foreground = plot->cmap->colors[1];
////	values.background = plot->cmap->colors[0];
////#endif
////    } else {
//// /*
////  * swap colors
////  */
////#if 0
////	values.foreground = WhitePixel(dpy, scr);
////	values.background = BlackPixel(dpy, scr);
////#else
////	values.foreground = plot->cmap->colors[0];
////	values.background = plot->cmap->colors[1];
////#endif
////    }
////    values.function = GXcopy;
////    values.font = font->fid;
////
////    *ret = XCreateGC(dpy, pixmap, mask, &values);
////}
////
//// /*
////  * split a string at `splitchar'.
////  */
//// /* FIXME HBB 20020225: This function is not used anywhere ??? */
////static int
////SplitAt(char **args, int maxargs, char *buf, char splitchar)
////{
////    int argc = 0;
////
////    while (*buf != '\0' && argc < maxargs) {
////
////	if ((*buf == splitchar))
////	    *buf++ = '\0';
////
////	if (!(*buf))		// don't count the terminating NULL 
////	    break;
////
//// /* Save the argument.  */
////	*args++ = buf;
////	argc++;
////
//// /* Skip over the argument */
////	while ((*buf != '\0') && (*buf != splitchar))
////	    buf++;
////    }
////
////    *args = '\0';		// terminate 
////    return argc;
////}
////
//// /* FIXME HBB 20020225: This function is not used anywhere ??? */
////static void
////xfree(void *fred)
////{
////    if (fred)
////	free(fred);
////}
///#endif

/* erase the last displayed position string */
	///#if 0
	////static void GetGCBlackAndWhite __PROTO((plot_struct *, GC *, Pixmap, int));
	////static int SplitAt __PROTO((char **, int, char *, char));
	////static void xfree __PROTO((void *));
	///#endif
	public static void EraseCoords(plot_struct current_plot)
	{
		GlobalMembersGplt_x11.DrawCoords(current_plot, current_plot.str);
	}
	public static void DrawCoords(plot_struct current_plot, String str)
	{
		if (gc_xor == null)
		{
		GlobalMembersGplt_x11.GetGCXor(current_plot, gc_xor);
		}

		if (str.charAt(0) != 0)
		GlobalMembersGplt_x11.gpXDrawString(dpy, current_plot.window, gc_xor, 1, current_plot.gheight + vchar - 1, str, str.length());
	}

/* display text (e.g. mouse position) in the lower left corner of the window. */
	public static void DisplayCoords(plot_struct current_plot, String s)
	{
		/* first, erase old text */
		GlobalMembersGplt_x11.EraseCoords(current_plot);

		if (s.charAt(0) == 0)
		{
		/* no new text? */
		if (current_plot.height > current_plot.gheight)
		{
			/* and window has space for text? then make it smaller, unless we're already doing a resize: */
			if (!current_plot.resizing)
			{
	///#ifdef EXTERNAL_X11_WINDOW
			if (current_plot.external_container != None)
			{
				current_plot.gheight = current_plot.height;
				GlobalMembersGplt_x11.display(current_plot);
			}
			else
	///#endif
			XResizeWindow(dpy, current_plot.window, current_plot.width, current_plot.gheight);
			current_plot.resizing = true;
			}
		}
		}
		else
		{
		/* so we do have new text */
		if (current_plot.height == current_plot.gheight)
		{
			/* window not large enough? then make it larger, unless we're already doing a resize: */
			if (!current_plot.resizing)
			{
	///#ifdef EXTERNAL_X11_WINDOW
			if (current_plot.external_container != None)
			{
				current_plot.gheight = current_plot.height - vchar;
				GlobalMembersGplt_x11.display(current_plot);
			}
			else
	///#endif
			XResizeWindow(dpy, current_plot.window, current_plot.width, current_plot.gheight + vchar);
			current_plot.resizing = true;
			}
		}
		}

		/* finally, draw the new text: */
		GlobalMembersGplt_x11.DrawCoords(current_plot, s);

		/* and save it, for later erasing: */
		current_plot.str = s;
	}

	public static boolean is_meta(KeySym mod)
	{
		/* CJK keyboards may have these meta keys */
		if (0xFF20 <= mod && mod <= 0xFF3F)
		return true;

		/* Everyone else may have these meta keys */
		switch (mod)
		{
		case XK_Multi_key:
		case XK_Shift_L:
		case XK_Shift_R:
		case XK_Control_L:
		case XK_Control_R:
		case XK_Meta_L:
		case XK_Meta_R:
		case XK_Alt_L:
		case XK_Alt_R:
				return true;
		default:
				return false;
		}
	}

	///#ifndef DISABLE_SPACE_RAISES_CONSOLE
	public static int gnuplotXID = 0; // WINDOWID of gnuplot

///#ifndef DISABLE_SPACE_RAISES_CONSOLE
/* It returns NULL if we are not running in any known (=implemented) multitab
 * console.
 * Otherwise it returns a command to be executed in order to switch to the
 * appropriate tab of a multitab console.
 * In addition, it may return non-zero newGnuplotXID in order to overwrite zero
 * value of gnuplotXID (because Konsole's in KDE <3.2 don't set WINDOWID contrary
 * to all other xterm's).
 * Currently implemented for:
 *	- KDE's Konsole.
 * Note: if the returned command is !NULL, then it must be free()'d by the caller.
 */
	public static String getMultiTabConsoleSwitchCommand(int newGnuplotXID)
	{
	///#ifdef HAVE_STRDUP // We assume that any machine missing strdup is too old for KDE
		String cmd = DefineConstants.NULL; // result
		byte ptr = getenv("KONSOLE_DCOP_SESSION"); // Try KDE's Konsole first.
		newGnuplotXID = 0;
		if (ptr != 0)
		{
		/* We are in KDE's Konsole, or in a terminal window detached from a Konsole.
		 * In order to active a tab:
		 * 1. get environmental variable KONSOLE_DCOP_SESSION: it includes konsole id and session name
		 * 2. if
		 *	$WINDOWID is defined and it equals
		 *	    `dcop konsole-3152 konsole-mainwindow#1 getWinID`
		 *	(KDE 3.2) or when $WINDOWID is undefined (KDE 3.1), then run commands
		 *    dcop konsole-3152 konsole activateSession session-2;
	//  *    dcop konsole-3152 konsole-mainwindow#1 raise
		 * Note: by $WINDOWID we mean gnuplot's text console WINDOWID.
		 * Missing: focus is not transferred unless $WINDOWID is defined (should be fixed in KDE 3.2).
		 *
		 * Implementation and tests on KDE 3.1.4: Petr Mikulik.
		 */
		String konsole_name = DefineConstants.NULL;
		newGnuplotXID = 0; // don't change gnuplotXID by default
		/* use 'while' instead of 'if' to easily break out (aka catch exception) */
		while (true)
		{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * konsole_tab;
			int w;
			FILE p;
			ptr = tangible.StringFunctions.strChr(ptr, '(');
			/* the string for tab nb 4 looks like 'DCOPRef(konsole-2866, session-4)' */
			if (ptr == 0)
				return DefineConstants.NULL;
			konsole_name = ptr + 1;
			konsole_tab = tangible.StringFunctions.strChr(konsole_name, ',');
			if (konsole_tab == 0)
				break;
			*konsole_tab++= 0;
			ptr = tangible.StringFunctions.strChr(konsole_tab, ')');
			if (ptr != 0)
				ptr = 0;
			/* Not necessary to define DCOP_RAISE: returning newly known
			 * newGnuplotXID instead is sufficient.
			 */
	/* #define DCOP_RAISE */
	///#ifdef DCOP_RAISE
	//	    cmd = malloc(2*strlen(konsole_name) + strlen(konsole_tab) + 128);
	///#else
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
			cmd = malloc(konsole_name.length() + konsole_tab.length() + 64);
	///#endif
			String.format(cmd, "dcop %s konsole-mainwindow#1 getWinID 2>/dev/null", konsole_name);
			/* is  2>/dev/null  portable among various shells? */
			p = GlobalMembersAmiga.popen(cmd, "r");
			if (p != null)
			{
			fscanf(p, "%lu", w);
			GlobalMembersAmiga.pclose(p);
			}
			if (gnuplotXID != 0) // $WINDOWID is known
			{
			if (w != gnuplotXID)
				break;
				/* `dcop getWinID`==$WINDOWID thus we are running in a window detached from Konsole */
			}
			else
			{
			newGnuplotXID = w;
				/* $WINDOWID has not been known (KDE 3.1), thus set it up */
			}
	///#ifdef DCOP_RAISE
	// /* not necessary: returning newly known newGnuplotXID instead is sufficient */
	//	    sprintf(cmd, "dcop %s konsole-mainwindow#1 raise;", konsole_name);
	//	    sprintf(cmd+strlen(cmd), "dcop %s konsole activateSession %s", konsole_name, konsole_tab);
	///#else
			String.format(cmd, "dcop %s konsole activateSession %s", konsole_name, konsole_tab);
	///#endif
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(konsole_name);
			return cmd;
		}
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(konsole_name);
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
		free(cmd);
		return DefineConstants.NULL;
		}
		/* now test for GNOME multitab console */
		/* ... if somebody bothers to implement it ... */

	///#endif // HAVE_STRDUP
		/* we are not running in any known (implemented) multitab console */
		return DefineConstants.NULL;
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static GC DrawRotated_bitmapGC = (GC) 0;
	///#endif // DISABLE_SPACE_RAISES_CONSOLE 

	///#endif // USE_MOUSE 

	public static void DrawRotated(plot_struct current_plot, Display dpy, GC gc, int xdest, int ydest, String str, int len)
	{
		Window w = current_plot.window;
		Drawable d = current_plot.pixmap;
		double angle = current_plot.angle;
		JUSTIFY just = current_plot.jmode;
		int x;
		int y;
		double src_x;
		double src_y;
		double dest_x;
		double dest_y;
		int width = GlobalMembersGplt_x11.gpXTextWidth(font, str, len);
		int height = vchar;
		double src_cen_x = (double)width * 0.5;
		double src_cen_y = (double)height * 0.5;
		final double deg2rad = .01745329251994329576; // atan2(1, 1) / 45.0;
		double sa = Math.sin(angle * deg2rad);
		double ca = Math.cos(angle * deg2rad);
		int dest_width = (double)height * Math.abs(sa) + (double)width * Math.abs(ca) + 2;
		int dest_height = (double)width * Math.abs(sa) + (double)height * Math.abs(ca) + 2;
		double dest_cen_x = (double)dest_width * 0.5;
		double dest_cen_y = (double)dest_height * 0.5;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		byte data = (String) malloc(dest_width * dest_height * sizeof(byte));
		Pixmap pixmap_src = XCreatePixmap(dpy, root, (int)width, (int)height, 1);
		XImage image_src;
		XImage image_dest;
		XImage image_scr;
		int fgpixel = 0;
		int bgpixel = 0;
		XWindowAttributes win_attrib = new XWindowAttributes();
		int xscr;
		int yscr;
		int xoff;
		int yoff;
		int scr_width;
		int scr_height;
		XErrorHandler prevErrorHandler = new XErrorHandler();

		int gcFunctionMask = GCFunction;
		XGCValues gcValues = new XGCValues();
		int gcCurrentFunction = 0;
		Status s = new Status();

		/* bitmapGC is static, so that is has to be initialized only once */
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static GC bitmapGC = (GC) 0;

		/* eventually initialize bitmapGC */
		if ((GC)0 == DrawRotated_bitmapGC)
		{
		DrawRotated_bitmapGC = XCreateGC(dpy, pixmap_src, 0, (XGCValues) 0);
		XSetForeground(dpy, DrawRotated_bitmapGC, 1);
		XSetBackground(dpy, DrawRotated_bitmapGC, 0);
		}

		s = XGetGCValues(dpy, gc, gcFunctionMask | GCForeground | GCBackground, gcValues);
		if (s != null)
		{
		/* success */
		fgpixel = gcValues.foreground;
		bgpixel = gcValues.background;
		gcCurrentFunction = gcValues.function; // save current function
		}

		/* set font for the bitmap GC */
		if (font != null)
		  GlobalMembersGplt_x11.gpXSetFont(dpy, DrawRotated_bitmapGC, font.fid);

		/* draw string to the source bitmap */
		GlobalMembersGplt_x11.gpXDrawImageString(dpy, pixmap_src, DrawRotated_bitmapGC, 0, GlobalMembersGplt_x11.gpXGetFontascent(font), str, len);

		/* create XImage's of depth 1 */
		/* source from pixmap */
		image_src = XGetImage(dpy, pixmap_src, 0, 0, (int)width, (int)height, 1, XYPixmap); // ZPixmap, XYBitmap

		/* empty dest */
		assert data;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in Java:
		memset((Object)data, 0, (int)dest_width * dest_height);
		image_dest = XCreateImage(dpy, vis, 1, XYBitmap, 0, data, (int)dest_width, (int)dest_height, 8, 0);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RotateX(_x, _y) (( (_x) * ca + (_y) * sa + dest_cen_x))
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RotateY(_x, _y) ((-(_x) * sa + (_y) * ca + dest_cen_y))
		/* copy & rotate from source --> dest */
		for (y = 0, src_y = -src_cen_y; y < height; y++, src_y++)
		{
		for (x = 0, src_x = -src_cen_x; x < width; x++, src_x++)
		{
			/* TODO: move some operations outside the inner loop (joze) */
			dest_x = rint((((src_x) * ca + (src_y) * sa + dest_cen_x)));
			dest_y = rint(((-(src_x) * sa + (src_y) * ca + dest_cen_y)));
			if (dest_x >= 0 && dest_x < dest_width && dest_y >= 0 && dest_y < dest_height)
			XPutPixel(image_dest, (int)dest_x, (int)dest_y, XGetPixel(image_src, x, y));
		}
		}

		src_cen_y = 0; // EAM 29-Sep-2002 - vertical justification has already been done

		switch (just)
		{
		case LEFT:
		default:
			xdest -= (((-src_cen_x) * ca + (src_cen_y) * sa + dest_cen_x));
			ydest -= ((-(-src_cen_x) * sa + (src_cen_y) * ca + dest_cen_y));
			break;
		case CENTRE:
			xdest -= (((0) * ca + (src_cen_y) * sa + dest_cen_x));
			ydest -= ((-(0) * sa + (src_cen_y) * ca + dest_cen_y));
			break;
		case RIGHT:
			xdest -= (((src_cen_x) * ca + (src_cen_y) * sa + dest_cen_x));
			ydest -= ((-(src_cen_x) * sa + (src_cen_y) * ca + dest_cen_y));
			break;
		}

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef RotateX
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef RotateY

		if (fast_rotate)
		{
		/* This default method is a lot faster, but may corrupt the colors
		 * underneath the rotated text if the X display Visual is PseudoColor.
		 * EAM - August 2005
		 */
		assert s; // Previous success in reading XGetGCValues()
		/* Force pixels of new text to black, background unchanged */
		gcValues.function = GXand;
		gcValues.background = WhitePixel(dpy, scr);
		gcValues.foreground = BlackPixel(dpy, scr);
		XChangeGC(dpy, gc, gcFunctionMask | GCBackground | GCForeground, gcValues);
		XPutImage(dpy, d, gc, image_dest, 0, 0, xdest, ydest, dest_width, dest_height);

		/* Force pixels of new text to color, background unchanged */
		gcValues.function = GXor;
		gcValues.background = BlackPixel(dpy, scr);
		gcValues.foreground = fgpixel;
		XChangeGC(dpy, gc, gcFunctionMask | GCBackground | GCForeground, gcValues);
		XPutImage(dpy, d, gc, image_dest, 0, 0, xdest, ydest, dest_width, dest_height);

		}
		else
		{
		/* Slow but sure version - grab the current screen area where the new
		 * text will go and substitute in the pixels of the new text one by one.
		 * NB: selected by X Resource
		 *                             gnuplot*fastrotate: off
		 */
		assert s; // Previous success in reading XGetGCValues()
		gcValues.function = GXcopy;
		XChangeGC(dpy, gc, gcFunctionMask, gcValues);
		s = XGetWindowAttributes(dpy, w, win_attrib);
		/* compute screen coords that are within the current window */
		xscr = (xdest < 0)? 0 : xdest;
		yscr = (ydest < 0)? 0 : ydest;
		scr_width = dest_width;
		scr_height = dest_height;
		if (xscr + dest_width > win_attrib.width)
			scr_width = win_attrib.width - xscr;
		if (yscr + dest_height > win_attrib.height)
			scr_height = win_attrib.height - yscr;
		xoff = xscr - xdest;
		yoff = yscr - ydest;
		scr_width -= xoff;
		scr_height -= yoff;
		prevErrorHandler = XSetErrorHandler(GlobalMembersGplt_x11.DrawRotatedErrorHandler);

		image_scr = XGetImage(dpy, d, xscr, yscr, scr_width, scr_height, AllPlanes, XYPixmap);
		if (image_scr != 0)
		{
			/* copy from 1 bit bitmap image of text to the full depth image of screen*/
			for (y = 0; y < scr_height; y++)
			{
			for (x = 0; x < scr_width; x++)
			{
				if (XGetPixel(image_dest, x + xoff, y + yoff))
				{
				XPutPixel(image_scr, x, y, fgpixel);
				}
			}
			}
			/* copy the rotated image to the drawable d */
			XPutImage(dpy, d, gc, image_scr, 0, 0, xscr, yscr, scr_width, scr_height);

			XDestroyImage(image_scr);
		}
		XSetErrorHandler(prevErrorHandler);
		} // End slow rotatation code

		/* free resources */
		XFreePixmap(dpy, pixmap_src);
		XDestroyImage(image_src);
		XDestroyImage(image_dest);

		if (s != null)
		{
		/* restore original state of gc */
		gcValues.function = gcCurrentFunction;
		gcValues.background = bgpixel;
		XChangeGC(dpy, gc, gcFunctionMask | GCBackground, gcValues);
		}
	}

///#else // VMS 
//
// /*
//  *   record - record new plot from gnuplot inboard X11 driver (VMS)
//  */
//static struct plot_struct *plot = NULL;
//record()
//{
//    int status;
//
//    if ((STDIINiosb[0] & 0x1) == 0)
//	EXIT(STDIINiosb[0]);
//    STDIINbuffer[STDIINiosb[1]] = '\0';
//    strcpy(buf, STDIINbuffer);
//
//    switch (*buf) {
//    case 'G':			// enter graphics mode 
//	{
//	    if (!plot)
//		plot = Add_Plot_To_Linked_List(most_recent_plot_number);
//	    if (plot)
//		prepare_plot(plot);
//	    current_plot = plot;
//	    break;
//	}
//    case 'E':			// leave graphics mode 
//	if (plot)
//	    display(plot);
//	break;
//    case 'R':			// exit x11 mode 
//	FPRINTF((stderr, "received R - sending ClientMessage\n"));
//	reset_cursor();
//	sys$cancel(STDIINchannel);
// /* this is ridiculous - cook up an event to ourselves,
//  * in order to get the mainloop() out of the XNextEvent() call
//  * it seems that window manager can also send clientmessages,
//  * so put a checksum into the message
//  */
//	{
//	    XClientMessageEvent event;
//	    event.type = ClientMessage;
//	    event.send_event = True;
//	    event.display = dpy;
//	    event.window = message_window;
//	    event.message_type = None;
//	    event.format = 8;
//	    strcpy(event.data.b, "die gnuplot die");
//	    XSendEvent(dpy, message_window, False, 0, (XEvent *) & event);
//	    XFlush(dpy);
//	}
//	return;			// no ast 
//    default:
//	if (plot)
//	    store_command(buf, plot);
//	break;
//    }
//    ast();
//}
///#endif // VMS 

	public static int DrawRotatedErrorHandler(Display display, XErrorEvent error_event)
	{
	  return 0; // do nothing
	}

/*
 *   exec_cmd - execute drawing command from inboard driver
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static XPoint exec_cmd_points = DefineConstants.NULL;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_st_npoints = 0;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_saved_npoints = -1;
int saved_i = -1;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static boolean exec_cmd_transferring = false;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static byte exec_cmd_iptr;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int[] exec_cmd_int_cache = new int[2];
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_i_remaining;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static boolean exec_cmd_code_detected = false;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static XPoint exec_cmd_points = DefineConstants.NULL;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_st_npoints = 0;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_npoints = 0;
int style = 0;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static byte exec_cmd_iptr;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static boolean exec_cmd_transferring = false;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static short exec_cmd_image;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_M;
int N;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_pixel_1_1_x;
int pixel_1_1_y;
int pixel_M_N_x;
int pixel_M_N_y;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_visual_1_1_x;
int visual_1_1_y;
int visual_M_N_x;
int visual_M_N_y;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_color_mode;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_i_remaining;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static boolean exec_cmd_code_detected = false;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static short exec_cmd_R_msb_mask = 0;
short R_rshift;
short R_lshift;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static short exec_cmd_G_msb_mask;
short G_rshift;
short G_lshift;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static short exec_cmd_B_msb_mask;
short B_rshift;
short B_lshift;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_prev_red_mask;
int prev_green_mask;
int prev_blue_mask;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int exec_cmd_prev_allocated = 0;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static short exec_cmd_palette_bit_shift = 0;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String exec_cmd_display_error_text_after = " display class cannot use component" "\n                     " "data.  Try palette mode.\n\n";
	public static void exec_cmd(plot_struct current_plot, String command)
	{
		int x;
		int y;
		int sw;
		int sl;
		int sj;
		String buffer;
		String str;

		buffer = command;

	///#ifdef X11_POLYLINE
		/*   X11_vector(x, y) - draw vector  */
		if (buffer.equals('V'))
		{
		sscanf(buffer, "V%4d%4d", x, y);
		if (polyline_size == 0)
		{
			polyline[polyline_size].x = (int)((cx) * xscale);
			polyline[polyline_size].y = (int)((4095 - (cy)) * yscale);
		}
		if (++polyline_size >= polyline_space)
		{
			polyline_space += 100;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'realloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			polyline = realloc(polyline, polyline_space * sizeof(XPoint));
			if (polyline == null)
				fprintf(stderr, "Panic: cannot realloc polyline\n");
		}
		polyline[polyline_size].x = (int)((x) * xscale);
		polyline[polyline_size].y = (int)((4095 - (y)) * yscale);
		cx = x;
		cy = y;
		/* Limit the number of vertices in any single polyline */
		if (polyline_size > max_request_size)
		{
			GlobalMembersFit.a((stderr, "(display) dumping polyline size %d\n", polyline_size));
			XDrawLines(dpy, current_plot.pixmap, current_gc, polyline, polyline_size + 1, CoordModeOrigin);
			polyline_size = 0;
		}
		return;
		}
		else if (polyline_size > 0)
		{
		GlobalMembersFit.a((stderr, "(display) dumping polyline size %d\n", polyline_size));
		XDrawLines(dpy, current_plot.pixmap, current_gc, polyline, polyline_size + 1, CoordModeOrigin);
		polyline_size = 0;
		}
	///#else
	// /*   X11_vector(x, y) - draw vector  */
	//    if (*buffer == 'V') {
	//	sscanf(buffer, "V%4d%4d", &x, &y);
	//	XDrawLine(dpy, plot->pixmap, *current_gc, X(cx), Y(cy), X(x), Y(y));
	//	cx = x;
	//	cy = y;
	//    } else
	///#endif
		/*   X11_move(x, y) - move  */
		if (buffer.equals('M'))
		sscanf(buffer, "M%4d%4d", cx, cy);

		/* change default font (QD) encoding (QE) or current font (QF)  */
		else if (buffer.equals('Q'))
		{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * c;
		switch (buffer.charAt(1))
		{
		case 'F':
			/* Strip out just the font name */
			c = &(buffer.charAt(buffer.length() - 1));
			while (*c <= ' ')
				*c--= '\0';
			GlobalMembersGplt_x11.pr_font(buffer.charAt(2));
			if (font != null)
			  GlobalMembersGplt_x11.gpXSetFont(dpy, gc, font.fid);
			break;
		case 'E':
			/* Save the requested font encoding */
		{
				int tmp;
				sscanf(buffer, "QE%d", tmp);
				encoding = set_encoding_id.forValue(tmp);
		}
			GlobalMembersFit.a((stderr, "gnuplot_x11: changing encoding to %d\n", encoding));
			break;
		case 'D':
			/* Save the request default font */
			c = &(buffer.charAt(buffer.length() - 1));
			while (*c <= ' ')
				*c--= '\0';
			default_font = String.valueOf(buffer.charAt(2)).substring(0, String.valueOf(buffer.charAt(2)).length() + 1);
			GlobalMembersFit.a((stderr, "gnuplot_x11: exec_cmd() set default_font to \"%s\"\n", default_font));
			break;
		}
		}

		/*   X11_put_text(x, y, str) - draw text   */
		else if (buffer.equals('T'))
		{
		/* Enhanced text mode added November 2003 - Ethan A Merritt */
		int x_offset = 0;
		int y_offset = 0;
		int v_offset = 0;

		switch (buffer.charAt(1))
		{

		case 'j': // Set start for right-justified enhanced text
				sscanf(buffer + 2, "%4d%4d", x_offset, y_offset);
				current_plot.xLast = x_offset - (current_plot.xLast - x_offset);
				current_plot.yLast = y_offset - (vchar / 3) / yscale;
				return;
		case 'k': // Set start for center-justified enhanced text
				sscanf(buffer + 2, "%4d%4d", x_offset, y_offset);
				current_plot.xLast = x_offset - 0.5 * (current_plot.xLast - x_offset);
				current_plot.yLast = y_offset - (vchar / 3) / yscale;
				return;
		case 'l': // Set start for left-justified enhanced text
				sscanf(buffer + 2, "%4d%4d", x_offset, y_offset);
				current_plot.xLast = x_offset;
				current_plot.yLast = y_offset - (vchar / 3) / yscale;
				return;
		case 'o': // Enhanced mode print with no update
		case 'c': // Enhanced mode print with update to center
		case 'u': // Enhanced mode print with update
		case 's': // Enhanced mode update with no print
				sscanf(buffer + 2, "%4d%4d", x_offset, y_offset);
				/* EAM FIXME - This code has only been tested for x_offset == 0 */
				if (current_plot.angle != 0)
				{
				int xtmp = 0;
				int ytmp = 0;
				xtmp += x_offset * Math.cos((double)(current_plot.angle) * 0.01745);
				xtmp -= y_offset * Math.sin((double)(current_plot.angle) * 0.01745) * yscale / xscale;
				ytmp += x_offset * Math.sin((double)(current_plot.angle) * 0.01745) * xscale / yscale;
				ytmp += y_offset * Math.cos((double)(current_plot.angle) * 0.01745);
				x_offset = xtmp;
				y_offset = ytmp;
				}
				x = current_plot.xLast + x_offset;
				y = current_plot.yLast + y_offset;
				str = buffer + 10;
				break;
		case 'p': // Push (Save) position for later use
				current_plot.xSave = current_plot.xLast;
				current_plot.ySave = current_plot.yLast;
				return;
		case 'r': // Pop (Restore) saved position
				current_plot.xLast = current_plot.xSave;
				current_plot.yLast = current_plot.ySave;
				return;
		default:
				sscanf(buffer, "T%4d%4d", x, y);
				v_offset = vchar / 3; // Why is this???
				str = buffer + 9;
				break;
		}

		sl = str.length() - 1;
		sw = GlobalMembersGplt_x11.gpXTextWidth(font, str, sl);

	/*	EAM - May 2002	Modify to allow colored text.
	 *	1) do not force foreground of gc to be black
	 *	2) write text to (*current_gc), rather than to gc, so that text color can be set
	 *	   using pm3d mappings.
	 */

		switch (current_plot.jmode)
		{
			default:
			case LEFT:
			sj = 0;
			break;
			case CENTRE:
			sj = -sw / 2;
			break;
			case RIGHT:
			sj = -sw;
			break;
		}

		if (sl == 0) // Pointless to draw empty string
			;
		else if (buffer.charAt(1) == 's') // Enhanced text mode reserve space only
			;
		else if (current_plot.angle != 0)
		{
			/* rotated text */
			GlobalMembersGplt_x11.DrawRotated(current_plot, dpy, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale), str, sl);
		}
		else
		{
			/* horizontal text */
			GlobalMembersGplt_x11.gpXDrawString(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale) + sj, (int)((4095 - (y)) * yscale) + v_offset, str, sl);
		}

		/* Update current text position */
		if (buffer.charAt(1) == 'c')
		{
			current_plot.xLast = ((((int)((x) * xscale) + sj + sw / 2) + 0.5) / xscale) - x_offset;
			current_plot.yLast = y - y_offset;
		}
		else if (buffer.charAt(1) != 'o')
		{
			current_plot.xLast = ((((int)((x) * xscale) + sj + sw) + 0.5) / xscale) - x_offset;
			current_plot.yLast = y - y_offset;
			if (current_plot.angle != 0) // This correction is not perfect
			{
			current_plot.yLast += (((sw) + 0.5) / xscale) * Math.sin((current_plot.angle) * 0.01745) * xscale / yscale;
			current_plot.xLast -= (((sw) + 0.5) / xscale) * (1.0 - Math.cos((current_plot.angle) * 0.01745));
			}
		}

		} // fill box
		else if (buffer.equals('F'))
		{
		int style;
		int xtmp;
		int ytmp;
		int w;
		int h;

		if (sscanf(buffer + 1, "%4d%4d%4d%4d%4d", style, xtmp, ytmp, w, h) == 5)
		{

			/* Load selected pattern or fill into a separate gc */
			if (fill_gc == null)
			fill_gc = XCreateGC(dpy, current_plot.window, 0, 0);
			XCopyGC(dpy, current_gc, ~0, fill_gc);
			GlobalMembersGplt_x11.x11_setfill(fill_gc, style);

			/* gnuplot has origin at bottom left, but X uses top left
			 * There may be an off-by-one (or more) error here.
			 */
			ytmp += h; // top left corner of rectangle to be filled
			w *= xscale;
			h *= yscale;
			XFillRectangle(dpy, current_plot.pixmap, fill_gc, (int)((xtmp) * xscale), (int)((4095 - (ytmp)) * yscale), w + 1, h + 1);
		}
		}
		/*   X11_justify_text(mode) - set text justification mode  */
		else if (buffer.equals('J'))
		sscanf(buffer, "J%4d", (int) current_plot.jmode);

		else if (buffer.equals('A'))
		sscanf(buffer + 1, "%lf", current_plot.angle);

		/*  X11_linewidth(plot->lwidth) - set line width */
		else if (buffer.equals('W'))
		sscanf(buffer + 1, "%4d", current_plot.user_width);

		/*   X11_linetype(plot->type) - set line type  */
		else if (buffer.equals('L'))
		{
		sscanf(buffer, "L%4d", current_plot.lt);
		current_plot.lt = (current_plot.lt % 8) + 2;

		if (current_plot.lt < 0) // LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED
			current_plot.lt = -3;

		else // Fixme: no mechanism to hold width or dashstyle for LT_BACKGROUND
		{
			/* default width is 0 {which X treats as 1} */
			current_plot.lwidth = widths[current_plot.lt] != 0 ? current_plot.user_width * widths[current_plot.lt] : current_plot.user_width;

			if ((dashedlines != 0 && dashes[current_plot.lt][0] != 0) || (current_plot.lt == DefineConstants.LT_AXIS + 2 && dashes[DefineConstants.LT_AXIS + 2][0] != 0))
			{
			current_plot.type = LineOnOffDash;
			XSetDashes(dpy, gc, 0, dashes[current_plot.lt], String.valueOf(dashes[current_plot.lt]).length());
			}
			else
			{
			current_plot.type = LineSolid;
			}
		}

		XSetForeground(dpy, gc, current_plot.cmap.colors[current_plot.lt + 3]);
		XSetLineAttributes(dpy, gc, current_plot.lwidth, current_plot.type, CapButt, JoinBevel);
		current_plot.current_rgb = current_plot.cmap.rgbcolors[current_plot.lt + 3];
		current_gc = gc;
		}
		/*   X11_point(number) - draw a point */
		else if (buffer.equals('P'))
		{
		int point;
		sscanf(buffer + 1, "%d %d %d", point, x, y);
		if (point == -2)
		{
			/* set point size */
			current_plot.px = (int)(x * xscale * pointsize);
			current_plot.py = (int)(y * yscale * pointsize);
		}
		else if (point == -1)
		{
			/* dot */
			XDrawPoint(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
		}
		else
		{
			byte fill = 0;
			byte upside_down_fill = 0;
			short upside_down_sign = 1;
			int delta = (current_plot.px + current_plot.py + 1) / 2;

			/* Force line type to solid, with round ends */
			XSetLineAttributes(dpy, current_gc, current_plot.lwidth, LineSolid, CapRound, JoinRound);

			switch (point % 13)
			{
			case 0: // do plus
			Plus[0].x1 = (short)(int)((x) * xscale) - delta;
			Plus[0].y1 = (short)(int)((4095 - (y)) * yscale);
			Plus[0].x2 = (short)(int)((x) * xscale) + delta;
			Plus[0].y2 = (short)(int)((4095 - (y)) * yscale);
			Plus[1].x1 = (short)(int)((x) * xscale);
			Plus[1].y1 = (short)(int)((4095 - (y)) * yscale) - delta;
			Plus[1].x2 = (short)(int)((x) * xscale);
			Plus[1].y2 = (short)(int)((4095 - (y)) * yscale) + delta;

			XDrawSegments(dpy, current_plot.pixmap, current_gc, Plus, 2);
			break;
			case 1: // do X
			Cross[0].x1 = (short)(int)((x) * xscale) - delta;
			Cross[0].y1 = (short)(int)((4095 - (y)) * yscale) - delta;
			Cross[0].x2 = (short)(int)((x) * xscale) + delta;
			Cross[0].y2 = (short)(int)((4095 - (y)) * yscale) + delta;
			Cross[1].x1 = (short)(int)((x) * xscale) - delta;
			Cross[1].y1 = (short)(int)((4095 - (y)) * yscale) + delta;
			Cross[1].x2 = (short)(int)((x) * xscale) + delta;
			Cross[1].y2 = (short)(int)((4095 - (y)) * yscale) - delta;

			XDrawSegments(dpy, current_plot.pixmap, current_gc, Cross, 2);
			break;
			case 2: // do star
			Star[0].x1 = (short)(int)((x) * xscale) - delta;
			Star[0].y1 = (short)(int)((4095 - (y)) * yscale);
			Star[0].x2 = (short)(int)((x) * xscale) + delta;
			Star[0].y2 = (short)(int)((4095 - (y)) * yscale);
			Star[1].x1 = (short)(int)((x) * xscale);
			Star[1].y1 = (short)(int)((4095 - (y)) * yscale) - delta;
			Star[1].x2 = (short)(int)((x) * xscale);
			Star[1].y2 = (short)(int)((4095 - (y)) * yscale) + delta;
			Star[2].x1 = (short)(int)((x) * xscale) - delta;
			Star[2].y1 = (short)(int)((4095 - (y)) * yscale) - delta;
			Star[2].x2 = (short)(int)((x) * xscale) + delta;
			Star[2].y2 = (short)(int)((4095 - (y)) * yscale) + delta;
			Star[3].x1 = (short)(int)((x) * xscale) - delta;
			Star[3].y1 = (short)(int)((4095 - (y)) * yscale) + delta;
			Star[3].x2 = (short)(int)((x) * xscale) + delta;
			Star[3].y2 = (short)(int)((4095 - (y)) * yscale) - delta;

			XDrawSegments(dpy, current_plot.pixmap, current_gc, Star, 4);
			break;
			case 3: // do box
			XDrawRectangle(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale) - delta, (int)((4095 - (y)) * yscale) - delta, (delta + delta), (delta + delta));
			XDrawPoint(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
			break;
			case 4: // filled box
			XFillRectangle(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale) - delta, (int)((4095 - (y)) * yscale) - delta, (delta + delta), (delta + delta));
			break;
			case 5: // circle
			XDrawArc(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale) - delta, (int)((4095 - (y)) * yscale) - delta, 2 * delta, 2 * delta, 0, 23040);
			XDrawPoint(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
			break;
			case 6: // filled circle
			XFillArc(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale) - delta, (int)((4095 - (y)) * yscale) - delta, 2 * delta, 2 * delta, 0, 23040);
			break;
			case 10: // filled upside-down triangle
			upside_down_fill = 1;
			/* FALLTHRU */
			case 9: // do upside-down triangle
			upside_down_sign = (short) - 1;
			case 8: // filled triangle
			fill = 1;
			/* FALLTHRU */
			case 7: // do triangle
			{
				short temp_x;
				short temp_y;

				temp_x = (short)(1.33 * (double) delta + 0.5);
				temp_y = (short)(1.33 * (double) delta + 0.5);

				Triangle[0].x = (short)(int)((x) * xscale);
				Triangle[0].y = (short)(int)((4095 - (y)) * yscale) - upside_down_sign * temp_y;
				Triangle[1].x = (short) temp_x;
				Triangle[1].y = (short) upside_down_sign * 2 * delta;
				Triangle[2].x = (short) - (2 * temp_x);
				Triangle[2].y = (short) 0;
				Triangle[3].x = (short) temp_x;
				Triangle[3].y = (short) - (upside_down_sign * 2 * delta);

				if ((upside_down_sign == 1 && fill != 0) || upside_down_fill != 0)
				{
				XFillPolygon(dpy, current_plot.pixmap, current_gc, Triangle, 4, Convex, CoordModePrevious);
				}
				else
				{
				XDrawLines(dpy, current_plot.pixmap, current_gc, Triangle, 4, CoordModePrevious);
				XDrawPoint(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
				}
			}
			break;
			case 12: // filled diamond
			fill = 1;
			/* FALLTHRU */
			case 11: // do diamond
			Diamond[0].x = (short)(int)((x) * xscale) - delta;
			Diamond[0].y = (short)(int)((4095 - (y)) * yscale);
			Diamond[1].x = (short) delta;
			Diamond[1].y = (short) - delta;
			Diamond[2].x = (short) delta;
			Diamond[2].y = (short) delta;
			Diamond[3].x = (short) - delta;
			Diamond[3].y = (short) delta;
			Diamond[4].x = (short) - delta;
			Diamond[4].y = (short) - delta;

			/*
			 * Should really do a check with XMaxRequestSize()
			 */

			if (fill != 0)
			{
				XFillPolygon(dpy, current_plot.pixmap, current_gc, Diamond, 5, Convex, CoordModePrevious);
			}
			else
			{
				XDrawLines(dpy, current_plot.pixmap, current_gc, Diamond, 5, CoordModePrevious);
				XDrawPoint(dpy, current_plot.pixmap, current_gc, (int)((x) * xscale), (int)((4095 - (y)) * yscale));
			}
			break;
			}

			/* Restore original line style */
			XSetLineAttributes(dpy, current_gc, current_plot.lwidth, current_plot.type, CapButt, JoinBevel);
		}
		}
		else if (buffer.equals(DefineConstants.X11_GR_SET_LINECOLOR))
		{
			int lt;
			sscanf(buffer + 1, "%4d", lt);
			lt = (lt % 8) + 2;
			if (lt < 0) // LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED
			lt = -3;
			XSetForeground(dpy, gc, current_plot.cmap.colors[lt + 3]);
			current_plot.current_rgb = current_plot.cmap.rgbcolors[lt + 3];
			current_gc = gc;
		}
		else if (buffer.equals(DefineConstants.X11_GR_SET_RGBCOLOR))
		{
			int rgb255color;
			XColor xcolor = new XColor();
			sscanf(buffer + 1, "%x", rgb255color);
			xcolor.red = (double)(0xffff) * (double)((rgb255color >> 16) & 0xff) / 255.;
			xcolor.green = (double)(0xffff) * (double)((rgb255color >> 8) & 0xff) / 255.;
			xcolor.blue = (double)(0xffff) * (double)(rgb255color & 0xff) / 255.;
			GlobalMembersFit.a((stderr, "gplt_x11: got request for color %d %d %d\n", xcolor.red, xcolor.green, xcolor.blue));
			if (XAllocColor(dpy, current_plot.cmap.colormap, xcolor))
			{
			XSetForeground(dpy, gc, xcolor.pixel);
			current_plot.current_rgb = rgb255color;
			}
			else
			{
			GlobalMembersFit.a((stderr, "          failed to allocate color\n"));
			}
			current_gc = gc;

		} // set color
		else if (buffer.equals(DefineConstants.X11_GR_SET_COLOR))
		{
		if (have_pm3d != 0) // ignore, if your X server is not supported
		{
			double gray;
			sscanf(buffer + 1, "%lf", gray);
			GlobalMembersGplt_x11.PaletteSetColor(current_plot, gray);
			current_gc = gc;
		}
		}

		else if (buffer.equals(DefineConstants.X11_GR_BINARY_COLOR)) // set color
		{
		if (have_pm3d != 0) // ignore, if your X server is not supported
		{
			/* This command will fit within a single buffer so it doesn't
			 * need to be so elaborate.
			 */
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte exec_cmd_iptr;
			float gray;
			int exec_cmd_i_remaining;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * bptr;
			boolean exec_cmd_code_detected = false;

			exec_cmd_iptr = (byte) & gray;
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			exec_cmd_i_remaining = sizeof(gray);

			/* Decode and reconstruct the data. */
			for (bptr = buffer + 1; exec_cmd_i_remaining;)
			{
			  byte uctmp = *bptr++;
			  if (exec_cmd_code_detected)
			  {
			exec_cmd_code_detected = false;
			exec_cmd_iptr++= uctmp - 1 + DefineConstants.SET_COLOR_TRANSLATION_CHAR;
			exec_cmd_i_remaining--;
			  }
			  else
			  {
			if (uctmp == DefineConstants.SET_COLOR_CODE_CHAR)
			{
			  exec_cmd_code_detected = true;
			}
			else
			{
			  exec_cmd_iptr++= uctmp + DefineConstants.SET_COLOR_TRANSLATION_CHAR;
			  exec_cmd_i_remaining--;
			}
			  }
			}

			if (swap_endian)
			{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			  GlobalMembersGplt_x11.byteswap((String) & gray, sizeof(gray));
			}

			GlobalMembersGplt_x11.PaletteSetColor(current_plot, (double)gray);
			current_gc = gc;
		}
		}

		else if (buffer.equals(DefineConstants.X11_GR_FILLED_POLYGON)) // filled polygon
		{
		if (have_pm3d != 0) // ignore, if your X server is not supported
		{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static XPoint *points = DefineConstants.NULL;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int st_npoints = 0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int saved_npoints = -1, saved_i = -1; // HBB 20010919
			int i;
			int exec_cmd_npoints;
			int style;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * ptr = buffer + 1;

			sscanf(ptr, "%4d", exec_cmd_npoints);

			if (exec_cmd_npoints > 0)
			{
			ptr += 4;
			sscanf(ptr, "%4d", style);
			}

			/* HBB 20010919: Implement buffer overflow protection by
			 * breaking up long lines */
			if (exec_cmd_npoints == -1)
			{
			/* This is a continuation line. */
			if (exec_cmd_saved_npoints < 100)
			{
				fprintf(stderr, "gnuplot_x11: filled_polygon() protocol error\n");
				do
				{
					GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
					close(1);
					close(0);
					System.exit(1);
				} while (0);
			}
			/* Continue filling at end of previous list: */
			i = saved_i;
			exec_cmd_npoints = exec_cmd_saved_npoints;
			}
			else
			{
			exec_cmd_saved_npoints = exec_cmd_npoints;
			i = 0;
			}

			ptr += 4;
			if (exec_cmd_npoints > exec_cmd_st_npoints)
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'realloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			XPoint new_points = realloc(exec_cmd_points, sizeof(XPoint) * exec_cmd_npoints);
			exec_cmd_st_npoints = exec_cmd_npoints;
			if (new_points == null)
			{
				perror("gnuplot_x11: exec_cmd()->points");
				do
				{
					GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
					close(1);
					close(0);
					System.exit(1);
				} while (0);
			}
			exec_cmd_points = new_points;
			}

			while (*ptr != 'x' && i < exec_cmd_npoints) // not end-of-line marker
			{
			sscanf(ptr, "%4d%4d", x, y);
			ptr += 8;
			exec_cmd_points[i].x = (int)((x) * xscale);
			exec_cmd_points[i].y = (int)((4095 - (y)) * yscale);
			i++;
			}

			if (i >= exec_cmd_npoints)
			{
			/* Load selected pattern or fill into a separate gc */
			if (fill_gc == null)
				fill_gc = XCreateGC(dpy, current_plot.window, 0, 0);
			XCopyGC(dpy, current_gc, ~0, fill_gc);

			GlobalMembersGplt_x11.x11_setfill(fill_gc, style);

			XFillPolygon(dpy, current_plot.pixmap, fill_gc, exec_cmd_points, exec_cmd_npoints, Nonconvex, CoordModeOrigin);

			/* Flag this continuation line as closed */
			exec_cmd_saved_npoints = saved_i = -1;
			}
			else
			{
			/* Store how far we got: */
			saved_i = i;
			}

		}

		}

		else if (buffer.equals(DefineConstants.X11_GR_BINARY_POLYGON)) // filled polygon
		{
		if (have_pm3d != 0) // ignore, if your X server is not supported
		{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static boolean transferring = 0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static byte *iptr;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int int_cache[2];
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int i_remaining;
			short i_buffer;
			String bptr;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static boolean code_detected = 0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static XPoint *points = DefineConstants.NULL;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int st_npoints = 0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int npoints = 0, style = 0;

			/* The first value read will be the number of points or the number of
			 * points followed by style.  Set up parameters to point to npoints.
			 */
			if (!exec_cmd_transferring)
			{
			exec_cmd_iptr = (byte) exec_cmd_int_cache;
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			exec_cmd_i_remaining = sizeof(exec_cmd_int_cache);
			}

			i_buffer = DefineConstants.X11_COMMAND_BUFFER_LENGTH - 3;

			/* Decode and reconstruct the data. */
			for (bptr = buffer.charAt(1); i_buffer && exec_cmd_i_remaining != 0; i_buffer--)
			{

			byte uctmp = bptr++;

			if (exec_cmd_code_detected)
			{
				exec_cmd_code_detected = false;
				exec_cmd_iptr++= uctmp - 1 + DefineConstants.FILLED_POLYGON_TRANSLATION_CHAR;
				exec_cmd_i_remaining--;
			}
			else
			{
				if (uctmp == DefineConstants.FILLED_POLYGON_CODE_CHAR)
				{
				exec_cmd_code_detected = true;
				}
				else
				{
				exec_cmd_iptr++= uctmp + DefineConstants.FILLED_POLYGON_TRANSLATION_CHAR;
				exec_cmd_i_remaining--;
				}
			}

			if (exec_cmd_i_remaining == 0 && !exec_cmd_transferring)
			{
				/* The number of points was just read.  Now set up points array and continue. */
				if (swap_endian)
				{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersGplt_x11.byteswap((String) & exec_cmd_int_cache[0], sizeof(int));
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersGplt_x11.byteswap((String) & exec_cmd_int_cache[1], sizeof(int));
				}
				exec_cmd_npoints = exec_cmd_int_cache[0];
				style = exec_cmd_int_cache[1];
				if (exec_cmd_npoints > exec_cmd_st_npoints)
				{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'realloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				XPoint new_points = realloc(exec_cmd_points, exec_cmd_npoints * 2 * sizeof(int));
				exec_cmd_st_npoints = exec_cmd_npoints;
				if (new_points == null)
				{
					perror("gnuplot_x11: exec_cmd()->points");
					do
					{
						GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
						close(1);
						close(0);
						System.exit(1);
					} while (0);
				}
				exec_cmd_points = new_points;
				}
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				exec_cmd_i_remaining = exec_cmd_npoints * 2 * sizeof(int);
				exec_cmd_iptr = (byte) exec_cmd_points;
				exec_cmd_transferring = true;
			}

			}

			if (exec_cmd_i_remaining == 0)
			{

			int i;

			exec_cmd_transferring = false;

			/* If the byte order needs to be swapped, do so. */
			if (swap_endian)
			{
				i = 2 * exec_cmd_npoints;
				for (i--; i >= 0; i--)
				{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
				GlobalMembersGplt_x11.byteswap((String) & ((int)exec_cmd_points)[i], sizeof(int));
				}
			}

			/* Convert the ints to XPoint format. This looks like it tramples
			 * on itself, but the XPoint x and y are smaller than an int.
			 */
			for (i = 0; i < exec_cmd_npoints; i++)
			{
				exec_cmd_points[i].x = (int)((((int)exec_cmd_points)[2 * i]) * xscale);
				exec_cmd_points[i].y = (int)((4095 - (((int)exec_cmd_points)[2 * i + 1])) * yscale);
			}

			/* Load selected pattern or fill into a separate gc */
			if (fill_gc == null)
				fill_gc = XCreateGC(dpy, current_plot.window, 0, 0);
			XCopyGC(dpy, current_gc, ~0, fill_gc);

			GlobalMembersGplt_x11.x11_setfill(fill_gc, style);

			XFillPolygon(dpy, current_plot.pixmap, fill_gc, exec_cmd_points, exec_cmd_npoints, Nonconvex, CoordModeOrigin);
			}
		}

		}

		else if (buffer.equals(DefineConstants.X11_GR_IMAGE)) // image
		{

	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static byte *iptr;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static boolean transferring = 0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static short *image;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int M, N;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int pixel_1_1_x, pixel_1_1_y, pixel_M_N_x, pixel_M_N_y;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int visual_1_1_x, visual_1_1_y, visual_M_N_x, visual_M_N_y;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int color_mode;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int i_remaining;

		/* ignore, if your X server is not supported */
		if (have_pm3d == 0)
			return;

	/* These might work better as fuctions, but defines will do for now. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ERROR_NOTICE(str) "\nGNUPLOT (gplt_x11):  " str
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define ERROR_NOTICE_NEWLINE(str) "\n                     " str

		if (!exec_cmd_transferring)
		{

			/* Get variables. */
			if (11 != sscanf(buffer.charAt(1), "%x %x %x %x %x %x %x %x %x %x %x", exec_cmd_M, N, exec_cmd_pixel_1_1_x, pixel_1_1_y, pixel_M_N_x, pixel_M_N_y, exec_cmd_visual_1_1_x, visual_1_1_y, visual_M_N_x, visual_M_N_y, exec_cmd_color_mode))
			{
			fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Couldn't read image parameters correctly.\n\n");
			}
			else
			{

			/* Number of symbols depends upon whether it is color or palette lookup. */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			exec_cmd_i_remaining = exec_cmd_M * N * sizeof(exec_cmd_image[0]);
			if (exec_cmd_color_mode == t_imagecolor.IC_RGB.getValue())
				exec_cmd_i_remaining *= 3;
			else if (exec_cmd_color_mode == t_imagecolor.IC_RGBA.getValue())
				exec_cmd_i_remaining *= 4;

			if (exec_cmd_i_remaining == 0)
			{
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Image of size zero.\n\n");
			}
			else
			{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
				exec_cmd_image = (short) malloc(exec_cmd_i_remaining);
				if (exec_cmd_image != 0)
				{
				exec_cmd_iptr = (byte) exec_cmd_image;
				exec_cmd_transferring = true;
				}
				else
				{
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Cannot allocate memory for image.\n\n");
				}
			}
			}

		}
		else
		{

			short i_buffer;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
			byte * bptr;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static boolean code_detected = 0;

			i_buffer = DefineConstants.X11_COMMAND_BUFFER_LENGTH - 3;

			/* Decode and reconstruct the data. */
			for (bptr = buffer.charAt(1); i_buffer && exec_cmd_i_remaining != 0; i_buffer--)
			{
			byte uctmp = *bptr++;
			if (exec_cmd_code_detected)
			{
				exec_cmd_code_detected = false;
				exec_cmd_iptr++= uctmp - 1 + DefineConstants.IMAGE_TRANSLATION_CHAR;
				exec_cmd_i_remaining--;
			}
			else
			{
				if (uctmp == DefineConstants.IMAGE_CODE_CHAR)
				{
				exec_cmd_code_detected = true;
				}
				else
				{
				exec_cmd_iptr++= uctmp + DefineConstants.IMAGE_TRANSLATION_CHAR;
				exec_cmd_i_remaining--;
				}
			}
			}

			if (exec_cmd_i_remaining == 0)
			{

			/* Expand or contract the image into a new image and place this on the screen. */

	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static short R_msb_mask=0, R_rshift, R_lshift;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static short G_msb_mask, G_rshift, G_lshift;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static short B_msb_mask, B_rshift, B_lshift;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int prev_red_mask, prev_green_mask, prev_blue_mask;
	///#define LET_XPUTPIXEL_SWAP_BYTES 1
	///#if !LET_XPUTPIXEL_SWAP_BYTES
	//		static TBOOLEAN swap_image_bytes = FALSE;
	///#endif
			boolean create_image = false;
	///#define SINGLE_PALETTE_BIT_SHIFT 0
	///#if SINGLE_PALETTE_BIT_SHIFT
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static int prev_allocated=0;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//		static short palette_bit_shift=0;
	///#endif

			exec_cmd_transferring = false;

			/* If the byte order needs to be swapped, do so. */
			if (swap_endian)
			{
				int i = exec_cmd_M * N;
				if (exec_cmd_color_mode == t_imagecolor.IC_RGB.getValue())
				i *= 3;
				else if (exec_cmd_color_mode == t_imagecolor.IC_RGBA.getValue())
				i *= 4;
				for (i--; i >= 0; i--)
				{
				/* The assumption is that image data through the pipe is 16 bits. */
				byteswap_char = ((String) & exec_cmd_image[i])[0];
				((String) & exec_cmd_image[i])[0] = ((String) & exec_cmd_image[i])[1];
				((String) & exec_cmd_image[i])[1] = byteswap_char;
				}
			}

			if (exec_cmd_color_mode == t_imagecolor.IC_PALETTE.getValue())
			{

	///#if SINGLE_PALETTE_BIT_SHIFT
	/* If the palette size is 2 to some power then a single bit shift would work.
	 * The multiply/shift method doesn't seem noticably slower and generally works
	 * with any size pallete.  Keep this around for the time being in case some
	 * use for it comes up.
	 */
				/* Initialize the palette shift, or if the palette size changes then update the shift. */
				if (exec_cmd_palette_bit_shift == 0 || (current_plot.cmap.allocated != exec_cmd_prev_allocated))
				{
				short i_bits;
				short n_colors;
				exec_cmd_prev_allocated = current_plot.cmap.allocated;
				for (exec_cmd_palette_bit_shift = 16, n_colors = 1; exec_cmd_palette_bit_shift > 0; exec_cmd_palette_bit_shift--)
				{
					if (n_colors >= current_plot.cmap.allocated)
					{
						break;
					}
					n_colors <<= 1;
				}
				}
	///#endif

				create_image = true;
			}
			else
			{

				switch (vis.class)
				{

	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//			static sbyte *display_error_text_after = " display class cannot use component" "\n                     " "data.  Try palette mode.\n\n";

				case TrueColor:

				/* This algorithm for construction of pixel values from the RGB components
				 * doesn't look to be the most portable.  However, it tries to be.  It
				 * gets the red/green/blue masks from the X11 information and generates
				 * appropriate shifts and masks from that.  The X11 documentation mentions
				 * something about using the masks in some odd way to generate an index
				 * for a color table.  It all seemed like a bother for no benefit however.
				 * Certainly we don't want to have only a few bits of color, and we don't
				 * want to have some huge color table.  My feeling on the matter is to
				 * just pack bits according to the masks that X11 indicates.  If someone
				 * finds they have a peculiar display type that doesn't work, that can be
				 * considered when and if it happens.
				 */

				/* Get the color mask information and compute the proper bit shifts, but only upon
				 * first call or if the masks change.  I'm not sure if it is necessary to check if
				 * the masks changed, but I left it in as a safeguard in case there is some strange
				 * system out there somewhere.
				 */
				if (exec_cmd_R_msb_mask == 0 || (vis.red_mask != exec_cmd_prev_red_mask) || (vis.green_mask != prev_green_mask) || (vis.blue_mask != prev_blue_mask))
				{
					short R_bits;
					short G_bits;
					short B_bits;
					short min_bits;
					exec_cmd_prev_red_mask = vis.red_mask;
					prev_green_mask = vis.green_mask;
					prev_blue_mask = vis.blue_mask;
					exec_cmd_R_msb_mask = GlobalMembersGplt_x11.BitMaskDetails(vis.red_mask, R_rshift, R_lshift);
					exec_cmd_G_msb_mask = GlobalMembersGplt_x11.BitMaskDetails(vis.green_mask, G_rshift, G_lshift);
					exec_cmd_B_msb_mask = GlobalMembersGplt_x11.BitMaskDetails(vis.blue_mask, B_rshift, B_lshift);

					/* Graphics info in case strange behavior occurs in a particular system.
					 */
					GlobalMembersFit.a((stderr, "\n\nvis->visualid: 0x%x   vis->class: %d   vis->bits_per_rgb: %d\n", (int)vis.visualid, vis.class, vis.bits_per_rgb));
					GlobalMembersFit.a((stderr, "vis->red_mask: %lx   vis->green_mask: %lx   vis->blue_mask: %lx\n", vis.red_mask, vis.green_mask, vis.blue_mask));
					GlobalMembersFit.a((stderr, "ImageByteOrder:  %d\n\n", ImageByteOrder(dpy)));

					R_bits = 32 - R_rshift - R_lshift;
					G_bits = 32 - G_rshift - G_lshift;
					B_bits = 32 - B_rshift - B_lshift;
					min_bits = ((((R_bits) < (G_bits) ? (R_bits) : (G_bits))) < (B_bits) ? (((R_bits) < (G_bits) ? (R_bits) : (G_bits))) : (B_bits));
					if (R_bits > min_bits)
					{
					exec_cmd_R_msb_mask >>= (R_bits - min_bits);
					R_lshift += (R_bits - min_bits);
					R_bits = min_bits;
					}
					if (G_bits > min_bits)
					{
					exec_cmd_G_msb_mask >>= (G_bits - min_bits);
					G_lshift += (G_bits - min_bits);
					G_bits = min_bits;
					}
					if (B_bits > min_bits)
					{
					exec_cmd_B_msb_mask >>= (B_bits - min_bits);
					B_lshift += (B_bits - min_bits);
					B_bits = min_bits;
					}
					R_rshift = 16 - R_bits;
					G_rshift = 16 - G_bits;
					B_rshift = 16 - B_bits;

	///#if !LET_XPUTPIXEL_SWAP_BYTES
	// /* Now deal with the byte order issue. */
	//			    if (ImageByteOrder(dpy)) {
	// /* If the bit field for each channel is 8 bits, the masks can be rearranged instead
	//  * of having to actually perform a byte order swap on the image data.
	//  */
	//				if ((R_bits == 8) && (G_bits == 8) && (B_bits == 8)) {
	//				    R_lshift = 24 - R_lshift;
	//				    G_lshift = 24 - G_lshift;
	//				    B_lshift = 24 - B_lshift;
	//				    swap_image_bytes = FALSE;
	//				} else {
	//				    swap_image_bytes = TRUE;
	//				}
	//			    } else {
	//				swap_image_bytes = FALSE;
	//			    }
	///#endif
				}

				create_image = true;
				break;

				case PseudoColor:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "PseudoColor");
				fprintf(stderr, exec_cmd_display_error_text_after);
				break;

				case GrayScale:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "GrayScale");
				fprintf(stderr, exec_cmd_display_error_text_after);
				break;

				case StaticColor:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "StaticColor");
				fprintf(stderr, exec_cmd_display_error_text_after);
				break;

				case StaticGray:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "StaticGray");
				fprintf(stderr, exec_cmd_display_error_text_after);
				break;

				case DirectColor:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "DirectColor display class currently" "\n                     " "not supported.\n\n");
				break;

				default:
				fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Unknown X11 display class.\n\n");
				break;

				}

			}

			if (create_image)
			{

				int M_pixel;
				int N_pixel;
				int M_view;
				int N_view;
				int pixel_1_1_x_plot;
				int pixel_1_1_y_plot;
				int pixel_M_N_x_plot;
				int pixel_M_N_y_plot;
				int view_1_1_x_plot;
				int view_1_1_y_plot;
				int view_M_N_x_plot;
				int view_M_N_y_plot;
				int final_1_1_x_plot;
				int final_1_1_y_plot;
				int i_start;
				int j_start;
				int itmp;

				/* Compute the image extent with sanity check. */
				pixel_1_1_x_plot = (int)((exec_cmd_pixel_1_1_x) * xscale);
				pixel_M_N_x_plot = (int)((pixel_M_N_x) * xscale);
				M_pixel = pixel_M_N_x_plot - pixel_1_1_x_plot;
				if (M_pixel < 0)
				{
				M_pixel = -M_pixel;
				itmp = pixel_1_1_x_plot;
				pixel_1_1_x_plot = pixel_M_N_x_plot;
				pixel_M_N_x_plot = itmp;
				}
				pixel_1_1_y_plot = (int)((4095 - (pixel_1_1_y)) * yscale);
				pixel_M_N_y_plot = (int)((4095 - (pixel_M_N_y)) * yscale);
				N_pixel = pixel_M_N_y_plot - pixel_1_1_y_plot;
				if (N_pixel < 0)
				{
				N_pixel = -N_pixel;
				itmp = pixel_1_1_y_plot;
				pixel_1_1_y_plot = pixel_M_N_y_plot;
				pixel_M_N_y_plot = itmp;
				}

				/* Compute the visual extent of the plot with sanity check. */
				view_1_1_x_plot = (int)((exec_cmd_visual_1_1_x) * xscale);
				view_M_N_x_plot = (int)((visual_M_N_x) * xscale);
				if (view_M_N_x_plot < view_1_1_x_plot)
				{
				itmp = view_1_1_x_plot;
				view_1_1_x_plot = view_M_N_x_plot;
				view_M_N_x_plot = itmp;
				}
				view_1_1_y_plot = (int)((4095 - (visual_1_1_y)) * yscale);
				view_M_N_y_plot = (int)((4095 - (visual_M_N_y)) * yscale);
				if (view_M_N_y_plot < view_1_1_y_plot)
				{
				itmp = view_1_1_y_plot;
				view_1_1_y_plot = view_M_N_y_plot;
				view_M_N_y_plot = itmp;
				}

				/* Determine parameters for the image that will be built and put on screen. */
				itmp = view_1_1_x_plot - pixel_1_1_x_plot;
				if (itmp > 0)
				{
				i_start = itmp;
				final_1_1_x_plot = view_1_1_x_plot;
				}
				else
				{
				i_start = 0;
				final_1_1_x_plot = pixel_1_1_x_plot;
				}
				itmp = pixel_M_N_x_plot - view_M_N_x_plot;
				if (itmp > 0)
				{
				M_view = M_pixel - itmp - i_start;
				}
				else
				{
				M_view = M_pixel - i_start;
				}

				itmp = view_1_1_y_plot - pixel_1_1_y_plot;
				if (itmp > 0)
				{
				j_start = itmp;
				final_1_1_y_plot = view_1_1_y_plot;
				}
				else
				{
				j_start = 0;
				final_1_1_y_plot = pixel_1_1_y_plot;
				}
				itmp = pixel_M_N_y_plot - view_M_N_y_plot;
				if (itmp > 0)
				{
				N_view = N_pixel - itmp - j_start;
				}
				else
				{
				N_view = N_pixel - j_start;
				}

				if ((M_view > 0) && (N_view > 0))
				{

				String sample_data;
				short sample_data_size;
				int i_view;
				int j_view;

				/* Determine if 2 bytes is sufficient or 4 bytes are necessary for color image data. */
				sample_data_size = (dep > 16) ? 4 : 2;

				/* Expand or compress the original image to the pixels it will occupy on the screen. */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
				sample_data = (String) malloc(M_view * N_view * sample_data_size);

				if (sample_data != null)
				{

					XImage image_src = DefineConstants.NULL;
					XImage image_dest;

					/* Create an initialized image object. */
					image_dest = XCreateImage(dpy, vis, dep, ZPixmap, 0, sample_data, M_view, N_view, 8 * sample_data_size, M_view * sample_data_size);
					if (image_dest == null)
					{
					fputs("gnuplot_x11: can't get memory for image object.\n", stderr);
					do
					{
						GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
						close(1);
						close(0);
						System.exit(1);
					} while (0);
					}

					/* Get the drawable image if using alpha blending. */
					if (exec_cmd_color_mode == t_imagecolor.IC_RGBA.getValue())
					image_src = XGetImage(dpy, current_plot.pixmap, final_1_1_x_plot, final_1_1_y_plot, M_view, N_view, AllPlanes, ZPixmap);

					/* Fill in the output image data by decimating or repeating the input image data. */
					for (j_view = 0; j_view < N_view; j_view++)
					{
					int j = ((j_view + j_start) * N) / N_pixel;
					int row_start = j * exec_cmd_M;
					for (i_view = 0; i_view < M_view; i_view++)
					{
						int i = ((i_view + i_start) * exec_cmd_M) / M_pixel;
						if (exec_cmd_color_mode == t_imagecolor.IC_PALETTE.getValue())
						{

	///#if SINGLE_PALETTE_BIT_SHIFT
	/* If the palette size is 2 to some power then a single bit shift would work.
	 * The multiply/shift method doesn't seem noticably slower and generally works
	 * with any size pallete.  Keep this around for the time being in case some
	 * use for it comes up.
	 */
						int pixel = current_plot.cmap.pixels[exec_cmd_image[row_start + i] >> exec_cmd_palette_bit_shift];
	///#else
	// /* The methods below avoid using floating point.  The basic idea is to multiply
	//  * the palette size by the "normalized" data coming across the pipe.  (I think
	//  * some DSP people call this Q1 or Q0 format, or something like that.)  Following
	//  * this multiplication by division by 2^16 gives the final answer.  Most moderately
	//  * advanced CPUs have bit shifting.  The first method uses this.  However, a bit
	//  * shift isn't necessary because we can just take the top word of a two word
	//  * number and we've effectively divided by 2^16.  The second method uses this.
	//  * However, my guess is that C compilers more effeciently translate the first
	//  * method with the bit shift than the second method which pulls out the top word.
	//  * (There is one instruction less for the shift version than the word selection
	//  * version on gcc for x86.)
	//  */
	///#if 1
	//					unsigned long pixel;
	//					unsigned short index  = (plot->cmap->allocated * (unsigned long) image[row_start + i]) >> 16;
	//					pixel = plot->cmap->pixels[index];
	///#else
	//					unsigned long index;
	//					unsigned long pixel;
	//					index  = plot->cmap->allocated * (unsigned long) image[row_start + i];
	//					pixel = plot->cmap->pixels[((unsigned short *)&index)[1]];
	///#endif
	///#endif
						XPutPixel(image_dest, i_view, j_view, pixel);
						}
						else if (exec_cmd_color_mode == t_imagecolor.IC_RGB.getValue())
						{
						int index3 = 3 * (row_start + i);
						int pixel = ((int)((exec_cmd_image[index3++] >> R_rshift) & exec_cmd_R_msb_mask)) << R_lshift;
						pixel |= ((int)((exec_cmd_image[index3++] >> G_rshift) & exec_cmd_G_msb_mask)) << G_lshift;
						pixel |= ((int)((exec_cmd_image[index3] >> B_rshift) & exec_cmd_B_msb_mask)) << B_lshift;
						XPutPixel(image_dest, i_view, j_view, pixel);
						}
						else
						{
						/* EAM - I'm confused as to where the scaling happens, but by the time
						 * we arrive here, RGB components run 0-0xffff but A runs 0-0xff
						 */
						int index4 = 4 * (row_start + i);
						double alpha = (double)(exec_cmd_image[index4 + 3] & 0xff) / 255.;

						/* Decompose existing pixel, i.e., reverse process. */
						int pixel = XGetPixel(image_src, i_view, j_view);
						int red = ((pixel >> R_lshift) & exec_cmd_R_msb_mask) << R_rshift;
						int green = ((pixel >> G_lshift) & exec_cmd_G_msb_mask) << G_rshift;
						int blue = ((pixel >> B_lshift) & exec_cmd_B_msb_mask) << B_rshift;
						/* Apply alpha blending. */
						red = (alpha * exec_cmd_image[index4++] + (1.-alpha) * red);
						green = (alpha * exec_cmd_image[index4++] + (1.-alpha) * green);
						blue = (alpha * exec_cmd_image[index4] + (1.-alpha) * blue);
						pixel = ((int)((red >> R_rshift) & exec_cmd_R_msb_mask)) << R_lshift;
						pixel |= ((int)((green >> G_rshift) & exec_cmd_G_msb_mask)) << G_lshift;
						pixel |= ((int)((blue >> B_rshift) & exec_cmd_B_msb_mask)) << B_lshift;
						XPutPixel(image_dest, i_view, j_view, pixel);
						}
					}
					}

	///#if !LET_XPUTPIXEL_SWAP_BYTES
	// /* Swap the image byte order if necessary. */
	//			    if (swap_image_bytes) {
	//				int i_swap = M_view*N_view - 1;
	//				if (sample_data_size == 2) {
	//				    for (; i_swap >= 0; i_swap--) {
	//					byteswap2(&(((unsigned short *)sample_data)[i_swap]));
	//				    }
	//				} else {
	//				    for (; i_swap >= 0; i_swap--) {
	//					byteswap4(&(((unsigned int *)sample_data)[i_swap]));
	//				    }
	//				}
	//			    }
	///#endif

					/* Copy the image to the drawable d. */
					XPutImage(dpy, current_plot.pixmap, gc, image_dest, 0, 0, final_1_1_x_plot, final_1_1_y_plot, M_view, N_view);

					/* Free resources. */
					XDestroyImage(image_dest);
					if (exec_cmd_color_mode == t_imagecolor.IC_RGBA.getValue())
					XDestroyImage(image_src);

					/* XDestroyImage frees the sample_data memory, so no "free" here. */

				}
				else
				{
					fprintf(stderr, "\nGNUPLOT (gplt_x11):  " "Could not allocate memory for image.\n\n");
				}
				}

			}

			/* image was not used as part of X resource, so must "free" here. */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
			free(exec_cmd_image);

			}
		}

		}

	///#if defined(USE_MOUSE) && defined(MOUSE_ALL_WINDOWS)
		/*   Axis scaling information to save for later mouse clicks */
		else if (buffer.equals('S'))
		{
		int axis;
		int axis_mask;

		sscanf(buffer.charAt(1), "%d %d", axis, axis_mask);
		if (axis == -2)
		{
			current_plot.almost2d = axis_mask;
		}
		else if (axis < 0)
		{
			current_plot.axis_mask = axis_mask;
		}
		else if (axis < 2 * DefineConstants.SECOND_AXES)
		{
			sscanf(buffer.charAt(1), "%d %lg %d %lg %lg", axis, (current_plot.axis_scale[axis].min), (current_plot.axis_scale[axis].term_lower), (current_plot.axis_scale[axis].term_scale), (current_plot.axis_scale[axis].logbase));
			GlobalMembersFit.a((stderr, "gnuplot_x11: axis %d scaling %14.3lg %14d %14.3lg %14.3lg\n", axis, current_plot.axis_scale[axis].min, current_plot.axis_scale[axis].term_lower, current_plot.axis_scale[axis].term_scale, current_plot.axis_scale[axis].logbase));
		}
		}
	///#endif
		/*   Switch to a different color map */
		else if (buffer.equals('e'))
		{
		if (have_pm3d != 0)
		{
			/* Get colormap index and choose find the appropriate cmap */
			int cm_index;
			int i;
			cmap_struct csp;
			sscanf(buffer.charAt(1), "%u", cm_index);
			csp = current_plot.first_cmap_struct;
			for (i = 0; i < cm_index; i++)
			csp = csp.next_cmap_struct;
			current_plot.cmap = csp.cmap;
		}
		}
		else
		{
		fprintf(stderr, "gnuplot_x11: unknown command <%s>\n", buffer);
		}
	}

///#endif
///#endif	// DISABLE_SPACE_RAISES_CONSOLE 


/*---------------------------------------------------------------------------
 *  reset all cursors (since we dont have a record of the previous terminal #)
 *---------------------------------------------------------------------------*/


	public static void reset_cursor()
	{
		plot_struct current_plot = plot_list_start;

		while (current_plot != null)
		{
		if (current_plot.window != null)
		{
			GlobalMembersFit.a((stderr, "Window for plot %d exists\n", current_plot.plot_number));
			XUndefineCursor(dpy, current_plot.window);
		}
		current_plot = current_plot.next_plot;
		}

		GlobalMembersFit.a((stderr, "Cursors reset\n"));
		return;
	}

	public static void preset(int argc, tangible.RefObject<String[]> argv)
	{
		int Argc = argc;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		String Argv = argv.argvalue;

	///#ifdef VMS
	//    char *ldisplay = (char *) 0;
	///#else
		byte ldisplay = getenv("DISPLAY");
	///#endif
		byte home = getenv("HOME");
		String server_defaults;
		String env;
		String buffer = new String(new char[256]);
	///#if 0
	////    Visual *TrueColor_vis, *PseudoColor_vis, *StaticGray_vis, *GrayScale_vis;
	////    int TrueColor_depth, PseudoColor_depth, StaticGray_depth, GrayScale_depth;
	///#endif
		String db_string;

		GlobalMembersFit.a((stderr, "(preset) \n"));

		/* avoid bus error when env vars are not set */
		if (ldisplay == DefineConstants.NULL)
		ldisplay = "";
		if (home == DefineConstants.NULL)
		home = "";

	/*---set to ignore ^C and ^Z----------------------------------------------*/

		signal(SIGINT, SIG_IGN);
	///#ifdef SIGTSTP
	//    signal(SIGTSTP, SIG_IGN);
	///#endif

	/*---prescan arguments for "-name"----------------------------------------*/

		while (++Argv, --Argc > 0)
		{
		if (!strcmp(Argv, "-name") && Argc > 1)
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			X_Name = String.valueOf(Argv.charAt(1)).substring(0, sizeof(X_Name) - 1);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			X_Class = String.valueOf(Argv.charAt(1)).substring(0, sizeof(X_Class) - 1);
			/* just in case */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			X_Name = tangible.StringFunctions.changeCharacter(X_Name, sizeof(X_Name) - 1, DefineConstants.NUL);
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			X_Class = tangible.StringFunctions.changeCharacter(X_Class, sizeof(X_Class) - 1, DefineConstants.NUL);
			if (X_Class.charAt(0) >= 'a' && X_Class.charAt(0) <= 'z')
			X_Class.charAt(0) -= 0x20;
		}
		}
		Argc = argc;
		Argv = argv.argvalue;

	/*---parse command line---------------------------------------------------*/

		XrmInitialize();
//C++ TO JAVA CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: XrmParseCommand(&dbCmd, options, sizeof(options) / sizeof(options[0]), X_Name, &Argc, Argv);
		XrmParseCommand(dbCmd, options, options.length, X_Name, Argc, Argv);
		if (Argc > 1)
		{
	///#ifdef PIPE_IPC
		if (!strcmp(Argv.charAt(1), "-noevents"))
		{
			GlobalMembersGpexecute.pipe_died = 1;
		}
		else
		{
	///#endif
			fprintf(stderr, "\ngnuplot: bad option: %s\ngnuplot: X11 aborted.\n", Argv.charAt(1));
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
	///#ifdef PIPE_IPC
		}
	///#endif
		}
		if (GlobalMembersGplt_x11.pr_GetR(dbCmd, ".display") != null)
		ldisplay = (String) value.addr;

	/*---open display---------------------------------------------------------*/

	///#ifdef USE_MOUSE
		XSetErrorHandler(GlobalMembersGplt_x11.ErrorHandler);
	///#endif
		dpy = XOpenDisplay(ldisplay);
		if (dpy == null)
		{
		fprintf(stderr, "\ngnuplot: unable to open display '%s'\ngnuplot: X11 aborted.\n", ldisplay);
		do
		{
			GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
			close(1);
			close(0);
			System.exit(1);
		} while (0);
		}
		scr = DefaultScreen(dpy);
		root = DefaultRootWindow(dpy);
		server_defaults = XResourceManagerString(dpy);
		vis = DefaultVisual(dpy, scr);
		dep = DefaultDepth(dpy, scr);
		default_cmap.colormap = DefaultColormap(dpy, scr);
		current_cmap = default_cmap;
		max_request_size = XMaxRequestSize(dpy) / 2;


	/**** atoms we will need later ****/

		WM_PROTOCOLS = XInternAtom(dpy, "WM_PROTOCOLS", False);
		WM_DELETE_WINDOW = XInternAtom(dpy, "WM_DELETE_WINDOW", False);


	/*---get application defaults--(subset of Xt processing)------------------*/

	///#ifdef VMS
	//    strcpy(buffer, "DECW$USER_DEFAULTS:GNUPLOT_X11.INI");
	///#elif defined OS2
	// /* for XFree86 ... */
	//    {
	//	char appdefdir[MAXPATHLEN];
	//	strncpy(appdefdir,
	//	        __XOS2RedirRoot("/XFree86/lib/X11/app-defaults"),
	//	        sizeof(appdefdir));
	//	sprintf(buffer, "%s/%s", appdefdir, "Gnuplot");
	//    }
	///#else // !OS/2
		{
		String appdefdir;
		if ((appdefdir = getenv("XAPPLRESDIR")) == DefineConstants.NULL)
		{
	///#ifdef XAPPLRESDIR
				buffer = DefineConstants.XAPPLRESDIR;
				buffer += "/";
				buffer += "Gnuplot";
	///#else
	//	    *buffer = '\0';
	///#endif
		}
		else
		{
				buffer = appdefdir;
				buffer += "/";
				buffer += "Gnuplot";
		}
		}
	///#endif // !VMS

		dbApp = XrmGetFileDatabase(buffer);
		XrmMergeDatabases(dbApp, db);

	/*---get server or ~/.Xdefaults-------------------------------------------*/

		if (server_defaults != null)
		dbDef = XrmGetStringDatabase(server_defaults);
		else
		{
	///#ifdef VMS
	//	strcpy(buffer, "DECW$USER_DEFAULTS:DECW$XDEFAULTS.DAT");
	///#else
		buffer = home;
		buffer += "/.Xdefaults";
	///#endif
		dbDef = XrmGetFileDatabase(buffer);
		}
		XrmMergeDatabases(dbDef, db);

	/*---get XENVIRONMENT or  ~/.Xdefaults-hostname---------------------------*/

	///#ifndef VMS
		if ((env = getenv("XENVIRONMENT")) != DefineConstants.NULL)
		dbEnv = XrmGetFileDatabase(env);
		else
		{
		String p = DefineConstants.NULL;
		String host = new String(new char[DefineConstants.MAXHOSTNAMELEN]);

		if (gethostname((host), DefineConstants.MAXHOSTNAMELEN) < 0)
		{
			fprintf(stderr, "gnuplot: %s failed. X11 aborted.\n", DefineConstants.SYSINFO_METHOD);
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
		}
		if ((p = tangible.StringFunctions.strChr(host, '.')) != DefineConstants.NULL)
			p = '\0';
		buffer = home;
		buffer += "/.Xdefaults-";
		buffer += host;
		dbEnv = XrmGetFileDatabase(buffer);
		}
		XrmMergeDatabases(dbEnv, db);
	///#endif // not VMS

	/*---merge command line options-------------------------------------------*/

		XrmMergeDatabases(dbCmd, db);

	/*---set geometry, font, colors, line widths, dash styles, point size-----*/

		/* a specific visual can be forced by the X resource visual */
		db_string = GlobalMembersGplt_x11.pr_GetR(db, ".visual") != null ? (String) value.addr : (String) 0;
		if (db_string != null)
		{
		Visual visual = (Visual) 0;
		int depth = (int) 0;
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		String ptr = visual_name;
		int i;
		for (i = 0; ptr; i++, ptr++)
		{
			if (!strcmp(db_string, ptr))
			{
	///#if 0
	////		if (DirectColor == i) {
	////		    fprintf(stderr, "DirectColor not supported by pm3d, using default.\n");
	////		} else
	///#endif
			if (GlobalMembersGplt_x11.GetVisual(i, visual, depth) != 0)
			{
				vis = visual;
				dep = depth;
				if (vis != DefaultVisual(dpy, scr))
				{
				/* this will be the default colormap */
				default_cmap.colormap = XCreateColormap(dpy, root, vis, AllocNone);
				}
			}
			else
			{
				fprintf(stderr, "%s not supported by %s, using default.\n", ptr, ldisplay);
			}
			break;
			}
		}
		}
	///#if 0
	////    if (DirectColor == vis->class) {
	////	have_pm3d = 0;
	////    }
	///#endif
	///#if 0
	//// /* removed this message as it is annoying
	////  * when using gnuplot in a pipe (joze) */
	////    if (vis->class < (sizeof(visual_name) / sizeof(char **)) - 1) {
	////	fprintf(stderr, "Using %s at depth %d.\n", visual_name[vis->class], dep);
	////    }
	///#endif
		GlobalMembersGplt_x11.CmapClear(default_cmap);

		/* set default of maximal_possible_colors */
		if (dep > 12)
		{
		maximal_possible_colors = 0x200;
		}
		else if (dep > 8)
		{
		maximal_possible_colors = 0x100;
		}
		else
		{
		/* will be something like PseudoColor * 8 */
		maximal_possible_colors = 240; // leave 16 for line colors
		}

		/* check database for maxcolors */
		db_string = GlobalMembersGplt_x11.pr_GetR(db, ".maxcolors") != null ? (String) value.addr : (String) 0;
		if (db_string != null)
		{
		int itmp;
		if (sscanf(db_string, "%d", itmp))
		{
			if (itmp <= 0)
			{
			fprintf(stderr, "\nmaxcolors must be strictly positive.\n");
			}
			else if (itmp > Math.pow((double) 2, (double) dep))
			{
			fprintf(stderr, "\noops, cannot use this many colors on a %d bit deep display.\n", dep);
			}
			else
			{
			maximal_possible_colors = itmp;
			}
		}
		else
		{
			fprintf(stderr, "\nunable to parse '%s' as integer\n", db_string);
		}
		}

		/* setting a default for minimal_possible_colors */
		minimal_possible_colors = maximal_possible_colors / (num_colormaps > 1 ? 2 : 8); // 0x20 / 30
		/* check database for mincolors */
		db_string = GlobalMembersGplt_x11.pr_GetR(db, ".mincolors") != null ? (String) value.addr : (String) 0;
		if (db_string != null)
		{
		int itmp;
		if (sscanf(db_string, "%d", itmp))
		{
			if (itmp <= 0)
			{
			fprintf(stderr, "\nmincolors must be strictly positive.\n");
			}
			else if (itmp > Math.pow((double) 2, (double) dep))
			{
			fprintf(stderr, "\noops, cannot use this many colors on a %d bit deep display.\n", dep);
			}
			else if (itmp > maximal_possible_colors)
			{
			fprintf(stderr, "\nmincolors must be <= %d\n", maximal_possible_colors);
			}
			else
			{
			minimal_possible_colors = itmp;
			}
		}
		else
		{
			fprintf(stderr, "\nunable to parse '%s' as integer\n", db_string);
		}
		}

		GlobalMembersGplt_x11.pr_geometry(DefineConstants.NULL);
		GlobalMembersGplt_x11.pr_encoding(); // check for global default encoding
		GlobalMembersGplt_x11.pr_font(DefineConstants.NULL); // set current font to default font
		GlobalMembersGplt_x11.pr_color(default_cmap); // set colors for default colormap
		GlobalMembersGplt_x11.pr_width();
		GlobalMembersGplt_x11.pr_dashes();
		GlobalMembersGplt_x11.pr_pointsize();
		GlobalMembersGplt_x11.pr_raise();
		GlobalMembersGplt_x11.pr_persist();
		GlobalMembersGplt_x11.pr_feedback();
		GlobalMembersGplt_x11.pr_ctrlq();
		GlobalMembersGplt_x11.pr_fastrotate();
	///#ifdef EXPORT_SELECTION
		GlobalMembersGplt_x11.pr_exportselection();
	///#endif

	}

/*-----------------------------------------------------------------------------
 *   pr_GetR - get resource from database using "-name" option (if any)
 *---------------------------------------------------------------------------*/

	public static String pr_GetR(XrmDatabase xrdb, String resource)
	{
		String name = new String(new char[128]);
		String class_Renamed = new String(new char[128]);
		String rc;

		name = X_Name;
		name += resource;
		class_Renamed = X_Class;
		class_Renamed += resource;
		rc = XrmGetResource(xrdb, name, class_Renamed, type, value) ? (String) value.addr : (String) 0;
		return (rc);
	}
	public static void pr_color(cmap_t cmap_ptr)
	{
		int black = BlackPixel(dpy, scr);
		int white = WhitePixel(dpy, scr);
		String option = new String(new char[20]);
		String color = new String(new char[30]);
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
		byte * v;
		String ctype;
		XColor xcolor = new XColor();
		double intensity = -1;
		int n;

		if (GlobalMembersGplt_x11.pr_GetR(db, ".mono") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		Mono++;
		if (GlobalMembersGplt_x11.pr_GetR(db, ".gray") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		Gray++;
		if (GlobalMembersGplt_x11.pr_GetR(db, ".reverseVideo") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		Rv++;

		if (Gray == null && (vis.class == GrayScale || vis.class == StaticGray))
		Mono++;

		if (Mono == null)
		{

		ctype = (Gray) ? "Gray" : "Color";

		if (current_cmap != cmap_ptr)
		{
			/* for private colormaps: make sure
			 * that pixel 0 gets black (joze) */
			xcolor.red = 0;
			xcolor.green = 0;
			xcolor.blue = 0;
			XAllocColor(dpy, cmap_ptr.colormap, xcolor);
		}

		for (n = 0; n < DefineConstants.Ncolors; n++)
		{
			option = ".";
			option += color_keys[n];
			if (n > 1)
			option += ctype;
			v = GlobalMembersGplt_x11.pr_GetR(db, option) != null ? (String) value.addr : ((Gray) ? gray_values[n] : (Rv != null ? color_values_rv[n] : color_values[n]));

			if (sscanf(v, "%30[^, ], %lf", color, intensity) == 2)
			{
			if (intensity < 0 || intensity > 1)
			{
				fprintf(stderr, "\ngnuplot: invalid color intensity in '%s'\n", color);
				intensity = 1;
			}
			}
			else
			{
			color = v;
			intensity = 1;
			}

			if (!XParseColor(dpy, cmap_ptr.colormap, color, xcolor))
			{
			fprintf(stderr, "\ngnuplot: unable to parse '%s'. Using black.\n", color);
			cmap_ptr.colors[n] = black;
			}
			else
			{
			xcolor.red *= intensity;
			xcolor.green *= intensity;
			xcolor.blue *= intensity;
			if (XAllocColor(dpy, cmap_ptr.colormap, xcolor))
			{
				cmap_ptr.colors[n] = xcolor.pixel;
				cmap_ptr.rgbcolors[n] = ((xcolor.red >> 8 & 0xff) << 16) + ((xcolor.green>>8 & 0xff) << 8) + (xcolor.blue>>8);
			}
			else
			{
				fprintf(stderr, "\ngnuplot: can't allocate '%s'. Using black.\n", v);
				cmap_ptr.colors[n] = black;
			}
			}
		}
		}
		else
		{
		cmap_ptr.colors[0] = (Rv) ? black : white;
		for (n = 1; n < DefineConstants.Ncolors; n++)
			cmap_ptr.colors[n] = (Rv) ? white : black;
		}
	///#ifdef USE_MOUSE
		{
		/* create the xor GC just for allocating the xor value
		 * before a palette is created. This way the xor foreground
		 * will be available. */
		GlobalMembersGplt_x11.AllocateXorPixel(cmap_ptr);
		}
	///#endif
	}
	public static void pr_dashes()
	{
		int n;
		int j;
		int l;
		int ok;
		String option = new String(new char[20]);
		String v;

		if (GlobalMembersGplt_x11.pr_GetR(db, ".dashed") != null)
		{
		dashedlines = (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4));
		}

		for (n = 0; n < DefineConstants.Ndashes; n++)
		{
		option = ".";
		option += dash_keys[n];
		option += "Dashes";
		v = GlobalMembersGplt_x11.pr_GetR(db, option) != null ? (String) value.addr : ((Mono) ? dash_mono[n] : dash_color[n]);
		l = v.length();
		if (l == 1 && v.equals('0'))
		{
			dashes[n][0] = (byte) 0;
			continue;
		}
		for (ok = 0, j = 0; j < l; j++)
		{
			if (v.charAt(j) >= '1' && v.charAt(j) <= '9')
			ok++;
		}
		if (ok != l || (ok != 2 && ok != 4))
		{
			fprintf(stderr, "gnuplot: illegal dashes value %s:%s\n", option, v);
			dashes[n][0] = (byte) 0;
			continue;
		}
		for (j = 0; j < l; j++)
		{
			dashes[n][j] = (byte)(v.charAt(j) - '0');
		}
		dashes[n][l] = (byte) 0;
		}
	}
///#endif

	public static void pr_encoding()
	{
		String encoding;
		if ((encoding = GlobalMembersGplt_x11.pr_GetR(db, ".encoding")))
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		default_encoding = encoding.substring(0, sizeof(default_encoding) - 1);
		}
	}
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void pr_font(String NamelessParameter);

/*-----------------------------------------------------------------------------
 *   pr_geometry - determine window geometry
 *---------------------------------------------------------------------------*/

	public static void pr_geometry(String instr)
	{
		byte geometry = (!instr.equals(DefineConstants.NULL))? instr : GlobalMembersGplt_x11.pr_GetR(db, ".geometry");
		int x;
		int y;
		int flags;
		int w;
		int h;

		if (geometry != 0)
		{
		flags = XParseGeometry(geometry, x, y, w, h);
		if (flags & WidthValue != 0)
			gW = w;
		if (flags & HeightValue != 0)
			gH = h;
		if (flags & (WidthValue | HeightValue) != 0)
			gFlags = (gFlags & ~PSize) | USSize;

		if (flags & XValue != 0)
			gX = (flags & XNegative) ? x + DisplayWidth(dpy, scr) - gW - BorderWidth * 2 : x;

		if (flags & YValue != 0)
			gY = (flags & YNegative) ? y + DisplayHeight(dpy, scr) - gH - BorderWidth * 2 : y;

		if (flags & (XValue | YValue) != 0)
			gFlags = (gFlags & ~PPosition) | USPosition;
		}
	}

/*-----------------------------------------------------------------------------
 *   pr_pointsize - determine size of points for 'points' plotting style
 *---------------------------------------------------------------------------*/

	public static void pr_pointsize()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".pointsize") != null)
		{
		if (sscanf((String) value.addr, "%lf", pointsize) == 1)
		{
			if (pointsize <= 0 || pointsize > 10)
			{
			fprintf(stderr, "\ngnuplot: invalid pointsize '%s'\n", value.addr);
			pointsize = 1;
			}
		}
		else
		{
			fprintf(stderr, "\ngnuplot: invalid pointsize '%s'\n", value.addr);
			pointsize = 1;
		}
		}
		else
		{
		pointsize = 1;
		}
	}
	public static void pr_width()
	{
		int n;
		String option = new String(new char[20]);
		String v;

		for (n = 0; n < DefineConstants.Nwidths; n++)
		{
		option = ".";
		option += width_keys[n];
		option += "Width";
		if ((v = GlobalMembersGplt_x11.pr_GetR(db, option)) != DefineConstants.NULL)
		{
			if (v.compareTo('0') < 0 || v.compareTo('9') > 0 || v.length() > 1)
			fprintf(stderr, "gnuplot: illegal width value %s:%s\n", option, v);
			else
			widths[n] = (int) Integer.parseInt(v);
		}
		}
	}

/*-----------------------------------------------------------------------------
 *   pr_window - create window
 *---------------------------------------------------------------------------*/

//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static XSizeHints pr_window_hints = new XSizeHints();
	public static void pr_window(plot_struct current_plot)
	{
		byte title = GlobalMembersGplt_x11.pr_GetR(db, ".title");
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static XSizeHints hints;
		int Tvtwm = 0;
		int event_mask = KeyPressMask | KeyReleaseMask | StructureNotifyMask | PointerMotionMask | PointerMotionHintMask | ButtonPressMask | ButtonReleaseMask | ExposureMask | EnterWindowMask;

		GlobalMembersFit.a((stderr, "(pr_window) \n"));

	///#ifdef EXTERNAL_X11_WINDOW
		if (current_plot.external_container != None)
		{
		XWindowAttributes gattr = new XWindowAttributes();
		XGetWindowAttributes(dpy, current_plot.external_container, gattr);
		current_plot.x = 0;
		current_plot.y = 0;
		current_plot.width = gattr.width;
		current_plot.height = gattr.height;
		current_plot.gheight = gattr.height;
		if (current_plot.window == null)
		{
			current_plot.window = XCreateWindow(dpy, current_plot.external_container, current_plot.x, current_plot.y, current_plot.width, current_plot.height, 0, dep, InputOutput, vis, 0, DefineConstants.NULL);
			GlobalMembersGplt_x11.gp_execute_GE_plotdone(current_plot.window); // notify main program, send WINDOWID
		}
		}
	///#endif // EXTERNAL_X11_WINDOW

		if (have_pm3d != 0)
		{
		XSetWindowAttributes attr = new XSetWindowAttributes();
		int mask = CWBackPixel | CWBorderPixel | CWColormap;
		attr.background_pixel = current_plot.cmap.colors[0];
		attr.border_pixel = current_plot.cmap.colors[1];
		attr.colormap = current_plot.cmap.colormap;
		if (current_plot.window == null)
		{
			current_plot.window = XCreateWindow(dpy, root, current_plot.x, current_plot.y, current_plot.width, current_plot.height, BorderWidth, dep, InputOutput, vis, mask, attr);
			GlobalMembersGplt_x11.gp_execute_GE_plotdone(current_plot.window); // notify main program, send WINDOWID
		}
		else
			XChangeWindowAttributes(dpy, current_plot.window, mask, attr);
		}
		else
	///#ifdef EXTERNAL_X11_WINDOW
		if (current_plot.window == null)
	///#endif
		{
		current_plot.window = XCreateSimpleWindow(dpy, root, current_plot.x, current_plot.y, current_plot.width, current_plot.height, BorderWidth, current_plot.cmap.colors[1], current_plot.cmap.colors[0]);
			GlobalMembersGplt_x11.gp_execute_GE_plotdone(current_plot.window); // notify main program, send WINDOWID
		}

		/* Return if something wrong. */
		if (current_plot.window == None)
		return;

		/* ask ICCCM-compliant window manager to tell us when close window
		 * has been chosen, rather than just killing us
		 */

		XChangeProperty(dpy, current_plot.window, WM_PROTOCOLS, XA_ATOM, 32, PropModeReplace, (byte) WM_DELETE_WINDOW, 1);

		if (GlobalMembersGplt_x11.pr_GetR(db, ".clear") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		Clear++;
		if (GlobalMembersGplt_x11.pr_GetR(db, ".tvtwm") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		Tvtwm++;

		if (Tvtwm == 0)
		{
		pr_window_hints.flags = current_plot.posn_flags;
		}
		else
		{
		pr_window_hints.flags = (current_plot.posn_flags & ~USPosition) | PPosition; // ?
		}
		pr_window_hints.x = gX;
		pr_window_hints.y = gY;
		pr_window_hints.width = current_plot.width;
		pr_window_hints.height = current_plot.height;

		XSetNormalHints(dpy, current_plot.window, pr_window_hints);

		if (GlobalMembersGplt_x11.pr_GetR(db, ".iconic") != null && (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)))
		{
		XWMHints wmh = new XWMHints();

		wmh.flags = StateHint;
		wmh.initial_state = IconicState;
		XSetWMHints(dpy, current_plot.window, wmh);
		}
	///#if 0 // 1 clear, 0 do not clear
	////    if (plot->titlestring) {
	////	free(plot->titlestring);
	////	plot->titlestring = 0;
	////    }
	///#endif

		/* Set up the events to process */
		XSelectInput(dpy, current_plot.window, event_mask);
	///#ifdef EXTERNAL_X11_WINDOW
		/* Two clients of an X window cannot share ButtonPress events at the same time.
		 * The outside application may still have ButtonPress selected, and that is the
		 * reason for using the external window as a container. */
		if (current_plot.external_container != None)
		XSelectInput(dpy, current_plot.external_container, event_mask & (~(ButtonPressMask | ButtonReleaseMask)));
	///#endif
		XSync(dpy, 0);

		/* If title doesn't exist, create one. */
	///#if 1
	///#define ICON_TEXT "gplt"
	///#define TEMP_NUM_LEN 16
		{
		/* append the X11 terminal number (if greater than zero) */
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		String numstr = new String(new char[sizeof(DefineConstants.ICON_TEXT) + DefineConstants.TEMP_NUM_LEN + 1]); // space for text, number and terminating \0
		if (current_plot.plot_number > 0)
		String.format(numstr, "%s%d%c", DefineConstants.ICON_TEXT, current_plot.plot_number, '\0');
		else
		String.format(numstr, "%s%c", DefineConstants.ICON_TEXT, '\0');
		GlobalMembersFit.a((stderr, "term_number is %d", current_plot.plot_number));
		XSetIconName(dpy, current_plot.window, numstr);
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef TEMP_NUM_LEN
		if (current_plot.titlestring == null)
		{
		int orig_len;
		if (title == 0)
			title = X_Class;
		orig_len = title.length();
		/* memory for text, white space, number and terminating \0 */
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
		if ((current_plot.titlestring = (String) malloc(orig_len + ((orig_len != 0 && (current_plot.plot_number > 0)) ? 1 : 0) + numstr.length() - DefineConstants.ICON_TEXT.length() + 1)))
		{
			current_plot.titlestring = title;
			if (orig_len != 0 && (current_plot.plot_number > 0))
			current_plot.titlestring = tangible.StringFunctions.changeCharacter(current_plot.titlestring, orig_len++, ' ');
			current_plot.titlestring + orig_len = numstr + DefineConstants.ICON_TEXT.length();
			XStoreName(dpy, current_plot.window, current_plot.titlestring);
		}
		else
			XStoreName(dpy, current_plot.window, title);
		}
		else
		{
		XStoreName(dpy, current_plot.window, current_plot.titlestring);
		}
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef ICON_TEXT
	///#endif

		XMapWindow(dpy, current_plot.window);
	///#ifdef EXTERNAL_X11_WINDOW
		if (current_plot.external_container != None)
		XMapWindow(dpy, current_plot.external_container);
	///#endif

		windows_open++;
	}

/***** pr_raise ***/
	public static void pr_raise()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".raise") != null)
		do_raise = ((!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)));
	}
	public static void pr_persist()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".persist") != null)
		persist = ((!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4)));
	}
	public static void pr_feedback()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".feedback") != null)
		feedback = !(!strncasecmp(value.addr, "off", 3) || !strncasecmp(value.addr, "false", 5));
		GlobalMembersFit.a((stderr, "gplt_x11: set feedback to %d (%s)\n", feedback, value.addr));
	}
	public static void pr_ctrlq()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".ctrlq") != null)
		{
		ctrlq = (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4));
		GlobalMembersFit.a((stderr, "gplt_x11: require <ctrl>q and <ctrl><space>\n"));
		}
	}
	public static void pr_fastrotate()
	{
		if (GlobalMembersGplt_x11.pr_GetR(db, ".fastrotate") != null)
		{
		fast_rotate = (!strncasecmp(value.addr, "on", 2) || !strncasecmp(value.addr, "true", 4));
		GlobalMembersFit.a((stderr, "gplt_x11: Use fast but imperfect text rotation\n"));
		}
	}

	///#ifdef EXPORT_SELECTION
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static void export_graph(plot_struct NamelessParameter);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to events in Java:
	//static void handle_selection_event(XEvent *event)

///#ifdef EXPORT_SELECTION
	//{
	//	switch (event->type)
	//	{
	//	case SelectionRequest:
	//	{
	//		XEvent reply;
	//
	//		static Atom XA_TARGETS = (Atom) 0;
	//		static Atom XA_TIMESTAMP = (Atom) 0;
	//
	//		if (XA_TARGETS == 0)
	//		XA_TARGETS = XInternAtom(dpy, "TARGETS", False);
	//		if (XA_TIMESTAMP == 0)
	//		XA_TIMESTAMP = XInternAtom(dpy, "TIMESTAMP", False);
	//
	//		reply.type = SelectionNotify;
	//		reply.xselection.send_event = True;
	//		reply.xselection.display = event->xselectionrequest.display;
	//		reply.xselection.requestor = event->xselectionrequest.requestor;
	//		reply.xselection.selection = event->xselectionrequest.selection;
	//		reply.xselection.target = event->xselectionrequest.target;
	//		reply.xselection.property = event->xselectionrequest.property;
	//		reply.xselection.time = event->xselectionrequest.time;
	//
	//		if (reply.xselection.target == XA_TARGETS)
	//		{
	//		static Atom targets[] = { XA_PIXMAP, XA_COLORMAP };
	//		static Atom mousecoord[] = { XA_STRING };
	//
	//		a((stderr, "Targets request from %d\n", reply.xselection.requestor));
	//
	//		if (*selection)
	//			XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 32, PropModeReplace, (byte *)(mousecoord), 1);
	//		else if (exported_plot)
	//			XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 32, PropModeReplace, (byte *) targets, 2);
	//		}
	//		else if (reply.xselection.target == XA_COLORMAP)
	//		{
	//
	//		a((stderr, "colormap request from %d\n", reply.xselection.requestor));
	//
	//		XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 32, PropModeReplace, (byte *) &(default_cmap.colormap), 1);
	//		}
	//		else if (reply.xselection.target == XA_PIXMAP && exported_plot)
	//		{
	//
	//		a((stderr, "pixmap request from %d\n", reply.xselection.requestor));
	//
	//		XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 32, PropModeReplace, (byte *) &(exported_plot->pixmap), 1);
	//		exported_plot = DefineConstants.NULL;
	//		}
	//		else if (reply.xselection.target == XA_TIMESTAMP)
	//		{
	//
	//		a((stderr, "timestamp request from %d : %ld\n", reply.xselection.requestor, export_time));
	//
	//		XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 32, PropModeReplace, (byte *) &(export_time), 1);
	/////#ifdef PIPE_IPC
	//		}
	//		else if (reply.xselection.target == XA_STRING && *selection)
	//		{
	//		a((stderr, "XA_STRING request\n"));
	//		XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target, 8, PropModeReplace, (byte *) selection, strlen(selection));
	//		*selection = '\0';
	/////#endif
	//		}
	//		else
	//		{
	//		a((stderr, "selection request target: %d\n", reply.xselection.target));
	//		reply.xselection.property = None;
	//		if (!exported_plot && ! *selection)
	// /* We have now satisfied the select request. Say goodbye */
	//			XSetSelectionOwner(dpy, XA_PRIMARY, None, CurrentTime);
	//		}
	//
	//		XSendEvent(dpy, reply.xselection.requestor, False, 0L, &reply);
	// /* we never block on XNextEvent(), so must flush manually
	//  * (took me *ages* to find this out !)
	//  */
	//
	//		XFlush(dpy);
	//	}
	//	break;
	//	}
	//}
	public static void pr_exportselection()
	{
		/* Allow export selection to be turned on or off using X resource *exportselection */
		if (GlobalMembersGplt_x11.pr_GetR(db, ".exportselection") != null)
		{
		if (!strncmp((String)value.addr, "off", 3) || !strncmp((String)value.addr, "false", 5))
		{
			exportselection = false;
			GlobalMembersFit.a((stderr, "gnuplot_x11: exportselection is disabled\n"));
		}
		}
	}

///#endif // EXPORT_SELECTION 

///#if defined(USE_MOUSE) && defined(MOUSE_ALL_WINDOWS)
/* Convert X-window mouse coordinates to coordinate system of plot axes */
	///#endif

	///#if defined(USE_MOUSE) && defined(MOUSE_ALL_WINDOWS)
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to events in Java:
	//static void mouse_to_coords(plot_struct *current_plot, XEvent *event, double *x, double *y, double *x2, double *y2)
	//{
	//	int xx = 4096.* (event->xbutton.x + 0.5)/ current_plot->width;
	//	int yy = 4095.- 4096.* (event->xbutton.y + 0.5)/ current_plot->gheight;
	//
	////C++ TO JAVA CONVERTER TODO TASK: There is no direct equivalent in Java to the C++ __LINE__ macro:
	//	a((stderr, "gnuplot_x11 %d: mouse at %d %d\t", __LINE__, xx, yy));
	//
	//	*x = mouse_to_axis(xx, &(current_plot->axis_scale[FIRST_X_AXIS]));
	//	*y = mouse_to_axis(yy, &(current_plot->axis_scale[FIRST_Y_AXIS]));
	//	*x2 = mouse_to_axis(xx, &(current_plot->axis_scale[SECOND_X_AXIS]));
	//	*y2 = mouse_to_axis(yy, &(current_plot->axis_scale[SECOND_Y_AXIS]));
	//
	//	a((stderr, "mouse x y %10g %10g x2 y2 %10g %10g\n", *x, *y, *x2, *y2));
	//}
	public static double mouse_to_axis(int mouse_coord, axis_scale_t axis)
	{
		double axis_coord;

		if (axis.term_scale == 0.0)
		return 0.;

		axis_coord = ((double)(mouse_coord - axis.term_lower)) / axis.term_scale + axis.min;
		if (axis.logbase > 0.0)
		axis_coord = Math.exp(axis_coord * axis.logbase);

		return axis_coord;
	}
	///#endif

	public static String FallbackFont = "fixed";
	///#ifdef USE_X11_MULTIBYTE
	public static String FallbackFontMB = "mbfont:*-medium-r-normal--14-*;*-medium-r-normal--16-*";
	///#define FontSetSep ';'
	public static int usemultibyte = 0;
	public static int multibyte_fonts_usable = 1;

///#ifdef USE_X11_MULTIBYTE
	public static int fontset_transsep(String nfname, String ofname, int n)
	{
		String s;

		nfname = ofname.substring(0, n);
		if (nfname.charAt(n - 1) != '\0')
		nfname.charAt(n) = '\0';
		if (tangible.StringFunctions.strChr(nfname, ','))
		return 1;
		s = nfname;
		while ((s = tangible.StringFunctions.strChr(nfname, DefineConstants.FontSetSep)) != DefineConstants.NULL)
		{
		s = ',';
		nfname = s;
		}
		return 0;
	}

/*-----------------------------------------------------------------------------
 *   pr_font - determine font
 *---------------------------------------------------------------------------*/

/* wrapper functions */
	///#endif // USE_X11_MULTIBYTE 
	public static int gpXTextWidth(XFontStruct cfont, String str, int count)
	{
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0)
		return XmbTextEscapement(mbfont, str, count);
	///#endif
		return XTextWidth(cfont, str, count);
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static XFontSetExtents gpXTextHeight_extents;
	public static int gpXTextHeight(XFontStruct cfont)
	{
	///#ifdef USE_X11_MULTIBYTE
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static XFontSetExtents *extents;
		if (usemultibyte != 0)
		{
		gpXTextHeight_extents = XExtentsOfFontSet(mbfont);
		return gpXTextHeight_extents.max_logical_extent.height;
		}
		else
	///#endif
		return cfont.ascent + cfont.descent;
	}
	public static void gpXSetFont(Display disp, GC gc, Font fontid)
	{
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte == 0)
	///#endif
		XSetFont(disp, gc, fontid);
	}
	public static void gpXDrawImageString(Display disp, Drawable d, GC gc, int x, int y, String str, int len)
	{
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0)
		{
		XmbDrawImageString(disp, d, mbfont, gc, x, y, str, len);
		return;
		}
	///#endif
		XDrawImageString(disp, d, gc, x, y, str, len);
	}
	public static void gpXDrawString(Display disp, Drawable d, GC gc, int x, int y, String str, int len)
	{
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0)
		{
		XmbDrawString(disp, d, mbfont, gc, x, y, str, len);
		return;
		}
	///#endif
		XDrawString(disp, d, gc, x, y, str, len);
	}
	public static void gpXFreeFont(Display disp, XFontStruct cfont)
	{
	///#ifndef USE_X11_MULTIBYTE
	//    if (cfont)
	//	XFreeFont(disp, cfont);
	///#else
		if (font != null)
		{
		XFreeFont(disp, font);
		font = DefineConstants.NULL;
		}
		if (mbfont != null)
		{
		XFreeFontSet(disp, mbfont);
		mbfont = DefineConstants.NULL;
		}
	///#endif
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String[] gpXLoadQueryFont_miss;
String def;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static boolean gpXLoadQueryFont_first_time = true;
	public static XFontStruct gpXLoadQueryFont(Display disp, String fontname)
	{
	///#ifndef USE_X11_MULTIBYTE
	//    return XLoadQueryFont(disp, fontname);
	///#else
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte **miss, *def;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static boolean first_time = true;
		int n_miss;
		String tmpfname = new String(new char[256]);

		if (usemultibyte == 0)
		return XLoadQueryFont(disp, fontname);
		else
		{
		GlobalMembersGplt_x11.fontset_transsep(tmpfname, fontname, 256 - 1);
		mbfont = XCreateFontSet(disp, tmpfname, gpXLoadQueryFont_miss, n_miss, def);

		/* This test seemed to make sense for Japanese locales, which only */
		/* claim to require a small number of character sets.  But it is   */
		/* highly likely to fail for more generic locales like en_US.UTF-8 */
		/* that claim to "require" about 2 dozen obscure character sets.   */
		/* EAM - do not fail the request; just continue after a warning.   */
		if (n_miss > 0)
		{
	///#if (0)
	//	    if (mbfont) {
	//		XFreeFontSet(disp, mbfont);
	//		mbfont=NULL;
	//	    }
	///#else
			if (gpXLoadQueryFont_first_time)
			{
			fprintf(stderr,"gnuplot_x11: Some character sets not available\n");
			gpXLoadQueryFont_first_time = false;
			}
			while (n_miss-- > 0)
			GlobalMembersFit.a((stderr,"Missing charset: %s\n", gpXLoadQueryFont_miss[n_miss]));
	///#endif
			XFreeStringList(gpXLoadQueryFont_miss);
		}

		return DefineConstants.NULL;
		}
	///#endif
	}
	public static String gpFallbackFont()
	{
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0)
		return FallbackFontMB;
	///#endif
		return FallbackFont;
	}
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static XFontStruct[] gpXGetFontascent_eachfonts;
	public static int gpXGetFontascent(XFontStruct cfont)
	{
	///#ifndef USE_X11_MULTIBYTE
	//    return cfont->ascent;
	///#else
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static XFontStruct **eachfonts;
		String[] fontnames;
		int max_ascent = 0;
		int i;
		int n_fonts;

		if (usemultibyte == 0)
			return font.ascent;
		n_fonts = XFontsOfFontSet(mbfont, gpXGetFontascent_eachfonts, fontnames);
		for (i = 0; i < n_fonts; i++)
		{
		if (gpXGetFontascent_eachfonts[i].ascent > max_ascent)
		  max_ascent = gpXGetFontascent_eachfonts[i].ascent;
		}
		return max_ascent;
	///#endif
	}

	public static set_encoding_id encoding = set_encoding_id.S_ENC_DEFAULT; // EAM - mirrored from core code by 'QE'
	public static String default_font = "";
	public static String default_encoding = "";

	///#define Nwidths 10
	public static int[] widths = {2, 0, 0, 0, 0, 0, 0, 0, 0, 0};

	///#define Ndashes 10
	public static byte[][] dashes = new byte[DefineConstants.Ndashes][5];

	public static t_sm_palette sm_palette = new t_sm_palette(-1, palette_color_mode.SMPAL_COLOR_MODE_NONE, 0, 0, 0, 0, 0, -1, (rgb_color *) 0, 0, 0, (gradient_struct *) 0);
		/* Afunc, Bfunc and Cfunc can't be initialised here */

	public static int have_pm3d = 1;
	public static int num_colormaps = 0;
	public static int maximal_possible_colors = 0x100;
	public static int minimal_possible_colors;

	/* the following visual names must match the
	 * definitions in X.h in this order ! I hope
	 * this is standard (joze) */
	public static String[] visual_name = {"StaticGray", "GrayScale", "StaticColor", "PseudoColor", "TrueColor", "DirectColor", (byte *) 0};

	public static Display dpy;
	public static int scr;
	public static Window root = new Window();
	public static Visual vis = (Visual *) 0;
	public static GC gc = (GC) 0;
	public static GC current_gc = (GC *) 0;
	public static GC gc_xor = (GC) 0;
	public static GC gc_xor_dashed = (GC) 0;
	public static GC fill_gc = (GC) 0;
	public static XFontStruct font = DefineConstants.NULL;
	///#ifdef USE_X11_MULTIBYTE
	public static XFontSet mbfont = DefineConstants.NULL;
	///#endif
	public static int do_raise = AnonymousEnum2.yes.getValue();
	public static int persist = AnonymousEnum2.no.getValue();
	public static boolean fast_rotate = true;
	public static int feedback = AnonymousEnum2.yes.getValue();
	public static int ctrlq = AnonymousEnum2.no.getValue();
	public static int dashedlines = AnonymousEnum2.no.getValue();
	///#ifdef EXPORT_SELECTION
	public static boolean exportselection = true;
	///#endif
	public static Cursor cursor = new Cursor();
	public static Cursor cursor_default = new Cursor();
	///#ifdef USE_MOUSE
	public static Cursor cursor_exchange = new Cursor();
	public static Cursor cursor_sizing = new Cursor();
	public static Cursor cursor_zooming = new Cursor();
	///#ifndef TITLE_BAR_DRAWING_MSG
	public static Cursor cursor_waiting = new Cursor();
	public static Cursor cursor_save = new Cursor();
	public static int button_pressed = 0;
	///#endif
	///#endif

	public static int windows_open = 0;

	public static int gX = 100;
	public static int gY = 100;
	public static int gW = 640;
	public static int gH = 450;
	public static int gFlags = PSize;

	public static int BorderWidth = 2;
	public static int dep; // depth
	public static int max_request_size;

	public static Bool Mono = 0;
	public static Bool Gray = 0;
	public static Bool Rv = 0;
	public static Bool Clear = 0;
	public static String X_Name = "gnuplot";
	public static String X_Class = "Gnuplot";

	public static int cx = 0;
	public static int cy = 0;

	/* Font characteristics held locally but sent back via pipe to x11.trm */
	public static int vchar;
	public static int hchar;

	/* Speficy negative values as indicator of uninitialized state */
	public static double xscale = -1.;
	public static double yscale = -1.;
	public static double pointsize = -1.;
	/* Avoid a crash upon using uninitialized variables from
	   above and avoid unnecessary calls to display().
	   Probably this is not the best fix ... */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Call_display(plot) if (xscale<0.) display(plot);
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define X(x) (int) ((x) * xscale)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Y(y) (int) ((4095-(y)) * yscale)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RevX(x) (((x)+0.5)/xscale)
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define RevY(y) (4095-((y)+0.5)/yscale)
	/* note: the 0.5 term in RevX(x) and RevY(y) compensates for the round-off in X(x) and Y(y) */

	public static String buf = new String(new char[DefineConstants.X11_COMMAND_BUFFER_LENGTH]);
	public static int buffered_input_available = 0;

	public static FILE X11_ipc;

	/* when using an ICCCM-compliant window manager, we can ask it
	 * to send us an event when user chooses 'close window'. We do this
	 * by setting WM_DELETE_WINDOW atom in property WM_PROTOCOLS
	 */

	public static Atom WM_PROTOCOLS = new Atom();
	public static Atom WM_DELETE_WINDOW = new Atom();

	public static XPoint[] Diamond = new XPoint[5];
	public static XPoint[] Triangle = new XPoint[4];
	public static XSegment[] Plus = new XSegment[2];
	public static XSegment[] Cross = new XSegment[2];
	public static XSegment[] Star = new XSegment[4];

	/* pixmaps used for filled boxes (ULIG) */
	/* FIXME EAM - These data structures are a duplicate of the ones in bitmap.c */

	/* pattern stipples for pattern fillstyle */
	///#define stipple_pattern_width 8
	///#define stipple_pattern_height 8
	///#define stipple_pattern_num 8
	public static final byte[][] stipple_pattern_bits = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x41}, {0x88, 0x55, 0x22, 0x55, 0x88, 0x55, 0x22, 0x55}, {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}, {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01}, {0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88}, {0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11}};

	public static Pixmap[] stipple_pattern = new Pixmap[DefineConstants.stipple_pattern_num];
	public static int stipple_initialized = 0;

	///#ifdef X11_POLYLINE
	public static XPoint polyline = DefineConstants.NULL;
	public static int polyline_space = 0;
	public static int polyline_size = 0;
	///#endif

	/*
	 * Main program
	 */
	public static void Main(int argc, String[] args)
	{

	///#ifdef PIPE_IPC
		int getfl;
	///#endif

	///#ifdef OSK
	// /* malloc large blocks, otherwise problems with fragmented mem */
	//    _mallocmin(102400);
	///#endif
	///#ifdef __EMX__
	// /* close open file handles */
	//    fcloseall();
	///#endif

	///#ifdef USE_X11_MULTIBYTE
		if (setlocale(LC_ALL, "") == DefineConstants.NULL || XSupportsLocale() == False)
		  multibyte_fonts_usable = 0;
		setlocale(LC_NUMERIC, "C"); // HBB 20050525
	///#endif // USE_X11_MULTIBYTE 
	tangible.RefObject<String[]> tempRef_args = new tangible.RefObject<String[]>(args);
		GlobalMembersGplt_x11.preset(argc, tempRef_args);
		args = tempRef_args.argvalue;

	/* set up the alternative cursor */
		cursor_default = XCreateFontCursor(dpy, XC_crosshair);
		cursor = cursor_default;
	///#ifdef USE_MOUSE
		/* create cursors for the splot actions */
		cursor_exchange = XCreateFontCursor(dpy, XC_exchange);
		cursor_sizing = XCreateFontCursor(dpy, XC_sizing);
		/* arrow, top_left_arrow, left_ptr, sb_left_arrow, sb_right_arrow,
		 * plus, pencil, draft_large, right_ptr, draft_small */
		cursor_zooming = XCreateFontCursor(dpy, XC_draft_small);
	///#ifndef TITLE_BAR_DRAWING_MSG
		cursor_waiting = XCreateFontCursor(dpy, XC_watch);
		cursor_save = (Cursor)0;
	///#endif
	///#endif
	///#ifdef PIPE_IPC
		if (GlobalMembersGpexecute.pipe_died == 0)
		{
		/* set up nonblocking stdout */
		getfl = fcntl(1, F_GETFL); // get current flags
		fcntl(1, F_SETFL, getfl | O_NONBLOCK);
		signal(SIGPIPE, GlobalMembersGpexecute.pipe_died_handler);
		}
	///#endif

	///#ifdef X11_POLYLINE
		polyline_space = 100;
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in Java:
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		polyline = calloc(polyline_space, sizeof(XPoint));
		if (polyline == null)
			fprintf(stderr, "Panic: cannot allocate polyline\n");
	///#endif

		GlobalMembersGplt_x11.mainloop();

		if (persist != 0)
		{
		GlobalMembersFit.a((stderr, "waiting for %d windows\n", windows_open));

	///#ifndef DEBUG
		/* HBB 20030519: Some programs executing gnuplot -persist may
		 * be waiting for all default handles to be closed before they
		 * consider the sub-process finished.  Emacs, e.g., does.  So,
		 * unless this is a DEBUG build, drop our connection to stderr
		 * now.  Using Freopen() ensures that debug fprintf()s won't
		 * crash. */
		freopen("/dev/null", "w", stderr);
	///#endif

		/* read x events until all windows have been quit */
		while (windows_open > 0)
		{
			XEvent event = new XEvent();
			XNextEvent(dpy, event);
			process_event(event);
		}
		}
		XCloseDisplay(dpy);

		GlobalMembersFit.a((stderr, "exiting\n"));

		do
		{
			GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
			close(1);
			close(0);
			System.exit(0);
		} while (0);
	}

/*
 * Handle input.  Use read instead of fgets because stdio buffering
 * causes trouble when combined with calls to select.
 */
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int read_input_rdbuf_size = 10 * DefineConstants.X11_COMMAND_BUFFER_LENGTH;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String read_input_rdbuf = new String(new char[10 * DefineConstants.X11_COMMAND_BUFFER_LENGTH]);
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int read_input_total_chars;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int read_input_rdbuf_offset;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int read_input_buf_offset;
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static int read_input_partial_read = 0;

	///#ifndef VMS

	public static int read_input()
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int rdbuf_size = 10 * DefineConstants.X11_COMMAND_BUFFER_LENGTH;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte rdbuf[10 * DefineConstants.X11_COMMAND_BUFFER_LENGTH];
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int total_chars;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int rdbuf_offset;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int buf_offset;
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static int partial_read = 0;
		int fd = fileno(X11_ipc);

		if (read_input_partial_read == 0)
		read_input_buf_offset = 0;

		if (buffered_input_available == 0)
		{
		read_input_total_chars = read(fd, read_input_rdbuf, read_input_rdbuf_size);
		buffered_input_available = 1;
		read_input_partial_read = 0;
		read_input_rdbuf_offset = 0;
		if (read_input_total_chars == 0)
			return -2;
		if (read_input_total_chars < 0)
			return -1;
		}

		if (read_input_rdbuf_offset < read_input_total_chars)
		{
		while (read_input_rdbuf_offset < read_input_total_chars && read_input_buf_offset < DefineConstants.X11_COMMAND_BUFFER_LENGTH)
		{
			byte c = read_input_rdbuf.charAt(read_input_rdbuf_offset++);
			buf = tangible.StringFunctions.changeCharacter(buf, read_input_buf_offset++, c);
			if (c == '\n')
			break;
		}

		if (read_input_buf_offset == DefineConstants.X11_COMMAND_BUFFER_LENGTH)
		{
			fputs("\ngplt_x11.c: buffer overflow in read_input!\n" + "            X11 aborted.\n", stderr);
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
		}
		else
			buf = tangible.StringFunctions.changeCharacter(buf, read_input_buf_offset, DefineConstants.NUL);
		}

		if (read_input_rdbuf_offset == read_input_total_chars)
		{
		buffered_input_available = 0;
		if (buf.charAt(read_input_buf_offset - 1) != '\n')
			read_input_partial_read = 1;
		}

		return read_input_partial_read;
	}

/*
 * Handle a whole input line, issuing an error message if a complete
 * read does not appear after a few tries.
 */

	public static void read_input_line()
	{
		int i_read;
		for (i_read = 1; GlobalMembersGplt_x11.read_input() == 1; i_read++)
		{
		if (i_read == 5)
			fprintf(stderr, "\ngplt_x11.c: A complete buffer instruction is not appearing across\n" + "            link.  Check for system overload or driver error.\n");
		};
	}


	/*
	 * record - record new plot from gnuplot inboard X11 driver (Unix)
	 */
	/* Would like to change "plot" in this function to "current_plot".
	 * "plot" is somewhat general, as though it were a local variable.
	 * However, do a redefinition for now. */
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define plot current_plot
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	///#undef plot

	/*-----------------------------------------------------------------------------
	 *   resize - rescale last plot if window resized
	 *---------------------------------------------------------------------------*/

	///#ifdef USE_MOUSE

	/* the status of the shift, ctrl and alt keys
	*/
	public static int modifier_mask = 0;

	public static void update_modifiers(int state)
	{
		int old_mod_mask;

		old_mod_mask = modifier_mask;
		modifier_mask = ((state & ShiftMask) ? AnonymousEnum2.Mod_Shift : 0) | ((state & ControlMask) ? AnonymousEnum2.Mod_Ctrl : 0) | ((state & Mod1Mask) ? AnonymousEnum2.Mod_Alt : 0);
		if (old_mod_mask != modifier_mask)
		{
		GlobalMembersGpexecute.gp_exec_event(AnonymousEnum.GE_modifier, 0, 0, modifier_mask, 0, 0);
		}
	}

	///#endif

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to events in Java:
	//static void process_configure_notify_event(XEvent *event)
	//{
	//	plot_struct *current_plot;
	//	int force_redraw = 0;
	//
	// /* Filter down to the last ConfigureNotify event */
	//	XSync(dpy, False);
	//	while (XCheckTypedWindowEvent(dpy, event->xany.window, ConfigureNotify, event))
	//	;
	//
	//	current_plot = Find_Plot_In_Linked_List_By_Window(event->xconfigure.window);
	//	if (current_plot)
	//	{
	//	int w = event->xconfigure.width, h = event->xconfigure.height;
	//
	// /* store settings in case window is closed then recreated */
	// /* but: don't do this if both x and y are 0, since some
	//  * (all?) systems set these to zero when only resizing
	//  * (not moving) the window. This does mean that a move to
	//  * (0, 0) won't be registered: can we solve that? */
	//	if (event->xconfigure.x != 0 || event->xconfigure.y != 0)
	//	{
	//		current_plot->x = event->xconfigure.x;
	//		current_plot->y = event->xconfigure.y;
	//		current_plot->posn_flags = (current_plot->posn_flags & ~PPosition) | USPosition;
	//	}
	/////#ifdef USE_MOUSE
	// /* first, check whether we were waiting for completion of a resize */
	//	if (current_plot->resizing)
	//	{
	// /* it seems to be impossible to distinguish between a
	//  * resize caused by our call to XResizeWindow(), and a
	//  * resize started by the user/windowmanager; but we can
	//  * make a good guess which can only fail if the user
	//  * resizes the window while we're also resizing it
	//  * ourselves: */
	//		if (w == current_plot->width && (h == current_plot->gheight || h == current_plot->gheight + vchar))
	//		{
	// /* most likely, it's a resize for showing/hiding the status line.
	//  * Test whether the height is now correct; if not, start another resize. */
	//		current_plot->resizing = false;
	//		if (w == current_plot->width && h == current_plot->gheight + (current_plot->str[0] ? vchar : 0))
	//		{
	// /* Was successful, status line can be drawn without rescaling plot. */
	//			current_plot->height = h;
	//			return;
	//		}
	//		else
	//		{
	// /* Possibly, a resize attempt _failed_ because window manager denied it.
	//    Resizing again goes into a vicious endless loop!
	//    (Seen with fluxbox-1.0.0 and a tab group of gnuplot windows.) */
	// /* Instead of just appending the status line, redraw/scale the plot. */
	//			force_redraw = true;
	//		}
	//		}
	//	}
	/////#endif
	//
	//	if (w > 1 && h > 1 && (force_redraw || w != current_plot->width || h != current_plot->height))
	//	{
	//
	//		current_plot->width = w;
	//		current_plot->height = h;
	/////#ifdef USE_MOUSE
	// /* Make sure that unsigned number doesn't underflow. */
	//		if (current_plot->str[0])
	//		current_plot->gheight = (vchar > current_plot->height) ? 0 : current_plot->height - vchar;
	//		else
	//		current_plot->gheight = current_plot->height;
	/////#endif
	//		current_plot->posn_flags = (current_plot->posn_flags & ~PSize) | USSize;
	//
	//		if (stipple_initialized)
	//		{
	//		int i;
	//		for (i = 0; i < DefineConstants.stipple_pattern_num; i++)
	//			XFreePixmap(dpy, stipple_pattern[i]);
	//		stipple_initialized = 0;
	//		}
	//
	//		if (current_plot->pixmap)
	//		{
	// /* it is the wrong size now */
	//		a((stderr, "Free pixmap %d\n", 0));
	//		XFreePixmap(dpy, current_plot->pixmap);
	//		current_plot->pixmap = None;
	//		}
	//
	/////#ifdef EXTERNAL_X11_WINDOW
	//		if (current_plot->external_container != None)
	//		{
	// /* Resize so that all parts of plot remain visible
	//  * when the plot is expanded. */
	//		XResizeWindow(dpy, current_plot->window, current_plot->width, current_plot->height);
	// /* This may be redundant because the application might
	//  * handle resizing the external window.  However, this
	//  * probably isn't necessarily true, so resize the
	//  * external window as well. */
	//		XResizeWindow(dpy, current_plot->external_container, current_plot->width, current_plot->height);
	//		}
	/////#endif
	//
	//		display(current_plot);
	//	}
	//	}
	//}

	/*-----------------------------------------------------------------------------
	 *   preset - determine options, open display, create window
	 *---------------------------------------------------------------------------*/
	/*
	#define On(v) ( !strcmp(v, "on") || !strcmp(v, "true") ||                 !strcmp(v, "On") || !strcmp(v, "True") ||                 !strcmp(v, "ON") || !strcmp(v, "TRUE") )
	ignore
	ignore
	*/
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define On(v) ( !strncasecmp(v, "on", 2) || !strncasecmp(v, "true", 4) )

	///#ifndef MAXHOSTNAMELEN
	///#define MAXHOSTNAMELEN 64
	///#endif

	public static XrmDatabase dbCmd = new XrmDatabase();
	public static XrmDatabase dbApp = new XrmDatabase();
	public static XrmDatabase dbDef = new XrmDatabase();
	public static XrmDatabase dbEnv = new XrmDatabase();
	public static XrmDatabase db = (XrmDatabase) 0;

	public static String[] type = new String[20];
	public static XrmValue value = new XrmValue();

	public static XrmOptionDescRec[] options = {{"-mono", ".mono", XrmoptionNoArg, (XPointer) "on"}, {"-gray", ".gray", XrmoptionNoArg, (XPointer) "on"}, {"-clear", ".clear", XrmoptionNoArg, (XPointer) "on"}, {"-tvtwm", ".tvtwm", XrmoptionNoArg, (XPointer) "on"}, {"-pointsize", ".pointsize", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-display", ".display", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-name", ".name", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-geometry", "*geometry", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-background", "*background", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-bg", "*background", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-foreground", "*foreground", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-fg", "*foreground", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-bordercolor", "*bordercolor", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-bd", "*bordercolor", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-borderwidth", ".borderWidth", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-bw", ".borderWidth", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-font", "*font", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-fn", "*font", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-reverse", "*reverseVideo", XrmoptionNoArg, (XPointer) "on"}, {"-rv", "*reverseVideo", XrmoptionNoArg, (XPointer) "on"}, {"+rv", "*reverseVideo", XrmoptionNoArg, (XPointer) "off"}, {"-iconic", "*iconic", XrmoptionNoArg, (XPointer) "on"}, {"-synchronous", "*synchronous", XrmoptionNoArg, (XPointer) "on"}, {"-xnllanguage", "*xnllanguage", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-selectionTimeout", "*selectionTimeout", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-title", ".title", XrmoptionSepArg, (XPointer) DefineConstants.NULL}, {"-xrm", DefineConstants.NULL, XrmoptionResArg, (XPointer) DefineConstants.NULL}, {"-raise", "*raise", XrmoptionNoArg, (XPointer) "on"}, {"-noraise", "*raise", XrmoptionNoArg, (XPointer) "off"}, {"-feedback", "*feedback", XrmoptionNoArg, (XPointer) "on"}, {"-nofeedback", "*feedback", XrmoptionNoArg, (XPointer) "off"}, {"-ctrlq", "*ctrlq", XrmoptionNoArg, (XPointer) "on"}, {"-dashed", "*dashed", XrmoptionNoArg, (XPointer) "on"}, {"-solid", "*dashed", XrmoptionNoArg, (XPointer) "off"}, {"-persist", "*persist", XrmoptionNoArg, (XPointer) "on"}};

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	///#define Nopt (sizeof(options) / sizeof(options[0]))

	/*-----------------------------------------------------------------------------
	 *   pr_color - determine color values
	 *---------------------------------------------------------------------------*/

	public static final String[] color_keys = {"background", "bordercolor", "text", "border", "axis", "line1", "line2", "line3", "line4", "line5", "line6", "line7", "line8"};
	public static String[] color_values = {"white", "black", "black", "black", "black", "red", "green", "blue", "magenta", "cyan", "sienna", "orange", "coral"};
	public static String[] color_values_rv = {"black", "white", "white", "white", "white", "red", "green", "blue", "magenta", "cyan", "sienna", "orange", "coral"};
	public static String[] gray_values = {"black", "white", "white", "gray50", "gray50", "gray100", "gray60", "gray80", "gray40", "gray90", "gray50", "gray70", "gray30"};

	/*-----------------------------------------------------------------------------
	 *   pr_dashes - determine line dash styles
	 *---------------------------------------------------------------------------*/

	public static final String[] dash_keys = {"border", "axis", "line1", "line2", "line3", "line4", "line5", "line6", "line7", "line8"};

	public static String[] dash_mono = {"0", "16", "0", "42", "13", "44", "15", "4441", "42", "13"};

	public static String[] dash_color = {"0", "16", "0", "0", "0", "0", "0", "0", "0", "0"};
//C++ TO JAVA CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in Java):
private static String pr_font_previous_font_name = new String(new char[128]);

	public static void pr_font(String fontname)
	{
	//C++ TO JAVA CONVERTER NOTE: This static local variable declaration (not allowed in Java) has been moved just prior to the method:
	//	static sbyte previous_font_name[128];
		String fontspec = new String(new char[128]);
		int fontsize = 0;
	///#ifdef USE_X11_MULTIBYTE
		String orgfontname = DefineConstants.NULL;
	///#endif

		if (fontname == null || !(fontname))
		fontname = default_font;

		if (fontname == null || !(fontname))
		{
		if ((fontname = GlobalMembersGplt_x11.pr_GetR(db, ".font")))
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			default_font = fontname.substring(0, sizeof(default_font) - 1);
			GlobalMembersFit.a((stderr, "gnuplot_x11: setting default font %s from Xresource\n", fontname));
		}

	///#ifdef USE_X11_MULTIBYTE
		if (fontname != null && strncmp(fontname, "mbfont:", 7) == 0)
		{
		if (multibyte_fonts_usable != 0)
		{
			usemultibyte = 1;
			orgfontname = fontname;
			fontname = fontname.charAt(7);
		}
		else
		{
			usemultibyte = 0;
			fontname = DefineConstants.NULL;
		}
		}
		else
			usemultibyte = 0;
	///#endif
		if (fontname == null)
		  fontname = GlobalMembersGplt_x11.gpFallbackFont();

		/* EAM DEBUG - Free previous font before searching for a new one. */
		/* This doesn't seem right, since we will probably need it again  */
		/* very soon. But if we don't free it, we gradually leak memory.  */
		GlobalMembersGplt_x11.gpXFreeFont(dpy, font);

		font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontname);

	///#ifndef USE_X11_MULTIBYTE
	//    if (!font) {
	///#else
		if (font == null && mbfont == null && !tangible.StringFunctions.strChr(fontname, DefineConstants.FontSetSep))
		{
	///#endif
		/* EAM 19-Aug-2002 Try to construct a plausible X11 full font spec */
		/* We are passed "font<, size><, slant>"                             */
		String shortname = new String(new char[64]);
		String fontencoding;
		byte slant;
		String weight;
		int sep;
	///#ifdef USE_X11_MULTIBYTE
		int backfont = 0;
	///#endif

		/* Enhanced font processing wants a method of requesting a new size  */
		/* for whatever the previously selected font was, so we have to save */
		/* and reuse the previous font name to construct the new spec.       */
		if (!strncmp(fontname, "DEFAULT", 7))
		{
			sscanf(fontname.charAt(8), "%d", fontsize);
			fontname = default_font;
	///#ifdef USE_X11_MULTIBYTE
			backfont = 1;
	///#endif
		}
		else if (fontname.equals(','))
		{
			sscanf(fontname.charAt(1), "%d", fontsize);
			fontname = pr_font_previous_font_name;
	///#ifdef USE_X11_MULTIBYTE
			backfont = 1;
	///#endif
		}
	///#ifdef USE_X11_MULTIBYTE
		if (backfont != 0 && fontname != null && strncmp(fontname, "mbfont:", 7) == 0 && multibyte_fonts_usable != 0)
		{
			usemultibyte = 1;
			orgfontname = fontname;
			fontname = fontname.charAt(7);
		}
	///#endif

		sep = strcspn(fontname, ",");
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
		if (sep >= sizeof(shortname))
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			sep = sizeof(shortname) - 1;
		shortname = fontname.substring(0, sep);
		shortname = tangible.StringFunctions.changeCharacter(shortname, sep, '\0');
		if (fontsize == 0)
			sscanf((fontname.charAt(sep + 1)), "%d", fontsize);
		if (fontsize > 99 || fontsize < 1)
			fontsize = 12;

		slant = tangible.StringFunctions.strStr(fontname.charAt(sep + 1), "italic") ? 'i' : tangible.StringFunctions.strStr(fontname.charAt(sep + 1), "oblique") ? 'o' : 'r';

		weight = tangible.StringFunctions.strStr(fontname.charAt(sep + 1), "bold") ? "bold" : tangible.StringFunctions.strStr(fontname.charAt(sep + 1), "medium") ? "medium" : "*";

		if (!strncmp("Symbol", shortname, 6) || !strncmp("symbol", shortname, 6))
			fontencoding = "*-*";
	///#ifdef USE_X11_MULTIBYTE
		else if (usemultibyte != 0)
			fontencoding = "*-*";
	///#endif
		else
			fontencoding = (encoding == (set_encoding_id.S_ENC_CP437.getValue()) != 0 ? "dosencoding-cp437" : encoding == (set_encoding_id.S_ENC_CP850.getValue()) != 0 ? "dosencoding-cp850" : encoding == (set_encoding_id.S_ENC_ISO8859_1.getValue()) != 0 ? "iso8859-1" : encoding == (set_encoding_id.S_ENC_ISO8859_2.getValue()) != 0 ? "iso8859-2" : encoding == (set_encoding_id.S_ENC_ISO8859_15.getValue()) != 0 ? "iso8859-15" : encoding == (set_encoding_id.S_ENC_KOI8_R.getValue()) != 0 ? "koi8-r" : encoding == (set_encoding_id.S_ENC_KOI8_U.getValue()) != 0 ? "koi8-u" : encoding == (set_encoding_id.S_ENC_UTF8.getValue()) != 0 ? "utf-8" : default_encoding.charAt(0) ? default_encoding : "*-*");

		String.format(fontspec, "-*-%s-%s-%c-*-*-%d-*-*-*-*-*-%s", shortname, weight, slant, fontsize, fontencoding);
		font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);

	///#ifndef USE_X11_MULTIBYTE
	//	if (!font) {
	///#else
		if (font == null && mbfont == null)
		{
	///#endif
			/* Try to decode some common PostScript font names */
			if (!strcmp("Times-Bold", shortname) || !strcmp("times-bold", shortname))
			{
			String.format(fontspec, "-*-times-bold-r-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Times-Roman", shortname) || !strcmp("times-roman", shortname))
			{
			String.format(fontspec, "-*-times-medium-r-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Times-Italic", shortname) || !strcmp("times-italic", shortname))
			{
			String.format(fontspec, "-*-times-medium-i-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Times-BoldItalic", shortname) || !strcmp("times-bolditalic", shortname))
			{
			String.format(fontspec, "-*-times-bold-i-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Helvetica-Bold", shortname) || !strcmp("helvetica-bold", shortname))
			{
			String.format(fontspec, "-*-helvetica-bold-r-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Helvetica-Oblique", shortname) || !strcmp("helvetica-oblique", shortname))
			{
			String.format(fontspec, "-*-helvetica-medium-o-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Helvetica-BoldOblique", shortname) || !strcmp("helvetica-boldoblique", shortname))
			{
			String.format(fontspec, "-*-helvetica-bold-o-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
			else if (!strcmp("Helvetica-Narrow-Bold", shortname) || !strcmp("helvetica-narrow-bold", shortname))
			{
			String.format(fontspec, "-*-arial narrow-bold-r-*-*-%d-*-*-*-*-*-%s", fontsize, fontencoding);
			}
	///#ifdef USE_X11_MULTIBYTE
			/* Japanese standard PostScript font names (adviced from
			 * N.Matsuda). */
			else if (multibyte_fonts_usable != 0 && (!strncmp("Ryumin-Light", shortname, "Ryumin-Light".length()) || !strncmp("ryumin-light", shortname, "ryumin-light".length())))
			{
			if (usemultibyte == 0)
			{
				usemultibyte = 1;
				orgfontname = fontname;
			}
			String.format(fontspec, "-*-mincho-medium-%c-*--%d-*", slant, fontsize);
			}
			else if (multibyte_fonts_usable != 0 && (!strncmp("GothicBBB-Medium", shortname, "GothicBBB-Medium".length()) || !strncmp("gothicbbb-medium", shortname, "gothicbbb-medium".length())))
			{
			if (usemultibyte == 0)
			{
				usemultibyte = 1;
				orgfontname = fontname;
			}
			/* FIXME: Doesn't work on most non-japanese setups, because */
			/* many purely Western fonts are gothic-bold.               */
			String.format(fontspec, "-*-gothic-bold-%c-*--%d-*", slant, fontsize);
			}
	///#endif // USE_X11_MULTIBYTE 
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);

	///#ifdef USE_X11_MULTIBYTE
			if (usemultibyte != 0 && mbfont == null)
			{
			/* But (mincho|gothic) X fonts are not provided
			 * on some X servers even in Japan
			 */
			String.format(fontspec, "*-%s-%c-*--%d-*", weight, slant, fontsize);
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);
			}
	///#endif // USE_X11_MULTIBYTE 
		}

		}

	///#ifndef USE_X11_MULTIBYTE
	//    if (font) {
	///#else
		if (font != null || mbfont != null)
		{
		if (usemultibyte != 0 && orgfontname != null)
		  fontname = orgfontname;
	///#endif
//C++ TO JAVA CONVERTER TODO TASK: There is no Java equivalent to 'sizeof':
			pr_font_previous_font_name = fontname.substring(0, sizeof(pr_font_previous_font_name) - 1);
			GlobalMembersFit.a((stderr, "gnuplot_x11:saving current font name \"%s\"\n", pr_font_previous_font_name));
		}

		/* By now we have tried everything we can to honor the specific request. */
		/* Try some common scaleable fonts before falling back to a last resort  */
		/* fixed font.                                                           */
	///#ifndef USE_X11_MULTIBYTE
	//    if (!font) {
	///#else
		if (usemultibyte == 0 && font == null)
		{
	///#endif
		String.format(fontspec, "-*-bitstream vera sans-bold-r-*-*-%d-*-*-*-*-*-*-*", fontsize);
		font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);
		fontname = fontspec;
		if (font == null)
		{
			String.format(fontspec, "-*-arial-medium-r-*-*-%d-*-*-*-*-*-*-*", fontsize);
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);
		}
		if (font == null)
		{
			String.format(fontspec, "-*-helvetica-medium-r-*-*-%d-*-*-*-*-*-*", fontsize);
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, fontspec);
		}
		if (font == null)
		{
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, GlobalMembersGplt_x11.gpFallbackFont());
			fontname = GlobalMembersGplt_x11.gpFallbackFont();
		}
		if (font == null)
		{
			fprintf(stderr, "\ngnuplot_x11: can't find usable font - X11 aborted.\n");
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
		}
		GlobalMembersFit.a((stderr, "\ngnuplot_x11: requested font not found, using '%s' instead.\n", fontname));
		}
	///#ifdef USE_X11_MULTIBYTE
		if (usemultibyte != 0 && mbfont == null) // multibyte font setting
		{
		font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, GlobalMembersGplt_x11.gpFallbackFont());
		if (mbfont == null)
		{
			usemultibyte = 0;
			font = GlobalMembersGplt_x11.gpXLoadQueryFont(dpy, GlobalMembersGplt_x11.gpFallbackFont());
			if (font == null)
			{
			fprintf(stderr, "\ngnuplot_x11: can't find usable font - X11 aborted.\n");
			do
			{
				GlobalMembersGpexecute.gp_exec_event(GE_pending, 0, 0, 0, 0, 0);
				close(1);
				close(0);
				System.exit(1);
			} while (0);
			}
		}
		fontname = GlobalMembersGplt_x11.gpFallbackFont();
		}
	///#endif // USE_X11_MULTIBYTE 

		vchar = GlobalMembersGplt_x11.gpXTextHeight(font);
		hchar = GlobalMembersGplt_x11.gpXTextWidth(font, "0123456789", 10) / 10;

		GlobalMembersFit.a((stderr, "gnuplot_x11: pr_font() set font %s, vchar %d hchar %d\n", fontname, vchar, hchar));

	}

	/*-----------------------------------------------------------------------------
	 *   pr_width - determine line width values
	 *---------------------------------------------------------------------------*/

	public static final String[] width_keys = {"border", "axis", "line1", "line2", "line3", "line4", "line5", "line6", "line7", "line8"};
	///#endif

	/************ code to handle selection export *********************/

	///#ifdef EXPORT_SELECTION

	/* bit of a bodge, but ... */
	public static plot_struct exported_plot;
	public static Time export_time = new Time();

	public static void export_graph(plot_struct current_plot)
	{
		GlobalMembersFit.a((stderr, "export_graph(0x%x)\n", current_plot));

		XSetSelectionOwner(dpy, XA_PRIMARY, current_plot.window, CurrentTime);
		/* to check we have selection, we would have to do a
		 * GetSelectionOwner(), but if it failed, it failed - no big deal
		 */
		if (selection == null)
		{
		exported_plot = current_plot;
		export_time = (current_plot == null || !(current_plot.time)) ? 1 : current_plot.time;
		}
	}
}